frappe.dom.set_style("/* sfc-style:/home/dev2/projects/v15/apps/library_management/library_management/public/js/ebook_reader/components/Sidebar.vue?type=style&index=0 */\n.app-bar[data-v-899d8ded] {\n  z-index: 2;\n  margin-top: 60px;\n  height: 60px;\n}\n.nav-drawer[data-v-899d8ded] {\n  z-index: 1;\n  margin-top: 70px;\n  width: 70%;\n}\n\n/* sfc-style:/home/dev2/projects/v15/apps/library_management/library_management/public/js/ebook_reader/components/EpubTitlebar.vue?type=style&index=0 */\n.v-dialog--fullscreen[data-v-66b69e18] {\n  background-color: white;\n}\n\n/* sfc-style:/home/dev2/projects/v15/apps/library_management/library_management/public/js/ebook_reader/components/EpubReader.vue?type=style&index=0 */\n.v-card-text[data-v-a7e9f2db] {\n  overflow: auto;\n}\n#epub-render-area[data-v-a7e9f2db] {\n  max-height: 80vh;\n}\n#pdf-canvas[data-v-a7e9f2db] {\n  height: calc(80vh - 80px);\n  width: 700px;\n  overflow: auto;\n}\n\n/* sfc-style:/home/dev2/projects/v15/apps/library_management/library_management/public/js/ebook_reader/components/PdfTitlebar.vue?type=style&index=0 */\n.v-dialog--fullscreen[data-v-51668b80] {\n  background-color: white;\n}\n\n/* sfc-style:/home/dev2/projects/v15/apps/library_management/library_management/public/js/ebook_reader/components/PdfReader.vue?type=style&index=0 */\n.v-card[data-v-64b5f53b] {\n  padding: 0 !important;\n  margin: 0 !important;\n}\n.pdf-container[data-v-64b5f53b] {\n  overflow-y: auto;\n  max-height: 80vh;\n  width: 100%;\n  display: block;\n  justify-content: center;\n}\n#pdf-canvas[data-v-64b5f53b] {\n  width: 700px;\n  height: auto;\n  display: block;\n  margin: 0 auto;\n}\n.wrap-text[data-v-64b5f53b] {\n  white-space: normal;\n  word-wrap: break-word;\n  width: 100%;\n}\n.page-input-field .v-field__input[data-v-64b5f53b] {\n  width: 40px;\n  font-weight: bold;\n  color: black;\n}\n\n/* sfc-style:/home/dev2/projects/v15/apps/library_management/library_management/public/js/books/Books.vue?type=style&index=0 */\n#app-container[data-v-3dde91c7] {\n  margin-top: 20px;\n  text-align: center;\n}\n.drawer-open[data-v-3dde91c7] {\n  transition: margin-left 0.3s;\n  margin-left: 10px;\n}\n.v-card img[data-v-3dde91c7] {\n  object-fit: cover;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VApp/VApp.css */\n.v-application {\n  display: flex;\n  background: rgb(var(--v-theme-background));\n  color: rgba(var(--v-theme-on-background), var(--v-high-emphasis-opacity));\n}\n.v-application__wrap {\n  backface-visibility: hidden;\n  display: flex;\n  flex-direction: column;\n  flex: 1 1 auto;\n  max-width: 100%;\n  min-height: 100vh;\n  min-height: 100dvh;\n  position: relative;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VAppBar/VAppBar.css */\n.v-app-bar {\n  display: flex;\n}\n.v-app-bar.v-toolbar {\n  background: rgb(var(--v-theme-surface));\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n}\n.v-app-bar.v-toolbar:not(.v-toolbar--flat) {\n  box-shadow:\n    0px 2px 4px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 4px 5px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 10px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-app-bar:not(.v-toolbar--absolute) {\n  padding-inline-end: var(--v-scrollbar-offset);\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VToolbar/VToolbar.css */\n.v-toolbar {\n  align-items: flex-start;\n  display: flex;\n  flex: none;\n  flex-direction: column;\n  justify-content: space-between;\n  max-width: 100%;\n  position: relative;\n  transition: 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n  transition-property:\n    height,\n    width,\n    transform,\n    max-width,\n    left,\n    right,\n    top,\n    bottom,\n    box-shadow;\n  width: 100%;\n  border-color: rgba(var(--v-border-color), var(--v-border-opacity));\n  border-style: solid;\n  border-width: 0;\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n  border-radius: 0;\n  background: rgb(var(--v-theme-surface-light));\n  color: rgba(var(--v-theme-on-surface-light), var(--v-high-emphasis-opacity));\n}\n.v-toolbar--border {\n  border-width: thin;\n  box-shadow: none;\n}\n.v-toolbar--absolute {\n  position: absolute;\n}\n.v-toolbar--collapse {\n  max-width: 112px;\n  overflow: hidden;\n  border-end-end-radius: 24px;\n}\n.v-toolbar--collapse .v-toolbar-title {\n  display: none;\n}\n.v-toolbar--flat {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-toolbar--floating {\n  display: inline-flex;\n}\n.v-toolbar--rounded {\n  border-radius: 4px;\n}\n.v-toolbar__content,\n.v-toolbar__extension {\n  align-items: center;\n  display: flex;\n  flex: 0 0 auto;\n  position: relative;\n  transition: inherit;\n  width: 100%;\n}\n.v-toolbar__content {\n  overflow: hidden;\n}\n.v-toolbar__content > .v-btn:first-child {\n  margin-inline-start: 10px;\n}\n.v-toolbar__content > .v-btn:last-child {\n  margin-inline-end: 10px;\n}\n.v-toolbar__content > .v-toolbar-title {\n  margin-inline-start: 16px;\n}\n.v-toolbar--density-prominent .v-toolbar__content {\n  align-items: flex-start;\n}\n.v-toolbar__image {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  opacity: var(--v-toolbar-image-opacity, 1);\n  transition-property: opacity;\n}\n.v-toolbar__prepend,\n.v-toolbar__append {\n  align-items: center;\n  align-self: stretch;\n  display: flex;\n}\n.v-toolbar__prepend {\n  margin-inline: 10px auto;\n}\n.v-toolbar__append {\n  margin-inline: auto 10px;\n}\n.v-toolbar-title {\n  flex: 1 1;\n  font-size: 1.25rem;\n  min-width: 0;\n  font-size: 1.25rem;\n  font-weight: 400;\n  letter-spacing: 0;\n  line-height: 1.75rem;\n  text-transform: none;\n}\n.v-toolbar--density-prominent .v-toolbar-title {\n  align-self: flex-end;\n  padding-bottom: 6px;\n  font-size: 1.5rem;\n  font-weight: 400;\n  letter-spacing: 0;\n  line-height: 2.25rem;\n  text-transform: none;\n}\n.v-toolbar-title__placeholder {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n.v-toolbar-items {\n  display: flex;\n  height: inherit;\n  align-self: stretch;\n}\n.v-toolbar-items > .v-btn {\n  border-radius: 0;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VImg/VImg.css */\n.v-img {\n  --v-theme-overlay-multiplier: 3;\n  z-index: 0;\n}\n.v-img--booting .v-responsive__sizer {\n  transition: none;\n}\n.v-img--rounded {\n  border-radius: 4px;\n}\n.v-img__img,\n.v-img__picture,\n.v-img__gradient,\n.v-img__placeholder,\n.v-img__error {\n  z-index: -1;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n.v-img__img--preload {\n  filter: blur(4px);\n}\n.v-img__img--contain {\n  object-fit: contain;\n}\n.v-img__img--cover {\n  object-fit: cover;\n}\n.v-img__gradient {\n  background-repeat: no-repeat;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VResponsive/VResponsive.css */\n.v-responsive {\n  display: flex;\n  flex: 1 0 auto;\n  max-height: 100%;\n  max-width: 100%;\n  overflow: hidden;\n  position: relative;\n}\n.v-responsive--inline {\n  display: inline-flex;\n  flex: 0 0 auto;\n}\n.v-responsive__content {\n  flex: 1 0 0px;\n  max-width: 100%;\n}\n.v-responsive__sizer ~ .v-responsive__content {\n  margin-inline-start: -100%;\n}\n.v-responsive__sizer {\n  flex: 1 0 0px;\n  transition: padding-bottom 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n  pointer-events: none;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VBtn/VBtn.css */\n.v-btn {\n  align-items: center;\n  border-radius: 4px;\n  display: inline-grid;\n  grid-template-areas: \"prepend content append\";\n  grid-template-columns: max-content auto max-content;\n  font-weight: 500;\n  justify-content: center;\n  letter-spacing: 0.0892857143em;\n  line-height: normal;\n  max-width: 100%;\n  outline: none;\n  position: relative;\n  text-decoration: none;\n  text-indent: 0.0892857143em;\n  text-transform: uppercase;\n  transition-property:\n    box-shadow,\n    transform,\n    opacity,\n    background;\n  transition-duration: 0.28s;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  user-select: none;\n  vertical-align: middle;\n  flex-shrink: 0;\n  border-color: rgba(var(--v-border-color), var(--v-border-opacity));\n  border-style: solid;\n  border-width: 0;\n}\n.v-btn--size-x-small {\n  --v-btn-size: 0.625rem;\n  --v-btn-height: 20px;\n  font-size: var(--v-btn-size);\n  min-width: 36px;\n  padding: 0 8px;\n}\n.v-btn--size-small {\n  --v-btn-size: 0.75rem;\n  --v-btn-height: 28px;\n  font-size: var(--v-btn-size);\n  min-width: 50px;\n  padding: 0 12px;\n}\n.v-btn--size-default {\n  --v-btn-size: 0.875rem;\n  --v-btn-height: 36px;\n  font-size: var(--v-btn-size);\n  min-width: 64px;\n  padding: 0 16px;\n}\n.v-btn--size-large {\n  --v-btn-size: 1rem;\n  --v-btn-height: 44px;\n  font-size: var(--v-btn-size);\n  min-width: 78px;\n  padding: 0 20px;\n}\n.v-btn--size-x-large {\n  --v-btn-size: 1.125rem;\n  --v-btn-height: 52px;\n  font-size: var(--v-btn-size);\n  min-width: 92px;\n  padding: 0 24px;\n}\n.v-btn.v-btn--density-default {\n  height: calc(var(--v-btn-height) + 0px);\n}\n.v-btn.v-btn--density-comfortable {\n  height: calc(var(--v-btn-height) + -8px);\n}\n.v-btn.v-btn--density-compact {\n  height: calc(var(--v-btn-height) + -12px);\n}\n.v-btn--border {\n  border-width: thin;\n  box-shadow: none;\n}\n.v-btn--absolute {\n  position: absolute;\n}\n.v-btn--fixed {\n  position: fixed;\n}\n.v-btn:hover > .v-btn__overlay {\n  opacity: calc(var(--v-hover-opacity) * var(--v-theme-overlay-multiplier));\n}\n.v-btn:focus-visible > .v-btn__overlay {\n  opacity: calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier));\n}\n@supports not selector(:focus-visible) {\n  .v-btn:focus > .v-btn__overlay {\n    opacity: calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-btn--active > .v-btn__overlay,\n.v-btn[aria-haspopup=menu][aria-expanded=true] > .v-btn__overlay {\n  opacity: calc(var(--v-activated-opacity) * var(--v-theme-overlay-multiplier));\n}\n.v-btn--active:hover > .v-btn__overlay,\n.v-btn[aria-haspopup=menu][aria-expanded=true]:hover > .v-btn__overlay {\n  opacity: calc((var(--v-activated-opacity) + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier));\n}\n.v-btn--active:focus-visible > .v-btn__overlay,\n.v-btn[aria-haspopup=menu][aria-expanded=true]:focus-visible > .v-btn__overlay {\n  opacity: calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n}\n@supports not selector(:focus-visible) {\n  .v-btn--active:focus > .v-btn__overlay,\n  .v-btn[aria-haspopup=menu][aria-expanded=true]:focus > .v-btn__overlay {\n    opacity: calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-btn--variant-plain,\n.v-btn--variant-outlined,\n.v-btn--variant-text,\n.v-btn--variant-tonal {\n  background: transparent;\n  color: inherit;\n}\n.v-btn--variant-plain {\n  opacity: 0.62;\n}\n.v-btn--variant-plain:focus,\n.v-btn--variant-plain:hover {\n  opacity: 1;\n}\n.v-btn--variant-plain .v-btn__overlay {\n  display: none;\n}\n.v-btn--variant-elevated,\n.v-btn--variant-flat {\n  background: rgb(var(--v-theme-surface));\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n}\n.v-btn--variant-elevated {\n  box-shadow:\n    0px 3px 1px -2px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 2px 2px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 5px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-btn--variant-flat {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-btn--variant-outlined {\n  border: thin solid currentColor;\n}\n.v-btn--variant-text .v-btn__overlay {\n  background: currentColor;\n}\n.v-btn--variant-tonal .v-btn__underlay {\n  background: currentColor;\n  opacity: var(--v-activated-opacity);\n  border-radius: inherit;\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  pointer-events: none;\n}\n@supports selector(:focus-visible) {\n  .v-btn::after {\n    content: \"\";\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n    border: 2px solid currentColor;\n    border-radius: inherit;\n    opacity: 0;\n    transition: opacity 0.2s ease-in-out;\n  }\n  .v-btn:focus-visible::after {\n    opacity: calc(0.25 * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-btn--icon {\n  border-radius: 50%;\n  min-width: 0;\n  padding: 0;\n}\n.v-btn--icon.v-btn--size-default {\n  --v-btn-size: 1rem;\n}\n.v-btn--icon.v-btn--density-default {\n  width: calc(var(--v-btn-height) + 12px);\n  height: calc(var(--v-btn-height) + 12px);\n}\n.v-btn--icon.v-btn--density-comfortable {\n  width: calc(var(--v-btn-height) + 0px);\n  height: calc(var(--v-btn-height) + 0px);\n}\n.v-btn--icon.v-btn--density-compact {\n  width: calc(var(--v-btn-height) + -8px);\n  height: calc(var(--v-btn-height) + -8px);\n}\n.v-btn--elevated:hover,\n.v-btn--elevated:focus {\n  box-shadow:\n    0px 2px 4px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 4px 5px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 10px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-btn--elevated:active {\n  box-shadow:\n    0px 5px 5px -3px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 8px 10px 1px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 3px 14px 2px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-btn--flat {\n  box-shadow: none;\n}\n.v-btn--block {\n  display: flex;\n  flex: 1 0 auto;\n  min-width: 100%;\n}\n.v-btn--disabled {\n  pointer-events: none;\n  opacity: 0.26;\n}\n.v-btn--disabled:hover {\n  opacity: 0.26;\n}\n.v-btn--disabled.v-btn--variant-elevated,\n.v-btn--disabled.v-btn--variant-flat {\n  box-shadow: none;\n  opacity: 1;\n  color: rgba(var(--v-theme-on-surface), 0.26);\n  background: rgb(var(--v-theme-surface));\n}\n.v-btn--disabled.v-btn--variant-elevated .v-btn__overlay,\n.v-btn--disabled.v-btn--variant-flat .v-btn__overlay {\n  opacity: 0.4615384615;\n}\n.v-btn--loading {\n  pointer-events: none;\n}\n.v-btn--loading .v-btn__content,\n.v-btn--loading .v-btn__prepend,\n.v-btn--loading .v-btn__append {\n  opacity: 0;\n}\n.v-btn--stacked {\n  grid-template-areas: \"prepend\" \"content\" \"append\";\n  grid-template-columns: auto;\n  grid-template-rows: max-content max-content max-content;\n  justify-items: center;\n  align-content: center;\n}\n.v-btn--stacked .v-btn__content {\n  flex-direction: column;\n  line-height: 1.25;\n}\n.v-btn--stacked .v-btn__prepend,\n.v-btn--stacked .v-btn__append,\n.v-btn--stacked .v-btn__content > .v-icon--start,\n.v-btn--stacked .v-btn__content > .v-icon--end {\n  margin-inline: 0;\n}\n.v-btn--stacked .v-btn__prepend,\n.v-btn--stacked .v-btn__content > .v-icon--start {\n  margin-bottom: 4px;\n}\n.v-btn--stacked .v-btn__append,\n.v-btn--stacked .v-btn__content > .v-icon--end {\n  margin-top: 4px;\n}\n.v-btn--stacked.v-btn--size-x-small {\n  --v-btn-size: 0.625rem;\n  --v-btn-height: 56px;\n  font-size: var(--v-btn-size);\n  min-width: 56px;\n  padding: 0 12px;\n}\n.v-btn--stacked.v-btn--size-small {\n  --v-btn-size: 0.75rem;\n  --v-btn-height: 64px;\n  font-size: var(--v-btn-size);\n  min-width: 64px;\n  padding: 0 14px;\n}\n.v-btn--stacked.v-btn--size-default {\n  --v-btn-size: 0.875rem;\n  --v-btn-height: 72px;\n  font-size: var(--v-btn-size);\n  min-width: 72px;\n  padding: 0 16px;\n}\n.v-btn--stacked.v-btn--size-large {\n  --v-btn-size: 1rem;\n  --v-btn-height: 80px;\n  font-size: var(--v-btn-size);\n  min-width: 80px;\n  padding: 0 18px;\n}\n.v-btn--stacked.v-btn--size-x-large {\n  --v-btn-size: 1.125rem;\n  --v-btn-height: 88px;\n  font-size: var(--v-btn-size);\n  min-width: 88px;\n  padding: 0 20px;\n}\n.v-btn--stacked.v-btn--density-default {\n  height: calc(var(--v-btn-height) + 0px);\n}\n.v-btn--stacked.v-btn--density-comfortable {\n  height: calc(var(--v-btn-height) + -16px);\n}\n.v-btn--stacked.v-btn--density-compact {\n  height: calc(var(--v-btn-height) + -24px);\n}\n.v-btn--slim {\n  padding: 0 8px;\n}\n.v-btn--rounded {\n  border-radius: 24px;\n}\n.v-btn--rounded.v-btn--icon {\n  border-radius: 4px;\n}\n.v-btn .v-icon {\n  --v-icon-size-multiplier: 0.8571428571;\n}\n.v-btn--icon .v-icon {\n  --v-icon-size-multiplier: 1;\n}\n.v-btn--stacked .v-icon {\n  --v-icon-size-multiplier: 1.1428571429;\n}\n.v-btn__loader {\n  align-items: center;\n  display: flex;\n  height: 100%;\n  justify-content: center;\n  left: 0;\n  position: absolute;\n  top: 0;\n  width: 100%;\n}\n.v-btn__content,\n.v-btn__prepend,\n.v-btn__append {\n  align-items: center;\n  display: flex;\n  transition: transform, opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-btn__prepend {\n  grid-area: prepend;\n  margin-inline: calc(var(--v-btn-height) / -9) calc(var(--v-btn-height) / 4.5);\n}\n.v-btn__append {\n  grid-area: append;\n  margin-inline: calc(var(--v-btn-height) / 4.5) calc(var(--v-btn-height) / -9);\n}\n.v-btn__content {\n  grid-area: content;\n  justify-content: center;\n  white-space: nowrap;\n}\n.v-btn__content > .v-icon--start {\n  margin-inline: calc(var(--v-btn-height) / -9) calc(var(--v-btn-height) / 4.5);\n}\n.v-btn__content > .v-icon--end {\n  margin-inline: calc(var(--v-btn-height) / 4.5) calc(var(--v-btn-height) / -9);\n}\n.v-btn--stacked .v-btn__content {\n  white-space: normal;\n}\n.v-btn__overlay {\n  background-color: currentColor;\n  border-radius: inherit;\n  opacity: 0;\n  transition: opacity 0.2s ease-in-out;\n}\n.v-btn__overlay,\n.v-btn__underlay {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n}\n.v-card-actions .v-btn ~ .v-btn:not(.v-btn-toggle .v-btn) {\n  margin-inline-start: 0.5rem;\n}\n.v-pagination .v-btn {\n  border-radius: 4px;\n}\n.v-pagination .v-btn--rounded {\n  border-radius: 50%;\n}\n.v-btn__overlay {\n  transition: none;\n}\n.v-pagination__item--is-active .v-btn__overlay {\n  opacity: var(--v-border-opacity);\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VBtnToggle/VBtnToggle.css */\n.v-btn-toggle > .v-btn.v-btn--active:not(.v-btn--disabled) > .v-btn__overlay {\n  opacity: calc(var(--v-activated-opacity) * var(--v-theme-overlay-multiplier));\n}\n.v-btn-toggle > .v-btn.v-btn--active:not(.v-btn--disabled):hover > .v-btn__overlay {\n  opacity: calc((var(--v-activated-opacity) + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier));\n}\n.v-btn-toggle > .v-btn.v-btn--active:not(.v-btn--disabled):focus-visible > .v-btn__overlay {\n  opacity: calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n}\n@supports not selector(:focus-visible) {\n  .v-btn-toggle > .v-btn.v-btn--active:not(.v-btn--disabled):focus > .v-btn__overlay {\n    opacity: calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n  }\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VBtnGroup/VBtnGroup.css */\n.v-btn-group {\n  display: inline-flex;\n  flex-wrap: nowrap;\n  max-width: 100%;\n  min-width: 0;\n  overflow: hidden;\n  vertical-align: middle;\n  border-color: rgba(var(--v-border-color), var(--v-border-opacity));\n  border-style: solid;\n  border-width: 0;\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n  border-radius: 4px;\n  background: transparent;\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n}\n.v-btn-group--border {\n  border-width: thin;\n  box-shadow: none;\n}\n.v-btn-group--density-default.v-btn-group {\n  height: 48px;\n}\n.v-btn-group--density-comfortable.v-btn-group {\n  height: 40px;\n}\n.v-btn-group--density-compact.v-btn-group {\n  height: 36px;\n}\n.v-btn-group .v-btn {\n  border-radius: 0;\n  border-color: inherit;\n}\n.v-btn-group .v-btn:not(:last-child) {\n  border-inline-end: none;\n}\n.v-btn-group .v-btn:not(:first-child) {\n  border-inline-start: none;\n}\n.v-btn-group .v-btn:first-child {\n  border-start-start-radius: inherit;\n  border-end-start-radius: inherit;\n}\n.v-btn-group .v-btn:last-child {\n  border-start-end-radius: inherit;\n  border-end-end-radius: inherit;\n}\n.v-btn-group--divided .v-btn:not(:last-child) {\n  border-inline-end-width: thin;\n  border-inline-end-style: solid;\n  border-inline-end-color: rgba(var(--v-border-color), var(--v-border-opacity));\n}\n.v-btn-group--tile {\n  border-radius: 0;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VIcon/VIcon.css */\n.v-icon {\n  --v-icon-size-multiplier: 1;\n  align-items: center;\n  display: inline-flex;\n  font-feature-settings: \"liga\";\n  height: 1em;\n  justify-content: center;\n  letter-spacing: normal;\n  line-height: 1;\n  position: relative;\n  text-indent: 0;\n  text-align: center;\n  user-select: none;\n  vertical-align: middle;\n  width: 1em;\n  min-width: 1em;\n}\n.v-icon--clickable {\n  cursor: pointer;\n}\n.v-icon--disabled {\n  pointer-events: none;\n  opacity: 0.38;\n}\n.v-icon--size-x-small {\n  font-size: calc(var(--v-icon-size-multiplier) * 1em);\n}\n.v-icon--size-small {\n  font-size: calc(var(--v-icon-size-multiplier) * 1.25em);\n}\n.v-icon--size-default {\n  font-size: calc(var(--v-icon-size-multiplier) * 1.5em);\n}\n.v-icon--size-large {\n  font-size: calc(var(--v-icon-size-multiplier) * 1.75em);\n}\n.v-icon--size-x-large {\n  font-size: calc(var(--v-icon-size-multiplier) * 2em);\n}\n.v-icon__svg {\n  fill: currentColor;\n  width: 100%;\n  height: 100%;\n}\n.v-icon--start {\n  margin-inline-end: 8px;\n}\n.v-icon--end {\n  margin-inline-start: 8px;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VProgressCircular/VProgressCircular.css */\n.v-progress-circular {\n  align-items: center;\n  display: inline-flex;\n  justify-content: center;\n  position: relative;\n  vertical-align: middle;\n}\n.v-progress-circular > svg {\n  width: 100%;\n  height: 100%;\n  margin: auto;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  z-index: 0;\n}\n.v-progress-circular__content {\n  align-items: center;\n  display: flex;\n  justify-content: center;\n}\n.v-progress-circular__underlay {\n  color: rgba(var(--v-border-color), var(--v-border-opacity));\n  stroke: currentColor;\n  z-index: 1;\n}\n.v-progress-circular__overlay {\n  stroke: currentColor;\n  transition: all 0.2s ease-in-out, stroke-width 0s;\n  z-index: 2;\n}\n.v-progress-circular--size-x-small {\n  height: 16px;\n  width: 16px;\n}\n.v-progress-circular--size-small {\n  height: 24px;\n  width: 24px;\n}\n.v-progress-circular--size-default {\n  height: 32px;\n  width: 32px;\n}\n.v-progress-circular--size-large {\n  height: 48px;\n  width: 48px;\n}\n.v-progress-circular--size-x-large {\n  height: 64px;\n  width: 64px;\n}\n.v-progress-circular--indeterminate > svg {\n  animation: progress-circular-rotate 1.4s linear infinite;\n  transform-origin: center center;\n  transition: all 0.2s ease-in-out;\n}\n.v-progress-circular--indeterminate .v-progress-circular__overlay {\n  animation: progress-circular-dash 1.4s ease-in-out infinite, progress-circular-rotate 1.4s linear infinite;\n  stroke-dasharray: 25, 200;\n  stroke-dashoffset: 0;\n  stroke-linecap: round;\n  transform-origin: center center;\n  transform: rotate(-90deg);\n}\n.v-progress-circular--disable-shrink > svg {\n  animation-duration: 0.7s;\n}\n.v-progress-circular--disable-shrink .v-progress-circular__overlay {\n  animation: none;\n}\n.v-progress-circular--indeterminate:not(.v-progress-circular--visible) > svg,\n.v-progress-circular--indeterminate:not(.v-progress-circular--visible) .v-progress-circular__overlay {\n  animation-play-state: paused !important;\n}\n@keyframes progress-circular-dash {\n  0% {\n    stroke-dasharray: 1, 200;\n    stroke-dashoffset: 0px;\n  }\n  50% {\n    stroke-dasharray: 100, 200;\n    stroke-dashoffset: -15px;\n  }\n  100% {\n    stroke-dasharray: 100, 200;\n    stroke-dashoffset: -124px;\n  }\n}\n@keyframes progress-circular-rotate {\n  100% {\n    transform: rotate(270deg);\n  }\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VProgressLinear/VProgressLinear.css */\n.v-progress-linear {\n  background: transparent;\n  overflow: hidden;\n  position: relative;\n  transition: 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n  width: 100%;\n}\n.v-progress-linear--rounded {\n  border-radius: 9999px;\n}\n.v-progress-linear__background {\n  background: currentColor;\n  bottom: 0;\n  left: 0;\n  opacity: var(--v-border-opacity);\n  position: absolute;\n  top: 0;\n  transition-property:\n    width,\n    left,\n    right;\n  transition: inherit;\n}\n.v-progress-linear__content {\n  align-items: center;\n  display: flex;\n  height: 100%;\n  justify-content: center;\n  left: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 0;\n  width: 100%;\n}\n.v-progress-linear__determinate,\n.v-progress-linear__indeterminate {\n  background: currentColor;\n}\n.v-progress-linear__determinate {\n  height: inherit;\n  left: 0;\n  position: absolute;\n  transition: inherit;\n  transition-property:\n    width,\n    left,\n    right;\n}\n.v-progress-linear__indeterminate .long,\n.v-progress-linear__indeterminate .short {\n  animation-play-state: paused;\n  animation-duration: 2.2s;\n  animation-iteration-count: infinite;\n  bottom: 0;\n  height: inherit;\n  left: 0;\n  position: absolute;\n  right: auto;\n  top: 0;\n  width: auto;\n}\n.v-progress-linear__indeterminate .long {\n  animation-name: indeterminate-ltr;\n}\n.v-progress-linear__indeterminate .short {\n  animation-name: indeterminate-short-ltr;\n}\n.v-progress-linear__stream {\n  animation: stream 0.25s infinite linear;\n  animation-play-state: paused;\n  bottom: 0;\n  left: auto;\n  opacity: 0.3;\n  pointer-events: none;\n  position: absolute;\n  transition: inherit;\n  transition-property:\n    width,\n    left,\n    right;\n}\n.v-progress-linear--reverse .v-progress-linear__background,\n.v-progress-linear--reverse .v-progress-linear__determinate,\n.v-progress-linear--reverse .v-progress-linear__content {\n  left: auto;\n  right: 0;\n}\n.v-progress-linear--reverse .v-progress-linear__indeterminate .long,\n.v-progress-linear--reverse .v-progress-linear__indeterminate .short {\n  left: auto;\n  right: 0;\n}\n.v-progress-linear--reverse .v-progress-linear__indeterminate .long {\n  animation-name: indeterminate-rtl;\n}\n.v-progress-linear--reverse .v-progress-linear__indeterminate .short {\n  animation-name: indeterminate-short-rtl;\n}\n.v-progress-linear--reverse .v-progress-linear__stream {\n  right: auto;\n}\n.v-progress-linear--absolute,\n.v-progress-linear--fixed {\n  left: 0;\n  z-index: 1;\n}\n.v-progress-linear--absolute {\n  position: absolute;\n}\n.v-progress-linear--fixed {\n  position: fixed;\n}\n.v-progress-linear--rounded {\n  border-radius: 9999px;\n}\n.v-progress-linear--rounded.v-progress-linear--rounded-bar .v-progress-linear__determinate,\n.v-progress-linear--rounded.v-progress-linear--rounded-bar .v-progress-linear__indeterminate {\n  border-radius: inherit;\n}\n.v-progress-linear--striped .v-progress-linear__determinate {\n  animation: progress-linear-stripes 1s infinite linear;\n  background-image: linear-gradient(135deg, hsla(0, 0%, 100%, 0.25) 25%, transparent 0, transparent 50%, hsla(0, 0%, 100%, 0.25) 0, hsla(0, 0%, 100%, 0.25) 75%, transparent 0, transparent);\n  background-repeat: repeat;\n  background-size: var(--v-progress-linear-height);\n}\n.v-progress-linear--active .v-progress-linear__indeterminate .long,\n.v-progress-linear--active .v-progress-linear__indeterminate .short {\n  animation-play-state: running;\n}\n.v-progress-linear--active .v-progress-linear__stream {\n  animation-play-state: running;\n}\n.v-progress-linear--rounded-bar .v-progress-linear__determinate,\n.v-progress-linear--rounded-bar .v-progress-linear__indeterminate,\n.v-progress-linear--rounded-bar .v-progress-linear__stream + .v-progress-linear__background {\n  border-radius: 9999px;\n}\n.v-progress-linear--rounded-bar .v-progress-linear__determinate {\n  border-start-start-radius: 0;\n  border-end-start-radius: 0;\n}\n@keyframes indeterminate-ltr {\n  0% {\n    left: -90%;\n    right: 100%;\n  }\n  60% {\n    left: -90%;\n    right: 100%;\n  }\n  100% {\n    left: 100%;\n    right: -35%;\n  }\n}\n@keyframes indeterminate-rtl {\n  0% {\n    left: 100%;\n    right: -90%;\n  }\n  60% {\n    left: 100%;\n    right: -90%;\n  }\n  100% {\n    left: -35%;\n    right: 100%;\n  }\n}\n@keyframes indeterminate-short-ltr {\n  0% {\n    left: -200%;\n    right: 100%;\n  }\n  60% {\n    left: 107%;\n    right: -8%;\n  }\n  100% {\n    left: 107%;\n    right: -8%;\n  }\n}\n@keyframes indeterminate-short-rtl {\n  0% {\n    left: 100%;\n    right: -200%;\n  }\n  60% {\n    left: -8%;\n    right: 107%;\n  }\n  100% {\n    left: -8%;\n    right: 107%;\n  }\n}\n@keyframes stream {\n  to {\n    transform: translateX(var(--v-progress-linear-stream-to));\n  }\n}\n@keyframes progress-linear-stripes {\n  0% {\n    background-position-x: var(--v-progress-linear-height);\n  }\n}\n\n/* ../library_management/node_modules/vuetify/lib/directives/ripple/VRipple.css */\n.v-ripple__container {\n  color: inherit;\n  border-radius: inherit;\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n  overflow: hidden;\n  z-index: 0;\n  pointer-events: none;\n  contain: strict;\n}\n.v-ripple__animation {\n  color: inherit;\n  position: absolute;\n  top: 0;\n  left: 0;\n  border-radius: 50%;\n  background: currentColor;\n  opacity: 0;\n  pointer-events: none;\n  overflow: hidden;\n  will-change: transform, opacity;\n}\n.v-ripple__animation--enter {\n  transition: none;\n  opacity: 0;\n}\n.v-ripple__animation--in {\n  transition: transform 0.25s cubic-bezier(0, 0, 0.2, 1), opacity 0.1s cubic-bezier(0, 0, 0.2, 1);\n  opacity: calc(0.25 * var(--v-theme-overlay-multiplier));\n}\n.v-ripple__animation--out {\n  transition: opacity 0.3s cubic-bezier(0, 0, 0.2, 1);\n  opacity: 0;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VAlert/VAlert.css */\n.v-alert {\n  display: grid;\n  flex: 1 1;\n  grid-template-areas: \"prepend content append close\" \". content . .\";\n  grid-template-columns: max-content auto max-content max-content;\n  position: relative;\n  padding: 16px;\n  overflow: hidden;\n  --v-border-color: currentColor;\n  border-radius: 4px;\n}\n.v-alert--absolute {\n  position: absolute;\n}\n.v-alert--fixed {\n  position: fixed;\n}\n.v-alert--sticky {\n  position: sticky;\n}\n.v-alert--variant-plain,\n.v-alert--variant-outlined,\n.v-alert--variant-text,\n.v-alert--variant-tonal {\n  background: transparent;\n  color: inherit;\n}\n.v-alert--variant-plain {\n  opacity: 0.62;\n}\n.v-alert--variant-plain:focus,\n.v-alert--variant-plain:hover {\n  opacity: 1;\n}\n.v-alert--variant-plain .v-alert__overlay {\n  display: none;\n}\n.v-alert--variant-elevated,\n.v-alert--variant-flat {\n  background: rgb(var(--v-theme-surface-light));\n  color: rgba(var(--v-theme-on-surface-light), var(--v-high-emphasis-opacity));\n}\n.v-alert--variant-elevated {\n  box-shadow:\n    0px 2px 1px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 1px 1px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 3px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-alert--variant-flat {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-alert--variant-outlined {\n  border: thin solid currentColor;\n}\n.v-alert--variant-text .v-alert__overlay {\n  background: currentColor;\n}\n.v-alert--variant-tonal .v-alert__underlay {\n  background: currentColor;\n  opacity: var(--v-activated-opacity);\n  border-radius: inherit;\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  pointer-events: none;\n}\n.v-alert--prominent {\n  grid-template-areas: \"prepend content append close\" \"prepend content . .\";\n}\n.v-alert.v-alert--border {\n  --v-border-opacity: 0.38;\n}\n.v-alert.v-alert--border.v-alert--border-start {\n  padding-inline-start: 24px;\n}\n.v-alert.v-alert--border.v-alert--border-end {\n  padding-inline-end: 24px;\n}\n.v-alert--variant-plain {\n  transition: 0.2s opacity cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-alert--density-default {\n  padding-bottom: 16px;\n  padding-top: 16px;\n}\n.v-alert--density-default.v-alert--border-top {\n  padding-top: 24px;\n}\n.v-alert--density-default.v-alert--border-bottom {\n  padding-bottom: 24px;\n}\n.v-alert--density-comfortable {\n  padding-bottom: 12px;\n  padding-top: 12px;\n}\n.v-alert--density-comfortable.v-alert--border-top {\n  padding-top: 20px;\n}\n.v-alert--density-comfortable.v-alert--border-bottom {\n  padding-bottom: 20px;\n}\n.v-alert--density-compact {\n  padding-bottom: 8px;\n  padding-top: 8px;\n}\n.v-alert--density-compact.v-alert--border-top {\n  padding-top: 16px;\n}\n.v-alert--density-compact.v-alert--border-bottom {\n  padding-bottom: 16px;\n}\n.v-alert__border {\n  border-radius: inherit;\n  bottom: 0;\n  left: 0;\n  opacity: var(--v-border-opacity);\n  position: absolute;\n  pointer-events: none;\n  right: 0;\n  top: 0;\n  width: 100%;\n  border-color: currentColor;\n  border-style: solid;\n  border-width: 0;\n}\n.v-alert__border--border {\n  border-width: 8px;\n  box-shadow: none;\n}\n.v-alert--border-start .v-alert__border {\n  border-inline-start-width: 8px;\n}\n.v-alert--border-end .v-alert__border {\n  border-inline-end-width: 8px;\n}\n.v-alert--border-top .v-alert__border {\n  border-top-width: 8px;\n}\n.v-alert--border-bottom .v-alert__border {\n  border-bottom-width: 8px;\n}\n.v-alert__close {\n  flex: 0 1 auto;\n  grid-area: close;\n}\n.v-alert__content {\n  align-self: center;\n  grid-area: content;\n  overflow: hidden;\n}\n.v-alert__append,\n.v-alert__close {\n  align-self: flex-start;\n  margin-inline-start: 16px;\n}\n.v-alert__append {\n  align-self: flex-start;\n  grid-area: append;\n}\n.v-alert__append + .v-alert__close {\n  margin-inline-start: 16px;\n}\n.v-alert__prepend {\n  align-self: flex-start;\n  display: flex;\n  align-items: center;\n  grid-area: prepend;\n  margin-inline-end: 16px;\n}\n.v-alert--prominent .v-alert__prepend {\n  align-self: center;\n}\n.v-alert__underlay {\n  grid-area: none;\n  position: absolute;\n}\n.v-alert--border-start .v-alert__underlay {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n.v-alert--border-end .v-alert__underlay {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n.v-alert--border-top .v-alert__underlay {\n  border-top-left-radius: 0;\n  border-top-right-radius: 0;\n}\n.v-alert--border-bottom .v-alert__underlay {\n  border-bottom-left-radius: 0;\n  border-bottom-right-radius: 0;\n}\n.v-alert-title {\n  align-items: center;\n  align-self: center;\n  display: flex;\n  font-size: 1.25rem;\n  font-weight: 500;\n  hyphens: auto;\n  letter-spacing: 0.0125em;\n  line-height: 1.75rem;\n  overflow-wrap: normal;\n  text-transform: none;\n  word-break: normal;\n  word-wrap: break-word;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VAutocomplete/VAutocomplete.css */\n.v-autocomplete .v-field .v-text-field__prefix,\n.v-autocomplete .v-field .v-text-field__suffix,\n.v-autocomplete .v-field .v-field__input,\n.v-autocomplete .v-field.v-field {\n  cursor: text;\n}\n.v-autocomplete .v-field .v-field__input > input {\n  flex: 1 1;\n}\n.v-autocomplete .v-field input {\n  min-width: 64px;\n}\n.v-autocomplete .v-field:not(.v-field--focused) input {\n  min-width: 0;\n}\n.v-autocomplete .v-field--dirty .v-autocomplete__selection {\n  margin-inline-end: 2px;\n}\n.v-autocomplete .v-autocomplete__selection-text {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n.v-autocomplete__content {\n  overflow: hidden;\n  box-shadow:\n    0px 2px 4px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 4px 5px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 10px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n  border-radius: 4px;\n}\n.v-autocomplete__mask {\n  background: rgb(var(--v-theme-surface-light));\n}\n.v-autocomplete__selection {\n  display: inline-flex;\n  align-items: center;\n  height: 1.5rem;\n  letter-spacing: inherit;\n  line-height: inherit;\n  max-width: calc(100% - 2px - 2px);\n}\n.v-autocomplete__selection:first-child {\n  margin-inline-start: 0;\n}\n.v-autocomplete--chips.v-input--density-compact .v-field--variant-solo .v-label.v-field-label--floating,\n.v-autocomplete--chips.v-input--density-compact .v-field--variant-solo-inverted .v-label.v-field-label--floating,\n.v-autocomplete--chips.v-input--density-compact .v-field--variant-filled .v-label.v-field-label--floating,\n.v-autocomplete--chips.v-input--density-compact .v-field--variant-solo-filled .v-label.v-field-label--floating {\n  top: 0px;\n}\n.v-autocomplete--selecting-index .v-autocomplete__selection {\n  opacity: var(--v-medium-emphasis-opacity);\n}\n.v-autocomplete--selecting-index .v-autocomplete__selection--selected {\n  opacity: 1;\n}\n.v-autocomplete--selecting-index .v-field__input > input {\n  caret-color: transparent;\n}\n.v-autocomplete--single:not(.v-autocomplete--selection-slot).v-text-field input {\n  flex: 1 1;\n  position: absolute;\n  left: 0;\n  right: 0;\n  width: 100%;\n  padding-inline: inherit;\n}\n.v-autocomplete--single:not(.v-autocomplete--selection-slot) .v-field--active input {\n  transition: none;\n}\n.v-autocomplete--single:not(.v-autocomplete--selection-slot) .v-field--dirty:not(.v-field--focused) input {\n  opacity: 0;\n}\n.v-autocomplete--single:not(.v-autocomplete--selection-slot) .v-field--focused .v-autocomplete__selection {\n  opacity: 0;\n}\n.v-autocomplete__menu-icon {\n  margin-inline-start: 4px;\n  transition: 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-autocomplete--active-menu .v-autocomplete__menu-icon {\n  opacity: var(--v-high-emphasis-opacity);\n  transform: rotate(180deg);\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VAvatar/VAvatar.css */\n.v-avatar {\n  flex: none;\n  align-items: center;\n  display: inline-flex;\n  justify-content: center;\n  line-height: normal;\n  overflow: hidden;\n  position: relative;\n  text-align: center;\n  transition: 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n  transition-property: width, height;\n  vertical-align: middle;\n  border-radius: 50%;\n}\n.v-avatar.v-avatar--size-x-small {\n  --v-avatar-height: 24px;\n}\n.v-avatar.v-avatar--size-small {\n  --v-avatar-height: 32px;\n}\n.v-avatar.v-avatar--size-default {\n  --v-avatar-height: 40px;\n}\n.v-avatar.v-avatar--size-large {\n  --v-avatar-height: 48px;\n}\n.v-avatar.v-avatar--size-x-large {\n  --v-avatar-height: 56px;\n}\n.v-avatar.v-avatar--density-default {\n  height: calc(var(--v-avatar-height) + 0px);\n  width: calc(var(--v-avatar-height) + 0px);\n}\n.v-avatar.v-avatar--density-comfortable {\n  height: calc(var(--v-avatar-height) + -4px);\n  width: calc(var(--v-avatar-height) + -4px);\n}\n.v-avatar.v-avatar--density-compact {\n  height: calc(var(--v-avatar-height) + -8px);\n  width: calc(var(--v-avatar-height) + -8px);\n}\n.v-avatar--variant-plain,\n.v-avatar--variant-outlined,\n.v-avatar--variant-text,\n.v-avatar--variant-tonal {\n  background: transparent;\n  color: inherit;\n}\n.v-avatar--variant-plain {\n  opacity: 0.62;\n}\n.v-avatar--variant-plain:focus,\n.v-avatar--variant-plain:hover {\n  opacity: 1;\n}\n.v-avatar--variant-plain .v-avatar__overlay {\n  display: none;\n}\n.v-avatar--variant-elevated,\n.v-avatar--variant-flat {\n  background: var(--v-theme-surface);\n  color: rgba(var(--v-theme-on-surface), var(--v-medium-emphasis-opacity));\n}\n.v-avatar--variant-elevated {\n  box-shadow:\n    0px 2px 1px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 1px 1px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 3px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-avatar--variant-flat {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-avatar--variant-outlined {\n  border: thin solid currentColor;\n}\n.v-avatar--variant-text .v-avatar__overlay {\n  background: currentColor;\n}\n.v-avatar--variant-tonal .v-avatar__underlay {\n  background: currentColor;\n  opacity: var(--v-activated-opacity);\n  border-radius: inherit;\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  pointer-events: none;\n}\n.v-avatar--rounded {\n  border-radius: 4px;\n}\n.v-avatar--start {\n  margin-inline-end: 8px;\n}\n.v-avatar--end {\n  margin-inline-start: 8px;\n}\n.v-avatar .v-img {\n  height: 100%;\n  width: 100%;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VCheckbox/VCheckbox.css */\n.v-checkbox.v-input {\n  flex: 0 1 auto;\n}\n.v-checkbox .v-selection-control {\n  min-height: var(--v-input-control-height);\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VSelectionControl/VSelectionControl.css */\n.v-selection-control {\n  align-items: center;\n  contain: layout;\n  display: flex;\n  flex: 1 0;\n  grid-area: control;\n  position: relative;\n  user-select: none;\n}\n.v-selection-control .v-label {\n  white-space: normal;\n  word-break: break-word;\n  height: 100%;\n}\n.v-selection-control--disabled {\n  opacity: var(--v-disabled-opacity);\n  pointer-events: none;\n}\n.v-selection-control--error .v-label,\n.v-selection-control--disabled .v-label {\n  opacity: 1;\n}\n.v-selection-control--error:not(.v-selection-control--disabled) .v-label {\n  color: rgb(var(--v-theme-error));\n}\n.v-selection-control--inline {\n  display: inline-flex;\n  flex: 0 0 auto;\n  min-width: 0;\n  max-width: 100%;\n}\n.v-selection-control--inline .v-label {\n  width: auto;\n}\n.v-selection-control--density-default {\n  --v-selection-control-size: 40px;\n}\n.v-selection-control--density-comfortable {\n  --v-selection-control-size: 36px;\n}\n.v-selection-control--density-compact {\n  --v-selection-control-size: 28px;\n}\n.v-selection-control__wrapper {\n  width: var(--v-selection-control-size);\n  height: var(--v-selection-control-size);\n  display: inline-flex;\n  align-items: center;\n  position: relative;\n  justify-content: center;\n  flex: none;\n}\n.v-selection-control__input {\n  width: var(--v-selection-control-size);\n  height: var(--v-selection-control-size);\n  align-items: center;\n  display: flex;\n  flex: none;\n  justify-content: center;\n  position: relative;\n  border-radius: 50%;\n}\n.v-selection-control__input input {\n  cursor: pointer;\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  opacity: 0;\n}\n.v-selection-control__input::before {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  border-radius: 100%;\n  background-color: currentColor;\n  opacity: 0;\n  pointer-events: none;\n}\n.v-selection-control__input:hover::before {\n  opacity: calc(var(--v-hover-opacity) * var(--v-theme-overlay-multiplier));\n}\n.v-selection-control__input > .v-icon {\n  opacity: var(--v-medium-emphasis-opacity);\n}\n.v-selection-control--disabled .v-selection-control__input > .v-icon,\n.v-selection-control--dirty .v-selection-control__input > .v-icon,\n.v-selection-control--error .v-selection-control__input > .v-icon {\n  opacity: 1;\n}\n.v-selection-control--error:not(.v-selection-control--disabled) .v-selection-control__input > .v-icon {\n  color: rgb(var(--v-theme-error));\n}\n.v-selection-control--focus-visible .v-selection-control__input::before {\n  opacity: calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier));\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VLabel/VLabel.css */\n.v-label {\n  align-items: center;\n  color: inherit;\n  display: inline-flex;\n  font-size: 1rem;\n  letter-spacing: 0.009375em;\n  min-width: 0;\n  opacity: var(--v-medium-emphasis-opacity);\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n.v-label--clickable {\n  cursor: pointer;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VSelectionControlGroup/VSelectionControlGroup.css */\n.v-selection-control-group {\n  grid-area: control;\n  display: flex;\n  flex-direction: column;\n}\n.v-selection-control-group--inline {\n  flex-direction: row;\n  flex-wrap: wrap;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VInput/VInput.css */\n.v-input {\n  display: grid;\n  flex: 1 1 auto;\n  font-size: 1rem;\n  font-weight: 400;\n  line-height: 1.5;\n}\n.v-input--disabled {\n  pointer-events: none;\n}\n.v-input--density-default {\n  --v-input-control-height: 56px;\n  --v-input-padding-top: 16px;\n}\n.v-input--density-comfortable {\n  --v-input-control-height: 48px;\n  --v-input-padding-top: 12px;\n}\n.v-input--density-compact {\n  --v-input-control-height: 40px;\n  --v-input-padding-top: 8px;\n}\n.v-input--vertical {\n  grid-template-areas: \"append\" \"control\" \"prepend\";\n  grid-template-rows: max-content auto max-content;\n  grid-template-columns: min-content;\n}\n.v-input--vertical .v-input__prepend {\n  margin-block-start: 16px;\n}\n.v-input--vertical .v-input__append {\n  margin-block-end: 16px;\n}\n.v-input--horizontal {\n  grid-template-areas: \"prepend control append\" \"a messages b\";\n  grid-template-columns: max-content minmax(0, 1fr) max-content;\n  grid-template-rows: auto auto;\n}\n.v-input--horizontal .v-input__prepend {\n  margin-inline-end: 16px;\n}\n.v-input--horizontal .v-input__append {\n  margin-inline-start: 16px;\n}\n.v-input__details {\n  align-items: flex-end;\n  display: flex;\n  font-size: 0.75rem;\n  font-weight: 400;\n  grid-area: messages;\n  letter-spacing: 0.0333333333em;\n  line-height: normal;\n  min-height: 22px;\n  padding-top: 6px;\n  overflow: hidden;\n  justify-content: space-between;\n}\n.v-input__details > .v-icon,\n.v-input__prepend > .v-icon,\n.v-input__append > .v-icon {\n  opacity: var(--v-medium-emphasis-opacity);\n}\n.v-input--disabled .v-input__details > .v-icon,\n.v-input--disabled .v-input__details .v-messages,\n.v-input--error .v-input__details > .v-icon,\n.v-input--error .v-input__details .v-messages,\n.v-input--disabled .v-input__prepend > .v-icon,\n.v-input--disabled .v-input__prepend .v-messages,\n.v-input--error .v-input__prepend > .v-icon,\n.v-input--error .v-input__prepend .v-messages,\n.v-input--disabled .v-input__append > .v-icon,\n.v-input--disabled .v-input__append .v-messages,\n.v-input--error .v-input__append > .v-icon,\n.v-input--error .v-input__append .v-messages {\n  opacity: 1;\n}\n.v-input--disabled .v-input__details,\n.v-input--disabled .v-input__prepend,\n.v-input--disabled .v-input__append {\n  opacity: var(--v-disabled-opacity);\n}\n.v-input--error:not(.v-input--disabled) .v-input__details > .v-icon,\n.v-input--error:not(.v-input--disabled) .v-input__details .v-messages,\n.v-input--error:not(.v-input--disabled) .v-input__prepend > .v-icon,\n.v-input--error:not(.v-input--disabled) .v-input__prepend .v-messages,\n.v-input--error:not(.v-input--disabled) .v-input__append > .v-icon,\n.v-input--error:not(.v-input--disabled) .v-input__append .v-messages {\n  color: rgb(var(--v-theme-error));\n}\n.v-input__prepend,\n.v-input__append {\n  display: flex;\n  align-items: flex-start;\n  padding-top: var(--v-input-padding-top);\n}\n.v-input--center-affix .v-input__prepend,\n.v-input--center-affix .v-input__append {\n  align-items: center;\n  padding-top: 0;\n}\n.v-input__prepend {\n  grid-area: prepend;\n}\n.v-input__append {\n  grid-area: append;\n}\n.v-input__control {\n  display: flex;\n  grid-area: control;\n}\n.v-input--hide-spin-buttons input::-webkit-outer-spin-button,\n.v-input--hide-spin-buttons input::-webkit-inner-spin-button {\n  -webkit-appearance: none;\n  margin: 0;\n}\n.v-input--hide-spin-buttons input[type=number] {\n  -moz-appearance: textfield;\n}\n.v-input--plain-underlined .v-input__prepend,\n.v-input--plain-underlined .v-input__append {\n  align-items: flex-start;\n}\n.v-input--density-default.v-input--plain-underlined .v-input__prepend,\n.v-input--density-default.v-input--plain-underlined .v-input__append {\n  padding-top: calc(var(--v-input-padding-top) + 4px);\n}\n.v-input--density-comfortable.v-input--plain-underlined .v-input__prepend,\n.v-input--density-comfortable.v-input--plain-underlined .v-input__append {\n  padding-top: calc(var(--v-input-padding-top) + 2px);\n}\n.v-input--density-compact.v-input--plain-underlined .v-input__prepend,\n.v-input--density-compact.v-input--plain-underlined .v-input__append {\n  padding-top: calc(var(--v-input-padding-top) + 0px);\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VMessages/VMessages.css */\n.v-messages {\n  flex: 1 1 auto;\n  font-size: 12px;\n  min-height: 14px;\n  min-width: 1px;\n  opacity: var(--v-medium-emphasis-opacity);\n  position: relative;\n}\n.v-messages__message {\n  line-height: 12px;\n  word-break: break-word;\n  overflow-wrap: break-word;\n  word-wrap: break-word;\n  hyphens: auto;\n  transition-duration: 150ms;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VChip/VChip.css */\n.v-chip {\n  align-items: center;\n  display: inline-flex;\n  font-weight: 400;\n  max-width: 100%;\n  min-width: 0;\n  overflow: hidden;\n  position: relative;\n  text-decoration: none;\n  white-space: nowrap;\n  vertical-align: middle;\n  border-color: rgba(var(--v-border-color), var(--v-border-opacity));\n  border-style: solid;\n  border-width: 0;\n  border-radius: 9999px;\n}\n.v-chip .v-icon {\n  --v-icon-size-multiplier: 0.8571428571;\n}\n.v-chip.v-chip--size-x-small {\n  --v-chip-size: 0.625rem;\n  --v-chip-height: 20px;\n  font-size: 0.625rem;\n  padding: 0 8px;\n}\n.v-chip.v-chip--size-x-small .v-avatar {\n  --v-avatar-height: 14px;\n}\n.v-chip--pill.v-chip.v-chip--size-x-small .v-avatar {\n  --v-avatar-height: 20px;\n}\n.v-chip.v-chip--size-x-small .v-avatar--start {\n  margin-inline-start: -5.6px;\n  margin-inline-end: 4px;\n}\n.v-chip--pill.v-chip.v-chip--size-x-small .v-avatar--start {\n  margin-inline-start: -8px;\n}\n.v-chip.v-chip--size-x-small .v-avatar--end {\n  margin-inline-start: 4px;\n  margin-inline-end: -5.6px;\n}\n.v-chip--pill.v-chip.v-chip--size-x-small .v-avatar--end {\n  margin-inline-end: -8px;\n}\n.v-chip--pill.v-chip.v-chip--size-x-small .v-avatar--end + .v-chip__close {\n  margin-inline-start: 12px;\n}\n.v-chip.v-chip--size-x-small .v-icon--start,\n.v-chip.v-chip--size-x-small .v-chip__filter {\n  margin-inline-start: -4px;\n  margin-inline-end: 4px;\n}\n.v-chip.v-chip--size-x-small .v-icon--end,\n.v-chip.v-chip--size-x-small .v-chip__close {\n  margin-inline-start: 4px;\n  margin-inline-end: -4px;\n}\n.v-chip.v-chip--size-x-small .v-icon--end + .v-chip__close,\n.v-chip.v-chip--size-x-small .v-avatar--end + .v-chip__close,\n.v-chip.v-chip--size-x-small .v-chip__append + .v-chip__close {\n  margin-inline-start: 8px;\n}\n.v-chip.v-chip--size-small {\n  --v-chip-size: 0.75rem;\n  --v-chip-height: 26px;\n  font-size: 0.75rem;\n  padding: 0 10px;\n}\n.v-chip.v-chip--size-small .v-avatar {\n  --v-avatar-height: 20px;\n}\n.v-chip--pill.v-chip.v-chip--size-small .v-avatar {\n  --v-avatar-height: 26px;\n}\n.v-chip.v-chip--size-small .v-avatar--start {\n  margin-inline-start: -7px;\n  margin-inline-end: 5px;\n}\n.v-chip--pill.v-chip.v-chip--size-small .v-avatar--start {\n  margin-inline-start: -10px;\n}\n.v-chip.v-chip--size-small .v-avatar--end {\n  margin-inline-start: 5px;\n  margin-inline-end: -7px;\n}\n.v-chip--pill.v-chip.v-chip--size-small .v-avatar--end {\n  margin-inline-end: -10px;\n}\n.v-chip--pill.v-chip.v-chip--size-small .v-avatar--end + .v-chip__close {\n  margin-inline-start: 15px;\n}\n.v-chip.v-chip--size-small .v-icon--start,\n.v-chip.v-chip--size-small .v-chip__filter {\n  margin-inline-start: -5px;\n  margin-inline-end: 5px;\n}\n.v-chip.v-chip--size-small .v-icon--end,\n.v-chip.v-chip--size-small .v-chip__close {\n  margin-inline-start: 5px;\n  margin-inline-end: -5px;\n}\n.v-chip.v-chip--size-small .v-icon--end + .v-chip__close,\n.v-chip.v-chip--size-small .v-avatar--end + .v-chip__close,\n.v-chip.v-chip--size-small .v-chip__append + .v-chip__close {\n  margin-inline-start: 10px;\n}\n.v-chip.v-chip--size-default {\n  --v-chip-size: 0.875rem;\n  --v-chip-height: 32px;\n  font-size: 0.875rem;\n  padding: 0 12px;\n}\n.v-chip.v-chip--size-default .v-avatar {\n  --v-avatar-height: 26px;\n}\n.v-chip--pill.v-chip.v-chip--size-default .v-avatar {\n  --v-avatar-height: 32px;\n}\n.v-chip.v-chip--size-default .v-avatar--start {\n  margin-inline-start: -8.4px;\n  margin-inline-end: 6px;\n}\n.v-chip--pill.v-chip.v-chip--size-default .v-avatar--start {\n  margin-inline-start: -12px;\n}\n.v-chip.v-chip--size-default .v-avatar--end {\n  margin-inline-start: 6px;\n  margin-inline-end: -8.4px;\n}\n.v-chip--pill.v-chip.v-chip--size-default .v-avatar--end {\n  margin-inline-end: -12px;\n}\n.v-chip--pill.v-chip.v-chip--size-default .v-avatar--end + .v-chip__close {\n  margin-inline-start: 18px;\n}\n.v-chip.v-chip--size-default .v-icon--start,\n.v-chip.v-chip--size-default .v-chip__filter {\n  margin-inline-start: -6px;\n  margin-inline-end: 6px;\n}\n.v-chip.v-chip--size-default .v-icon--end,\n.v-chip.v-chip--size-default .v-chip__close {\n  margin-inline-start: 6px;\n  margin-inline-end: -6px;\n}\n.v-chip.v-chip--size-default .v-icon--end + .v-chip__close,\n.v-chip.v-chip--size-default .v-avatar--end + .v-chip__close,\n.v-chip.v-chip--size-default .v-chip__append + .v-chip__close {\n  margin-inline-start: 12px;\n}\n.v-chip.v-chip--size-large {\n  --v-chip-size: 1rem;\n  --v-chip-height: 38px;\n  font-size: 1rem;\n  padding: 0 14px;\n}\n.v-chip.v-chip--size-large .v-avatar {\n  --v-avatar-height: 32px;\n}\n.v-chip--pill.v-chip.v-chip--size-large .v-avatar {\n  --v-avatar-height: 38px;\n}\n.v-chip.v-chip--size-large .v-avatar--start {\n  margin-inline-start: -9.8px;\n  margin-inline-end: 7px;\n}\n.v-chip--pill.v-chip.v-chip--size-large .v-avatar--start {\n  margin-inline-start: -14px;\n}\n.v-chip.v-chip--size-large .v-avatar--end {\n  margin-inline-start: 7px;\n  margin-inline-end: -9.8px;\n}\n.v-chip--pill.v-chip.v-chip--size-large .v-avatar--end {\n  margin-inline-end: -14px;\n}\n.v-chip--pill.v-chip.v-chip--size-large .v-avatar--end + .v-chip__close {\n  margin-inline-start: 21px;\n}\n.v-chip.v-chip--size-large .v-icon--start,\n.v-chip.v-chip--size-large .v-chip__filter {\n  margin-inline-start: -7px;\n  margin-inline-end: 7px;\n}\n.v-chip.v-chip--size-large .v-icon--end,\n.v-chip.v-chip--size-large .v-chip__close {\n  margin-inline-start: 7px;\n  margin-inline-end: -7px;\n}\n.v-chip.v-chip--size-large .v-icon--end + .v-chip__close,\n.v-chip.v-chip--size-large .v-avatar--end + .v-chip__close,\n.v-chip.v-chip--size-large .v-chip__append + .v-chip__close {\n  margin-inline-start: 14px;\n}\n.v-chip.v-chip--size-x-large {\n  --v-chip-size: 1.125rem;\n  --v-chip-height: 44px;\n  font-size: 1.125rem;\n  padding: 0 17px;\n}\n.v-chip.v-chip--size-x-large .v-avatar {\n  --v-avatar-height: 38px;\n}\n.v-chip--pill.v-chip.v-chip--size-x-large .v-avatar {\n  --v-avatar-height: 44px;\n}\n.v-chip.v-chip--size-x-large .v-avatar--start {\n  margin-inline-start: -11.9px;\n  margin-inline-end: 8.5px;\n}\n.v-chip--pill.v-chip.v-chip--size-x-large .v-avatar--start {\n  margin-inline-start: -17px;\n}\n.v-chip.v-chip--size-x-large .v-avatar--end {\n  margin-inline-start: 8.5px;\n  margin-inline-end: -11.9px;\n}\n.v-chip--pill.v-chip.v-chip--size-x-large .v-avatar--end {\n  margin-inline-end: -17px;\n}\n.v-chip--pill.v-chip.v-chip--size-x-large .v-avatar--end + .v-chip__close {\n  margin-inline-start: 25.5px;\n}\n.v-chip.v-chip--size-x-large .v-icon--start,\n.v-chip.v-chip--size-x-large .v-chip__filter {\n  margin-inline-start: -8.5px;\n  margin-inline-end: 8.5px;\n}\n.v-chip.v-chip--size-x-large .v-icon--end,\n.v-chip.v-chip--size-x-large .v-chip__close {\n  margin-inline-start: 8.5px;\n  margin-inline-end: -8.5px;\n}\n.v-chip.v-chip--size-x-large .v-icon--end + .v-chip__close,\n.v-chip.v-chip--size-x-large .v-avatar--end + .v-chip__close,\n.v-chip.v-chip--size-x-large .v-chip__append + .v-chip__close {\n  margin-inline-start: 17px;\n}\n.v-chip.v-chip--density-default {\n  height: calc(var(--v-chip-height) + 0px);\n}\n.v-chip.v-chip--density-comfortable {\n  height: calc(var(--v-chip-height) + -4px);\n}\n.v-chip.v-chip--density-compact {\n  height: calc(var(--v-chip-height) + -8px);\n}\n.v-chip:hover > .v-chip__overlay {\n  opacity: calc(var(--v-hover-opacity) * var(--v-theme-overlay-multiplier));\n}\n.v-chip:focus-visible > .v-chip__overlay {\n  opacity: calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier));\n}\n@supports not selector(:focus-visible) {\n  .v-chip:focus > .v-chip__overlay {\n    opacity: calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-chip--active > .v-chip__overlay,\n.v-chip[aria-haspopup=menu][aria-expanded=true] > .v-chip__overlay {\n  opacity: calc(var(--v-activated-opacity) * var(--v-theme-overlay-multiplier));\n}\n.v-chip--active:hover > .v-chip__overlay,\n.v-chip[aria-haspopup=menu][aria-expanded=true]:hover > .v-chip__overlay {\n  opacity: calc((var(--v-activated-opacity) + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier));\n}\n.v-chip--active:focus-visible > .v-chip__overlay,\n.v-chip[aria-haspopup=menu][aria-expanded=true]:focus-visible > .v-chip__overlay {\n  opacity: calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n}\n@supports not selector(:focus-visible) {\n  .v-chip--active:focus > .v-chip__overlay,\n  .v-chip[aria-haspopup=menu][aria-expanded=true]:focus > .v-chip__overlay {\n    opacity: calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-chip--variant-plain,\n.v-chip--variant-outlined,\n.v-chip--variant-text,\n.v-chip--variant-tonal {\n  background: transparent;\n  color: inherit;\n}\n.v-chip--variant-plain {\n  opacity: 0.26;\n}\n.v-chip--variant-plain:focus,\n.v-chip--variant-plain:hover {\n  opacity: 1;\n}\n.v-chip--variant-plain .v-chip__overlay {\n  display: none;\n}\n.v-chip--variant-elevated,\n.v-chip--variant-flat {\n  background: rgb(var(--v-theme-surface-variant));\n  color: rgb(var(--v-theme-on-surface-variant));\n}\n.v-chip--variant-elevated {\n  box-shadow:\n    0px 2px 1px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 1px 1px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 3px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-chip--variant-flat {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-chip--variant-outlined {\n  border: thin solid currentColor;\n}\n.v-chip--variant-text .v-chip__overlay {\n  background: currentColor;\n}\n.v-chip--variant-tonal .v-chip__underlay {\n  background: currentColor;\n  opacity: var(--v-activated-opacity);\n  border-radius: inherit;\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  pointer-events: none;\n}\n.v-chip--border {\n  border-width: thin;\n}\n.v-chip--link {\n  cursor: pointer;\n}\n.v-chip--filter {\n  user-select: none;\n}\n.v-chip--label {\n  border-radius: 4px;\n}\n.v-chip__content {\n  align-items: center;\n  display: inline-flex;\n}\n.v-autocomplete__selection .v-chip__content,\n.v-combobox__selection .v-chip__content,\n.v-select__selection .v-chip__content {\n  overflow: hidden;\n}\n.v-chip__filter,\n.v-chip__prepend,\n.v-chip__append,\n.v-chip__close {\n  align-items: center;\n  display: inline-flex;\n}\n.v-chip__close {\n  cursor: pointer;\n  flex: 0 1 auto;\n  font-size: 18px;\n  max-height: 18px;\n  max-width: 18px;\n  user-select: none;\n}\n.v-chip__close .v-icon {\n  font-size: inherit;\n}\n.v-chip__filter {\n  transition: 0.15s cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-chip__overlay {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background-color: currentColor;\n  border-radius: inherit;\n  pointer-events: none;\n  opacity: 0;\n  transition: opacity 0.2s ease-in-out;\n}\n.v-chip--disabled {\n  opacity: 0.3;\n  pointer-events: none;\n  user-select: none;\n}\n.v-chip--label {\n  border-radius: 4px;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VChipGroup/VChipGroup.css */\n.v-chip-group {\n  display: flex;\n  max-width: 100%;\n  min-width: 0;\n  overflow-x: auto;\n  padding: 4px 0;\n}\n.v-chip-group .v-chip {\n  margin: 4px 8px 4px 0;\n}\n.v-chip-group .v-chip.v-chip--selected:not(.v-chip--disabled) .v-chip__overlay {\n  opacity: var(--v-activated-opacity);\n}\n.v-chip-group--column .v-slide-group__content {\n  white-space: normal;\n  flex-wrap: wrap;\n  max-width: 100%;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VSlideGroup/VSlideGroup.css */\n.v-slide-group {\n  display: flex;\n  overflow: hidden;\n}\n.v-slide-group__next,\n.v-slide-group__prev {\n  align-items: center;\n  display: flex;\n  flex: 0 1 52px;\n  justify-content: center;\n  min-width: 52px;\n  cursor: pointer;\n}\n.v-slide-group__next--disabled,\n.v-slide-group__prev--disabled {\n  pointer-events: none;\n  opacity: var(--v-disabled-opacity);\n}\n.v-slide-group__content {\n  display: flex;\n  flex: 1 0 auto;\n  position: relative;\n  transition: 0.2s all cubic-bezier(0.4, 0, 0.2, 1);\n  white-space: nowrap;\n}\n.v-slide-group__content > * {\n  white-space: initial;\n}\n.v-slide-group__container {\n  contain: content;\n  display: flex;\n  flex: 1 1 auto;\n  overflow: hidden;\n}\n.v-slide-group--vertical,\n.v-slide-group--vertical .v-slide-group__container,\n.v-slide-group--vertical .v-slide-group__content {\n  flex-direction: column;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VList/VList.css */\n.v-list {\n  overflow: auto;\n  padding: 8px 0;\n  position: relative;\n  outline: none;\n  border-color: rgba(var(--v-border-color), var(--v-border-opacity));\n  border-style: solid;\n  border-width: 0;\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n  border-radius: 0;\n  background: rgba(var(--v-theme-surface));\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n}\n.v-list--border {\n  border-width: thin;\n  box-shadow: none;\n}\n.v-list--disabled {\n  pointer-events: none;\n  user-select: none;\n}\n.v-list--nav {\n  padding-inline: 8px;\n}\n.v-list--rounded {\n  border-radius: 4px;\n}\n.v-list--subheader {\n  padding-top: 0;\n}\n.v-list-img {\n  border-radius: inherit;\n  display: flex;\n  height: 100%;\n  left: 0;\n  overflow: hidden;\n  position: absolute;\n  top: 0;\n  width: 100%;\n  z-index: -1;\n}\n.v-list-subheader {\n  align-items: center;\n  background: inherit;\n  color: rgba(var(--v-theme-on-surface), var(--v-medium-emphasis-opacity));\n  display: flex;\n  font-size: 0.875rem;\n  font-weight: 400;\n  line-height: 1.375rem;\n  padding-inline-end: 16px;\n  min-height: 40px;\n  transition: 0.2s min-height cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-list-subheader__text {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n.v-list--density-default .v-list-subheader {\n  min-height: 40px;\n  padding-inline-start: calc(16px + var(--indent-padding)) !important;\n}\n.v-list--density-comfortable .v-list-subheader {\n  min-height: 36px;\n  padding-inline-start: calc(16px + var(--indent-padding)) !important;\n}\n.v-list--density-compact .v-list-subheader {\n  min-height: 32px;\n  padding-inline-start: calc(16px + var(--indent-padding)) !important;\n}\n.v-list-subheader--inset {\n  --indent-padding: 56px;\n}\n.v-list--nav .v-list-subheader {\n  font-size: 0.75rem;\n}\n.v-list-subheader--sticky {\n  background: inherit;\n  left: 0;\n  position: sticky;\n  top: 0;\n  z-index: 1;\n}\n.v-list__overlay {\n  background-color: currentColor;\n  border-radius: inherit;\n  bottom: 0;\n  left: 0;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  right: 0;\n  top: 0;\n  transition: opacity 0.2s ease-in-out;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VList/VListItem.css */\n.v-list-item {\n  align-items: center;\n  display: grid;\n  flex: none;\n  grid-template-areas: \"prepend content append\";\n  grid-template-columns: max-content 1fr auto;\n  outline: none;\n  max-width: 100%;\n  padding: 4px 16px;\n  position: relative;\n  text-decoration: none;\n  border-color: rgba(var(--v-border-color), var(--v-border-opacity));\n  border-style: solid;\n  border-width: 0;\n  border-radius: 0;\n}\n.v-list-item--border {\n  border-width: thin;\n  box-shadow: none;\n}\n.v-list-item:hover > .v-list-item__overlay {\n  opacity: calc(var(--v-hover-opacity) * var(--v-theme-overlay-multiplier));\n}\n.v-list-item:focus-visible > .v-list-item__overlay {\n  opacity: calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier));\n}\n@supports not selector(:focus-visible) {\n  .v-list-item:focus > .v-list-item__overlay {\n    opacity: calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-list-item--active > .v-list-item__overlay,\n.v-list-item[aria-haspopup=menu][aria-expanded=true] > .v-list-item__overlay {\n  opacity: calc(var(--v-activated-opacity) * var(--v-theme-overlay-multiplier));\n}\n.v-list-item--active:hover > .v-list-item__overlay,\n.v-list-item[aria-haspopup=menu][aria-expanded=true]:hover > .v-list-item__overlay {\n  opacity: calc((var(--v-activated-opacity) + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier));\n}\n.v-list-item--active:focus-visible > .v-list-item__overlay,\n.v-list-item[aria-haspopup=menu][aria-expanded=true]:focus-visible > .v-list-item__overlay {\n  opacity: calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n}\n@supports not selector(:focus-visible) {\n  .v-list-item--active:focus > .v-list-item__overlay,\n  .v-list-item[aria-haspopup=menu][aria-expanded=true]:focus > .v-list-item__overlay {\n    opacity: calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-list-item--variant-plain,\n.v-list-item--variant-outlined,\n.v-list-item--variant-text,\n.v-list-item--variant-tonal {\n  background: transparent;\n  color: inherit;\n}\n.v-list-item--variant-plain {\n  opacity: 0.62;\n}\n.v-list-item--variant-plain:focus,\n.v-list-item--variant-plain:hover {\n  opacity: 1;\n}\n.v-list-item--variant-plain .v-list-item__overlay {\n  display: none;\n}\n.v-list-item--variant-elevated,\n.v-list-item--variant-flat {\n  background: rgba(var(--v-theme-surface));\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n}\n.v-list-item--variant-elevated {\n  box-shadow:\n    0px 2px 1px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 1px 1px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 3px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-list-item--variant-flat {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-list-item--variant-outlined {\n  border: thin solid currentColor;\n}\n.v-list-item--variant-text .v-list-item__overlay {\n  background: currentColor;\n}\n.v-list-item--variant-tonal .v-list-item__underlay {\n  background: currentColor;\n  opacity: var(--v-activated-opacity);\n  border-radius: inherit;\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  pointer-events: none;\n}\n@supports selector(:focus-visible) {\n  .v-list-item::after {\n    content: \"\";\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n    border: 2px solid currentColor;\n    border-radius: 4px;\n    opacity: 0;\n    transition: opacity 0.2s ease-in-out;\n  }\n  .v-list-item:focus-visible::after {\n    opacity: calc(0.15 * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-list-item__prepend > .v-badge .v-icon,\n.v-list-item__prepend > .v-icon,\n.v-list-item__append > .v-badge .v-icon,\n.v-list-item__append > .v-icon {\n  opacity: var(--v-medium-emphasis-opacity);\n}\n.v-list-item--active .v-list-item__prepend > .v-badge .v-icon,\n.v-list-item--active .v-list-item__prepend > .v-icon,\n.v-list-item--active .v-list-item__append > .v-badge .v-icon,\n.v-list-item--active .v-list-item__append > .v-icon {\n  opacity: 1;\n}\n.v-list-item--active:not(.v-list-item--link) .v-list-item__overlay {\n  opacity: calc(var(--v-activated-opacity) * var(--v-theme-overlay-multiplier));\n}\n.v-list-item--rounded {\n  border-radius: 4px;\n}\n.v-list-item--disabled {\n  pointer-events: none;\n  user-select: none;\n  opacity: 0.6;\n}\n.v-list-item--link {\n  cursor: pointer;\n}\n.v-navigation-drawer--rail:not(.v-navigation-drawer--expand-on-hover) .v-list-item .v-avatar,\n.v-navigation-drawer--rail.v-navigation-drawer--expand-on-hover:not(.v-navigation-drawer--is-hovering) .v-list-item .v-avatar {\n  --v-avatar-height: 24px;\n}\n.v-list-item__prepend {\n  align-items: center;\n  align-self: center;\n  display: flex;\n  grid-area: prepend;\n}\n.v-list-item__prepend > .v-badge ~ .v-list-item__spacer,\n.v-list-item__prepend > .v-icon ~ .v-list-item__spacer,\n.v-list-item__prepend > .v-tooltip ~ .v-list-item__spacer {\n  width: 32px;\n}\n.v-list-item__prepend > .v-avatar ~ .v-list-item__spacer {\n  width: 16px;\n}\n.v-list-item__prepend > .v-list-item-action ~ .v-list-item__spacer {\n  width: 16px;\n}\n.v-list-item--slim .v-list-item__prepend > .v-badge ~ .v-list-item__spacer,\n.v-list-item--slim .v-list-item__prepend > .v-icon ~ .v-list-item__spacer,\n.v-list-item--slim .v-list-item__prepend > .v-tooltip ~ .v-list-item__spacer {\n  width: 20px;\n}\n.v-list-item--slim .v-list-item__prepend > .v-avatar ~ .v-list-item__spacer {\n  width: 4px;\n}\n.v-list-item--slim .v-list-item__prepend > .v-list-item-action ~ .v-list-item__spacer {\n  width: 4px;\n}\n.v-list-item--three-line .v-list-item__prepend {\n  align-self: start;\n}\n.v-list-item__append {\n  align-self: center;\n  display: flex;\n  align-items: center;\n  grid-area: append;\n}\n.v-list-item__append .v-list-item__spacer {\n  order: -1;\n  transition: 150ms width cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-list-item__append > .v-badge ~ .v-list-item__spacer,\n.v-list-item__append > .v-icon ~ .v-list-item__spacer,\n.v-list-item__append > .v-tooltip ~ .v-list-item__spacer {\n  width: 32px;\n}\n.v-list-item__append > .v-avatar ~ .v-list-item__spacer {\n  width: 16px;\n}\n.v-list-item__append > .v-list-item-action ~ .v-list-item__spacer {\n  width: 16px;\n}\n.v-list-item--slim .v-list-item__append > .v-badge ~ .v-list-item__spacer,\n.v-list-item--slim .v-list-item__append > .v-icon ~ .v-list-item__spacer,\n.v-list-item--slim .v-list-item__append > .v-tooltip ~ .v-list-item__spacer {\n  width: 20px;\n}\n.v-list-item--slim .v-list-item__append > .v-avatar ~ .v-list-item__spacer {\n  width: 4px;\n}\n.v-list-item--slim .v-list-item__append > .v-list-item-action ~ .v-list-item__spacer {\n  width: 4px;\n}\n.v-list-item--three-line .v-list-item__append {\n  align-self: start;\n}\n.v-list-item__content {\n  align-self: center;\n  grid-area: content;\n  overflow: hidden;\n}\n.v-list-item-action {\n  align-self: center;\n  display: flex;\n  align-items: center;\n  flex: none;\n  transition: inherit;\n  transition-property: height, width;\n}\n.v-list-item-action--start {\n  margin-inline-end: 8px;\n  margin-inline-start: -8px;\n}\n.v-list-item-action--end {\n  margin-inline-start: 8px;\n  margin-inline-end: -8px;\n}\n.v-list-item-media {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n.v-list-item-media--start {\n  margin-inline-end: 16px;\n}\n.v-list-item-media--end {\n  margin-inline-start: 16px;\n}\n.v-list-item--two-line .v-list-item-media {\n  margin-top: -4px;\n  margin-bottom: -4px;\n}\n.v-list-item--three-line .v-list-item-media {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n.v-list-item-subtitle {\n  -webkit-box-orient: vertical;\n  display: -webkit-box;\n  opacity: var(--v-medium-emphasis-opacity);\n  overflow: hidden;\n  padding: 0;\n  text-overflow: ellipsis;\n  overflow-wrap: break-word;\n  word-break: initial;\n  font-size: 0.875rem;\n  font-weight: 400;\n  letter-spacing: 0.0178571429em;\n  line-height: 1rem;\n  text-transform: none;\n}\n.v-list-item--one-line .v-list-item-subtitle {\n  -webkit-line-clamp: 1;\n}\n.v-list-item--two-line .v-list-item-subtitle {\n  -webkit-line-clamp: 2;\n}\n.v-list-item--three-line .v-list-item-subtitle {\n  -webkit-line-clamp: 3;\n}\n.v-list-item--nav .v-list-item-subtitle {\n  font-size: 0.75rem;\n  font-weight: 400;\n  letter-spacing: 0.0178571429em;\n  line-height: 1rem;\n}\n.v-list-item-title {\n  hyphens: auto;\n  overflow-wrap: normal;\n  overflow: hidden;\n  padding: 0;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  word-break: normal;\n  word-wrap: break-word;\n  font-size: 1rem;\n  font-weight: 400;\n  letter-spacing: 0.009375em;\n  line-height: 1.5rem;\n  text-transform: none;\n}\n.v-list-item--nav .v-list-item-title {\n  font-size: 0.8125rem;\n  font-weight: 500;\n  letter-spacing: normal;\n  line-height: 1rem;\n}\n.v-list-item--density-default {\n  min-height: 40px;\n}\n.v-list-item--density-default.v-list-item--one-line {\n  min-height: 48px;\n  padding-top: 4px;\n  padding-bottom: 4px;\n}\n.v-list-item--density-default.v-list-item--two-line {\n  min-height: 64px;\n  padding-top: 12px;\n  padding-bottom: 12px;\n}\n.v-list-item--density-default.v-list-item--three-line {\n  min-height: 88px;\n  padding-top: 16px;\n  padding-bottom: 16px;\n}\n.v-list-item--density-default.v-list-item--three-line .v-list-item__prepend,\n.v-list-item--density-default.v-list-item--three-line .v-list-item__append {\n  padding-top: 8px;\n}\n.v-list-item--density-default:not(.v-list-item--nav).v-list-item--one-line {\n  padding-inline: 16px;\n}\n.v-list-item--density-default:not(.v-list-item--nav).v-list-item--two-line {\n  padding-inline: 16px;\n}\n.v-list-item--density-default:not(.v-list-item--nav).v-list-item--three-line {\n  padding-inline: 16px;\n}\n.v-list-item--density-comfortable {\n  min-height: 36px;\n}\n.v-list-item--density-comfortable.v-list-item--one-line {\n  min-height: 44px;\n}\n.v-list-item--density-comfortable.v-list-item--two-line {\n  min-height: 60px;\n  padding-top: 8px;\n  padding-bottom: 8px;\n}\n.v-list-item--density-comfortable.v-list-item--three-line {\n  min-height: 84px;\n  padding-top: 12px;\n  padding-bottom: 12px;\n}\n.v-list-item--density-comfortable.v-list-item--three-line .v-list-item__prepend,\n.v-list-item--density-comfortable.v-list-item--three-line .v-list-item__append {\n  padding-top: 6px;\n}\n.v-list-item--density-comfortable:not(.v-list-item--nav).v-list-item--one-line {\n  padding-inline: 16px;\n}\n.v-list-item--density-comfortable:not(.v-list-item--nav).v-list-item--two-line {\n  padding-inline: 16px;\n}\n.v-list-item--density-comfortable:not(.v-list-item--nav).v-list-item--three-line {\n  padding-inline: 16px;\n}\n.v-list-item--density-compact {\n  min-height: 32px;\n}\n.v-list-item--density-compact.v-list-item--one-line {\n  min-height: 40px;\n}\n.v-list-item--density-compact.v-list-item--two-line {\n  min-height: 56px;\n  padding-top: 4px;\n  padding-bottom: 4px;\n}\n.v-list-item--density-compact.v-list-item--three-line {\n  min-height: 80px;\n  padding-top: 8px;\n  padding-bottom: 8px;\n}\n.v-list-item--density-compact.v-list-item--three-line .v-list-item__prepend,\n.v-list-item--density-compact.v-list-item--three-line .v-list-item__append {\n  padding-top: 4px;\n}\n.v-list-item--density-compact:not(.v-list-item--nav).v-list-item--one-line {\n  padding-inline: 16px;\n}\n.v-list-item--density-compact:not(.v-list-item--nav).v-list-item--two-line {\n  padding-inline: 16px;\n}\n.v-list-item--density-compact:not(.v-list-item--nav).v-list-item--three-line {\n  padding-inline: 16px;\n}\n.v-list-item--nav {\n  padding-inline: 8px;\n}\n.v-list .v-list-item--nav:not(:only-child) {\n  margin-bottom: 4px;\n}\n.v-list-item__underlay {\n  position: absolute;\n}\n.v-list-item__overlay {\n  background-color: currentColor;\n  border-radius: inherit;\n  bottom: 0;\n  left: 0;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  right: 0;\n  top: 0;\n  transition: opacity 0.2s ease-in-out;\n}\n.v-list-item--active.v-list-item--variant-elevated .v-list-item__overlay {\n  --v-theme-overlay-multiplier: 0;\n}\n.v-list {\n  --indent-padding: 0px;\n}\n.v-list--nav {\n  --indent-padding: -8px;\n}\n.v-list-group {\n  --list-indent-size: 16px;\n  --parent-padding: var(--indent-padding);\n  --prepend-width: 40px;\n}\n.v-list--slim .v-list-group {\n  --prepend-width: 28px;\n}\n.v-list-group--fluid {\n  --list-indent-size: 0px;\n}\n.v-list-group--prepend {\n  --parent-padding: calc(var(--indent-padding) + var(--prepend-width));\n}\n.v-list-group--fluid.v-list-group--prepend {\n  --parent-padding: var(--indent-padding);\n}\n.v-list-group__items {\n  --indent-padding: calc(var(--parent-padding) + var(--list-indent-size));\n}\n.v-list-group__items .v-list-item {\n  padding-inline-start: calc(16px + var(--indent-padding)) !important;\n}\n.v-list-group__header.v-list-item--active:not(:focus-visible) .v-list-item__overlay {\n  opacity: 0;\n}\n.v-list-group__header.v-list-item--active:hover .v-list-item__overlay {\n  opacity: calc(var(--v-hover-opacity) * var(--v-theme-overlay-multiplier));\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VDivider/VDivider.css */\n.v-divider {\n  display: block;\n  flex: 1 1 100%;\n  height: 0px;\n  max-height: 0px;\n  opacity: var(--v-border-opacity);\n  transition: inherit;\n  border-style: solid;\n  border-width: thin 0 0 0;\n}\n.v-divider--vertical {\n  align-self: stretch;\n  border-width: 0 thin 0 0;\n  display: inline-flex;\n  height: 100%;\n  margin-left: -1px;\n  max-height: 100%;\n  max-width: 0px;\n  vertical-align: text-bottom;\n  width: 0px;\n}\n.v-divider--inset:not(.v-divider--vertical) {\n  max-width: calc(100% - 72px);\n  margin-inline-start: 72px;\n}\n.v-divider--inset.v-divider--vertical {\n  margin-bottom: 8px;\n  margin-top: 8px;\n  max-height: calc(100% - 16px);\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VMenu/VMenu.css */\n.v-menu > .v-overlay__content {\n  display: flex;\n  flex-direction: column;\n  border-radius: 4px;\n}\n.v-menu > .v-overlay__content > .v-card,\n.v-menu > .v-overlay__content > .v-sheet,\n.v-menu > .v-overlay__content > .v-list {\n  background: rgb(var(--v-theme-surface));\n  border-radius: inherit;\n  overflow: auto;\n  height: 100%;\n  box-shadow:\n    0px 5px 5px -3px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 8px 10px 1px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 3px 14px 2px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VOverlay/VOverlay.css */\n.v-overlay-container {\n  contain: layout;\n  left: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 0;\n  display: contents;\n}\n.v-overlay-scroll-blocked {\n  padding-inline-end: var(--v-scrollbar-offset);\n}\n.v-overlay-scroll-blocked:not(html) {\n  overflow-y: hidden !important;\n}\nhtml.v-overlay-scroll-blocked {\n  position: fixed;\n  top: var(--v-body-scroll-y);\n  left: var(--v-body-scroll-x);\n  width: 100%;\n  height: 100%;\n}\n.v-overlay {\n  border-radius: inherit;\n  display: flex;\n  left: 0;\n  pointer-events: none;\n  position: fixed;\n  top: 0;\n  bottom: 0;\n  right: 0;\n}\n.v-overlay__content {\n  outline: none;\n  position: absolute;\n  pointer-events: auto;\n  contain: layout;\n}\n.v-overlay__scrim {\n  pointer-events: auto;\n  background: rgb(var(--v-theme-on-surface));\n  border-radius: inherit;\n  bottom: 0;\n  left: 0;\n  opacity: var(--v-overlay-opacity, 0.32);\n  position: fixed;\n  right: 0;\n  top: 0;\n}\n.v-overlay--absolute {\n  position: absolute;\n}\n.v-overlay--contained .v-overlay__scrim {\n  position: absolute;\n}\n.v-overlay--scroll-blocked {\n  padding-inline-end: var(--v-scrollbar-offset);\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VSelect/VSelect.css */\n.v-select .v-field .v-text-field__prefix,\n.v-select .v-field .v-text-field__suffix,\n.v-select .v-field .v-field__input,\n.v-select .v-field.v-field {\n  cursor: pointer;\n}\n.v-select .v-field .v-field__input > input {\n  align-self: flex-start;\n  opacity: 1;\n  flex: 0 0;\n  position: absolute;\n  width: 100%;\n  transition: none;\n  pointer-events: none;\n  caret-color: transparent;\n}\n.v-select .v-field--dirty .v-select__selection {\n  margin-inline-end: 2px;\n}\n.v-select .v-select__selection-text {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n.v-select__content {\n  overflow: hidden;\n  box-shadow:\n    0px 2px 4px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 4px 5px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 10px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n  border-radius: 4px;\n}\n.v-select__selection {\n  display: inline-flex;\n  align-items: center;\n  letter-spacing: inherit;\n  line-height: inherit;\n  max-width: 100%;\n}\n.v-select .v-select__selection:first-child {\n  margin-inline-start: 0;\n}\n.v-select--selected .v-field .v-field__input > input {\n  opacity: 0;\n}\n.v-select__menu-icon {\n  margin-inline-start: 4px;\n  transition: 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-select--active-menu .v-select__menu-icon {\n  opacity: var(--v-high-emphasis-opacity);\n  transform: rotate(180deg);\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VTextField/VTextField.css */\n.v-text-field input {\n  color: inherit;\n  opacity: 0;\n  flex: 1;\n  transition: 0.15s opacity cubic-bezier(0.4, 0, 0.2, 1);\n  min-width: 0;\n}\n.v-text-field input:focus,\n.v-text-field input:active {\n  outline: none;\n}\n.v-text-field input:invalid {\n  box-shadow: none;\n}\n.v-text-field .v-field {\n  cursor: text;\n}\n.v-text-field--prefixed.v-text-field .v-field__input {\n  --v-field-padding-start: 6px;\n}\n.v-text-field--suffixed.v-text-field .v-field__input {\n  --v-field-padding-end: 0;\n}\n.v-text-field .v-input__details {\n  padding-inline: 16px;\n}\n.v-input--plain-underlined.v-text-field .v-input__details {\n  padding-inline: 0;\n}\n.v-text-field .v-field--no-label input,\n.v-text-field .v-field--active input {\n  opacity: 1;\n}\n.v-text-field .v-field--single-line input {\n  transition: none;\n}\n.v-text-field__prefix,\n.v-text-field__suffix {\n  align-items: center;\n  color: rgba(var(--v-theme-on-surface), var(--v-medium-emphasis-opacity));\n  cursor: default;\n  display: flex;\n  opacity: 0;\n  transition: inherit;\n  white-space: nowrap;\n  min-height: max(var(--v-input-control-height, 56px), 1.5rem + var(--v-field-input-padding-top) + var(--v-field-input-padding-bottom));\n  padding-top: calc(var(--v-field-padding-top, 4px) + var(--v-input-padding-top, 0));\n  padding-bottom: var(--v-field-padding-bottom, 6px);\n}\n.v-field--active .v-text-field__prefix,\n.v-field--active .v-text-field__suffix {\n  opacity: 1;\n}\n.v-field--disabled .v-text-field__prefix,\n.v-field--disabled .v-text-field__suffix {\n  color: rgba(var(--v-theme-on-surface), var(--v-disabled-opacity));\n}\n.v-text-field__prefix {\n  padding-inline-start: var(--v-field-padding-start);\n}\n.v-text-field__suffix {\n  padding-inline-end: var(--v-field-padding-end);\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VCounter/VCounter.css */\n.v-counter {\n  color: rgba(var(--v-theme-on-surface), var(--v-medium-emphasis-opacity));\n  flex: 0 1 auto;\n  font-size: 12px;\n  transition-duration: 150ms;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VField/VField.css */\n.v-field {\n  display: grid;\n  grid-template-areas: \"prepend-inner field clear append-inner\";\n  grid-template-columns: min-content minmax(0, 1fr) min-content min-content;\n  font-size: 16px;\n  letter-spacing: 0.009375em;\n  max-width: 100%;\n  border-radius: 4px;\n  contain: layout;\n  flex: 1 0;\n  grid-area: control;\n  position: relative;\n  --v-field-padding-start: 16px;\n  --v-field-padding-end: 16px;\n  --v-field-padding-top: 8px;\n  --v-field-padding-bottom: 4px;\n  --v-field-input-padding-top: calc(var(--v-field-padding-top, 8px) + var(--v-input-padding-top, 0));\n  --v-field-input-padding-bottom: var(--v-field-padding-bottom, 4px);\n}\n.v-field--disabled {\n  opacity: var(--v-disabled-opacity);\n  pointer-events: none;\n}\n.v-field .v-chip {\n  --v-chip-height: 24px;\n}\n.v-field--prepended {\n  padding-inline-start: 12px;\n}\n.v-field--appended {\n  padding-inline-end: 12px;\n}\n.v-field--variant-solo,\n.v-field--variant-solo-filled {\n  background: rgb(var(--v-theme-surface));\n  border-color: transparent;\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n  box-shadow:\n    0px 3px 1px -2px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 2px 2px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 5px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-field--variant-solo-inverted {\n  background: rgb(var(--v-theme-surface));\n  border-color: transparent;\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n  box-shadow:\n    0px 3px 1px -2px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 2px 2px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 5px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-field--variant-solo-inverted.v-field--focused {\n  color: rgb(var(--v-theme-on-surface-variant));\n}\n.v-field--variant-filled {\n  border-bottom-left-radius: 0;\n  border-bottom-right-radius: 0;\n}\n.v-input--density-default .v-field--variant-solo,\n.v-input--density-default .v-field--variant-solo-inverted,\n.v-input--density-default .v-field--variant-solo-filled,\n.v-input--density-default .v-field--variant-filled {\n  --v-input-control-height: 56px;\n  --v-field-padding-bottom: 4px;\n}\n.v-input--density-comfortable .v-field--variant-solo,\n.v-input--density-comfortable .v-field--variant-solo-inverted,\n.v-input--density-comfortable .v-field--variant-solo-filled,\n.v-input--density-comfortable .v-field--variant-filled {\n  --v-input-control-height: 48px;\n  --v-field-padding-bottom: 0px;\n}\n.v-input--density-compact .v-field--variant-solo,\n.v-input--density-compact .v-field--variant-solo-inverted,\n.v-input--density-compact .v-field--variant-solo-filled,\n.v-input--density-compact .v-field--variant-filled {\n  --v-input-control-height: 40px;\n  --v-field-padding-bottom: 0px;\n}\n.v-field--variant-outlined,\n.v-field--single-line,\n.v-field--no-label {\n  --v-field-padding-top: 0px;\n}\n.v-input--density-default .v-field--variant-outlined,\n.v-input--density-default .v-field--single-line,\n.v-input--density-default .v-field--no-label {\n  --v-field-padding-bottom: 16px;\n}\n.v-input--density-comfortable .v-field--variant-outlined,\n.v-input--density-comfortable .v-field--single-line,\n.v-input--density-comfortable .v-field--no-label {\n  --v-field-padding-bottom: 12px;\n}\n.v-input--density-compact .v-field--variant-outlined,\n.v-input--density-compact .v-field--single-line,\n.v-input--density-compact .v-field--no-label {\n  --v-field-padding-bottom: 8px;\n}\n.v-field--variant-plain,\n.v-field--variant-underlined {\n  border-radius: 0;\n  padding: 0;\n}\n.v-field--variant-plain.v-field,\n.v-field--variant-underlined.v-field {\n  --v-field-padding-start: 0px;\n  --v-field-padding-end: 0px;\n}\n.v-input--density-default .v-field--variant-plain,\n.v-input--density-default .v-field--variant-underlined {\n  --v-input-control-height: 48px;\n  --v-field-padding-top: 4px;\n  --v-field-padding-bottom: 4px;\n}\n.v-input--density-comfortable .v-field--variant-plain,\n.v-input--density-comfortable .v-field--variant-underlined {\n  --v-input-control-height: 40px;\n  --v-field-padding-top: 2px;\n  --v-field-padding-bottom: 0px;\n}\n.v-input--density-compact .v-field--variant-plain,\n.v-input--density-compact .v-field--variant-underlined {\n  --v-input-control-height: 32px;\n  --v-field-padding-top: 0px;\n  --v-field-padding-bottom: 0px;\n}\n.v-field--flat {\n  box-shadow: none;\n}\n.v-field--rounded {\n  border-radius: 24px;\n}\n.v-field.v-field--prepended {\n  --v-field-padding-start: 6px;\n}\n.v-field.v-field--appended {\n  --v-field-padding-end: 6px;\n}\n.v-field__input {\n  align-items: center;\n  color: inherit;\n  column-gap: 2px;\n  display: flex;\n  flex-wrap: wrap;\n  letter-spacing: 0.009375em;\n  opacity: var(--v-high-emphasis-opacity);\n  min-height: max(var(--v-input-control-height, 56px), 1.5rem + var(--v-field-input-padding-top) + var(--v-field-input-padding-bottom));\n  min-width: 0;\n  padding-inline: var(--v-field-padding-start) var(--v-field-padding-end);\n  padding-top: var(--v-field-input-padding-top);\n  padding-bottom: var(--v-field-input-padding-bottom);\n  position: relative;\n  width: 100%;\n}\n.v-input--density-default .v-field__input {\n  row-gap: 8px;\n}\n.v-input--density-comfortable .v-field__input {\n  row-gap: 6px;\n}\n.v-input--density-compact .v-field__input {\n  row-gap: 4px;\n}\n.v-field__input input {\n  letter-spacing: inherit;\n}\n.v-field__input input::placeholder,\ninput.v-field__input::placeholder,\ntextarea.v-field__input::placeholder {\n  color: currentColor;\n  opacity: var(--v-disabled-opacity);\n}\n.v-field__input:focus,\n.v-field__input:active {\n  outline: none;\n}\n.v-field__input:invalid {\n  box-shadow: none;\n}\n.v-field__field {\n  flex: 1 0;\n  grid-area: field;\n  position: relative;\n  align-items: flex-start;\n  display: flex;\n}\n.v-field__prepend-inner {\n  grid-area: prepend-inner;\n  padding-inline-end: var(--v-field-padding-after);\n}\n.v-field__clearable {\n  grid-area: clear;\n}\n.v-field__append-inner {\n  grid-area: append-inner;\n  padding-inline-start: var(--v-field-padding-after);\n}\n.v-field__append-inner,\n.v-field__clearable,\n.v-field__prepend-inner {\n  display: flex;\n  align-items: flex-start;\n  padding-top: var(--v-input-padding-top, 8px);\n}\n.v-field--center-affix .v-field__append-inner,\n.v-field--center-affix .v-field__clearable,\n.v-field--center-affix .v-field__prepend-inner {\n  align-items: center;\n  padding-top: 0;\n}\n.v-field.v-field--variant-underlined .v-field__append-inner,\n.v-field.v-field--variant-underlined .v-field__clearable,\n.v-field.v-field--variant-underlined .v-field__prepend-inner,\n.v-field.v-field--variant-plain .v-field__append-inner,\n.v-field.v-field--variant-plain .v-field__clearable,\n.v-field.v-field--variant-plain .v-field__prepend-inner {\n  align-items: flex-start;\n  padding-top: calc(var(--v-field-padding-top, 8px) + var(--v-input-padding-top, 0));\n  padding-bottom: var(--v-field-padding-bottom, 4px);\n}\n.v-field--focused .v-field__prepend-inner,\n.v-field--focused .v-field__append-inner {\n  opacity: 1;\n}\n.v-field__prepend-inner > .v-icon,\n.v-field__append-inner > .v-icon,\n.v-field__clearable > .v-icon {\n  opacity: var(--v-medium-emphasis-opacity);\n}\n.v-field--disabled .v-field__prepend-inner > .v-icon,\n.v-field--error .v-field__prepend-inner > .v-icon,\n.v-field--disabled .v-field__append-inner > .v-icon,\n.v-field--error .v-field__append-inner > .v-icon,\n.v-field--disabled .v-field__clearable > .v-icon,\n.v-field--error .v-field__clearable > .v-icon {\n  opacity: 1;\n}\n.v-field--error:not(.v-field--disabled) .v-field__prepend-inner > .v-icon,\n.v-field--error:not(.v-field--disabled) .v-field__append-inner > .v-icon,\n.v-field--error:not(.v-field--disabled) .v-field__clearable > .v-icon {\n  color: rgb(var(--v-theme-error));\n}\n.v-field__clearable {\n  cursor: pointer;\n  opacity: 0;\n  overflow: hidden;\n  margin-inline: 4px;\n  transition: 0.15s cubic-bezier(0.4, 0, 0.2, 1);\n  transition-property:\n    opacity,\n    transform,\n    width;\n}\n.v-field--focused .v-field__clearable,\n.v-field--persistent-clear .v-field__clearable {\n  opacity: 1;\n}\n@media (hover: hover) {\n  .v-field:hover .v-field__clearable {\n    opacity: 1;\n  }\n}\n@media (hover: none) {\n  .v-field__clearable {\n    opacity: 1;\n  }\n}\n.v-label.v-field-label {\n  contain: layout paint;\n  display: block;\n  margin-inline-start: var(--v-field-padding-start);\n  margin-inline-end: var(--v-field-padding-end);\n  max-width: calc(100% - var(--v-field-padding-start) - var(--v-field-padding-end));\n  pointer-events: none;\n  position: absolute;\n  top: var(--v-input-padding-top);\n  transform-origin: left center;\n  transition: 0.15s cubic-bezier(0.4, 0, 0.2, 1);\n  transition-property: opacity, transform;\n  z-index: 1;\n}\n.v-field--variant-underlined .v-label.v-field-label,\n.v-field--variant-plain .v-label.v-field-label {\n  top: calc(var(--v-input-padding-top) + var(--v-field-padding-top));\n}\n.v-field--center-affix .v-label.v-field-label {\n  top: 50%;\n  transform: translateY(-50%);\n}\n.v-field--active .v-label.v-field-label {\n  visibility: hidden;\n}\n.v-field--focused .v-label.v-field-label,\n.v-field--error .v-label.v-field-label {\n  opacity: 1;\n}\n.v-field--error:not(.v-field--disabled) .v-label.v-field-label {\n  color: rgb(var(--v-theme-error));\n}\n.v-label.v-field-label--floating {\n  --v-field-label-scale: 0.75em;\n  font-size: var(--v-field-label-scale);\n  visibility: hidden;\n  max-width: 100%;\n}\n.v-field--center-affix .v-label.v-field-label--floating {\n  transform: none;\n}\n.v-field.v-field--active .v-label.v-field-label--floating {\n  visibility: unset;\n}\n.v-input--density-default .v-field--variant-solo .v-label.v-field-label--floating,\n.v-input--density-default .v-field--variant-solo-inverted .v-label.v-field-label--floating,\n.v-input--density-default .v-field--variant-filled .v-label.v-field-label--floating,\n.v-input--density-default .v-field--variant-solo-filled .v-label.v-field-label--floating {\n  top: 7px;\n}\n.v-input--density-comfortable .v-field--variant-solo .v-label.v-field-label--floating,\n.v-input--density-comfortable .v-field--variant-solo-inverted .v-label.v-field-label--floating,\n.v-input--density-comfortable .v-field--variant-filled .v-label.v-field-label--floating,\n.v-input--density-comfortable .v-field--variant-solo-filled .v-label.v-field-label--floating {\n  top: 5px;\n}\n.v-input--density-compact .v-field--variant-solo .v-label.v-field-label--floating,\n.v-input--density-compact .v-field--variant-solo-inverted .v-label.v-field-label--floating,\n.v-input--density-compact .v-field--variant-filled .v-label.v-field-label--floating,\n.v-input--density-compact .v-field--variant-solo-filled .v-label.v-field-label--floating {\n  top: 3px;\n}\n.v-field--variant-plain .v-label.v-field-label--floating,\n.v-field--variant-underlined .v-label.v-field-label--floating {\n  transform: translateY(-16px);\n  margin: 0;\n  top: var(--v-input-padding-top);\n}\n.v-field--variant-outlined .v-label.v-field-label--floating {\n  transform: translateY(-50%);\n  transform-origin: center;\n  position: static;\n  margin: 0 4px;\n}\n.v-field__outline {\n  --v-field-border-width: 1px;\n  --v-field-border-opacity: 0.38;\n  align-items: stretch;\n  contain: layout;\n  display: flex;\n  height: 100%;\n  left: 0;\n  pointer-events: none;\n  position: absolute;\n  right: 0;\n  width: 100%;\n}\n@media (hover: hover) {\n  .v-field:hover .v-field__outline {\n    --v-field-border-opacity: var(--v-high-emphasis-opacity);\n  }\n}\n.v-field--error:not(.v-field--disabled) .v-field__outline {\n  color: rgb(var(--v-theme-error));\n}\n.v-field.v-field--focused .v-field__outline,\n.v-input.v-input--error .v-field__outline {\n  --v-field-border-opacity: 1;\n}\n.v-field--variant-outlined.v-field--focused .v-field__outline {\n  --v-field-border-width: 2px;\n}\n.v-field--variant-filled .v-field__outline::before,\n.v-field--variant-underlined .v-field__outline::before {\n  border-color: currentColor;\n  border-style: solid;\n  border-width: 0 0 var(--v-field-border-width);\n  opacity: var(--v-field-border-opacity);\n  transition: opacity 250ms cubic-bezier(0.4, 0, 0.2, 1);\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n.v-field--variant-filled .v-field__outline::after,\n.v-field--variant-underlined .v-field__outline::after {\n  border-color: currentColor;\n  border-style: solid;\n  border-width: 0 0 2px;\n  transform: scaleX(0);\n  transition: transform 0.15s cubic-bezier(0.4, 0, 0.2, 1);\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n.v-field--focused.v-field--variant-filled .v-field__outline::after,\n.v-field--focused.v-field--variant-underlined .v-field__outline::after {\n  transform: scaleX(1);\n}\n.v-field--variant-outlined .v-field__outline {\n  border-radius: inherit;\n}\n.v-field--variant-outlined .v-field__outline__start,\n.v-field--variant-outlined .v-field__outline__notch::before,\n.v-field--variant-outlined .v-field__outline__notch::after,\n.v-field--variant-outlined .v-field__outline__end {\n  border: 0 solid currentColor;\n  opacity: var(--v-field-border-opacity);\n  transition: opacity 250ms cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-field--variant-outlined .v-field__outline__start {\n  flex: 0 0 12px;\n  border-top-width: var(--v-field-border-width);\n  border-bottom-width: var(--v-field-border-width);\n  border-inline-start-width: var(--v-field-border-width);\n  border-start-start-radius: inherit;\n  border-start-end-radius: 0;\n  border-end-end-radius: 0;\n  border-end-start-radius: inherit;\n}\n.v-field--rounded.v-field--variant-outlined .v-field__outline__start,\n[class^=rounded-].v-field--variant-outlined .v-field__outline__start,\n[class*=\" rounded-\"].v-field--variant-outlined .v-field__outline__start {\n  flex-basis: calc(var(--v-input-control-height) / 2 + 2px);\n}\n.v-field--reverse.v-field--variant-outlined .v-field__outline__start {\n  border-start-start-radius: 0;\n  border-start-end-radius: inherit;\n  border-end-end-radius: inherit;\n  border-end-start-radius: 0;\n  border-inline-end-width: var(--v-field-border-width);\n  border-inline-start-width: 0;\n}\n.v-field--variant-outlined .v-field__outline__notch {\n  flex: none;\n  position: relative;\n  max-width: calc(100% - 12px);\n}\n.v-field--variant-outlined .v-field__outline__notch::before,\n.v-field--variant-outlined .v-field__outline__notch::after {\n  opacity: var(--v-field-border-opacity);\n  transition: opacity 250ms cubic-bezier(0.4, 0, 0.2, 1);\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n.v-field--variant-outlined .v-field__outline__notch::before {\n  border-width: var(--v-field-border-width) 0 0;\n}\n.v-field--variant-outlined .v-field__outline__notch::after {\n  bottom: 0;\n  border-width: 0 0 var(--v-field-border-width);\n}\n.v-field--active.v-field--variant-outlined .v-field__outline__notch::before {\n  opacity: 0;\n}\n.v-field--variant-outlined .v-field__outline__end {\n  flex: 1;\n  border-top-width: var(--v-field-border-width);\n  border-bottom-width: var(--v-field-border-width);\n  border-inline-end-width: var(--v-field-border-width);\n  border-start-start-radius: 0;\n  border-start-end-radius: inherit;\n  border-end-end-radius: inherit;\n  border-end-start-radius: 0;\n}\n.v-field--reverse.v-field--variant-outlined .v-field__outline__end {\n  border-start-start-radius: inherit;\n  border-start-end-radius: 0;\n  border-end-end-radius: 0;\n  border-end-start-radius: inherit;\n  border-inline-end-width: 0;\n  border-inline-start-width: var(--v-field-border-width);\n}\n.v-field__loader {\n  top: calc(100% - 2px);\n  left: 0;\n  position: absolute;\n  right: 0;\n  width: 100%;\n  border-top-left-radius: 0;\n  border-top-right-radius: 0;\n  border-bottom-left-radius: inherit;\n  border-bottom-right-radius: inherit;\n  overflow: hidden;\n}\n.v-field--variant-outlined .v-field__loader {\n  top: calc(100% - 3px);\n  width: calc(100% - 1px * 2);\n  left: 1px;\n}\n.v-field__overlay {\n  border-radius: inherit;\n  pointer-events: none;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n.v-field--variant-filled .v-field__overlay {\n  background-color: currentColor;\n  opacity: 0.04;\n  transition: opacity 250ms cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-field--variant-filled.v-field--has-background .v-field__overlay {\n  opacity: 0;\n}\n@media (hover: hover) {\n  .v-field--variant-filled:hover .v-field__overlay {\n    opacity: calc((0.04 + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-field--variant-filled.v-field--focused .v-field__overlay {\n  opacity: calc((0.04 + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n}\n.v-field--variant-solo-filled .v-field__overlay {\n  background-color: currentColor;\n  opacity: 0.04;\n  transition: opacity 250ms cubic-bezier(0.4, 0, 0.2, 1);\n}\n@media (hover: hover) {\n  .v-field--variant-solo-filled:hover .v-field__overlay {\n    opacity: calc((0.04 + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-field--variant-solo-filled.v-field--focused .v-field__overlay {\n  opacity: calc((0.04 + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n}\n.v-field--variant-solo-inverted .v-field__overlay {\n  transition: opacity 250ms cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-field--variant-solo-inverted.v-field--has-background .v-field__overlay {\n  opacity: 0;\n}\n@media (hover: hover) {\n  .v-field--variant-solo-inverted:hover .v-field__overlay {\n    opacity: calc((0.04 + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-field--variant-solo-inverted.v-field--focused .v-field__overlay {\n  background-color: rgb(var(--v-theme-surface-variant));\n  opacity: 1;\n}\n.v-field--reverse .v-field__field,\n.v-field--reverse .v-field__input,\n.v-field--reverse .v-field__outline {\n  flex-direction: row-reverse;\n}\n.v-field--reverse .v-field__input,\n.v-field--reverse input {\n  text-align: end;\n}\n.v-input--disabled .v-field--variant-filled .v-field__outline::before,\n.v-input--disabled .v-field--variant-underlined .v-field__outline::before {\n  border-image: repeating-linear-gradient(to right, rgba(var(--v-theme-on-surface), var(--v-disabled-opacity)) 0px, rgba(var(--v-theme-on-surface), var(--v-disabled-opacity)) 2px, transparent 2px, transparent 4px) 1 repeat;\n}\n.v-field--loading .v-field__outline::after,\n.v-field--loading .v-field__outline::before {\n  opacity: 0;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VVirtualScroll/VVirtualScroll.css */\n.v-virtual-scroll {\n  display: block;\n  flex: 1 1 auto;\n  max-width: 100%;\n  overflow: auto;\n  position: relative;\n}\n.v-virtual-scroll__container {\n  display: block;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VBadge/VBadge.css */\n.v-badge {\n  display: inline-block;\n  line-height: 1;\n}\n.v-badge__badge {\n  align-items: center;\n  display: inline-flex;\n  border-radius: 10px;\n  font-size: 0.75rem;\n  font-weight: 500;\n  height: 1.25rem;\n  justify-content: center;\n  min-width: 20px;\n  padding: 4px 6px;\n  pointer-events: auto;\n  position: absolute;\n  text-align: center;\n  text-indent: 0;\n  transition: 0.225s cubic-bezier(0.4, 0, 0.2, 1);\n  white-space: nowrap;\n  background: rgb(var(--v-theme-surface-variant));\n  color: rgba(var(--v-theme-on-surface-variant), var(--v-high-emphasis-opacity));\n}\n.v-badge--bordered .v-badge__badge::after {\n  border-radius: inherit;\n  border-style: solid;\n  border-width: 2px;\n  bottom: 0;\n  color: rgb(var(--v-theme-background));\n  content: \"\";\n  left: 0;\n  position: absolute;\n  right: 0;\n  top: 0;\n  transform: scale(1.05);\n}\n.v-badge--dot .v-badge__badge {\n  border-radius: 4.5px;\n  height: 9px;\n  min-width: 0;\n  padding: 0;\n  width: 9px;\n}\n.v-badge--dot .v-badge__badge::after {\n  border-width: 1.5px;\n}\n.v-badge--inline .v-badge__badge {\n  position: relative;\n  vertical-align: middle;\n}\n.v-badge__badge .v-icon {\n  color: inherit;\n  font-size: 0.75rem;\n  margin: 0 -2px;\n}\n.v-badge__badge img,\n.v-badge__badge .v-img {\n  height: 100%;\n  width: 100%;\n}\n.v-badge__wrapper {\n  display: flex;\n  position: relative;\n}\n.v-badge--inline .v-badge__wrapper {\n  align-items: center;\n  display: inline-flex;\n  justify-content: center;\n  margin: 0 4px;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VBanner/VBanner.css */\n.v-banner {\n  display: grid;\n  flex: 1 1;\n  font-size: 0.875rem;\n  grid-template-areas: \"prepend content actions\";\n  grid-template-columns: max-content auto max-content;\n  grid-template-rows: max-content max-content;\n  line-height: 1.375rem;\n  overflow: hidden;\n  padding-inline: 16px 8px;\n  padding-top: 16px;\n  padding-bottom: 16px;\n  position: relative;\n  width: 100%;\n  border-color: rgba(var(--v-border-color), var(--v-border-opacity));\n  border-style: solid;\n  border-width: 0 0 thin 0;\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n  border-radius: 0;\n  background: rgb(var(--v-theme-surface));\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n}\n.v-banner--border {\n  border-width: thin;\n  box-shadow: none;\n}\n.v-banner--absolute {\n  position: absolute;\n}\n.v-banner--fixed {\n  position: fixed;\n}\n.v-banner--sticky {\n  position: sticky;\n}\n.v-banner--rounded {\n  border-radius: 4px;\n}\n.v-banner--stacked:not(.v-banner--one-line) {\n  grid-template-areas: \"prepend content\" \". actions\";\n}\n.v-banner--stacked .v-banner-text {\n  padding-inline-end: 36px;\n}\n.v-banner--density-default .v-banner-actions {\n  margin-bottom: -8px;\n}\n.v-banner--density-default.v-banner--one-line {\n  padding-top: 8px;\n  padding-bottom: 8px;\n}\n.v-banner--density-default.v-banner--one-line .v-banner-actions {\n  margin-bottom: 0;\n}\n.v-banner--density-default.v-banner--one-line {\n  padding-top: 10px;\n}\n.v-banner--density-default.v-banner--two-line {\n  padding-top: 16px;\n  padding-bottom: 16px;\n}\n.v-banner--density-default.v-banner--three-line {\n  padding-top: 24px;\n  padding-bottom: 16px;\n}\n.v-banner--density-default:not(.v-banner--one-line) .v-banner-actions,\n.v-banner--density-default.v-banner--two-line .v-banner-actions,\n.v-banner--density-default.v-banner--three-line .v-banner-actions {\n  margin-top: 20px;\n}\n.v-banner--density-comfortable .v-banner-actions {\n  margin-bottom: -4px;\n}\n.v-banner--density-comfortable.v-banner--one-line {\n  padding-top: 4px;\n  padding-bottom: 4px;\n}\n.v-banner--density-comfortable.v-banner--one-line .v-banner-actions {\n  margin-bottom: 0;\n}\n.v-banner--density-comfortable.v-banner--two-line {\n  padding-top: 12px;\n  padding-bottom: 12px;\n}\n.v-banner--density-comfortable.v-banner--three-line {\n  padding-top: 20px;\n  padding-bottom: 12px;\n}\n.v-banner--density-comfortable:not(.v-banner--one-line) .v-banner-actions,\n.v-banner--density-comfortable.v-banner--two-line .v-banner-actions,\n.v-banner--density-comfortable.v-banner--three-line .v-banner-actions {\n  margin-top: 16px;\n}\n.v-banner--density-compact .v-banner-actions {\n  margin-bottom: 0px;\n}\n.v-banner--density-compact.v-banner--one-line {\n  padding-top: 0px;\n  padding-bottom: 0px;\n}\n.v-banner--density-compact.v-banner--one-line .v-banner-actions {\n  margin-bottom: 0;\n}\n.v-banner--density-compact.v-banner--two-line {\n  padding-top: 8px;\n  padding-bottom: 8px;\n}\n.v-banner--density-compact.v-banner--three-line {\n  padding-top: 16px;\n  padding-bottom: 8px;\n}\n.v-banner--density-compact:not(.v-banner--one-line) .v-banner-actions,\n.v-banner--density-compact.v-banner--two-line .v-banner-actions,\n.v-banner--density-compact.v-banner--three-line .v-banner-actions {\n  margin-top: 12px;\n}\n.v-banner--sticky {\n  top: 0;\n}\n.v-banner__content {\n  align-items: center;\n  display: flex;\n  grid-area: content;\n}\n.v-banner__prepend {\n  align-self: flex-start;\n  grid-area: prepend;\n  margin-inline-end: 24px;\n}\n.v-banner-actions {\n  align-self: flex-end;\n  display: flex;\n  flex: 0 1;\n  grid-area: actions;\n  justify-content: flex-end;\n}\n.v-banner--two-line .v-banner-actions,\n.v-banner--three-line .v-banner-actions {\n  margin-top: 20px;\n}\n.v-banner-text {\n  -webkit-box-orient: vertical;\n  display: -webkit-box;\n  padding-inline-end: 90px;\n  overflow: hidden;\n}\n.v-banner--one-line .v-banner-text {\n  -webkit-line-clamp: 1;\n}\n.v-banner--two-line .v-banner-text {\n  -webkit-line-clamp: 2;\n}\n.v-banner--three-line .v-banner-text {\n  -webkit-line-clamp: 3;\n}\n.v-banner--two-line .v-banner-text,\n.v-banner--three-line .v-banner-text {\n  align-self: flex-start;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VBottomNavigation/VBottomNavigation.css */\n.v-bottom-navigation {\n  display: flex;\n  max-width: 100%;\n  overflow: hidden;\n  position: absolute;\n  transition:\n    transform,\n    color 0.2s,\n    0.2s cubic-bezier(0.4, 0, 0.2, 1);\n  border-color: rgba(var(--v-border-color), var(--v-border-opacity));\n  border-style: solid;\n  border-width: 0;\n  border-radius: 0;\n  background: rgb(var(--v-theme-surface));\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n}\n.v-bottom-navigation--border {\n  border-width: thin;\n  box-shadow: none;\n}\n.v-bottom-navigation--active {\n  box-shadow:\n    0px 2px 4px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 4px 5px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 10px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-bottom-navigation__content {\n  display: flex;\n  flex: none;\n  font-size: 0.75rem;\n  justify-content: center;\n  transition: inherit;\n  width: 100%;\n}\n.v-bottom-navigation .v-bottom-navigation__content > .v-btn {\n  font-size: inherit;\n  height: 100%;\n  max-width: 168px;\n  min-width: 80px;\n  text-transform: none;\n  transition: inherit;\n  width: auto;\n  border-radius: 0;\n}\n.v-bottom-navigation .v-bottom-navigation__content > .v-btn .v-btn__content,\n.v-bottom-navigation .v-bottom-navigation__content > .v-btn .v-btn__icon {\n  transition: inherit;\n}\n.v-bottom-navigation .v-bottom-navigation__content > .v-btn .v-btn__icon {\n  font-size: 1.5rem;\n}\n.v-bottom-navigation--grow .v-bottom-navigation__content > .v-btn {\n  flex-grow: 1;\n}\n.v-bottom-navigation--shift .v-bottom-navigation__content .v-btn:not(.v-btn--selected) .v-btn__content > span {\n  transition: inherit;\n  opacity: 0;\n}\n.v-bottom-navigation--shift .v-bottom-navigation__content .v-btn:not(.v-btn--selected) .v-btn__content {\n  transform: translateY(0.5rem);\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VBottomSheet/VBottomSheet.css */\n.bottom-sheet-transition-enter-from {\n  transform: translateY(100%);\n}\n.bottom-sheet-transition-leave-to {\n  transform: translateY(100%);\n}\n.v-bottom-sheet > .v-bottom-sheet__content.v-overlay__content {\n  align-self: flex-end;\n  border-radius: 0;\n  flex: 0 1 auto;\n  left: 0;\n  right: 0;\n  margin-inline: 0;\n  margin-bottom: 0;\n  transition-duration: 0.2s;\n  width: 100%;\n  max-width: 100%;\n  overflow: visible;\n  box-shadow:\n    0px 7px 8px -4px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 12px 17px 2px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 5px 22px 4px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-bottom-sheet > .v-bottom-sheet__content.v-overlay__content > .v-card,\n.v-bottom-sheet > .v-bottom-sheet__content.v-overlay__content > .v-sheet {\n  border-radius: 0;\n}\n.v-bottom-sheet.v-bottom-sheet--inset {\n  max-width: none;\n}\n@media (min-width: 600px) {\n  .v-bottom-sheet.v-bottom-sheet--inset {\n    max-width: 70%;\n  }\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VDialog/VDialog.css */\n.v-dialog {\n  align-items: center;\n  justify-content: center;\n  margin: auto;\n}\n.v-dialog > .v-overlay__content {\n  max-height: calc(100% - 48px);\n  width: calc(100% - 48px);\n  max-width: calc(100% - 48px);\n  margin: 24px;\n}\n.v-dialog > .v-overlay__content,\n.v-dialog > .v-overlay__content > form {\n  display: flex;\n  flex-direction: column;\n  min-height: 0;\n}\n.v-dialog > .v-overlay__content > .v-card,\n.v-dialog > .v-overlay__content > .v-sheet,\n.v-dialog > .v-overlay__content > form > .v-card,\n.v-dialog > .v-overlay__content > form > .v-sheet {\n  --v-scrollbar-offset: 0px;\n  border-radius: 4px;\n  overflow-y: auto;\n  box-shadow:\n    0px 11px 15px -7px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 24px 38px 3px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 9px 46px 8px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-dialog > .v-overlay__content > .v-card,\n.v-dialog > .v-overlay__content > form > .v-card {\n  display: flex;\n  flex-direction: column;\n}\n.v-dialog > .v-overlay__content > .v-card > .v-card-item,\n.v-dialog > .v-overlay__content > form > .v-card > .v-card-item {\n  padding: 14px 24px 0;\n}\n.v-dialog > .v-overlay__content > .v-card > .v-card-item + .v-card-text,\n.v-dialog > .v-overlay__content > form > .v-card > .v-card-item + .v-card-text {\n  padding-top: 10px;\n}\n.v-dialog > .v-overlay__content > .v-card > .v-card-text,\n.v-dialog > .v-overlay__content > form > .v-card > .v-card-text {\n  font-size: inherit;\n  letter-spacing: 0.03125em;\n  line-height: inherit;\n  padding: 16px 24px 10px;\n}\n.v-dialog--fullscreen {\n  --v-scrollbar-offset: 0px;\n}\n.v-dialog--fullscreen > .v-overlay__content {\n  border-radius: 0;\n  margin: 0;\n  padding: 0;\n  width: 100%;\n  height: 100%;\n  max-width: 100%;\n  max-height: 100%;\n  overflow-y: auto;\n  top: 0;\n  left: 0;\n}\n.v-dialog--fullscreen > .v-overlay__content > .v-card,\n.v-dialog--fullscreen > .v-overlay__content > .v-sheet,\n.v-dialog--fullscreen > .v-overlay__content > form > .v-card,\n.v-dialog--fullscreen > .v-overlay__content > form > .v-sheet {\n  min-height: 100%;\n  min-width: 100%;\n  border-radius: 0;\n}\n.v-dialog--scrollable > .v-overlay__content,\n.v-dialog--scrollable > .v-overlay__content > form {\n  display: flex;\n}\n.v-dialog--scrollable > .v-overlay__content > .v-card,\n.v-dialog--scrollable > .v-overlay__content > form > .v-card {\n  display: flex;\n  flex: 1 1 100%;\n  flex-direction: column;\n  max-height: 100%;\n  max-width: 100%;\n}\n.v-dialog--scrollable > .v-overlay__content > .v-card > .v-card-text,\n.v-dialog--scrollable > .v-overlay__content > form > .v-card > .v-card-text {\n  backface-visibility: hidden;\n  overflow-y: auto;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VBreadcrumbs/VBreadcrumbs.css */\n.v-breadcrumbs {\n  display: flex;\n  align-items: center;\n  line-height: 1.375rem;\n  padding: 16px 12px;\n}\n.v-breadcrumbs--rounded {\n  border-radius: 4px;\n}\n.v-breadcrumbs--density-default {\n  padding-top: 16px;\n  padding-bottom: 16px;\n}\n.v-breadcrumbs--density-comfortable {\n  padding-top: 12px;\n  padding-bottom: 12px;\n}\n.v-breadcrumbs--density-compact {\n  padding-top: 8px;\n  padding-bottom: 8px;\n}\n.v-breadcrumbs__prepend {\n  align-items: center;\n  display: inline-flex;\n}\n.v-breadcrumbs-item {\n  align-items: center;\n  color: inherit;\n  display: inline-flex;\n  padding: 0 4px;\n  text-decoration: none;\n  vertical-align: middle;\n}\n.v-breadcrumbs-item--disabled {\n  opacity: var(--v-disabled-opacity);\n  pointer-events: none;\n}\n.v-breadcrumbs-item--link {\n  color: inherit;\n  text-decoration: none;\n}\n.v-breadcrumbs-item--link:hover {\n  text-decoration: underline;\n}\n.v-breadcrumbs-item .v-icon {\n  font-size: 1rem;\n  margin-inline: -4px 2px;\n}\n.v-breadcrumbs-divider {\n  display: inline-block;\n  padding: 0 8px;\n  vertical-align: middle;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VCard/VCard.css */\n.v-card {\n  display: block;\n  overflow: hidden;\n  overflow-wrap: break-word;\n  position: relative;\n  padding: 0;\n  text-decoration: none;\n  transition-duration: 0.28s;\n  transition-property:\n    box-shadow,\n    opacity,\n    background;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  z-index: 0;\n  border-color: rgba(var(--v-border-color), var(--v-border-opacity));\n  border-style: solid;\n  border-width: 0;\n  border-radius: 4px;\n}\n.v-card--border {\n  border-width: thin;\n  box-shadow: none;\n}\n.v-card--absolute {\n  position: absolute;\n}\n.v-card--fixed {\n  position: fixed;\n}\n.v-card:hover > .v-card__overlay {\n  opacity: calc(var(--v-hover-opacity) * var(--v-theme-overlay-multiplier));\n}\n.v-card:focus-visible > .v-card__overlay {\n  opacity: calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier));\n}\n@supports not selector(:focus-visible) {\n  .v-card:focus > .v-card__overlay {\n    opacity: calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-card--active > .v-card__overlay,\n.v-card[aria-haspopup=menu][aria-expanded=true] > .v-card__overlay {\n  opacity: calc(var(--v-activated-opacity) * var(--v-theme-overlay-multiplier));\n}\n.v-card--active:hover > .v-card__overlay,\n.v-card[aria-haspopup=menu][aria-expanded=true]:hover > .v-card__overlay {\n  opacity: calc((var(--v-activated-opacity) + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier));\n}\n.v-card--active:focus-visible > .v-card__overlay,\n.v-card[aria-haspopup=menu][aria-expanded=true]:focus-visible > .v-card__overlay {\n  opacity: calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n}\n@supports not selector(:focus-visible) {\n  .v-card--active:focus > .v-card__overlay,\n  .v-card[aria-haspopup=menu][aria-expanded=true]:focus > .v-card__overlay {\n    opacity: calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-card--variant-plain,\n.v-card--variant-outlined,\n.v-card--variant-text,\n.v-card--variant-tonal {\n  background: transparent;\n  color: inherit;\n}\n.v-card--variant-plain {\n  opacity: 0.62;\n}\n.v-card--variant-plain:focus,\n.v-card--variant-plain:hover {\n  opacity: 1;\n}\n.v-card--variant-plain .v-card__overlay {\n  display: none;\n}\n.v-card--variant-elevated,\n.v-card--variant-flat {\n  background: rgb(var(--v-theme-surface));\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n}\n.v-card--variant-elevated {\n  box-shadow:\n    0px 2px 1px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 1px 1px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 3px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-card--variant-flat {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-card--variant-outlined {\n  border: thin solid currentColor;\n}\n.v-card--variant-text .v-card__overlay {\n  background: currentColor;\n}\n.v-card--variant-tonal .v-card__underlay {\n  background: currentColor;\n  opacity: var(--v-activated-opacity);\n  border-radius: inherit;\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  pointer-events: none;\n}\n.v-card--disabled {\n  pointer-events: none;\n  user-select: none;\n}\n.v-card--disabled > :not(.v-card__loader) {\n  opacity: 0.6;\n}\n.v-card--flat {\n  box-shadow: none;\n}\n.v-card--hover {\n  cursor: pointer;\n}\n.v-card--hover::before,\n.v-card--hover::after {\n  border-radius: inherit;\n  bottom: 0;\n  content: \"\";\n  display: block;\n  left: 0;\n  pointer-events: none;\n  position: absolute;\n  right: 0;\n  top: 0;\n  transition: inherit;\n}\n.v-card--hover::before {\n  opacity: 1;\n  z-index: -1;\n  box-shadow:\n    0px 2px 1px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 1px 1px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 3px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-card--hover::after {\n  z-index: 1;\n  opacity: 0;\n  box-shadow:\n    0px 5px 5px -3px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 8px 10px 1px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 3px 14px 2px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-card--hover:hover::after {\n  opacity: 1;\n}\n.v-card--hover:hover::before {\n  opacity: 0;\n}\n.v-card--hover:hover {\n  box-shadow:\n    0px 5px 5px -3px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 8px 10px 1px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 3px 14px 2px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-card--link {\n  cursor: pointer;\n}\n.v-card-actions {\n  align-items: center;\n  display: flex;\n  flex: none;\n  min-height: 52px;\n  padding: 0.5rem;\n}\n.v-card-item {\n  align-items: center;\n  display: grid;\n  flex: none;\n  grid-template-areas: \"prepend content append\";\n  grid-template-columns: max-content auto max-content;\n  padding: 0.625rem 1rem;\n}\n.v-card-item + .v-card-text {\n  padding-top: 0;\n}\n.v-card-item__prepend,\n.v-card-item__append {\n  align-items: center;\n  display: flex;\n}\n.v-card-item__prepend {\n  grid-area: prepend;\n  padding-inline-end: 0.5rem;\n}\n.v-card-item__append {\n  grid-area: append;\n  padding-inline-start: 0.5rem;\n}\n.v-card-item__content {\n  align-self: center;\n  grid-area: content;\n  overflow: hidden;\n}\n.v-card-title {\n  display: block;\n  flex: none;\n  font-size: 1.25rem;\n  font-weight: 500;\n  hyphens: auto;\n  letter-spacing: 0.0125em;\n  min-width: 0;\n  overflow-wrap: normal;\n  overflow: hidden;\n  padding: 0.5rem 1rem;\n  text-overflow: ellipsis;\n  text-transform: none;\n  white-space: nowrap;\n  word-break: normal;\n  word-wrap: break-word;\n}\n.v-card .v-card-title {\n  line-height: 2rem;\n}\n.v-card--density-comfortable .v-card-title {\n  line-height: 1.75rem;\n}\n.v-card--density-compact .v-card-title {\n  line-height: 1.55rem;\n}\n.v-card-item .v-card-title {\n  padding: 0;\n}\n.v-card-title + .v-card-text,\n.v-card-title + .v-card-actions {\n  padding-top: 0;\n}\n.v-card-subtitle {\n  display: block;\n  flex: none;\n  font-size: 0.875rem;\n  font-weight: 400;\n  letter-spacing: 0.0178571429em;\n  opacity: var(--v-medium-emphasis-opacity);\n  overflow: hidden;\n  padding: 0 1rem;\n  text-overflow: ellipsis;\n  text-transform: none;\n  white-space: nowrap;\n}\n.v-card .v-card-subtitle {\n  line-height: 1.25rem;\n}\n.v-card--density-comfortable .v-card-subtitle {\n  line-height: 1.125rem;\n}\n.v-card--density-compact .v-card-subtitle {\n  line-height: 1rem;\n}\n.v-card-item .v-card-subtitle {\n  padding: 0 0 0.25rem;\n}\n.v-card-text {\n  flex: 1 1 auto;\n  font-size: 0.875rem;\n  font-weight: 400;\n  letter-spacing: 0.0178571429em;\n  padding: 1rem;\n  text-transform: none;\n}\n.v-card .v-card-text {\n  line-height: 1.25rem;\n}\n.v-card--density-comfortable .v-card-text {\n  line-height: 1.2rem;\n}\n.v-card--density-compact .v-card-text {\n  line-height: 1.15rem;\n}\n.v-card__image {\n  display: flex;\n  height: 100%;\n  flex: 1 1 auto;\n  left: 0;\n  overflow: hidden;\n  position: absolute;\n  top: 0;\n  width: 100%;\n  z-index: -1;\n}\n.v-card__content {\n  border-radius: inherit;\n  overflow: hidden;\n  position: relative;\n}\n.v-card__loader {\n  bottom: auto;\n  top: 0;\n  left: 0;\n  position: absolute;\n  right: 0;\n  width: 100%;\n  z-index: 1;\n}\n.v-card__overlay {\n  background-color: currentColor;\n  border-radius: inherit;\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  pointer-events: none;\n  opacity: 0;\n  transition: opacity 0.2s ease-in-out;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VCarousel/VCarousel.css */\n.v-carousel {\n  overflow: hidden;\n  position: relative;\n  width: 100%;\n}\n.v-carousel__controls {\n  align-items: center;\n  bottom: 0;\n  display: flex;\n  height: 50px;\n  justify-content: center;\n  list-style-type: none;\n  position: absolute;\n  width: 100%;\n  z-index: 1;\n  background: rgba(var(--v-theme-surface-variant), 0.3);\n  color: rgb(var(--v-theme-on-surface-variant));\n}\n.v-carousel__controls > .v-item-group {\n  flex: 0 1 auto;\n}\n.v-carousel__controls__item {\n  margin: 0 8px;\n}\n.v-carousel__controls__item .v-icon {\n  opacity: 0.5;\n}\n.v-carousel__controls__item--active .v-icon {\n  opacity: 1;\n  vertical-align: middle;\n}\n.v-carousel__controls__item:hover {\n  background: none;\n}\n.v-carousel__controls__item:hover .v-icon {\n  opacity: 0.8;\n}\n.v-carousel__progress {\n  margin: 0;\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  right: 0;\n}\n.v-carousel-item {\n  display: block;\n  height: inherit;\n  text-decoration: none;\n}\n.v-carousel-item > .v-img {\n  height: inherit;\n}\n.v-carousel--hide-delimiter-background .v-carousel__controls {\n  background: transparent;\n}\n.v-carousel--vertical-delimiters .v-carousel__controls {\n  flex-direction: column;\n  height: 100% !important;\n  width: 50px;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VWindow/VWindow.css */\n.v-window {\n  overflow: hidden;\n}\n.v-window__container {\n  display: flex;\n  flex-direction: column;\n  height: inherit;\n  position: relative;\n  transition: 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);\n}\n.v-window__controls {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  padding: 0 16px;\n  pointer-events: none;\n}\n.v-window__controls > * {\n  pointer-events: auto;\n}\n.v-window--show-arrows-on-hover {\n  overflow: hidden;\n}\n.v-window--show-arrows-on-hover .v-window__left {\n  transform: translateX(-200%);\n}\n.v-window--show-arrows-on-hover .v-window__right {\n  transform: translateX(200%);\n}\n.v-window--show-arrows-on-hover:hover .v-window__left,\n.v-window--show-arrows-on-hover:hover .v-window__right {\n  transform: translateX(0);\n}\n.v-window-x-transition-enter-active,\n.v-window-x-transition-leave-active,\n.v-window-x-reverse-transition-enter-active,\n.v-window-x-reverse-transition-leave-active,\n.v-window-y-transition-enter-active,\n.v-window-y-transition-leave-active,\n.v-window-y-reverse-transition-enter-active,\n.v-window-y-reverse-transition-leave-active {\n  transition: 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);\n}\n.v-window-x-transition-leave-from,\n.v-window-x-transition-leave-to,\n.v-window-x-reverse-transition-leave-from,\n.v-window-x-reverse-transition-leave-to,\n.v-window-y-transition-leave-from,\n.v-window-y-transition-leave-to,\n.v-window-y-reverse-transition-leave-from,\n.v-window-y-reverse-transition-leave-to {\n  position: absolute !important;\n  top: 0;\n  width: 100%;\n}\n.v-window-x-transition-enter-from {\n  transform: translateX(100%);\n}\n.v-window-x-transition-leave-to {\n  transform: translateX(-100%);\n}\n.v-window-x-reverse-transition-enter-from {\n  transform: translateX(-100%);\n}\n.v-window-x-reverse-transition-leave-to {\n  transform: translateX(100%);\n}\n.v-window-y-transition-enter-from {\n  transform: translateY(100%);\n}\n.v-window-y-transition-leave-to {\n  transform: translateY(-100%);\n}\n.v-window-y-reverse-transition-enter-from {\n  transform: translateY(-100%);\n}\n.v-window-y-reverse-transition-leave-to {\n  transform: translateY(100%);\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VCode/VCode.css */\n.v-code {\n  background-color: rgb(var(--v-theme-code));\n  color: rgb(var(--v-theme-on-code));\n  border-radius: 4px;\n  line-height: 1.8;\n  font-size: 0.9em;\n  font-weight: normal;\n  padding: 0.2em 0.4em;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VColorPicker/VColorPicker.css */\n.v-color-picker {\n  align-self: flex-start;\n  contain: content;\n}\n.v-color-picker.v-sheet {\n  box-shadow:\n    0px 3px 1px -2px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 2px 2px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 5px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n  border-radius: 4px;\n}\n.v-color-picker__controls {\n  display: flex;\n  flex-direction: column;\n  padding: 16px;\n}\n.v-color-picker--flat {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-color-picker--flat .v-color-picker__track:not(.v-input--is-disabled) .v-slider__thumb {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VColorPicker/VColorPickerCanvas.css */\n.v-color-picker-canvas {\n  display: flex;\n  position: relative;\n  overflow: hidden;\n  contain: content;\n  touch-action: none;\n}\n.v-color-picker-canvas__dot {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 15px;\n  height: 15px;\n  background: transparent;\n  border-radius: 50%;\n  box-shadow: 0px 0px 0px 1.5px rgb(255, 255, 255), inset 0px 0px 1px 1.5px rgba(0, 0, 0, 0.3);\n}\n.v-color-picker-canvas__dot--disabled {\n  box-shadow: 0px 0px 0px 1.5px rgba(255, 255, 255, 0.7), inset 0px 0px 1px 1.5px rgba(0, 0, 0, 0.3);\n}\n.v-color-picker-canvas:hover .v-color-picker-canvas__dot {\n  will-change: transform;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VColorPicker/VColorPickerEdit.css */\n.v-color-picker-edit {\n  display: flex;\n  margin-top: 24px;\n}\n.v-color-picker-edit__input {\n  width: 100%;\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: center;\n  text-align: center;\n}\n.v-color-picker-edit__input:not(:last-child) {\n  margin-inline-end: 8px;\n}\n.v-color-picker-edit__input input {\n  border-radius: 4px;\n  margin-bottom: 8px;\n  min-width: 0;\n  outline: none;\n  text-align: center;\n  width: 100%;\n  height: 32px;\n  background: rgba(var(--v-theme-surface-variant), 0.2);\n  color: rgba(var(--v-theme-on-surface));\n}\n.v-color-picker-edit__input span {\n  font-size: 0.75rem;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VColorPicker/VColorPickerPreview.css */\n.v-color-picker-preview__alpha .v-slider-track__background {\n  background-color: transparent !important;\n}\n.v-locale--is-ltr.v-color-picker-preview__alpha .v-slider-track__background,\n.v-locale--is-ltr .v-color-picker-preview__alpha .v-slider-track__background {\n  background-image: linear-gradient(to right, transparent, var(--v-color-picker-color-hsv));\n}\n.v-locale--is-rtl.v-color-picker-preview__alpha .v-slider-track__background,\n.v-locale--is-rtl .v-color-picker-preview__alpha .v-slider-track__background {\n  background-image: linear-gradient(to left, transparent, var(--v-color-picker-color-hsv));\n}\n.v-color-picker-preview__alpha .v-slider-track__background::after {\n  content: \"\";\n  z-index: -1;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAAXNSR0IArs4c6QAAACRJREFUKFNjPHTo0H8GJGBnZ8eIzGekgwJk+0BsdCtRHEQbBQBbbh0dIGKknQAAAABJRU5ErkJggg==) repeat;\n  border-radius: inherit;\n}\n.v-color-picker-preview__sliders {\n  display: flex;\n  flex: 1 0 auto;\n  flex-direction: column;\n  padding-inline-end: 16px;\n}\n.v-color-picker-preview__dot {\n  position: relative;\n  height: 30px;\n  width: 30px;\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAAXNSR0IArs4c6QAAACRJREFUKFNjPHTo0H8GJGBnZ8eIzGekgwJk+0BsdCtRHEQbBQBbbh0dIGKknQAAAABJRU5ErkJggg==) repeat;\n  border-radius: 50%;\n  overflow: hidden;\n  margin-inline-end: 24px;\n}\n.v-color-picker-preview__dot > div {\n  width: 100%;\n  height: 100%;\n}\n.v-locale--is-ltr.v-color-picker-preview__hue:not(.v-input--is-disabled) .v-slider-track__background,\n.v-locale--is-ltr .v-color-picker-preview__hue:not(.v-input--is-disabled) .v-slider-track__background {\n  background: linear-gradient(to right, #F00 0%, #FF0 16.66%, #0F0 33.33%, #0FF 50%, #00F 66.66%, #F0F 83.33%, #F00 100%);\n}\n.v-locale--is-rtl.v-color-picker-preview__hue:not(.v-input--is-disabled) .v-slider-track__background,\n.v-locale--is-rtl .v-color-picker-preview__hue:not(.v-input--is-disabled) .v-slider-track__background {\n  background: linear-gradient(to left, #F00 0%, #FF0 16.66%, #0F0 33.33%, #0FF 50%, #00F 66.66%, #F0F 83.33%, #F00 100%);\n}\n.v-color-picker-preview__track {\n  position: relative;\n  width: 100%;\n  margin: 0 !important;\n}\n.v-color-picker-preview__track .v-slider-track__fill {\n  display: none;\n}\n.v-color-picker-preview {\n  align-items: center;\n  display: flex;\n  margin-bottom: 0;\n}\n.v-color-picker-preview__eye-dropper {\n  position: relative;\n  margin-right: 12px;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VSlider/VSlider.css */\n.v-slider .v-slider__container input {\n  cursor: default;\n  padding: 0;\n  width: 100%;\n  display: none;\n}\n.v-slider > .v-input__append,\n.v-slider > .v-input__prepend {\n  padding: 0;\n}\n.v-slider__container {\n  position: relative;\n  min-height: inherit;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  cursor: pointer;\n}\n.v-input--disabled .v-slider__container {\n  opacity: var(--v-disabled-opacity);\n}\n.v-input--error:not(.v-input--disabled) .v-slider__container {\n  color: rgb(var(--v-theme-error));\n}\n.v-slider.v-input--horizontal {\n  align-items: center;\n  margin-inline: 8px 8px;\n}\n.v-slider.v-input--horizontal > .v-input__control {\n  min-height: 32px;\n  display: flex;\n  align-items: center;\n}\n.v-slider.v-input--vertical {\n  justify-content: center;\n  margin-top: 12px;\n  margin-bottom: 12px;\n}\n.v-slider.v-input--vertical > .v-input__control {\n  min-height: 300px;\n}\n.v-slider.v-input--disabled {\n  pointer-events: none;\n}\n.v-slider--has-labels > .v-input__control {\n  margin-bottom: 4px;\n}\n.v-slider__label {\n  margin-inline-end: 12px;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VSlider/VSliderThumb.css */\n.v-slider-thumb {\n  touch-action: none;\n  color: rgb(var(--v-theme-surface-variant));\n}\n.v-input--error:not(.v-input--disabled) .v-slider-thumb {\n  color: inherit;\n}\n.v-slider-thumb__label {\n  background: rgba(var(--v-theme-surface-variant), 0.7);\n  color: rgb(var(--v-theme-on-surface-variant));\n}\n.v-slider-thumb__label::before {\n  color: rgba(var(--v-theme-surface-variant), 0.7);\n}\n.v-slider-thumb {\n  outline: none;\n  position: absolute;\n  transition: 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);\n}\n.v-slider-thumb__surface {\n  cursor: pointer;\n  width: var(--v-slider-thumb-size);\n  height: var(--v-slider-thumb-size);\n  border-radius: 50%;\n  user-select: none;\n  background-color: currentColor;\n}\n.v-slider-thumb__surface::before {\n  transition: 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n  content: \"\";\n  color: inherit;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  border-radius: 50%;\n  background: currentColor;\n  position: absolute;\n  pointer-events: none;\n  opacity: 0;\n}\n.v-slider-thumb__surface::after {\n  content: \"\";\n  width: 42px;\n  height: 42px;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n.v-slider-thumb__label-container {\n  position: absolute;\n  transition: 0.2s cubic-bezier(0.4, 0, 1, 1);\n}\n.v-slider-thumb__label {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 0.75rem;\n  min-width: 35px;\n  height: 25px;\n  border-radius: 4px;\n  padding: 6px;\n  position: absolute;\n  user-select: none;\n  transition: 0.2s cubic-bezier(0.4, 0, 1, 1);\n}\n.v-slider-thumb__label::before {\n  content: \"\";\n  width: 0;\n  height: 0;\n  position: absolute;\n}\n.v-slider-thumb__ripple {\n  position: absolute;\n  left: calc(var(--v-slider-thumb-size) / -2);\n  top: calc(var(--v-slider-thumb-size) / -2);\n  width: calc(var(--v-slider-thumb-size) * 2);\n  height: calc(var(--v-slider-thumb-size) * 2);\n  background: inherit;\n}\n.v-slider.v-input--horizontal .v-slider-thumb {\n  top: 50%;\n  transform: translateY(-50%);\n  inset-inline-start: calc(var(--v-slider-thumb-position) - var(--v-slider-thumb-size) / 2);\n}\n.v-slider.v-input--horizontal .v-slider-thumb__label-container {\n  left: calc(var(--v-slider-thumb-size) / 2);\n  top: 0;\n}\n.v-slider.v-input--horizontal .v-slider-thumb__label {\n  bottom: calc(var(--v-slider-thumb-size) / 2);\n}\n.v-locale--is-ltr.v-slider.v-input--horizontal .v-slider-thumb__label,\n.v-locale--is-ltr .v-slider.v-input--horizontal .v-slider-thumb__label {\n  transform: translateX(-50%);\n}\n.v-locale--is-rtl.v-slider.v-input--horizontal .v-slider-thumb__label,\n.v-locale--is-rtl .v-slider.v-input--horizontal .v-slider-thumb__label {\n  transform: translateX(50%);\n}\n.v-slider.v-input--horizontal .v-slider-thumb__label::before {\n  border-left: 6px solid transparent;\n  border-right: 6px solid transparent;\n  border-top: 6px solid currentColor;\n  bottom: -6px;\n}\n.v-slider.v-input--vertical .v-slider-thumb {\n  top: calc(var(--v-slider-thumb-position) - var(--v-slider-thumb-size) / 2);\n}\n.v-slider.v-input--vertical .v-slider-thumb__label-container {\n  top: calc(var(--v-slider-thumb-size) / 2);\n  right: 0;\n}\n.v-slider.v-input--vertical .v-slider-thumb__label {\n  top: -12.5px;\n  left: calc(var(--v-slider-thumb-size) / 2);\n}\n.v-slider.v-input--vertical .v-slider-thumb__label::before {\n  border-right: 6px solid currentColor;\n  border-top: 6px solid transparent;\n  border-bottom: 6px solid transparent;\n  left: -6px;\n}\n.v-slider-thumb--focused .v-slider-thumb__surface::before {\n  transform: scale(2);\n  opacity: var(--v-focus-opacity);\n}\n.v-slider-thumb--pressed {\n  transition: none;\n}\n.v-slider-thumb--pressed .v-slider-thumb__surface::before {\n  opacity: var(--v-pressed-opacity);\n}\n@media (hover: hover) {\n  .v-slider-thumb:hover .v-slider-thumb__surface::before {\n    transform: scale(2);\n  }\n  .v-slider-thumb:hover:not(.v-slider-thumb--focused) .v-slider-thumb__surface::before {\n    opacity: var(--v-hover-opacity);\n  }\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VSlider/VSliderTrack.css */\n.v-slider-track__background {\n  background-color: rgb(var(--v-theme-surface-variant));\n}\n.v-slider-track__fill {\n  background-color: rgb(var(--v-theme-surface-variant));\n}\n.v-slider-track__tick {\n  background-color: rgb(var(--v-theme-surface-variant));\n}\n.v-slider-track__tick--filled {\n  background-color: rgb(var(--v-theme-surface-light));\n}\n.v-slider-track {\n  border-radius: 6px;\n}\n.v-slider-track__background,\n.v-slider-track__fill {\n  position: absolute;\n  transition: 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);\n  border-radius: inherit;\n}\n.v-slider--pressed .v-slider-track__background,\n.v-slider--pressed .v-slider-track__fill {\n  transition: none;\n}\n.v-input--error:not(.v-input--disabled) .v-slider-track__background,\n.v-input--error:not(.v-input--disabled) .v-slider-track__fill {\n  background-color: currentColor;\n}\n.v-slider-track__ticks {\n  height: 100%;\n  width: 100%;\n  position: relative;\n}\n.v-slider-track__tick {\n  position: absolute;\n  opacity: 0;\n  transition: 0.2s opacity cubic-bezier(0.4, 0, 0.2, 1);\n  border-radius: 2px;\n  width: var(--v-slider-tick-size);\n  height: var(--v-slider-tick-size);\n  transform: translate(calc(var(--v-slider-tick-size) / -2), calc(var(--v-slider-tick-size) / -2));\n}\n.v-locale--is-ltr.v-slider-track__tick--first .v-slider-track__tick-label,\n.v-locale--is-ltr .v-slider-track__tick--first .v-slider-track__tick-label {\n  transform: none;\n}\n.v-locale--is-rtl.v-slider-track__tick--first .v-slider-track__tick-label,\n.v-locale--is-rtl .v-slider-track__tick--first .v-slider-track__tick-label {\n  transform: translateX(100%);\n}\n.v-locale--is-ltr.v-slider-track__tick--last .v-slider-track__tick-label,\n.v-locale--is-ltr .v-slider-track__tick--last .v-slider-track__tick-label {\n  transform: translateX(-100%);\n}\n.v-locale--is-rtl.v-slider-track__tick--last .v-slider-track__tick-label,\n.v-locale--is-rtl .v-slider-track__tick--last .v-slider-track__tick-label {\n  transform: none;\n}\n.v-slider-track__tick-label {\n  position: absolute;\n  user-select: none;\n  white-space: nowrap;\n}\n.v-slider.v-input--horizontal .v-slider-track {\n  display: flex;\n  align-items: center;\n  width: 100%;\n  height: calc(var(--v-slider-track-size) + 2px);\n  touch-action: pan-y;\n}\n.v-slider.v-input--horizontal .v-slider-track__background {\n  height: var(--v-slider-track-size);\n}\n.v-slider.v-input--horizontal .v-slider-track__fill {\n  height: inherit;\n}\n.v-slider.v-input--horizontal .v-slider-track__tick {\n  margin-top: calc(calc(var(--v-slider-track-size) + 2px) / 2);\n}\n.v-locale--is-rtl.v-slider.v-input--horizontal .v-slider-track__tick,\n.v-locale--is-rtl .v-slider.v-input--horizontal .v-slider-track__tick {\n  transform: translate(calc(var(--v-slider-tick-size) / 2), calc(var(--v-slider-tick-size) / -2));\n}\n.v-slider.v-input--horizontal .v-slider-track__tick .v-slider-track__tick-label {\n  margin-top: calc(var(--v-slider-track-size) / 2 + 8px);\n}\n.v-locale--is-ltr.v-slider.v-input--horizontal .v-slider-track__tick .v-slider-track__tick-label,\n.v-locale--is-ltr .v-slider.v-input--horizontal .v-slider-track__tick .v-slider-track__tick-label {\n  transform: translateX(-50%);\n}\n.v-locale--is-rtl.v-slider.v-input--horizontal .v-slider-track__tick .v-slider-track__tick-label,\n.v-locale--is-rtl .v-slider.v-input--horizontal .v-slider-track__tick .v-slider-track__tick-label {\n  transform: translateX(50%);\n}\n.v-slider.v-input--horizontal .v-slider-track__tick--first {\n  margin-inline-start: calc(var(--v-slider-tick-size) + 1px);\n}\n.v-locale--is-ltr.v-slider.v-input--horizontal .v-slider-track__tick--first .v-slider-track__tick-label,\n.v-locale--is-ltr .v-slider.v-input--horizontal .v-slider-track__tick--first .v-slider-track__tick-label {\n  transform: translateX(0%);\n}\n.v-locale--is-rtl.v-slider.v-input--horizontal .v-slider-track__tick--first .v-slider-track__tick-label,\n.v-locale--is-rtl .v-slider.v-input--horizontal .v-slider-track__tick--first .v-slider-track__tick-label {\n  transform: translateX(0%);\n}\n.v-slider.v-input--horizontal .v-slider-track__tick--last {\n  margin-inline-start: calc(100% - var(--v-slider-tick-size) - 1px);\n}\n.v-locale--is-ltr.v-slider.v-input--horizontal .v-slider-track__tick--last .v-slider-track__tick-label,\n.v-locale--is-ltr .v-slider.v-input--horizontal .v-slider-track__tick--last .v-slider-track__tick-label {\n  transform: translateX(-100%);\n}\n.v-locale--is-rtl.v-slider.v-input--horizontal .v-slider-track__tick--last .v-slider-track__tick-label,\n.v-locale--is-rtl .v-slider.v-input--horizontal .v-slider-track__tick--last .v-slider-track__tick-label {\n  transform: translateX(100%);\n}\n.v-slider.v-input--vertical .v-slider-track {\n  height: 100%;\n  display: flex;\n  justify-content: center;\n  width: calc(var(--v-slider-track-size) + 2px);\n  touch-action: pan-x;\n}\n.v-slider.v-input--vertical .v-slider-track__background {\n  width: var(--v-slider-track-size);\n}\n.v-slider.v-input--vertical .v-slider-track__fill {\n  width: inherit;\n}\n.v-slider.v-input--vertical .v-slider-track__ticks {\n  height: 100%;\n}\n.v-slider.v-input--vertical .v-slider-track__tick {\n  margin-inline-start: calc(calc(var(--v-slider-track-size) + 2px) / 2);\n  transform: translate(calc(var(--v-slider-tick-size) / -2), calc(var(--v-slider-tick-size) / 2));\n}\n.v-locale--is-rtl.v-slider.v-input--vertical .v-slider-track__tick,\n.v-locale--is-rtl .v-slider.v-input--vertical .v-slider-track__tick {\n  transform: translate(calc(var(--v-slider-tick-size) / 2), calc(var(--v-slider-tick-size) / 2));\n}\n.v-slider.v-input--vertical .v-slider-track__tick--first {\n  bottom: calc(0% + var(--v-slider-tick-size) + 1px);\n}\n.v-slider.v-input--vertical .v-slider-track__tick--last {\n  bottom: calc(100% - var(--v-slider-tick-size) - 1px);\n}\n.v-slider.v-input--vertical .v-slider-track__tick .v-slider-track__tick-label {\n  margin-inline-start: calc(var(--v-slider-track-size) / 2 + 12px);\n  transform: translateY(-50%);\n}\n.v-slider-track__ticks--always-show .v-slider-track__tick,\n.v-slider--focused .v-slider-track__tick {\n  opacity: 1;\n}\n.v-slider-track__background--opacity {\n  opacity: 0.38;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VColorPicker/VColorPickerSwatches.css */\n.v-color-picker-swatches {\n  overflow-y: auto;\n}\n.v-color-picker-swatches > div {\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: center;\n  padding: 8px;\n}\n.v-color-picker-swatches__swatch {\n  display: flex;\n  flex-direction: column;\n  margin-bottom: 10px;\n}\n.v-color-picker-swatches__color {\n  position: relative;\n  height: 18px;\n  max-height: 18px;\n  width: 45px;\n  margin: 2px 4px;\n  border-radius: 2px;\n  user-select: none;\n  overflow: hidden;\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAAXNSR0IArs4c6QAAACRJREFUKFNjPHTo0H8GJGBnZ8eIzGekgwJk+0BsdCtRHEQbBQBbbh0dIGKknQAAAABJRU5ErkJggg==) repeat;\n  cursor: pointer;\n}\n.v-color-picker-swatches__color > div {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  height: 100%;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VSheet/VSheet.css */\n.v-sheet {\n  display: block;\n  border-color: rgba(var(--v-border-color), var(--v-border-opacity));\n  border-style: solid;\n  border-width: 0;\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n  border-radius: 0;\n  background: rgb(var(--v-theme-surface));\n  color: rgba(var(--v-theme-on-background), var(--v-high-emphasis-opacity));\n}\n.v-sheet--border {\n  border-width: thin;\n  box-shadow: none;\n}\n.v-sheet--absolute {\n  position: absolute;\n}\n.v-sheet--fixed {\n  position: fixed;\n}\n.v-sheet--relative {\n  position: relative;\n}\n.v-sheet--sticky {\n  position: sticky;\n}\n.v-sheet--rounded {\n  border-radius: 4px;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VCombobox/VCombobox.css */\n.v-combobox .v-field .v-text-field__prefix,\n.v-combobox .v-field .v-text-field__suffix,\n.v-combobox .v-field .v-field__input,\n.v-combobox .v-field.v-field {\n  cursor: text;\n}\n.v-combobox .v-field .v-field__input > input {\n  flex: 1 1;\n}\n.v-combobox .v-field input {\n  min-width: 64px;\n}\n.v-combobox .v-field:not(.v-field--focused) input {\n  min-width: 0;\n}\n.v-combobox .v-field--dirty .v-combobox__selection {\n  margin-inline-end: 2px;\n}\n.v-combobox .v-combobox__selection-text {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n.v-combobox__content {\n  overflow: hidden;\n  box-shadow:\n    0px 2px 4px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 4px 5px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 10px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n  border-radius: 4px;\n}\n.v-combobox__mask {\n  background: rgb(var(--v-theme-surface-light));\n}\n.v-combobox__selection {\n  display: inline-flex;\n  align-items: center;\n  height: 1.5rem;\n  letter-spacing: inherit;\n  line-height: inherit;\n  max-width: calc(100% - 2px - 2px);\n}\n.v-combobox__selection:first-child {\n  margin-inline-start: 0;\n}\n.v-combobox--chips.v-input--density-compact .v-field--variant-solo .v-label.v-field-label--floating,\n.v-combobox--chips.v-input--density-compact .v-field--variant-solo-inverted .v-label.v-field-label--floating,\n.v-combobox--chips.v-input--density-compact .v-field--variant-filled .v-label.v-field-label--floating,\n.v-combobox--chips.v-input--density-compact .v-field--variant-solo-filled .v-label.v-field-label--floating {\n  top: 0px;\n}\n.v-combobox--selecting-index .v-combobox__selection {\n  opacity: var(--v-medium-emphasis-opacity);\n}\n.v-combobox--selecting-index .v-combobox__selection--selected {\n  opacity: 1;\n}\n.v-combobox--selecting-index .v-field__input > input {\n  caret-color: transparent;\n}\n.v-combobox--single:not(.v-combobox--selection-slot).v-text-field input {\n  flex: 1 1;\n  position: absolute;\n  left: 0;\n  right: 0;\n  width: 100%;\n  padding-inline: inherit;\n}\n.v-combobox--single:not(.v-combobox--selection-slot) .v-field--active input {\n  transition: none;\n}\n.v-combobox--single:not(.v-combobox--selection-slot) .v-field--dirty:not(.v-field--focused) input {\n  opacity: 0;\n}\n.v-combobox--single:not(.v-combobox--selection-slot) .v-field--focused .v-combobox__selection {\n  opacity: 0;\n}\n.v-combobox__menu-icon {\n  margin-inline-start: 4px;\n  transition: 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-combobox--active-menu .v-combobox__menu-icon {\n  opacity: var(--v-high-emphasis-opacity);\n  transform: rotate(180deg);\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VDataTable/VDataTable.css */\n.v-data-table {\n  width: 100%;\n}\n.v-data-table__table {\n  width: 100%;\n  border-collapse: separate;\n  border-spacing: 0;\n}\n.v-data-table__tr--focus {\n  border: 1px dotted black;\n}\n.v-data-table__tr--clickable {\n  cursor: pointer;\n}\n.v-data-table .v-table__wrapper > table > thead > tr > td.v-data-table-column--align-end,\n.v-data-table .v-table__wrapper > table > thead > tr th.v-data-table-column--align-end,\n.v-data-table .v-table__wrapper > table tbody > tr > td.v-data-table-column--align-end,\n.v-data-table .v-table__wrapper > table tbody > tr th.v-data-table-column--align-end {\n  text-align: end;\n}\n.v-data-table .v-table__wrapper > table > thead > tr > td.v-data-table-column--align-end .v-data-table-header__content,\n.v-data-table .v-table__wrapper > table > thead > tr th.v-data-table-column--align-end .v-data-table-header__content,\n.v-data-table .v-table__wrapper > table tbody > tr > td.v-data-table-column--align-end .v-data-table-header__content,\n.v-data-table .v-table__wrapper > table tbody > tr th.v-data-table-column--align-end .v-data-table-header__content {\n  flex-direction: row-reverse;\n}\n.v-data-table .v-table__wrapper > table > thead > tr > td.v-data-table-column--align-center,\n.v-data-table .v-table__wrapper > table > thead > tr th.v-data-table-column--align-center,\n.v-data-table .v-table__wrapper > table tbody > tr > td.v-data-table-column--align-center,\n.v-data-table .v-table__wrapper > table tbody > tr th.v-data-table-column--align-center {\n  text-align: center;\n}\n.v-data-table .v-table__wrapper > table > thead > tr > td.v-data-table-column--align-center .v-data-table-header__content,\n.v-data-table .v-table__wrapper > table > thead > tr th.v-data-table-column--align-center .v-data-table-header__content,\n.v-data-table .v-table__wrapper > table tbody > tr > td.v-data-table-column--align-center .v-data-table-header__content,\n.v-data-table .v-table__wrapper > table tbody > tr th.v-data-table-column--align-center .v-data-table-header__content {\n  justify-content: center;\n}\n.v-data-table .v-table__wrapper > table > thead > tr > td.v-data-table-column--no-padding,\n.v-data-table .v-table__wrapper > table > thead > tr th.v-data-table-column--no-padding,\n.v-data-table .v-table__wrapper > table tbody > tr > td.v-data-table-column--no-padding,\n.v-data-table .v-table__wrapper > table tbody > tr th.v-data-table-column--no-padding {\n  padding: 0 8px;\n}\n.v-data-table .v-table__wrapper > table > thead > tr > th,\n.v-data-table .v-table__wrapper > table tbody > tr > th {\n  align-items: center;\n}\n.v-data-table .v-table__wrapper > table > thead > tr > th.v-data-table__th--fixed,\n.v-data-table .v-table__wrapper > table tbody > tr > th.v-data-table__th--fixed {\n  position: sticky;\n}\n.v-data-table .v-table__wrapper > table > thead > tr > th.v-data-table__th--sortable:hover,\n.v-data-table .v-table__wrapper > table tbody > tr > th.v-data-table__th--sortable:hover {\n  cursor: pointer;\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n}\n.v-data-table .v-table__wrapper > table > thead > tr > th:not(.v-data-table__th--sorted) .v-data-table-header__sort-icon,\n.v-data-table .v-table__wrapper > table tbody > tr > th:not(.v-data-table__th--sorted) .v-data-table-header__sort-icon {\n  opacity: 0;\n}\n.v-data-table .v-table__wrapper > table > thead > tr > th:not(.v-data-table__th--sorted):hover .v-data-table-header__sort-icon,\n.v-data-table .v-table__wrapper > table tbody > tr > th:not(.v-data-table__th--sorted):hover .v-data-table-header__sort-icon {\n  opacity: 0.5;\n}\n.v-data-table-column--fixed,\n.v-data-table__th--sticky {\n  background: rgb(var(--v-theme-surface));\n  position: sticky !important;\n  left: 0;\n  z-index: 1;\n}\n.v-data-table-column--last-fixed {\n  border-right: 1px solid rgba(var(--v-border-color), var(--v-border-opacity));\n}\n.v-data-table.v-table--fixed-header > .v-table__wrapper > table > thead > tr > th.v-data-table-column--fixed {\n  z-index: 2;\n}\n.v-data-table-group-header-row td {\n  background: rgba(var(--v-theme-surface));\n  color: rgba(var(--v-theme-on-surface));\n}\n.v-data-table-group-header-row td > span {\n  padding-left: 5px;\n}\n.v-data-table--loading .v-data-table__td {\n  opacity: 0.3;\n}\n.v-data-table-group-header-row__column {\n  padding-left: calc(var(--v-data-table-group-header-row-depth) * 16px) !important;\n}\n.v-data-table-header__content {\n  display: flex;\n  align-items: center;\n}\n.v-data-table-header__sort-badge {\n  display: inline-flex;\n  justify-content: center;\n  align-items: center;\n  font-size: 0.875rem;\n  padding: 4px;\n  border-radius: 50%;\n  background: rgba(var(--v-border-color), var(--v-border-opacity));\n  min-width: 20px;\n  min-height: 20px;\n  width: 20px;\n  height: 20px;\n}\n.v-data-table-progress > th {\n  border: none !important;\n  height: auto !important;\n  padding: 0 !important;\n}\n.v-data-table-progress__loader {\n  position: relative;\n}\n.v-data-table-rows-loading,\n.v-data-table-rows-no-data {\n  text-align: center;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VDataTable/VDataTableFooter.css */\n.v-data-table-footer {\n  display: flex;\n  align-items: center;\n  flex-wrap: wrap;\n  padding: 4px;\n  justify-content: flex-end;\n}\n.v-data-table-footer__items-per-page {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.v-data-table-footer__items-per-page > span {\n  padding-inline-end: 8px;\n}\n.v-data-table-footer__items-per-page > .v-select {\n  width: 90px;\n}\n.v-data-table-footer__info {\n  display: flex;\n  justify-content: flex-end;\n  min-width: 116px;\n  padding: 0 16px;\n}\n.v-data-table-footer__pagination {\n  display: flex;\n  align-items: center;\n  margin-inline-start: 16px;\n}\n.v-data-table-footer__page {\n  padding: 0 8px;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VPagination/VPagination.css */\n.v-pagination__list {\n  display: inline-flex;\n  list-style-type: none;\n  justify-content: center;\n  width: 100%;\n}\n.v-pagination__item,\n.v-pagination__first,\n.v-pagination__prev,\n.v-pagination__next,\n.v-pagination__last {\n  margin: 0.3rem;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VTable/VTable.css */\n.v-table {\n  background: rgb(var(--v-theme-surface));\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n  font-size: 0.875rem;\n  transition-duration: 0.28s;\n  transition-property:\n    box-shadow,\n    opacity,\n    background,\n    height;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-table .v-table-divider {\n  border-right: thin solid rgba(var(--v-border-color), var(--v-border-opacity));\n}\n.v-table .v-table__wrapper > table > thead > tr > th {\n  border-bottom: thin solid rgba(var(--v-border-color), var(--v-border-opacity));\n}\n.v-table .v-table__wrapper > table > tbody > tr:not(:last-child) > td,\n.v-table .v-table__wrapper > table > tbody > tr:not(:last-child) > th {\n  border-bottom: thin solid rgba(var(--v-border-color), var(--v-border-opacity));\n}\n.v-table .v-table__wrapper > table > tfoot > tr > td,\n.v-table .v-table__wrapper > table > tfoot > tr > th {\n  border-top: thin solid rgba(var(--v-border-color), var(--v-border-opacity));\n}\n.v-table.v-table--hover > .v-table__wrapper > table > tbody > tr > td {\n  position: relative;\n}\n.v-table.v-table--hover > .v-table__wrapper > table > tbody > tr:hover > td::after {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: rgba(var(--v-border-color), var(--v-hover-opacity));\n  pointer-events: none;\n}\n.v-table.v-table--fixed-header > .v-table__wrapper > table > thead > tr > th {\n  background: rgb(var(--v-theme-surface));\n  box-shadow: inset 0 -1px 0 rgba(var(--v-border-color), var(--v-border-opacity));\n  z-index: 1;\n}\n.v-table.v-table--fixed-footer > tfoot > tr > th,\n.v-table.v-table--fixed-footer > tfoot > tr > td {\n  background: rgb(var(--v-theme-surface));\n  box-shadow: inset 0 1px 0 rgba(var(--v-border-color), var(--v-border-opacity));\n}\n.v-table {\n  border-radius: inherit;\n  line-height: 1.5;\n  max-width: 100%;\n  display: flex;\n  flex-direction: column;\n}\n.v-table > .v-table__wrapper > table {\n  width: 100%;\n  border-spacing: 0;\n}\n.v-table > .v-table__wrapper > table > tbody > tr > td,\n.v-table > .v-table__wrapper > table > tbody > tr > th,\n.v-table > .v-table__wrapper > table > thead > tr > td,\n.v-table > .v-table__wrapper > table > thead > tr > th,\n.v-table > .v-table__wrapper > table > tfoot > tr > td,\n.v-table > .v-table__wrapper > table > tfoot > tr > th {\n  padding: 0 16px;\n  transition-duration: 0.28s;\n  transition-property:\n    box-shadow,\n    opacity,\n    background,\n    height;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-table > .v-table__wrapper > table > tbody > tr > td,\n.v-table > .v-table__wrapper > table > thead > tr > td,\n.v-table > .v-table__wrapper > table > tfoot > tr > td {\n  height: var(--v-table-row-height);\n}\n.v-table > .v-table__wrapper > table > tbody > tr > th,\n.v-table > .v-table__wrapper > table > thead > tr > th,\n.v-table > .v-table__wrapper > table > tfoot > tr > th {\n  height: var(--v-table-header-height);\n  font-weight: 500;\n  user-select: none;\n  text-align: start;\n}\n.v-table--density-default {\n  --v-table-header-height: 56px;\n  --v-table-row-height: 52px;\n}\n.v-table--density-comfortable {\n  --v-table-header-height: 48px;\n  --v-table-row-height: 44px;\n}\n.v-table--density-compact {\n  --v-table-header-height: 40px;\n  --v-table-row-height: 36px;\n}\n.v-table__wrapper {\n  border-radius: inherit;\n  overflow: auto;\n  flex: 1 1 auto;\n}\n.v-table--has-top > .v-table__wrapper > table > tbody > tr:first-child:hover > td:first-child {\n  border-top-left-radius: 0;\n}\n.v-table--has-top > .v-table__wrapper > table > tbody > tr:first-child:hover > td:last-child {\n  border-top-right-radius: 0;\n}\n.v-table--has-bottom > .v-table__wrapper > table > tbody > tr:last-child:hover > td:first-child {\n  border-bottom-left-radius: 0;\n}\n.v-table--has-bottom > .v-table__wrapper > table > tbody > tr:last-child:hover > td:last-child {\n  border-bottom-right-radius: 0;\n}\n.v-table--fixed-height > .v-table__wrapper {\n  overflow-y: auto;\n}\n.v-table--fixed-header > .v-table__wrapper > table > thead {\n  position: sticky;\n  top: 0;\n  z-index: 2;\n}\n.v-table--fixed-header > .v-table__wrapper > table > thead > tr > th {\n  border-bottom: 0px !important;\n}\n.v-table--fixed-footer > .v-table__wrapper > table > tfoot > tr {\n  position: sticky;\n  bottom: 0;\n  z-index: 1;\n}\n.v-table--fixed-footer > .v-table__wrapper > table > tfoot > tr > td,\n.v-table--fixed-footer > .v-table__wrapper > table > tfoot > tr > th {\n  border-top: 0px !important;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VDatePicker/VDatePicker.css */\n.v-date-picker {\n  overflow: hidden;\n  width: 328px;\n}\n.v-date-picker--show-week {\n  width: 368px;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VDatePicker/VDatePickerControls.css */\n.v-date-picker-controls {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  font-size: 0.875rem;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-inline-start: 6px;\n  padding-inline-end: 12px;\n}\n.v-date-picker-controls > .v-btn:first-child {\n  text-transform: none;\n  font-weight: 400;\n  line-height: initial;\n  letter-spacing: initial;\n}\n.v-date-picker-controls--variant-classic {\n  padding-inline-start: 12px;\n}\n.v-date-picker-controls--variant-modern .v-date-picker__title:not(:hover) {\n  opacity: 0.7;\n}\n.v-date-picker--month .v-date-picker-controls--variant-modern .v-date-picker__title {\n  cursor: pointer;\n}\n.v-date-picker--year .v-date-picker-controls--variant-modern .v-date-picker__title {\n  opacity: 1;\n}\n.v-date-picker-controls .v-btn:last-child {\n  margin-inline-start: 4px;\n}\n.v-date-picker--year .v-date-picker-controls .v-date-picker-controls__mode-btn {\n  transform: rotate(180deg);\n}\n.v-date-picker-controls__date {\n  margin-inline-end: 4px;\n}\n.v-date-picker-controls--variant-classic .v-date-picker-controls__date {\n  margin: auto;\n  text-align: center;\n}\n.v-date-picker-controls__month {\n  display: flex;\n}\n.v-locale--is-rtl.v-date-picker-controls__month,\n.v-locale--is-rtl .v-date-picker-controls__month {\n  flex-direction: row-reverse;\n}\n.v-date-picker-controls--variant-classic .v-date-picker-controls__month {\n  flex: 1 0 auto;\n}\n.v-date-picker__title {\n  display: inline-block;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VGrid/VGrid.css */\n.v-container {\n  width: 100%;\n  padding: 16px;\n  margin-right: auto;\n  margin-left: auto;\n}\n@media (min-width: 960px) {\n  .v-container {\n    max-width: 900px;\n  }\n}\n@media (min-width: 1280px) {\n  .v-container {\n    max-width: 1200px;\n  }\n}\n@media (min-width: 1920px) {\n  .v-container {\n    max-width: 1800px;\n  }\n}\n@media (min-width: 2560px) {\n  .v-container {\n    max-width: 2400px;\n  }\n}\n.v-container--fluid {\n  max-width: 100%;\n}\n.v-container.fill-height {\n  align-items: center;\n  display: flex;\n  flex-wrap: wrap;\n}\n.v-row {\n  display: flex;\n  flex-wrap: wrap;\n  flex: 1 1 auto;\n  margin: -12px;\n}\n.v-row + .v-row {\n  margin-top: 12px;\n}\n.v-row + .v-row--dense {\n  margin-top: 4px;\n}\n.v-row--dense {\n  margin: -4px;\n}\n.v-row--dense > .v-col,\n.v-row--dense > [class*=v-col-] {\n  padding: 4px;\n}\n.v-row.v-row--no-gutters {\n  margin: 0;\n}\n.v-row.v-row--no-gutters > .v-col,\n.v-row.v-row--no-gutters > [class*=v-col-] {\n  padding: 0;\n}\n.v-spacer {\n  flex-grow: 1;\n}\n.v-col-xxl,\n.v-col-xxl-auto,\n.v-col-xxl-12,\n.v-col-xxl-11,\n.v-col-xxl-10,\n.v-col-xxl-9,\n.v-col-xxl-8,\n.v-col-xxl-7,\n.v-col-xxl-6,\n.v-col-xxl-5,\n.v-col-xxl-4,\n.v-col-xxl-3,\n.v-col-xxl-2,\n.v-col-xxl-1,\n.v-col-xl,\n.v-col-xl-auto,\n.v-col-xl-12,\n.v-col-xl-11,\n.v-col-xl-10,\n.v-col-xl-9,\n.v-col-xl-8,\n.v-col-xl-7,\n.v-col-xl-6,\n.v-col-xl-5,\n.v-col-xl-4,\n.v-col-xl-3,\n.v-col-xl-2,\n.v-col-xl-1,\n.v-col-lg,\n.v-col-lg-auto,\n.v-col-lg-12,\n.v-col-lg-11,\n.v-col-lg-10,\n.v-col-lg-9,\n.v-col-lg-8,\n.v-col-lg-7,\n.v-col-lg-6,\n.v-col-lg-5,\n.v-col-lg-4,\n.v-col-lg-3,\n.v-col-lg-2,\n.v-col-lg-1,\n.v-col-md,\n.v-col-md-auto,\n.v-col-md-12,\n.v-col-md-11,\n.v-col-md-10,\n.v-col-md-9,\n.v-col-md-8,\n.v-col-md-7,\n.v-col-md-6,\n.v-col-md-5,\n.v-col-md-4,\n.v-col-md-3,\n.v-col-md-2,\n.v-col-md-1,\n.v-col-sm,\n.v-col-sm-auto,\n.v-col-sm-12,\n.v-col-sm-11,\n.v-col-sm-10,\n.v-col-sm-9,\n.v-col-sm-8,\n.v-col-sm-7,\n.v-col-sm-6,\n.v-col-sm-5,\n.v-col-sm-4,\n.v-col-sm-3,\n.v-col-sm-2,\n.v-col-sm-1,\n.v-col,\n.v-col-auto,\n.v-col-12,\n.v-col-11,\n.v-col-10,\n.v-col-9,\n.v-col-8,\n.v-col-7,\n.v-col-6,\n.v-col-5,\n.v-col-4,\n.v-col-3,\n.v-col-2,\n.v-col-1 {\n  width: 100%;\n  padding: 12px;\n}\n.v-col {\n  flex-basis: 0;\n  flex-grow: 1;\n  max-width: 100%;\n}\n.v-col-auto {\n  flex: 0 0 auto;\n  width: auto;\n  max-width: 100%;\n}\n.v-col-1 {\n  flex: 0 0 8.3333333333%;\n  max-width: 8.3333333333%;\n}\n.v-col-2 {\n  flex: 0 0 16.6666666667%;\n  max-width: 16.6666666667%;\n}\n.v-col-3 {\n  flex: 0 0 25%;\n  max-width: 25%;\n}\n.v-col-4 {\n  flex: 0 0 33.3333333333%;\n  max-width: 33.3333333333%;\n}\n.v-col-5 {\n  flex: 0 0 41.6666666667%;\n  max-width: 41.6666666667%;\n}\n.v-col-6 {\n  flex: 0 0 50%;\n  max-width: 50%;\n}\n.v-col-7 {\n  flex: 0 0 58.3333333333%;\n  max-width: 58.3333333333%;\n}\n.v-col-8 {\n  flex: 0 0 66.6666666667%;\n  max-width: 66.6666666667%;\n}\n.v-col-9 {\n  flex: 0 0 75%;\n  max-width: 75%;\n}\n.v-col-10 {\n  flex: 0 0 83.3333333333%;\n  max-width: 83.3333333333%;\n}\n.v-col-11 {\n  flex: 0 0 91.6666666667%;\n  max-width: 91.6666666667%;\n}\n.v-col-12 {\n  flex: 0 0 100%;\n  max-width: 100%;\n}\n.offset-1 {\n  margin-inline-start: 8.3333333333%;\n}\n.offset-2 {\n  margin-inline-start: 16.6666666667%;\n}\n.offset-3 {\n  margin-inline-start: 25%;\n}\n.offset-4 {\n  margin-inline-start: 33.3333333333%;\n}\n.offset-5 {\n  margin-inline-start: 41.6666666667%;\n}\n.offset-6 {\n  margin-inline-start: 50%;\n}\n.offset-7 {\n  margin-inline-start: 58.3333333333%;\n}\n.offset-8 {\n  margin-inline-start: 66.6666666667%;\n}\n.offset-9 {\n  margin-inline-start: 75%;\n}\n.offset-10 {\n  margin-inline-start: 83.3333333333%;\n}\n.offset-11 {\n  margin-inline-start: 91.6666666667%;\n}\n@media (min-width: 600px) {\n  .v-col-sm {\n    flex-basis: 0;\n    flex-grow: 1;\n    max-width: 100%;\n  }\n  .v-col-sm-auto {\n    flex: 0 0 auto;\n    width: auto;\n    max-width: 100%;\n  }\n  .v-col-sm-1 {\n    flex: 0 0 8.3333333333%;\n    max-width: 8.3333333333%;\n  }\n  .v-col-sm-2 {\n    flex: 0 0 16.6666666667%;\n    max-width: 16.6666666667%;\n  }\n  .v-col-sm-3 {\n    flex: 0 0 25%;\n    max-width: 25%;\n  }\n  .v-col-sm-4 {\n    flex: 0 0 33.3333333333%;\n    max-width: 33.3333333333%;\n  }\n  .v-col-sm-5 {\n    flex: 0 0 41.6666666667%;\n    max-width: 41.6666666667%;\n  }\n  .v-col-sm-6 {\n    flex: 0 0 50%;\n    max-width: 50%;\n  }\n  .v-col-sm-7 {\n    flex: 0 0 58.3333333333%;\n    max-width: 58.3333333333%;\n  }\n  .v-col-sm-8 {\n    flex: 0 0 66.6666666667%;\n    max-width: 66.6666666667%;\n  }\n  .v-col-sm-9 {\n    flex: 0 0 75%;\n    max-width: 75%;\n  }\n  .v-col-sm-10 {\n    flex: 0 0 83.3333333333%;\n    max-width: 83.3333333333%;\n  }\n  .v-col-sm-11 {\n    flex: 0 0 91.6666666667%;\n    max-width: 91.6666666667%;\n  }\n  .v-col-sm-12 {\n    flex: 0 0 100%;\n    max-width: 100%;\n  }\n  .offset-sm-0 {\n    margin-inline-start: 0;\n  }\n  .offset-sm-1 {\n    margin-inline-start: 8.3333333333%;\n  }\n  .offset-sm-2 {\n    margin-inline-start: 16.6666666667%;\n  }\n  .offset-sm-3 {\n    margin-inline-start: 25%;\n  }\n  .offset-sm-4 {\n    margin-inline-start: 33.3333333333%;\n  }\n  .offset-sm-5 {\n    margin-inline-start: 41.6666666667%;\n  }\n  .offset-sm-6 {\n    margin-inline-start: 50%;\n  }\n  .offset-sm-7 {\n    margin-inline-start: 58.3333333333%;\n  }\n  .offset-sm-8 {\n    margin-inline-start: 66.6666666667%;\n  }\n  .offset-sm-9 {\n    margin-inline-start: 75%;\n  }\n  .offset-sm-10 {\n    margin-inline-start: 83.3333333333%;\n  }\n  .offset-sm-11 {\n    margin-inline-start: 91.6666666667%;\n  }\n}\n@media (min-width: 960px) {\n  .v-col-md {\n    flex-basis: 0;\n    flex-grow: 1;\n    max-width: 100%;\n  }\n  .v-col-md-auto {\n    flex: 0 0 auto;\n    width: auto;\n    max-width: 100%;\n  }\n  .v-col-md-1 {\n    flex: 0 0 8.3333333333%;\n    max-width: 8.3333333333%;\n  }\n  .v-col-md-2 {\n    flex: 0 0 16.6666666667%;\n    max-width: 16.6666666667%;\n  }\n  .v-col-md-3 {\n    flex: 0 0 25%;\n    max-width: 25%;\n  }\n  .v-col-md-4 {\n    flex: 0 0 33.3333333333%;\n    max-width: 33.3333333333%;\n  }\n  .v-col-md-5 {\n    flex: 0 0 41.6666666667%;\n    max-width: 41.6666666667%;\n  }\n  .v-col-md-6 {\n    flex: 0 0 50%;\n    max-width: 50%;\n  }\n  .v-col-md-7 {\n    flex: 0 0 58.3333333333%;\n    max-width: 58.3333333333%;\n  }\n  .v-col-md-8 {\n    flex: 0 0 66.6666666667%;\n    max-width: 66.6666666667%;\n  }\n  .v-col-md-9 {\n    flex: 0 0 75%;\n    max-width: 75%;\n  }\n  .v-col-md-10 {\n    flex: 0 0 83.3333333333%;\n    max-width: 83.3333333333%;\n  }\n  .v-col-md-11 {\n    flex: 0 0 91.6666666667%;\n    max-width: 91.6666666667%;\n  }\n  .v-col-md-12 {\n    flex: 0 0 100%;\n    max-width: 100%;\n  }\n  .offset-md-0 {\n    margin-inline-start: 0;\n  }\n  .offset-md-1 {\n    margin-inline-start: 8.3333333333%;\n  }\n  .offset-md-2 {\n    margin-inline-start: 16.6666666667%;\n  }\n  .offset-md-3 {\n    margin-inline-start: 25%;\n  }\n  .offset-md-4 {\n    margin-inline-start: 33.3333333333%;\n  }\n  .offset-md-5 {\n    margin-inline-start: 41.6666666667%;\n  }\n  .offset-md-6 {\n    margin-inline-start: 50%;\n  }\n  .offset-md-7 {\n    margin-inline-start: 58.3333333333%;\n  }\n  .offset-md-8 {\n    margin-inline-start: 66.6666666667%;\n  }\n  .offset-md-9 {\n    margin-inline-start: 75%;\n  }\n  .offset-md-10 {\n    margin-inline-start: 83.3333333333%;\n  }\n  .offset-md-11 {\n    margin-inline-start: 91.6666666667%;\n  }\n}\n@media (min-width: 1280px) {\n  .v-col-lg {\n    flex-basis: 0;\n    flex-grow: 1;\n    max-width: 100%;\n  }\n  .v-col-lg-auto {\n    flex: 0 0 auto;\n    width: auto;\n    max-width: 100%;\n  }\n  .v-col-lg-1 {\n    flex: 0 0 8.3333333333%;\n    max-width: 8.3333333333%;\n  }\n  .v-col-lg-2 {\n    flex: 0 0 16.6666666667%;\n    max-width: 16.6666666667%;\n  }\n  .v-col-lg-3 {\n    flex: 0 0 25%;\n    max-width: 25%;\n  }\n  .v-col-lg-4 {\n    flex: 0 0 33.3333333333%;\n    max-width: 33.3333333333%;\n  }\n  .v-col-lg-5 {\n    flex: 0 0 41.6666666667%;\n    max-width: 41.6666666667%;\n  }\n  .v-col-lg-6 {\n    flex: 0 0 50%;\n    max-width: 50%;\n  }\n  .v-col-lg-7 {\n    flex: 0 0 58.3333333333%;\n    max-width: 58.3333333333%;\n  }\n  .v-col-lg-8 {\n    flex: 0 0 66.6666666667%;\n    max-width: 66.6666666667%;\n  }\n  .v-col-lg-9 {\n    flex: 0 0 75%;\n    max-width: 75%;\n  }\n  .v-col-lg-10 {\n    flex: 0 0 83.3333333333%;\n    max-width: 83.3333333333%;\n  }\n  .v-col-lg-11 {\n    flex: 0 0 91.6666666667%;\n    max-width: 91.6666666667%;\n  }\n  .v-col-lg-12 {\n    flex: 0 0 100%;\n    max-width: 100%;\n  }\n  .offset-lg-0 {\n    margin-inline-start: 0;\n  }\n  .offset-lg-1 {\n    margin-inline-start: 8.3333333333%;\n  }\n  .offset-lg-2 {\n    margin-inline-start: 16.6666666667%;\n  }\n  .offset-lg-3 {\n    margin-inline-start: 25%;\n  }\n  .offset-lg-4 {\n    margin-inline-start: 33.3333333333%;\n  }\n  .offset-lg-5 {\n    margin-inline-start: 41.6666666667%;\n  }\n  .offset-lg-6 {\n    margin-inline-start: 50%;\n  }\n  .offset-lg-7 {\n    margin-inline-start: 58.3333333333%;\n  }\n  .offset-lg-8 {\n    margin-inline-start: 66.6666666667%;\n  }\n  .offset-lg-9 {\n    margin-inline-start: 75%;\n  }\n  .offset-lg-10 {\n    margin-inline-start: 83.3333333333%;\n  }\n  .offset-lg-11 {\n    margin-inline-start: 91.6666666667%;\n  }\n}\n@media (min-width: 1920px) {\n  .v-col-xl {\n    flex-basis: 0;\n    flex-grow: 1;\n    max-width: 100%;\n  }\n  .v-col-xl-auto {\n    flex: 0 0 auto;\n    width: auto;\n    max-width: 100%;\n  }\n  .v-col-xl-1 {\n    flex: 0 0 8.3333333333%;\n    max-width: 8.3333333333%;\n  }\n  .v-col-xl-2 {\n    flex: 0 0 16.6666666667%;\n    max-width: 16.6666666667%;\n  }\n  .v-col-xl-3 {\n    flex: 0 0 25%;\n    max-width: 25%;\n  }\n  .v-col-xl-4 {\n    flex: 0 0 33.3333333333%;\n    max-width: 33.3333333333%;\n  }\n  .v-col-xl-5 {\n    flex: 0 0 41.6666666667%;\n    max-width: 41.6666666667%;\n  }\n  .v-col-xl-6 {\n    flex: 0 0 50%;\n    max-width: 50%;\n  }\n  .v-col-xl-7 {\n    flex: 0 0 58.3333333333%;\n    max-width: 58.3333333333%;\n  }\n  .v-col-xl-8 {\n    flex: 0 0 66.6666666667%;\n    max-width: 66.6666666667%;\n  }\n  .v-col-xl-9 {\n    flex: 0 0 75%;\n    max-width: 75%;\n  }\n  .v-col-xl-10 {\n    flex: 0 0 83.3333333333%;\n    max-width: 83.3333333333%;\n  }\n  .v-col-xl-11 {\n    flex: 0 0 91.6666666667%;\n    max-width: 91.6666666667%;\n  }\n  .v-col-xl-12 {\n    flex: 0 0 100%;\n    max-width: 100%;\n  }\n  .offset-xl-0 {\n    margin-inline-start: 0;\n  }\n  .offset-xl-1 {\n    margin-inline-start: 8.3333333333%;\n  }\n  .offset-xl-2 {\n    margin-inline-start: 16.6666666667%;\n  }\n  .offset-xl-3 {\n    margin-inline-start: 25%;\n  }\n  .offset-xl-4 {\n    margin-inline-start: 33.3333333333%;\n  }\n  .offset-xl-5 {\n    margin-inline-start: 41.6666666667%;\n  }\n  .offset-xl-6 {\n    margin-inline-start: 50%;\n  }\n  .offset-xl-7 {\n    margin-inline-start: 58.3333333333%;\n  }\n  .offset-xl-8 {\n    margin-inline-start: 66.6666666667%;\n  }\n  .offset-xl-9 {\n    margin-inline-start: 75%;\n  }\n  .offset-xl-10 {\n    margin-inline-start: 83.3333333333%;\n  }\n  .offset-xl-11 {\n    margin-inline-start: 91.6666666667%;\n  }\n}\n@media (min-width: 2560px) {\n  .v-col-xxl {\n    flex-basis: 0;\n    flex-grow: 1;\n    max-width: 100%;\n  }\n  .v-col-xxl-auto {\n    flex: 0 0 auto;\n    width: auto;\n    max-width: 100%;\n  }\n  .v-col-xxl-1 {\n    flex: 0 0 8.3333333333%;\n    max-width: 8.3333333333%;\n  }\n  .v-col-xxl-2 {\n    flex: 0 0 16.6666666667%;\n    max-width: 16.6666666667%;\n  }\n  .v-col-xxl-3 {\n    flex: 0 0 25%;\n    max-width: 25%;\n  }\n  .v-col-xxl-4 {\n    flex: 0 0 33.3333333333%;\n    max-width: 33.3333333333%;\n  }\n  .v-col-xxl-5 {\n    flex: 0 0 41.6666666667%;\n    max-width: 41.6666666667%;\n  }\n  .v-col-xxl-6 {\n    flex: 0 0 50%;\n    max-width: 50%;\n  }\n  .v-col-xxl-7 {\n    flex: 0 0 58.3333333333%;\n    max-width: 58.3333333333%;\n  }\n  .v-col-xxl-8 {\n    flex: 0 0 66.6666666667%;\n    max-width: 66.6666666667%;\n  }\n  .v-col-xxl-9 {\n    flex: 0 0 75%;\n    max-width: 75%;\n  }\n  .v-col-xxl-10 {\n    flex: 0 0 83.3333333333%;\n    max-width: 83.3333333333%;\n  }\n  .v-col-xxl-11 {\n    flex: 0 0 91.6666666667%;\n    max-width: 91.6666666667%;\n  }\n  .v-col-xxl-12 {\n    flex: 0 0 100%;\n    max-width: 100%;\n  }\n  .offset-xxl-0 {\n    margin-inline-start: 0;\n  }\n  .offset-xxl-1 {\n    margin-inline-start: 8.3333333333%;\n  }\n  .offset-xxl-2 {\n    margin-inline-start: 16.6666666667%;\n  }\n  .offset-xxl-3 {\n    margin-inline-start: 25%;\n  }\n  .offset-xxl-4 {\n    margin-inline-start: 33.3333333333%;\n  }\n  .offset-xxl-5 {\n    margin-inline-start: 41.6666666667%;\n  }\n  .offset-xxl-6 {\n    margin-inline-start: 50%;\n  }\n  .offset-xxl-7 {\n    margin-inline-start: 58.3333333333%;\n  }\n  .offset-xxl-8 {\n    margin-inline-start: 66.6666666667%;\n  }\n  .offset-xxl-9 {\n    margin-inline-start: 75%;\n  }\n  .offset-xxl-10 {\n    margin-inline-start: 83.3333333333%;\n  }\n  .offset-xxl-11 {\n    margin-inline-start: 91.6666666667%;\n  }\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VDatePicker/VDatePickerHeader.css */\n.v-date-picker-header {\n  align-items: flex-end;\n  height: 70px;\n  display: grid;\n  grid-template-areas: \"prepend content append\";\n  grid-template-columns: min-content minmax(0, 1fr) min-content;\n  overflow: hidden;\n  padding-inline: 24px 12px;\n  padding-bottom: 12px;\n}\n.v-date-picker-header__append {\n  grid-area: append;\n}\n.v-date-picker-header__prepend {\n  grid-area: prepend;\n  padding-inline-start: 8px;\n}\n.v-date-picker-header__content {\n  align-items: center;\n  display: inline-flex;\n  font-size: 32px;\n  line-height: 40px;\n  grid-area: content;\n  justify-content: space-between;\n}\n.v-date-picker-header--clickable .v-date-picker-header__content {\n  cursor: pointer;\n}\n.v-date-picker-header--clickable .v-date-picker-header__content:not(:hover) {\n  opacity: 0.7;\n}\n.date-picker-header-transition-enter-active,\n.date-picker-header-reverse-transition-enter-active {\n  transition-duration: 0.3s;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n}\n.date-picker-header-transition-leave-active,\n.date-picker-header-reverse-transition-leave-active {\n  transition-duration: 0.3s;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n}\n.date-picker-header-transition-enter-from {\n  transform: translate(0, 100%);\n}\n.date-picker-header-transition-leave-to {\n  opacity: 0;\n  transform: translate(0, -100%);\n}\n.date-picker-header-reverse-transition-enter-from {\n  transform: translate(0, -100%);\n}\n.date-picker-header-reverse-transition-leave-to {\n  opacity: 0;\n  transform: translate(0, 100%);\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VDatePicker/VDatePickerMonth.css */\n.v-date-picker-month {\n  display: flex;\n  justify-content: center;\n  padding: 0 12px 8px;\n  --v-date-picker-month-day-diff: 4px;\n}\n.v-date-picker-month__weeks {\n  display: grid;\n  grid-template-rows: min-content min-content min-content min-content min-content min-content min-content;\n  column-gap: 4px;\n  font-size: 0.85rem;\n}\n.v-date-picker-month__weeks + .v-date-picker-month__days {\n  grid-row-gap: 0;\n}\n.v-date-picker-month__weekday {\n  font-size: 0.85rem;\n}\n.v-date-picker-month__days {\n  display: grid;\n  grid-template-columns: min-content min-content min-content min-content min-content min-content min-content;\n  column-gap: 4px;\n  flex: 1 1;\n  justify-content: space-around;\n}\n.v-date-picker-month__day {\n  align-items: center;\n  display: flex;\n  justify-content: center;\n  position: relative;\n  height: 40px;\n  width: 40px;\n}\n.v-date-picker-month__day--selected .v-btn {\n  background-color: rgb(var(--v-theme-surface-variant));\n  color: rgb(var(--v-theme-on-surface-variant));\n}\n.v-date-picker-month__day .v-btn.v-date-picker-month__day-btn {\n  --v-btn-height: 24px;\n  --v-btn-size: 0.85rem;\n}\n.v-date-picker-month__day--week {\n  font-size: var(--v-btn-size);\n}\n.v-date-picker-month__day--adjacent {\n  opacity: 0.5;\n}\n.v-date-picker-month__day--hide-adjacent {\n  opacity: 0;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VDatePicker/VDatePickerMonths.css */\n.v-date-picker-months {\n  height: 288px;\n}\n.v-date-picker-months__content {\n  align-items: center;\n  display: grid;\n  flex: 1 1;\n  height: inherit;\n  justify-content: space-around;\n  grid-template-columns: repeat(2, 1fr);\n  grid-gap: 0px 24px;\n  padding-inline-start: 36px;\n  padding-inline-end: 36px;\n}\n.v-date-picker-months__content .v-btn {\n  text-transform: none;\n  padding-inline-start: 8px;\n  padding-inline-end: 8px;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VDatePicker/VDatePickerYears.css */\n.v-date-picker-years {\n  height: 288px;\n  overflow-y: scroll;\n}\n.v-date-picker-years__content {\n  display: grid;\n  flex: 1 1;\n  justify-content: space-around;\n  grid-template-columns: repeat(3, 1fr);\n  gap: 8px 24px;\n  padding-inline: 32px;\n}\n.v-date-picker-years__content .v-btn {\n  padding-inline: 8px;\n}\n\n/* ../library_management/node_modules/vuetify/lib/labs/VPicker/VPicker.css */\n.v-picker.v-sheet {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n  border-radius: 4px;\n  display: grid;\n  grid-auto-rows: min-content;\n  grid-template-areas: \"title\" \"header\" \"body\";\n  overflow: hidden;\n}\n.v-picker.v-sheet.v-picker--with-actions {\n  grid-template-areas: \"title\" \"header\" \"body\" \"actions\";\n}\n.v-picker__body {\n  grid-area: body;\n}\n.v-picker__header {\n  grid-area: header;\n}\n.v-picker__actions {\n  grid-area: actions;\n  padding: 0 12px 12px;\n  display: flex;\n  align-items: center;\n  justify-content: flex-end;\n}\n.v-picker__actions .v-btn {\n  min-width: 48px;\n}\n.v-picker__actions .v-btn:not(:last-child) {\n  margin-inline-end: 8px;\n}\n.v-picker--landscape {\n  grid-template-areas: \"title\" \"header body\" \"header body\";\n}\n.v-picker--landscape.v-picker--with-actions {\n  grid-template-areas: \"title\" \"header body\" \"header actions\";\n}\n.v-picker-title {\n  text-transform: uppercase;\n  font-size: 0.75rem;\n  grid-area: title;\n  padding-inline: 24px 12px;\n  padding-top: 16px;\n  padding-bottom: 16px;\n  font-weight: 400;\n  letter-spacing: 0.1666666667em;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VExpansionPanel/VExpansionPanel.css */\n.v-expansion-panel {\n  background-color: rgb(var(--v-theme-surface));\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n}\n.v-expansion-panel:not(:first-child)::after {\n  border-color: rgba(var(--v-border-color), var(--v-border-opacity));\n}\n.v-expansion-panel--disabled .v-expansion-panel-title {\n  color: rgba(var(--v-theme-on-surface), 0.26);\n}\n.v-expansion-panel--disabled .v-expansion-panel-title .v-expansion-panel-title__overlay {\n  opacity: 0.4615384615;\n}\n.v-expansion-panels {\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: center;\n  list-style-type: none;\n  padding: 0;\n  width: 100%;\n  position: relative;\n  z-index: 1;\n}\n.v-expansion-panels:not(.v-expansion-panels--variant-accordion) > :not(:first-child):not(:last-child):not(.v-expansion-panel--active):not(.v-expansion-panel--before-active) {\n  border-bottom-left-radius: 0 !important;\n  border-bottom-right-radius: 0 !important;\n}\n.v-expansion-panels:not(.v-expansion-panels--variant-accordion) > :not(:first-child):not(:last-child):not(.v-expansion-panel--active):not(.v-expansion-panel--after-active) {\n  border-top-left-radius: 0 !important;\n  border-top-right-radius: 0 !important;\n}\n.v-expansion-panels:not(.v-expansion-panels--variant-accordion) > :first-child:not(:last-child):not(.v-expansion-panel--active):not(.v-expansion-panel--before-active) {\n  border-bottom-left-radius: 0 !important;\n  border-bottom-right-radius: 0 !important;\n}\n.v-expansion-panels:not(.v-expansion-panels--variant-accordion) > :last-child:not(:first-child):not(.v-expansion-panel--active):not(.v-expansion-panel--after-active) {\n  border-top-left-radius: 0 !important;\n  border-top-right-radius: 0 !important;\n}\n.v-expansion-panels--variant-accordion > :first-child:not(:last-child) {\n  border-bottom-left-radius: 0 !important;\n  border-bottom-right-radius: 0 !important;\n}\n.v-expansion-panels--variant-accordion > :last-child:not(:first-child) {\n  border-top-left-radius: 0 !important;\n  border-top-right-radius: 0 !important;\n}\n.v-expansion-panels--variant-accordion > :last-child:not(:first-child) .v-expansion-panel-title--active {\n  border-bottom-left-radius: initial;\n  border-bottom-right-radius: initial;\n}\n.v-expansion-panels--variant-accordion > :not(:first-child):not(:last-child) {\n  border-radius: 0 !important;\n}\n.v-expansion-panels--variant-accordion .v-expansion-panel-title__overlay {\n  transition: 0.3s border-radius cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-expansion-panel {\n  flex: 1 0 100%;\n  max-width: 100%;\n  position: relative;\n  transition: 0.3s all cubic-bezier(0.4, 0, 0.2, 1);\n  transition-property:\n    margin-top,\n    border-radius,\n    border,\n    max-width;\n  border-radius: 4px;\n}\n.v-expansion-panel:not(:first-child)::after {\n  border-top-style: solid;\n  border-top-width: thin;\n  content: \"\";\n  left: 0;\n  position: absolute;\n  right: 0;\n  top: 0;\n  transition: 0.3s opacity cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-expansion-panel--disabled .v-expansion-panel-title {\n  pointer-events: none;\n}\n.v-expansion-panel--active:not(:first-child),\n.v-expansion-panel--active + .v-expansion-panel {\n  margin-top: 16px;\n}\n.v-expansion-panel--active:not(:first-child)::after,\n.v-expansion-panel--active + .v-expansion-panel::after {\n  opacity: 0;\n}\n.v-expansion-panel--active > .v-expansion-panel-title {\n  border-bottom-left-radius: 0;\n  border-bottom-right-radius: 0;\n}\n.v-expansion-panel--active > .v-expansion-panel-title:not(.v-expansion-panel-title--static) {\n  min-height: 64px;\n}\n.v-expansion-panel__shadow {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  box-shadow:\n    0px 3px 1px -2px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 2px 2px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 5px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n  border-radius: inherit;\n  z-index: -1;\n}\n.v-expansion-panel-title {\n  align-items: center;\n  text-align: start;\n  border-radius: inherit;\n  display: flex;\n  font-size: 0.9375rem;\n  line-height: 1;\n  min-height: 48px;\n  outline: none;\n  padding: 16px 24px;\n  position: relative;\n  transition: 0.3s min-height cubic-bezier(0.4, 0, 0.2, 1);\n  width: 100%;\n  justify-content: space-between;\n}\n.v-expansion-panel-title:hover > .v-expansion-panel-title__overlay {\n  opacity: calc(var(--v-hover-opacity) * var(--v-theme-overlay-multiplier));\n}\n.v-expansion-panel-title:focus-visible > .v-expansion-panel-title__overlay {\n  opacity: calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier));\n}\n@supports not selector(:focus-visible) {\n  .v-expansion-panel-title:focus > .v-expansion-panel-title__overlay {\n    opacity: calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-expansion-panel-title--focusable.v-expansion-panel-title--active .v-expansion-panel-title__overlay {\n  opacity: calc(var(--v-activated-opacity) * var(--v-theme-overlay-multiplier));\n}\n.v-expansion-panel-title--focusable.v-expansion-panel-title--active:hover .v-expansion-panel-title__overlay {\n  opacity: calc((var(--v-activated-opacity) + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier));\n}\n.v-expansion-panel-title--focusable.v-expansion-panel-title--active:focus-visible .v-expansion-panel-title__overlay {\n  opacity: calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n}\n@supports not selector(:focus-visible) {\n  .v-expansion-panel-title--focusable.v-expansion-panel-title--active:focus .v-expansion-panel-title__overlay {\n    opacity: calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-expansion-panel-title__overlay {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background-color: currentColor;\n  border-radius: inherit;\n  opacity: 0;\n}\n.v-expansion-panel-title__icon {\n  display: inline-flex;\n  margin-bottom: -4px;\n  margin-top: -4px;\n  user-select: none;\n  margin-inline-start: auto;\n}\n.v-expansion-panel-text {\n  display: flex;\n}\n.v-expansion-panel-text__wrapper {\n  padding: 8px 24px 16px;\n  flex: 1 1 auto;\n  max-width: 100%;\n}\n.v-expansion-panels--variant-accordion > .v-expansion-panel {\n  margin-top: 0;\n}\n.v-expansion-panels--variant-accordion > .v-expansion-panel::after {\n  opacity: 1;\n}\n.v-expansion-panels--variant-popout > .v-expansion-panel {\n  max-width: calc(100% - 32px);\n}\n.v-expansion-panels--variant-popout > .v-expansion-panel--active {\n  max-width: calc(100% + 16px);\n}\n.v-expansion-panels--variant-inset > .v-expansion-panel {\n  max-width: 100%;\n}\n.v-expansion-panels--variant-inset > .v-expansion-panel--active {\n  max-width: calc(100% - 32px);\n}\n.v-expansion-panels--flat > .v-expansion-panel::after {\n  border-top: none;\n}\n.v-expansion-panels--flat > .v-expansion-panel .v-expansion-panel__shadow {\n  display: none;\n}\n.v-expansion-panels--tile {\n  border-radius: 0;\n}\n.v-expansion-panels--tile > .v-expansion-panel {\n  border-radius: 0;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VFileInput/VFileInput.css */\n.v-file-input--chips.v-input--density-compact .v-field--variant-solo .v-label.v-field-label--floating,\n.v-file-input--chips.v-input--density-compact .v-field--variant-solo-inverted .v-label.v-field-label--floating,\n.v-file-input--chips.v-input--density-compact .v-field--variant-filled .v-label.v-field-label--floating,\n.v-file-input--chips.v-input--density-compact .v-field--variant-solo-filled .v-label.v-field-label--floating {\n  top: 0px;\n}\n.v-file-input input[type=file] {\n  height: 100%;\n  left: 0;\n  opacity: 0;\n  position: absolute;\n  top: 0;\n  width: 100%;\n  z-index: 1;\n}\n.v-file-input .v-input__details {\n  padding-inline: 16px;\n}\n.v-input--plain-underlined.v-file-input .v-input__details {\n  padding-inline: 0;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VFooter/VFooter.css */\n.v-footer {\n  align-items: center;\n  display: flex;\n  flex: 1 1 auto;\n  padding: 8px 16px;\n  position: relative;\n  transition: 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n  transition-property:\n    height,\n    width,\n    transform,\n    max-width,\n    left,\n    right,\n    top,\n    bottom;\n  border-color: rgba(var(--v-border-color), var(--v-border-opacity));\n  border-style: solid;\n  border-width: 0;\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n  border-radius: 0;\n  background: rgb(var(--v-theme-surface));\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n}\n.v-footer--border {\n  border-width: thin;\n  box-shadow: none;\n}\n.v-footer--absolute {\n  position: absolute;\n}\n.v-footer--fixed {\n  position: fixed;\n}\n.v-footer--rounded {\n  border-radius: 4px;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VInfiniteScroll/VInfiniteScroll.css */\n.v-infinite-scroll--horizontal {\n  display: flex;\n  flex-direction: row;\n  overflow-x: auto;\n}\n.v-infinite-scroll--horizontal .v-infinite-scroll-intersect {\n  height: 100%;\n  width: 1px;\n}\n.v-infinite-scroll--vertical {\n  display: flex;\n  flex-direction: column;\n  overflow-y: auto;\n}\n.v-infinite-scroll--vertical .v-infinite-scroll-intersect {\n  height: 1px;\n  width: 100%;\n}\n.v-infinite-scroll__side {\n  align-items: center;\n  display: flex;\n  justify-content: center;\n  padding: 8px;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VItemGroup/VItemGroup.css */\n.v-item-group {\n  flex: 0 1 auto;\n  max-width: 100%;\n  position: relative;\n  transition: 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VKbd/VKbd.css */\n.v-kbd {\n  background: rgb(var(--v-theme-kbd));\n  color: rgb(var(--v-theme-on-kbd));\n  border-radius: 3px;\n  display: inline;\n  font-size: 85%;\n  font-weight: normal;\n  padding: 0.2em 0.4rem;\n  box-shadow:\n    0px 3px 1px -2px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 2px 2px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 5px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VLayout/VLayout.css */\n.v-layout {\n  --v-scrollbar-offset: 0px;\n  display: flex;\n  flex: 1 1 auto;\n}\n.v-layout--full-height {\n  --v-scrollbar-offset: inherit;\n  height: 100%;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VLayout/VLayoutItem.css */\n.v-layout-item {\n  position: absolute;\n  transition: 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-layout-item--absolute {\n  position: absolute;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VLocaleProvider/VLocaleProvider.css */\n.v-locale-provider {\n  display: contents;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VMain/VMain.css */\n.v-main {\n  flex: 1 0 auto;\n  max-width: 100%;\n  transition: 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n  padding-left: var(--v-layout-left);\n  padding-right: var(--v-layout-right);\n  padding-top: var(--v-layout-top);\n  padding-bottom: var(--v-layout-bottom);\n}\n.v-main__scroller {\n  max-width: 100%;\n  position: relative;\n}\n.v-main--scrollable {\n  display: flex;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n.v-main--scrollable > .v-main__scroller {\n  flex: 1 1 auto;\n  overflow-y: auto;\n  --v-layout-left: 0px;\n  --v-layout-right: 0px;\n  --v-layout-top: 0px;\n  --v-layout-bottom: 0px;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VNavigationDrawer/VNavigationDrawer.css */\n.v-navigation-drawer {\n  -webkit-overflow-scrolling: touch;\n  background: rgb(var(--v-theme-surface));\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n  max-width: 100%;\n  pointer-events: auto;\n  transition-duration: 0.2s;\n  transition-property:\n    box-shadow,\n    transform,\n    visibility,\n    width,\n    height,\n    left,\n    right,\n    top,\n    bottom;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  position: absolute;\n  border-color: rgba(var(--v-border-color), var(--v-border-opacity));\n  border-style: solid;\n  border-width: 0;\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n  background: rgb(var(--v-theme-surface));\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n}\n.v-navigation-drawer--border {\n  border-width: thin;\n  box-shadow: none;\n}\n.v-navigation-drawer--rounded {\n  border-radius: 4px;\n}\n.v-navigation-drawer--top {\n  top: 0;\n  border-bottom-width: thin;\n}\n.v-navigation-drawer--bottom {\n  left: 0;\n  border-top-width: thin;\n}\n.v-navigation-drawer--left {\n  top: 0;\n  left: 0;\n  right: auto;\n  border-right-width: thin;\n}\n.v-navigation-drawer--right {\n  top: 0;\n  left: auto;\n  right: 0;\n  border-left-width: thin;\n}\n.v-navigation-drawer--floating {\n  border: none;\n}\n.v-navigation-drawer--temporary {\n  box-shadow:\n    0px 8px 10px -5px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 16px 24px 2px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 6px 30px 5px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-navigation-drawer--sticky {\n  height: auto;\n  transition:\n    box-shadow,\n    transform,\n    visibility,\n    width,\n    height,\n    left,\n    right;\n}\n.v-navigation-drawer .v-list {\n  overflow: hidden;\n}\n.v-navigation-drawer__content {\n  flex: 0 1 auto;\n  height: 100%;\n  max-width: 100%;\n  overflow-x: hidden;\n  overflow-y: auto;\n}\n.v-navigation-drawer__img {\n  height: 100%;\n  left: 0;\n  position: absolute;\n  top: 0;\n  width: 100%;\n  z-index: -1;\n}\n.v-navigation-drawer__img img:not(.v-img__img) {\n  height: inherit;\n  object-fit: cover;\n  width: inherit;\n}\n.v-navigation-drawer__scrim {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: black;\n  opacity: 0.2;\n  transition: opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n  z-index: 1;\n}\n.v-navigation-drawer__prepend,\n.v-navigation-drawer__append {\n  flex: none;\n  overflow: hidden;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VOtpInput/VOtpInput.css */\n.v-otp-input {\n  border-radius: 4px;\n  align-items: center;\n  display: flex;\n  justify-content: center;\n  padding: 0.5rem 0;\n  position: relative;\n}\n.v-otp-input .v-field {\n  height: 100%;\n}\n.v-otp-input__divider {\n  margin: 0 8px;\n}\n.v-otp-input__content {\n  align-items: center;\n  display: flex;\n  gap: 0.5rem;\n  height: 64px;\n  padding: 0.5rem;\n  justify-content: center;\n  max-width: 320px;\n  position: relative;\n  border-radius: inherit;\n}\n.v-otp-input--divided .v-otp-input__content {\n  max-width: 360px;\n}\n.v-otp-input__field {\n  color: inherit;\n  font-size: 1.25rem;\n  height: 100%;\n  outline: none;\n  text-align: center;\n  width: 100%;\n}\n.v-otp-input__field[type=number]::-webkit-outer-spin-button,\n.v-otp-input__field[type=number]::-webkit-inner-spin-button {\n  -webkit-appearance: none;\n  margin: 0;\n}\n.v-otp-input__field[type=number] {\n  -moz-appearance: textfield;\n}\n.v-otp-input__loader {\n  align-items: center;\n  display: flex;\n  height: 100%;\n  justify-content: center;\n  width: 100%;\n}\n.v-otp-input__loader .v-progress-linear {\n  position: absolute;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VParallax/VParallax.css */\n.v-parallax {\n  position: relative;\n  overflow: hidden;\n}\n.v-parallax--active > .v-img__img {\n  will-change: transform;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VRadioGroup/VRadioGroup.css */\n.v-radio-group > .v-input__control {\n  flex-direction: column;\n}\n.v-radio-group > .v-input__control > .v-label {\n  margin-inline-start: 16px;\n}\n.v-radio-group > .v-input__control > .v-label + .v-selection-control-group {\n  padding-inline-start: 6px;\n  margin-top: 8px;\n}\n.v-radio-group .v-input__details {\n  padding-inline: 16px;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VRating/VRating.css */\n.v-rating {\n  max-width: 100%;\n  display: inline-flex;\n  white-space: nowrap;\n}\n.v-rating--readonly {\n  pointer-events: none;\n}\n.v-rating__wrapper {\n  align-items: center;\n  display: inline-flex;\n  flex-direction: column;\n}\n.v-rating__wrapper--bottom {\n  flex-direction: column-reverse;\n}\n.v-rating__item {\n  display: inline-flex;\n  position: relative;\n}\n.v-rating__item label {\n  cursor: pointer;\n}\n.v-rating__item .v-btn--variant-plain {\n  opacity: 1;\n}\n.v-rating__item .v-btn {\n  transition-property: transform;\n}\n.v-rating__item .v-btn .v-icon {\n  transition: inherit;\n  transition-timing-function: cubic-bezier(0, 0, 0.2, 1);\n}\n.v-rating--hover .v-rating__item:hover:not(.v-rating__item--focused) .v-btn {\n  transform: scale(1.25);\n}\n.v-rating__item--half {\n  overflow: hidden;\n  position: absolute;\n  clip-path: polygon(0 0, 50% 0, 50% 100%, 0 100%);\n  z-index: 1;\n}\n.v-rating__item--half .v-btn__overlay,\n.v-rating__item--half:hover .v-btn__overlay {\n  opacity: 0;\n}\n.v-rating__hidden {\n  height: 0;\n  opacity: 0;\n  position: absolute;\n  width: 0;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VSkeletonLoader/VSkeletonLoader.css */\n.v-skeleton-loader {\n  align-items: center;\n  background: rgb(var(--v-theme-surface));\n  border-radius: 4px;\n  display: flex;\n  flex-wrap: wrap;\n  position: relative;\n  vertical-align: top;\n}\n.v-skeleton-loader__actions {\n  justify-content: end;\n}\n.v-skeleton-loader .v-skeleton-loader__ossein {\n  height: 100%;\n}\n.v-skeleton-loader .v-skeleton-loader__avatar,\n.v-skeleton-loader .v-skeleton-loader__button,\n.v-skeleton-loader .v-skeleton-loader__chip,\n.v-skeleton-loader .v-skeleton-loader__divider,\n.v-skeleton-loader .v-skeleton-loader__heading,\n.v-skeleton-loader .v-skeleton-loader__image,\n.v-skeleton-loader .v-skeleton-loader__ossein,\n.v-skeleton-loader .v-skeleton-loader__text {\n  background: rgba(var(--v-theme-on-surface), var(--v-border-opacity));\n}\n.v-skeleton-loader .v-skeleton-loader__list-item,\n.v-skeleton-loader .v-skeleton-loader__list-item-avatar,\n.v-skeleton-loader .v-skeleton-loader__list-item-text,\n.v-skeleton-loader .v-skeleton-loader__list-item-two-line,\n.v-skeleton-loader .v-skeleton-loader__list-item-avatar-two-line,\n.v-skeleton-loader .v-skeleton-loader__list-item-three-line,\n.v-skeleton-loader .v-skeleton-loader__list-item-avatar-three-line {\n  border-radius: 4px;\n}\n.v-skeleton-loader__bone {\n  align-items: center;\n  border-radius: inherit;\n  display: flex;\n  flex: 1 1 100%;\n  flex-wrap: wrap;\n  overflow: hidden;\n  position: relative;\n}\n.v-skeleton-loader__bone::after {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  animation: loading 1.5s infinite;\n  background: linear-gradient(90deg, rgba(var(--v-theme-surface), 0), rgba(var(--v-theme-surface), 0.3), rgba(var(--v-theme-surface), 0));\n  transform: translateX(-100%);\n  z-index: 1;\n}\n.v-skeleton-loader__avatar {\n  border-radius: 50%;\n  flex: 0 1 auto;\n  margin: 8px 16px;\n  max-height: 48px;\n  min-height: 48px;\n  height: 48px;\n  max-width: 48px;\n  min-width: 48px;\n  width: 48px;\n}\n.v-skeleton-loader__avatar + .v-skeleton-loader__bone {\n  flex: 1 1 auto;\n  margin-inline-start: 0;\n}\n.v-skeleton-loader__avatar + .v-skeleton-loader__sentences > .v-skeleton-loader__text,\n.v-skeleton-loader__avatar + .v-skeleton-loader__paragraph > .v-skeleton-loader__text {\n  margin-inline-start: 0;\n}\n.v-skeleton-loader__button {\n  border-radius: 4px;\n  height: 36px;\n  margin: 16px;\n  max-width: 64px;\n}\n.v-skeleton-loader__button + .v-skeleton-loader__bone {\n  flex: 1 1 auto;\n  margin-inline-start: 0;\n}\n.v-skeleton-loader__button + .v-skeleton-loader__sentences > .v-skeleton-loader__text,\n.v-skeleton-loader__button + .v-skeleton-loader__paragraph > .v-skeleton-loader__text {\n  margin-inline-start: 0;\n}\n.v-skeleton-loader__chip {\n  border-radius: 16px;\n  margin: 16px;\n  height: 32px;\n  max-width: 96px;\n}\n.v-skeleton-loader__chip + .v-skeleton-loader__bone {\n  flex: 1 1 auto;\n  margin-inline-start: 0;\n}\n.v-skeleton-loader__chip + .v-skeleton-loader__sentences > .v-skeleton-loader__text,\n.v-skeleton-loader__chip + .v-skeleton-loader__paragraph > .v-skeleton-loader__text {\n  margin-inline-start: 0;\n}\n.v-skeleton-loader__date-picker {\n  border-radius: inherit;\n}\n.v-skeleton-loader__date-picker .v-skeleton-loader__list-item:first-child .v-skeleton-loader__text {\n  max-width: 88px;\n  width: 20%;\n}\n.v-skeleton-loader__date-picker .v-skeleton-loader__heading {\n  max-width: 256px;\n  width: 40%;\n}\n.v-skeleton-loader__date-picker-days {\n  flex-wrap: wrap;\n  margin: 16px;\n}\n.v-skeleton-loader__date-picker-days .v-skeleton-loader__avatar {\n  border-radius: 4px;\n  margin: 4px;\n  max-width: 100%;\n}\n.v-skeleton-loader__date-picker-options {\n  flex-wrap: nowrap;\n}\n.v-skeleton-loader__date-picker-options .v-skeleton-loader__text {\n  flex: 1 1 auto;\n}\n.v-skeleton-loader__divider {\n  border-radius: 1px;\n  height: 2px;\n}\n.v-skeleton-loader__heading {\n  border-radius: 12px;\n  margin: 16px;\n  height: 24px;\n}\n.v-skeleton-loader__heading + .v-skeleton-loader__subtitle {\n  margin-top: -16px;\n}\n.v-skeleton-loader__image {\n  height: 150px;\n  border-radius: 0;\n}\n.v-skeleton-loader__card .v-skeleton-loader__image {\n  border-radius: 0;\n}\n.v-skeleton-loader__list-item {\n  margin: 16px;\n}\n.v-skeleton-loader__list-item .v-skeleton-loader__text {\n  margin: 0;\n}\n.v-skeleton-loader__table-thead {\n  justify-content: space-between;\n}\n.v-skeleton-loader__table-thead .v-skeleton-loader__heading {\n  margin-top: 16px;\n  max-width: 16px;\n}\n.v-skeleton-loader__table-tfoot {\n  flex-wrap: nowrap;\n}\n.v-skeleton-loader__table-tfoot > .v-skeleton-loader__text.v-skeleton-loader__bone {\n  margin-top: 16px;\n}\n.v-skeleton-loader__table-row {\n  align-items: baseline;\n  margin: 0 8px;\n  justify-content: space-evenly;\n  flex-wrap: nowrap;\n}\n.v-skeleton-loader__table-row > .v-skeleton-loader__text.v-skeleton-loader__bone {\n  margin-inline: 8px;\n}\n.v-skeleton-loader__table-row + .v-skeleton-loader__divider {\n  margin: 0 16px;\n}\n.v-skeleton-loader__table-cell {\n  align-items: center;\n  display: flex;\n  height: 48px;\n  width: 88px;\n}\n.v-skeleton-loader__table-cell .v-skeleton-loader__text {\n  margin-bottom: 0;\n}\n.v-skeleton-loader__subtitle {\n  max-width: 70%;\n}\n.v-skeleton-loader__subtitle > .v-skeleton-loader__text {\n  height: 16px;\n  border-radius: 8px;\n}\n.v-skeleton-loader__text {\n  border-radius: 6px;\n  margin: 16px;\n  height: 12px;\n}\n.v-skeleton-loader__text + .v-skeleton-loader__text {\n  margin-top: -8px;\n  max-width: 50%;\n}\n.v-skeleton-loader__text + .v-skeleton-loader__text + .v-skeleton-loader__text {\n  max-width: 70%;\n}\n.v-skeleton-loader--boilerplate .v-skeleton-loader__bone:after {\n  display: none;\n}\n.v-skeleton-loader--is-loading {\n  overflow: hidden;\n}\n.v-skeleton-loader--tile {\n  border-radius: 0;\n}\n.v-skeleton-loader--tile .v-skeleton-loader__bone {\n  border-radius: 0;\n}\n@keyframes loading {\n  100% {\n    transform: translateX(100%);\n  }\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VSnackbar/VSnackbar.css */\n.v-snackbar {\n  justify-content: center;\n  z-index: 10000;\n  margin: 8px;\n  margin-inline-end: calc(8px + var(--v-scrollbar-offset));\n}\n.v-snackbar:not(.v-snackbar--centered):not(.v-snackbar--top) {\n  align-items: flex-end;\n}\n.v-snackbar__wrapper {\n  align-items: center;\n  display: flex;\n  max-width: 672px;\n  min-height: 48px;\n  min-width: 344px;\n  overflow: hidden;\n  padding: 0;\n  border-radius: 4px;\n}\n.v-snackbar--variant-plain,\n.v-snackbar--variant-outlined,\n.v-snackbar--variant-text,\n.v-snackbar--variant-tonal {\n  background: transparent;\n  color: inherit;\n}\n.v-snackbar--variant-plain {\n  opacity: 0.62;\n}\n.v-snackbar--variant-plain:focus,\n.v-snackbar--variant-plain:hover {\n  opacity: 1;\n}\n.v-snackbar--variant-plain .v-snackbar__overlay {\n  display: none;\n}\n.v-snackbar--variant-elevated,\n.v-snackbar--variant-flat {\n  background: rgb(var(--v-theme-surface-variant));\n  color: rgb(var(--v-theme-on-surface-variant));\n}\n.v-snackbar--variant-elevated {\n  box-shadow:\n    0px 3px 5px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 6px 10px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 18px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-snackbar--variant-flat {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-snackbar--variant-outlined {\n  border: thin solid currentColor;\n}\n.v-snackbar--variant-text .v-snackbar__overlay {\n  background: currentColor;\n}\n.v-snackbar--variant-tonal .v-snackbar__underlay {\n  background: currentColor;\n  opacity: var(--v-activated-opacity);\n  border-radius: inherit;\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  pointer-events: none;\n}\n.v-snackbar__content {\n  flex-grow: 1;\n  font-size: 0.875rem;\n  font-weight: 400;\n  letter-spacing: 0.0178571429em;\n  line-height: 1.25rem;\n  margin-right: auto;\n  padding: 14px 16px;\n  text-align: initial;\n}\n.v-snackbar__actions {\n  align-items: center;\n  align-self: center;\n  display: flex;\n  margin-inline-end: 8px;\n}\n.v-snackbar__actions > .v-btn {\n  padding: 0 8px;\n  min-width: auto;\n}\n.v-snackbar__timer {\n  width: 100%;\n  position: absolute;\n  top: 0;\n}\n.v-snackbar__timer .v-progress-linear {\n  transition: 0.2s linear;\n}\n.v-snackbar--absolute {\n  position: absolute;\n  z-index: 1;\n}\n.v-snackbar--multi-line .v-snackbar__wrapper {\n  min-height: 68px;\n}\n.v-snackbar--vertical .v-snackbar__wrapper {\n  flex-direction: column;\n}\n.v-snackbar--vertical .v-snackbar__wrapper .v-snackbar__actions {\n  align-self: flex-end;\n  margin-bottom: 8px;\n}\n.v-snackbar-transition-enter-active,\n.v-snackbar-transition-leave-active {\n  transition-duration: 0.15s;\n  transition-timing-function: cubic-bezier(0, 0, 0.2, 1);\n}\n.v-snackbar-transition-enter-active {\n  transition-property: opacity, transform;\n}\n.v-snackbar-transition-enter-from {\n  opacity: 0;\n  transform: scale(0.8);\n}\n.v-snackbar-transition-leave-active {\n  transition-property: opacity;\n}\n.v-snackbar-transition-leave-to {\n  opacity: 0;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VStepper/VStepper.css */\n.v-stepper.v-sheet {\n  box-shadow:\n    0px 3px 1px -2px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 2px 2px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 5px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n  border-radius: 4px;\n  overflow: hidden;\n}\n.v-stepper.v-sheet.v-stepper--flat {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-stepper-header {\n  box-shadow:\n    0px 3px 1px -2px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 2px 2px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 5px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n  align-items: center;\n  display: flex;\n  position: relative;\n  overflow-x: auto;\n  justify-content: space-between;\n  z-index: 1;\n}\n.v-stepper-header .v-divider {\n  margin: 0 -16px;\n}\n.v-stepper-header .v-divider:last-child {\n  margin-inline-end: 0;\n}\n.v-stepper-header .v-divider:first-child {\n  margin-inline-start: 0;\n}\n.v-stepper--alt-labels .v-stepper-header {\n  height: auto;\n}\n.v-stepper--alt-labels .v-stepper-header .v-divider {\n  align-self: flex-start;\n  margin: 35px -67px 0;\n}\n.v-stepper-window {\n  margin: 1.5rem;\n}\n.v-stepper-actions {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  padding: 1rem;\n}\n.v-stepper .v-stepper-actions {\n  padding: 0 1.5rem 1rem;\n}\n.v-stepper-window-item .v-stepper-actions {\n  padding: 1.5rem 0 0;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VStepper/VStepperItem.css */\n.v-stepper-item {\n  align-items: center;\n  align-self: stretch;\n  display: inline-flex;\n  flex: none;\n  opacity: var(--v-medium-emphasis-opacity);\n  padding: 1.5rem;\n  transition-duration: 0.2s;\n  transition-property: opacity;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-stepper-item--selected {\n  opacity: 1;\n}\n.v-stepper-item--error {\n  color: rgb(var(--v-theme-error));\n}\n.v-stepper-item--disabled {\n  opacity: var(--v-medium-emphasis-opacity);\n  pointer-events: none;\n}\n.v-stepper--alt-labels .v-stepper-item {\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: center;\n  flex-basis: 175px;\n}\n.v-stepper-item__avatar.v-avatar {\n  background: rgba(var(--v-theme-surface-variant), var(--v-medium-emphasis-opacity));\n  color: rgb(var(--v-theme-on-surface-variant));\n  font-size: 0.75rem;\n  margin-inline-end: 8px;\n}\n.v-stepper-item__avatar.v-avatar .v-icon {\n  font-size: 0.875rem;\n}\n.v-stepper-item--selected .v-stepper-item__avatar.v-avatar,\n.v-stepper-item--complete .v-stepper-item__avatar.v-avatar {\n  background: rgb(var(--v-theme-surface-variant));\n}\n.v-stepper-item--error .v-stepper-item__avatar.v-avatar {\n  background: rgb(var(--v-theme-error));\n}\n.v-stepper--alt-labels .v-stepper-item__avatar.v-avatar {\n  margin-bottom: 16px;\n  margin-inline-end: 0;\n}\n.v-stepper-item__title {\n  line-height: 1;\n}\n.v-stepper--mobile .v-stepper-item__title {\n  display: none;\n}\n.v-stepper-item__subtitle {\n  font-size: 0.75rem;\n  text-align: left;\n  line-height: 1;\n  opacity: var(--v-medium-emphasis-opacity);\n}\n.v-stepper--alt-labels .v-stepper-item__subtitle {\n  text-align: center;\n}\n.v-stepper--mobile .v-stepper-item__subtitle {\n  display: none;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VSwitch/VSwitch.css */\n.v-switch .v-label {\n  padding-inline-start: 10px;\n}\n.v-switch__loader {\n  display: flex;\n}\n.v-switch__loader .v-progress-circular {\n  color: rgb(var(--v-theme-surface));\n}\n.v-switch__track,\n.v-switch__thumb {\n  transition: none;\n}\n.v-selection-control--error:not(.v-selection-control--disabled) .v-switch__track,\n.v-selection-control--error:not(.v-selection-control--disabled) .v-switch__thumb {\n  background-color: rgb(var(--v-theme-error));\n  color: rgb(var(--v-theme-on-error));\n}\n.v-switch__track-true {\n  margin-inline-end: auto;\n}\n.v-selection-control:not(.v-selection-control--dirty) .v-switch__track-true {\n  opacity: 0;\n}\n.v-switch__track-false {\n  margin-inline-start: auto;\n}\n.v-selection-control--dirty .v-switch__track-false {\n  opacity: 0;\n}\n.v-switch__track {\n  display: inline-flex;\n  align-items: center;\n  font-size: 0.5rem;\n  padding: 0 5px;\n  background-color: rgb(var(--v-theme-surface-variant));\n  border-radius: 9999px;\n  height: 14px;\n  opacity: 0.6;\n  min-width: 36px;\n  cursor: pointer;\n  transition: 0.2s background-color cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-switch--inset .v-switch__track {\n  border-radius: 9999px;\n  font-size: 0.75rem;\n  height: 32px;\n  min-width: 52px;\n}\n.v-switch__thumb {\n  align-items: center;\n  background-color: rgb(var(--v-theme-surface-bright));\n  color: rgb(var(--v-theme-on-surface-bright));\n  border-radius: 50%;\n  display: flex;\n  font-size: 0.75rem;\n  height: 20px;\n  justify-content: center;\n  width: 20px;\n  pointer-events: none;\n  transition:\n    0.15s 0.05s transform cubic-bezier(0, 0, 0.2, 1),\n    0.2s color cubic-bezier(0.4, 0, 0.2, 1),\n    0.2s background-color cubic-bezier(0.4, 0, 0.2, 1);\n  position: relative;\n  overflow: hidden;\n}\n.v-switch:not(.v-switch--inset) .v-switch__thumb {\n  box-shadow:\n    0px 2px 4px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 4px 5px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 10px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-switch.v-switch--flat:not(.v-switch--inset) .v-switch__thumb {\n  background: rgb(var(--v-theme-surface-variant));\n  color: rgb(var(--v-theme-on-surface-variant));\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-switch--inset .v-switch__thumb {\n  height: 24px;\n  width: 24px;\n  transform: scale(0.6666666667);\n}\n.v-switch--inset .v-switch__thumb--filled {\n  transform: none;\n}\n.v-switch--inset .v-selection-control--dirty .v-switch__thumb {\n  transform: none;\n  transition: 0.15s 0.05s transform cubic-bezier(0, 0, 0.2, 1);\n}\n.v-switch.v-input {\n  flex: 0 1 auto;\n}\n.v-switch .v-selection-control {\n  min-height: var(--v-input-control-height);\n}\n.v-switch .v-selection-control__input {\n  border-radius: 50%;\n  transition: 0.2s transform cubic-bezier(0.4, 0, 0.2, 1);\n  transform: translateX(-10px);\n  position: absolute;\n}\n.v-switch .v-selection-control__input .v-icon {\n  position: absolute;\n}\n.v-switch .v-selection-control--dirty .v-selection-control__input {\n  transform: translateX(10px);\n}\n.v-switch.v-switch--indeterminate .v-selection-control__input {\n  transform: scale(0.8);\n}\n.v-switch.v-switch--indeterminate .v-switch__thumb {\n  transform: scale(0.75);\n  box-shadow: none;\n}\n.v-switch.v-switch--inset .v-selection-control__wrapper {\n  width: auto;\n}\n.v-switch.v-input--vertical .v-label {\n  min-width: max-content;\n}\n.v-switch.v-input--vertical .v-selection-control__wrapper {\n  transform: rotate(-90deg);\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VSystemBar/VSystemBar.css */\n.v-system-bar {\n  align-items: center;\n  display: flex;\n  flex: 1 1 auto;\n  height: 24px;\n  justify-content: flex-end;\n  max-width: 100%;\n  padding-inline: 8px;\n  position: relative;\n  text-align: end;\n  width: 100%;\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n  background: rgba(var(--v-theme-surface-light));\n  color: rgba(var(--v-theme-on-surface-light), var(--v-high-emphasis-opacity));\n  font-size: 0.75rem;\n  font-weight: 400;\n  letter-spacing: 0.0333333333em;\n  line-height: 1.25rem;\n  text-transform: none;\n}\n.v-system-bar .v-icon {\n  opacity: var(--v-medium-emphasis-opacity);\n}\n.v-system-bar--absolute {\n  position: absolute;\n}\n.v-system-bar--fixed {\n  position: fixed;\n}\n.v-system-bar--rounded {\n  border-radius: 0;\n}\n.v-system-bar--window {\n  height: 32px;\n}\n.v-system-bar:not(.v-system-bar--absolute) {\n  padding-inline-end: calc(var(--v-scrollbar-offset) + 8px);\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VTabs/VTabs.css */\n.v-tabs {\n  display: flex;\n  height: var(--v-tabs-height);\n}\n.v-tabs--density-default {\n  --v-tabs-height: 48px;\n}\n.v-tabs--density-default.v-tabs--stacked {\n  --v-tabs-height: 72px;\n}\n.v-tabs--density-comfortable {\n  --v-tabs-height: 44px;\n}\n.v-tabs--density-comfortable.v-tabs--stacked {\n  --v-tabs-height: 68px;\n}\n.v-tabs--density-compact {\n  --v-tabs-height: 36px;\n}\n.v-tabs--density-compact.v-tabs--stacked {\n  --v-tabs-height: 60px;\n}\n.v-tabs.v-slide-group--vertical {\n  height: auto;\n  flex: none;\n  --v-tabs-height: 48px;\n}\n.v-tabs--align-tabs-title:not(.v-slide-group--has-affixes) .v-tab:first-child {\n  margin-inline-start: 42px;\n}\n.v-tabs--fixed-tabs .v-slide-group__content > *:last-child,\n.v-tabs--align-tabs-center .v-slide-group__content > *:last-child {\n  margin-inline-end: auto;\n}\n.v-tabs--fixed-tabs .v-slide-group__content > *:first-child,\n.v-tabs--align-tabs-center .v-slide-group__content > *:first-child {\n  margin-inline-start: auto;\n}\n.v-tabs--grow {\n  flex-grow: 1;\n}\n.v-tabs--grow .v-tab {\n  flex: 1 0 auto;\n  max-width: none;\n}\n.v-tabs--align-tabs-end .v-tab:first-child {\n  margin-inline-start: auto;\n}\n.v-tabs--align-tabs-end .v-tab:last-child {\n  margin-inline-end: 0;\n}\n@media (max-width: 1279.98px) {\n  .v-tabs.v-slide-group--is-overflowing.v-slide-group--horizontal:not(.v-slide-group--has-affixes) .v-tab:first-child {\n    margin-inline-start: 52px;\n  }\n  .v-tabs.v-slide-group--is-overflowing.v-slide-group--horizontal:not(.v-slide-group--has-affixes) .v-tab:last-child {\n    margin-inline-end: 52px;\n  }\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VTabs/VTab.css */\n.v-tab.v-tab.v-btn {\n  height: var(--v-tabs-height);\n  border-radius: 0;\n  min-width: 90px;\n}\n.v-slide-group--horizontal .v-tab {\n  max-width: 360px;\n}\n.v-slide-group--vertical .v-tab {\n  justify-content: start;\n}\n.v-tab__slider {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  height: 2px;\n  width: 100%;\n  background: currentColor;\n  pointer-events: none;\n  opacity: 0;\n}\n.v-tab--selected .v-tab__slider {\n  opacity: 1;\n}\n.v-slide-group--vertical .v-tab__slider {\n  top: 0;\n  height: 100%;\n  width: 2px;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VTextarea/VTextarea.css */\n.v-textarea .v-field {\n  --v-textarea-control-height: var(--v-input-control-height);\n}\n.v-textarea .v-field__field {\n  --v-input-control-height: var(--v-textarea-control-height);\n}\n.v-textarea .v-field__input {\n  flex: 1 1 auto;\n  outline: none;\n  -webkit-mask-image: linear-gradient(to bottom, transparent, transparent calc(var(--v-field-padding-top, 0) + var(--v-input-padding-top, 0) - 6px), black calc(var(--v-field-padding-top, 0) + var(--v-input-padding-top, 0) + 4px));\n  mask-image: linear-gradient(to bottom, transparent, transparent calc(var(--v-field-padding-top, 0) + var(--v-input-padding-top, 0) - 6px), black calc(var(--v-field-padding-top, 0) + var(--v-input-padding-top, 0) + 4px));\n}\n.v-textarea .v-field__input.v-textarea__sizer {\n  visibility: hidden;\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 0 !important;\n  min-height: 0 !important;\n  pointer-events: none;\n}\n.v-textarea--no-resize .v-field__input {\n  resize: none;\n}\n.v-textarea .v-field--no-label textarea,\n.v-textarea .v-field--active textarea {\n  opacity: 1;\n}\n.v-textarea textarea {\n  opacity: 0;\n  flex: 1;\n  min-width: 0;\n  transition: 0.15s opacity cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-textarea textarea:focus,\n.v-textarea textarea:active {\n  outline: none;\n}\n.v-textarea textarea:invalid {\n  box-shadow: none;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VThemeProvider/VThemeProvider.css */\n.v-theme-provider {\n  background: rgb(var(--v-theme-background));\n  color: rgb(var(--v-theme-on-background));\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VTimeline/VTimeline.css */\n.v-timeline .v-timeline-divider__dot {\n  background: rgb(var(--v-theme-surface-light));\n}\n.v-timeline .v-timeline-divider__inner-dot {\n  background: rgb(var(--v-theme-on-surface));\n}\n.v-timeline {\n  display: grid;\n  grid-auto-flow: dense;\n  position: relative;\n}\n.v-timeline--horizontal.v-timeline {\n  grid-column-gap: 24px;\n  width: 100%;\n}\n.v-timeline--horizontal.v-timeline .v-timeline-item:nth-child(2n) .v-timeline-item__body {\n  grid-row: 3;\n  padding-block-start: 24px;\n}\n.v-timeline--horizontal.v-timeline .v-timeline-item:nth-child(2n) .v-timeline-item__opposite {\n  grid-row: 1;\n  padding-block-end: 24px;\n  align-self: flex-end;\n}\n.v-timeline--horizontal.v-timeline .v-timeline-item:nth-child(2n+1) .v-timeline-item__body {\n  grid-row: 1;\n  padding-block-end: 24px;\n  align-self: flex-end;\n}\n.v-timeline--horizontal.v-timeline .v-timeline-item:nth-child(2n+1) .v-timeline-item__opposite {\n  grid-row: 3;\n  padding-block-start: 24px;\n}\n.v-timeline--vertical.v-timeline {\n  row-gap: 24px;\n  height: 100%;\n}\n.v-timeline--vertical.v-timeline .v-timeline-item:first-child .v-timeline-divider,\n.v-timeline--vertical.v-timeline .v-timeline-item:first-child .v-timeline-item__body,\n.v-timeline--vertical.v-timeline .v-timeline-item:first-child .v-timeline-item__opposite {\n  padding-block-start: 24px;\n}\n.v-timeline--vertical.v-timeline .v-timeline-item:last-child .v-timeline-divider,\n.v-timeline--vertical.v-timeline .v-timeline-item:last-child .v-timeline-item__body,\n.v-timeline--vertical.v-timeline .v-timeline-item:last-child .v-timeline-item__opposite {\n  padding-block-end: 24px;\n}\n.v-timeline--vertical.v-timeline .v-timeline-item:nth-child(2n) .v-timeline-item__body {\n  grid-column: 1;\n  padding-inline-end: 24px;\n}\n.v-timeline--vertical.v-timeline .v-timeline-item:nth-child(2n) .v-timeline-item__opposite {\n  grid-column: 3;\n  padding-inline-start: 24px;\n}\n.v-timeline--vertical.v-timeline .v-timeline-item:nth-child(2n+1) .v-timeline-item__body {\n  grid-column: 3;\n  padding-inline-start: 24px;\n}\n.v-timeline--vertical.v-timeline .v-timeline-item:nth-child(2n+1) .v-timeline-item__opposite {\n  grid-column: 1;\n  justify-self: flex-end;\n  padding-inline-end: 24px;\n}\n.v-timeline-item {\n  display: contents;\n}\n.v-timeline-divider {\n  position: relative;\n  display: flex;\n  align-items: center;\n}\n.v-timeline--horizontal .v-timeline-divider {\n  flex-direction: row;\n  grid-row: 2;\n  width: 100%;\n}\n.v-timeline--vertical .v-timeline-divider {\n  height: 100%;\n  flex-direction: column;\n  grid-column: 2;\n}\n.v-timeline-divider__before {\n  background: rgba(var(--v-border-color), var(--v-border-opacity));\n  position: absolute;\n}\n.v-timeline--horizontal .v-timeline-divider__before {\n  height: var(--v-timeline-line-thickness);\n  width: calc(var(--v-timeline-line-size-base) + 12px - var(--v-timeline-line-inset));\n  inset-inline-start: -12px;\n  inset-inline-end: initial;\n}\n.v-timeline--vertical .v-timeline-divider__before {\n  height: calc(var(--v-timeline-line-size-base) + 12px - var(--v-timeline-line-inset));\n  width: var(--v-timeline-line-thickness);\n  top: -12px;\n}\n.v-timeline-divider__after {\n  background: rgba(var(--v-border-color), var(--v-border-opacity));\n  position: absolute;\n}\n.v-timeline--horizontal .v-timeline-divider__after {\n  height: var(--v-timeline-line-thickness);\n  width: calc(var(--v-timeline-line-size-base) + 12px - var(--v-timeline-line-inset));\n  inset-inline-end: -12px;\n  inset-inline-start: initial;\n}\n.v-timeline--vertical .v-timeline-divider__after {\n  height: calc(var(--v-timeline-line-size-base) + 12px - var(--v-timeline-line-inset));\n  width: var(--v-timeline-line-thickness);\n  bottom: -12px;\n}\n.v-timeline--vertical .v-timeline-item:first-child .v-timeline-divider__before {\n  height: calc(var(--v-timeline-line-size-base) + 12px - var(--v-timeline-line-inset));\n  top: 0;\n}\n.v-timeline--horizontal .v-timeline-item:first-child .v-timeline-divider__before {\n  width: calc(var(--v-timeline-line-size-base) + 12px - var(--v-timeline-line-inset));\n  inset-inline-start: 0;\n  inset-inline-end: initial;\n}\n.v-timeline--vertical .v-timeline-item:first-child .v-timeline-divider__after {\n  height: calc(var(--v-timeline-line-size-base) - var(--v-timeline-line-inset) + var(--v-timeline-line-size-offset));\n}\n.v-timeline--horizontal .v-timeline-item:first-child .v-timeline-divider__after {\n  width: calc(var(--v-timeline-line-size-base) - var(--v-timeline-line-inset) + var(--v-timeline-line-size-offset));\n  inset-inline-end: -12px;\n  inset-inline-start: initial;\n}\n.v-timeline--vertical .v-timeline-item:last-child .v-timeline-divider__before {\n  height: calc(var(--v-timeline-line-size-base) - var(--v-timeline-line-inset) + var(--v-timeline-line-size-offset));\n}\n.v-timeline--horizontal .v-timeline-item:last-child .v-timeline-divider__before {\n  width: calc(var(--v-timeline-line-size-base) - var(--v-timeline-line-inset) + var(--v-timeline-line-size-offset));\n}\n.v-timeline--vertical .v-timeline-item:last-child .v-timeline-divider__after {\n  height: calc(var(--v-timeline-line-size-base) + 12px - var(--v-timeline-line-inset));\n  bottom: 0;\n}\n.v-timeline--horizontal .v-timeline-item:last-child .v-timeline-divider__after {\n  width: calc(var(--v-timeline-line-size-base) + 12px - var(--v-timeline-line-inset));\n  inset-inline-end: 0;\n  inset-inline-start: initial;\n}\n.v-timeline--vertical .v-timeline-item:only-child .v-timeline-divider__after {\n  height: calc(var(--v-timeline-line-size-base) - var(--v-timeline-line-inset));\n}\n.v-timeline-divider__dot {\n  z-index: 1;\n  flex-shrink: 0;\n  border-radius: 50%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-timeline-divider__dot--size-x-small {\n  height: 22px;\n  width: 22px;\n}\n.v-timeline-divider__dot--size-x-small .v-timeline-divider__inner-dot {\n  height: calc(100% - 6px);\n  width: calc(100% - 6px);\n}\n.v-timeline-divider__dot--size-small {\n  height: 30px;\n  width: 30px;\n}\n.v-timeline-divider__dot--size-small .v-timeline-divider__inner-dot {\n  height: calc(100% - 8px);\n  width: calc(100% - 8px);\n}\n.v-timeline-divider__dot--size-default {\n  height: 38px;\n  width: 38px;\n}\n.v-timeline-divider__dot--size-default .v-timeline-divider__inner-dot {\n  height: calc(100% - 8px);\n  width: calc(100% - 8px);\n}\n.v-timeline-divider__dot--size-large {\n  height: 46px;\n  width: 46px;\n}\n.v-timeline-divider__dot--size-large .v-timeline-divider__inner-dot {\n  height: calc(100% - 8px);\n  width: calc(100% - 8px);\n}\n.v-timeline-divider__dot--size-x-large {\n  height: 54px;\n  width: 54px;\n}\n.v-timeline-divider__dot--size-x-large .v-timeline-divider__inner-dot {\n  height: calc(100% - 10px);\n  width: calc(100% - 10px);\n}\n.v-timeline-divider__inner-dot {\n  align-items: center;\n  border-radius: 50%;\n  display: flex;\n  justify-content: center;\n}\n.v-timeline--horizontal.v-timeline--justify-center {\n  grid-template-rows: minmax(auto, 50%) min-content minmax(auto, 50%);\n}\n.v-timeline--vertical.v-timeline--justify-center {\n  grid-template-columns: minmax(auto, 50%) min-content minmax(auto, 50%);\n}\n.v-timeline--horizontal.v-timeline--justify-auto {\n  grid-template-rows: auto min-content auto;\n}\n.v-timeline--vertical.v-timeline--justify-auto {\n  grid-template-columns: auto min-content auto;\n}\n.v-timeline--horizontal.v-timeline--density-comfortable {\n  height: 100%;\n}\n.v-timeline--horizontal.v-timeline--density-comfortable.v-timeline--side-end {\n  grid-template-rows: min-content min-content auto;\n}\n.v-timeline--horizontal.v-timeline--density-comfortable.v-timeline--side-start {\n  grid-template-rows: auto min-content min-content;\n}\n.v-timeline--vertical.v-timeline--density-comfortable {\n  width: 100%;\n}\n.v-timeline--vertical.v-timeline--density-comfortable.v-timeline--side-end {\n  grid-template-columns: min-content min-content auto;\n}\n.v-timeline--vertical.v-timeline--density-comfortable.v-timeline--side-start {\n  grid-template-columns: auto min-content min-content;\n}\n.v-timeline--horizontal.v-timeline--density-compact.v-timeline--side-end {\n  grid-template-rows: 0 min-content auto;\n}\n.v-timeline--horizontal.v-timeline--density-compact.v-timeline--side-start {\n  grid-template-rows: auto min-content 0;\n}\n.v-timeline--horizontal.v-timeline--density-compact .v-timeline-item__body {\n  grid-row: 1;\n}\n.v-timeline--vertical.v-timeline--density-compact.v-timeline--side-end {\n  grid-template-columns: 0 min-content auto;\n}\n.v-timeline--vertical.v-timeline--density-compact.v-timeline--side-start {\n  grid-template-columns: auto min-content 0;\n}\n.v-timeline--vertical.v-timeline--density-compact .v-timeline-item__body {\n  grid-column: 3;\n}\n.v-timeline--horizontal.v-timeline.v-timeline--side-end .v-timeline-item .v-timeline-item__body {\n  grid-row: 3;\n  padding-block-end: initial;\n  padding-block-start: 24px;\n}\n.v-timeline--horizontal.v-timeline.v-timeline--side-end .v-timeline-item .v-timeline-item__opposite {\n  grid-row: 1;\n  padding-block-end: 24px;\n  padding-block-start: initial;\n}\n.v-timeline--vertical.v-timeline.v-timeline--side-end .v-timeline-item .v-timeline-item__body {\n  grid-column: 3;\n  padding-inline-start: 24px;\n  padding-inline-end: initial;\n  justify-self: flex-start;\n}\n.v-timeline--vertical.v-timeline.v-timeline--side-end .v-timeline-item .v-timeline-item__opposite {\n  grid-column: 1;\n  justify-self: flex-end;\n  padding-inline-end: 24px;\n  padding-inline-start: initial;\n}\n.v-timeline--horizontal.v-timeline.v-timeline--side-start .v-timeline-item .v-timeline-item__body {\n  grid-row: 1;\n  padding-block-end: 24px;\n  padding-block-start: initial;\n}\n.v-timeline--horizontal.v-timeline.v-timeline--side-start .v-timeline-item .v-timeline-item__opposite {\n  grid-row: 3;\n  padding-block-end: initial;\n  padding-block-start: 24px;\n}\n.v-timeline--vertical.v-timeline.v-timeline--side-start .v-timeline-item .v-timeline-item__body {\n  grid-column: 1;\n  justify-self: flex-end;\n  padding-inline-end: 24px;\n}\n.v-timeline--vertical.v-timeline.v-timeline--side-start .v-timeline-item .v-timeline-item__opposite {\n  grid-column: 3;\n  padding-inline-start: 24px;\n  justify-self: flex-start;\n}\n.v-timeline-divider--fill-dot .v-timeline-divider__inner-dot {\n  height: inherit;\n  width: inherit;\n}\n.v-timeline--align-center {\n  --v-timeline-line-size-base: 50%;\n  --v-timeline-line-size-offset: 0px;\n}\n.v-timeline--horizontal.v-timeline--align-center {\n  justify-items: center;\n}\n.v-timeline--horizontal.v-timeline--align-center .v-timeline-item__body {\n  padding-inline: 12px;\n}\n.v-timeline--horizontal.v-timeline--align-center .v-timeline-item__opposite {\n  padding-inline: 12px;\n}\n.v-timeline--horizontal.v-timeline--align-center .v-timeline-divider {\n  justify-content: center;\n}\n.v-timeline--vertical.v-timeline--align-center {\n  align-items: center;\n}\n.v-timeline--vertical.v-timeline--align-center .v-timeline-divider {\n  justify-content: center;\n}\n.v-timeline--align-start {\n  --v-timeline-line-size-base: 100%;\n  --v-timeline-line-size-offset: 12px;\n}\n.v-timeline--align-start .v-timeline-item:first-child .v-timeline-divider__before {\n  --v-timeline-line-size-offset: 24px;\n}\n.v-timeline--align-start .v-timeline-item:first-child .v-timeline-divider__after {\n  --v-timeline-line-size-offset: -12px;\n}\n.v-timeline--align-start .v-timeline-item:last-child .v-timeline-divider__after {\n  --v-timeline-line-size-offset: 0px;\n}\n.v-timeline--horizontal.v-timeline--align-start {\n  justify-items: flex-start;\n}\n.v-timeline--horizontal.v-timeline--align-start .v-timeline-divider {\n  justify-content: flex-start;\n}\n.v-timeline--horizontal.v-timeline--align-start .v-timeline-divider .v-timeline-divider__before {\n  width: calc(var(--v-timeline-line-size-offset) + var(--v-timeline-dot-size) / 2 - var(--v-timeline-line-inset));\n}\n.v-timeline--horizontal.v-timeline--align-start .v-timeline-divider .v-timeline-divider__after {\n  width: calc(var(--v-timeline-line-size-base) - var(--v-timeline-dot-size) / 2 + var(--v-timeline-line-size-offset) - var(--v-timeline-line-inset));\n}\n.v-timeline--vertical.v-timeline--align-start {\n  align-items: flex-start;\n}\n.v-timeline--vertical.v-timeline--align-start .v-timeline-divider {\n  justify-content: flex-start;\n}\n.v-timeline--vertical.v-timeline--align-start .v-timeline-divider .v-timeline-divider__before {\n  height: calc(var(--v-timeline-line-size-offset) + var(--v-timeline-dot-size) / 2 - var(--v-timeline-line-inset));\n}\n.v-timeline--vertical.v-timeline--align-start .v-timeline-divider .v-timeline-divider__after {\n  height: calc(var(--v-timeline-line-size-base) - var(--v-timeline-dot-size) / 2 + var(--v-timeline-line-size-offset) - var(--v-timeline-line-inset));\n}\n.v-timeline--truncate-line-start .v-timeline-item:first-child .v-timeline-divider__before {\n  display: none;\n}\n.v-timeline--truncate-line-start .v-timeline-item:first-child .v-timeline-divider__after {\n  --v-timeline-line-size-offset: 12px;\n}\n.v-timeline--vertical.v-timeline--truncate-line-start .v-timeline-item:first-child .v-timeline-divider,\n.v-timeline--vertical.v-timeline--truncate-line-start .v-timeline-item:first-child .v-timeline-item__body,\n.v-timeline--vertical.v-timeline--truncate-line-start .v-timeline-item:first-child .v-timeline-item__opposite {\n  padding-block-start: 0;\n}\n.v-timeline--horizontal.v-timeline--truncate-line-start .v-timeline-item:first-child .v-timeline-divider,\n.v-timeline--horizontal.v-timeline--truncate-line-start .v-timeline-item:first-child .v-timeline-item__body,\n.v-timeline--horizontal.v-timeline--truncate-line-start .v-timeline-item:first-child .v-timeline-item__opposite {\n  padding-inline-start: 0;\n}\n.v-timeline--truncate-line-end .v-timeline-item:last-child .v-timeline-divider__after {\n  display: none;\n}\n.v-timeline--truncate-line-end .v-timeline-item:last-child .v-timeline-divider__before {\n  --v-timeline-line-size-offset: 12px;\n}\n.v-timeline--vertical.v-timeline--truncate-line-end .v-timeline-item:last-child .v-timeline-divider,\n.v-timeline--vertical.v-timeline--truncate-line-end .v-timeline-item:last-child .v-timeline-item__body,\n.v-timeline--vertical.v-timeline--truncate-line-end .v-timeline-item:last-child .v-timeline-item__opposite {\n  padding-block-end: 0;\n}\n.v-timeline--horizontal.v-timeline--truncate-line-end .v-timeline-item:last-child .v-timeline-divider,\n.v-timeline--horizontal.v-timeline--truncate-line-end .v-timeline-item:last-child .v-timeline-item__body,\n.v-timeline--horizontal.v-timeline--truncate-line-end .v-timeline-item:last-child .v-timeline-item__opposite {\n  padding-inline-end: 0;\n}\n\n/* ../library_management/node_modules/vuetify/lib/components/VTooltip/VTooltip.css */\n.v-tooltip > .v-overlay__content {\n  background: rgb(var(--v-theme-surface-variant));\n  color: rgb(var(--v-theme-on-surface-variant));\n  border-radius: 4px;\n  font-size: 0.875rem;\n  line-height: 1.6;\n  display: inline-block;\n  padding: 5px 16px;\n  text-transform: initial;\n  width: auto;\n  opacity: 1;\n  pointer-events: none;\n  transition-property: opacity, transform;\n  overflow-wrap: break-word;\n}\n.v-tooltip > .v-overlay__content[class*=enter-active] {\n  transition-timing-function: cubic-bezier(0, 0, 0.2, 1);\n  transition-duration: 150ms;\n}\n.v-tooltip > .v-overlay__content[class*=leave-active] {\n  transition-timing-function: cubic-bezier(0.4, 0, 1, 1);\n  transition-duration: 75ms;\n}\n/*# sourceMappingURL=books.bundle.7RL6TWWN.css.map */\n");
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // ../library_management/node_modules/type/value/is.js
  var require_is = __commonJS({
    "../library_management/node_modules/type/value/is.js"(exports, module) {
      "use strict";
      var _undefined = void 0;
      module.exports = function(value) {
        return value !== _undefined && value !== null;
      };
    }
  });

  // ../library_management/node_modules/type/object/is.js
  var require_is2 = __commonJS({
    "../library_management/node_modules/type/object/is.js"(exports, module) {
      "use strict";
      var isValue = require_is();
      var possibleTypes = { "object": true, "function": true, "undefined": true };
      module.exports = function(value) {
        if (!isValue(value))
          return false;
        return hasOwnProperty.call(possibleTypes, typeof value);
      };
    }
  });

  // ../library_management/node_modules/type/prototype/is.js
  var require_is3 = __commonJS({
    "../library_management/node_modules/type/prototype/is.js"(exports, module) {
      "use strict";
      var isObject3 = require_is2();
      module.exports = function(value) {
        if (!isObject3(value))
          return false;
        try {
          if (!value.constructor)
            return false;
          return value.constructor.prototype === value;
        } catch (error) {
          return false;
        }
      };
    }
  });

  // ../library_management/node_modules/type/function/is.js
  var require_is4 = __commonJS({
    "../library_management/node_modules/type/function/is.js"(exports, module) {
      "use strict";
      var isPrototype = require_is3();
      module.exports = function(value) {
        if (typeof value !== "function")
          return false;
        if (!hasOwnProperty.call(value, "length"))
          return false;
        try {
          if (typeof value.length !== "number")
            return false;
          if (typeof value.call !== "function")
            return false;
          if (typeof value.apply !== "function")
            return false;
        } catch (error) {
          return false;
        }
        return !isPrototype(value);
      };
    }
  });

  // ../library_management/node_modules/type/plain-function/is.js
  var require_is5 = __commonJS({
    "../library_management/node_modules/type/plain-function/is.js"(exports, module) {
      "use strict";
      var isFunction2 = require_is4();
      var classRe = /^\s*class[\s{/}]/;
      var functionToString = Function.prototype.toString;
      module.exports = function(value) {
        if (!isFunction2(value))
          return false;
        if (classRe.test(functionToString.call(value)))
          return false;
        return true;
      };
    }
  });

  // ../library_management/node_modules/es5-ext/object/assign/is-implemented.js
  var require_is_implemented = __commonJS({
    "../library_management/node_modules/es5-ext/object/assign/is-implemented.js"(exports, module) {
      "use strict";
      module.exports = function() {
        var assign2 = Object.assign, obj;
        if (typeof assign2 !== "function")
          return false;
        obj = { foo: "raz" };
        assign2(obj, { bar: "dwa" }, { trzy: "trzy" });
        return obj.foo + obj.bar + obj.trzy === "razdwatrzy";
      };
    }
  });

  // ../library_management/node_modules/es5-ext/object/keys/is-implemented.js
  var require_is_implemented2 = __commonJS({
    "../library_management/node_modules/es5-ext/object/keys/is-implemented.js"(exports, module) {
      "use strict";
      module.exports = function() {
        try {
          Object.keys("primitive");
          return true;
        } catch (e) {
          return false;
        }
      };
    }
  });

  // ../library_management/node_modules/es5-ext/function/noop.js
  var require_noop = __commonJS({
    "../library_management/node_modules/es5-ext/function/noop.js"(exports, module) {
      "use strict";
      module.exports = function() {
      };
    }
  });

  // ../library_management/node_modules/es5-ext/object/is-value.js
  var require_is_value = __commonJS({
    "../library_management/node_modules/es5-ext/object/is-value.js"(exports, module) {
      "use strict";
      var _undefined = require_noop()();
      module.exports = function(val) {
        return val !== _undefined && val !== null;
      };
    }
  });

  // ../library_management/node_modules/es5-ext/object/keys/shim.js
  var require_shim = __commonJS({
    "../library_management/node_modules/es5-ext/object/keys/shim.js"(exports, module) {
      "use strict";
      var isValue = require_is_value();
      var keys2 = Object.keys;
      module.exports = function(object) {
        return keys2(isValue(object) ? Object(object) : object);
      };
    }
  });

  // ../library_management/node_modules/es5-ext/object/keys/index.js
  var require_keys = __commonJS({
    "../library_management/node_modules/es5-ext/object/keys/index.js"(exports, module) {
      "use strict";
      module.exports = require_is_implemented2()() ? Object.keys : require_shim();
    }
  });

  // ../library_management/node_modules/es5-ext/object/valid-value.js
  var require_valid_value = __commonJS({
    "../library_management/node_modules/es5-ext/object/valid-value.js"(exports, module) {
      "use strict";
      var isValue = require_is_value();
      module.exports = function(value) {
        if (!isValue(value))
          throw new TypeError("Cannot use null or undefined");
        return value;
      };
    }
  });

  // ../library_management/node_modules/es5-ext/object/assign/shim.js
  var require_shim2 = __commonJS({
    "../library_management/node_modules/es5-ext/object/assign/shim.js"(exports, module) {
      "use strict";
      var keys2 = require_keys();
      var value = require_valid_value();
      var max = Math.max;
      module.exports = function(dest, src) {
        var error, i, length = max(arguments.length, 2), assign2;
        dest = Object(value(dest));
        assign2 = function(key) {
          try {
            dest[key] = src[key];
          } catch (e) {
            if (!error)
              error = e;
          }
        };
        for (i = 1; i < length; ++i) {
          src = arguments[i];
          keys2(src).forEach(assign2);
        }
        if (error !== void 0)
          throw error;
        return dest;
      };
    }
  });

  // ../library_management/node_modules/es5-ext/object/assign/index.js
  var require_assign = __commonJS({
    "../library_management/node_modules/es5-ext/object/assign/index.js"(exports, module) {
      "use strict";
      module.exports = require_is_implemented()() ? Object.assign : require_shim2();
    }
  });

  // ../library_management/node_modules/es5-ext/object/normalize-options.js
  var require_normalize_options = __commonJS({
    "../library_management/node_modules/es5-ext/object/normalize-options.js"(exports, module) {
      "use strict";
      var isValue = require_is_value();
      var forEach = Array.prototype.forEach;
      var create = Object.create;
      var process2 = function(src, obj) {
        var key;
        for (key in src)
          obj[key] = src[key];
      };
      module.exports = function(opts1) {
        var result = create(null);
        forEach.call(arguments, function(options) {
          if (!isValue(options))
            return;
          process2(Object(options), result);
        });
        return result;
      };
    }
  });

  // ../library_management/node_modules/es5-ext/string/#/contains/is-implemented.js
  var require_is_implemented3 = __commonJS({
    "../library_management/node_modules/es5-ext/string/#/contains/is-implemented.js"(exports, module) {
      "use strict";
      var str = "razdwatrzy";
      module.exports = function() {
        if (typeof str.contains !== "function")
          return false;
        return str.contains("dwa") === true && str.contains("foo") === false;
      };
    }
  });

  // ../library_management/node_modules/es5-ext/string/#/contains/shim.js
  var require_shim3 = __commonJS({
    "../library_management/node_modules/es5-ext/string/#/contains/shim.js"(exports, module) {
      "use strict";
      var indexOf = String.prototype.indexOf;
      module.exports = function(searchString) {
        return indexOf.call(this, searchString, arguments[1]) > -1;
      };
    }
  });

  // ../library_management/node_modules/es5-ext/string/#/contains/index.js
  var require_contains = __commonJS({
    "../library_management/node_modules/es5-ext/string/#/contains/index.js"(exports, module) {
      "use strict";
      module.exports = require_is_implemented3()() ? String.prototype.contains : require_shim3();
    }
  });

  // ../library_management/node_modules/d/index.js
  var require_d = __commonJS({
    "../library_management/node_modules/d/index.js"(exports, module) {
      "use strict";
      var isValue = require_is();
      var isPlainFunction = require_is5();
      var assign2 = require_assign();
      var normalizeOpts = require_normalize_options();
      var contains = require_contains();
      var d = module.exports = function(dscr, value) {
        var c, e, w, options, desc;
        if (arguments.length < 2 || typeof dscr !== "string") {
          options = value;
          value = dscr;
          dscr = null;
        } else {
          options = arguments[2];
        }
        if (isValue(dscr)) {
          c = contains.call(dscr, "c");
          e = contains.call(dscr, "e");
          w = contains.call(dscr, "w");
        } else {
          c = w = true;
          e = false;
        }
        desc = { value, configurable: c, enumerable: e, writable: w };
        return !options ? desc : assign2(normalizeOpts(options), desc);
      };
      d.gs = function(dscr, get2, set3) {
        var c, e, options, desc;
        if (typeof dscr !== "string") {
          options = set3;
          set3 = get2;
          get2 = dscr;
          dscr = null;
        } else {
          options = arguments[3];
        }
        if (!isValue(get2)) {
          get2 = void 0;
        } else if (!isPlainFunction(get2)) {
          options = get2;
          get2 = set3 = void 0;
        } else if (!isValue(set3)) {
          set3 = void 0;
        } else if (!isPlainFunction(set3)) {
          options = set3;
          set3 = void 0;
        }
        if (isValue(dscr)) {
          c = contains.call(dscr, "c");
          e = contains.call(dscr, "e");
        } else {
          c = true;
          e = false;
        }
        desc = { get: get2, set: set3, configurable: c, enumerable: e };
        return !options ? desc : assign2(normalizeOpts(options), desc);
      };
    }
  });

  // ../library_management/node_modules/es5-ext/object/valid-callable.js
  var require_valid_callable = __commonJS({
    "../library_management/node_modules/es5-ext/object/valid-callable.js"(exports, module) {
      "use strict";
      module.exports = function(fn) {
        if (typeof fn !== "function")
          throw new TypeError(fn + " is not a function");
        return fn;
      };
    }
  });

  // ../library_management/node_modules/event-emitter/index.js
  var require_event_emitter = __commonJS({
    "../library_management/node_modules/event-emitter/index.js"(exports, module) {
      "use strict";
      var d = require_d();
      var callable = require_valid_callable();
      var apply = Function.prototype.apply;
      var call = Function.prototype.call;
      var create = Object.create;
      var defineProperty = Object.defineProperty;
      var defineProperties = Object.defineProperties;
      var hasOwnProperty4 = Object.prototype.hasOwnProperty;
      var descriptor = { configurable: true, enumerable: false, writable: true };
      var on;
      var once;
      var off;
      var emit2;
      var methods;
      var descriptors;
      var base;
      on = function(type2, listener) {
        var data;
        callable(listener);
        if (!hasOwnProperty4.call(this, "__ee__")) {
          data = descriptor.value = create(null);
          defineProperty(this, "__ee__", descriptor);
          descriptor.value = null;
        } else {
          data = this.__ee__;
        }
        if (!data[type2])
          data[type2] = listener;
        else if (typeof data[type2] === "object")
          data[type2].push(listener);
        else
          data[type2] = [data[type2], listener];
        return this;
      };
      once = function(type2, listener) {
        var once2, self2;
        callable(listener);
        self2 = this;
        on.call(this, type2, once2 = function() {
          off.call(self2, type2, once2);
          apply.call(listener, this, arguments);
        });
        once2.__eeOnceListener__ = listener;
        return this;
      };
      off = function(type2, listener) {
        var data, listeners, candidate, i;
        callable(listener);
        if (!hasOwnProperty4.call(this, "__ee__"))
          return this;
        data = this.__ee__;
        if (!data[type2])
          return this;
        listeners = data[type2];
        if (typeof listeners === "object") {
          for (i = 0; candidate = listeners[i]; ++i) {
            if (candidate === listener || candidate.__eeOnceListener__ === listener) {
              if (listeners.length === 2)
                data[type2] = listeners[i ? 0 : 1];
              else
                listeners.splice(i, 1);
            }
          }
        } else {
          if (listeners === listener || listeners.__eeOnceListener__ === listener) {
            delete data[type2];
          }
        }
        return this;
      };
      emit2 = function(type2) {
        var i, l, listener, listeners, args;
        if (!hasOwnProperty4.call(this, "__ee__"))
          return;
        listeners = this.__ee__[type2];
        if (!listeners)
          return;
        if (typeof listeners === "object") {
          l = arguments.length;
          args = new Array(l - 1);
          for (i = 1; i < l; ++i)
            args[i - 1] = arguments[i];
          listeners = listeners.slice();
          for (i = 0; listener = listeners[i]; ++i) {
            apply.call(listener, this, args);
          }
        } else {
          switch (arguments.length) {
            case 1:
              call.call(listeners, this);
              break;
            case 2:
              call.call(listeners, this, arguments[1]);
              break;
            case 3:
              call.call(listeners, this, arguments[1], arguments[2]);
              break;
            default:
              l = arguments.length;
              args = new Array(l - 1);
              for (i = 1; i < l; ++i) {
                args[i - 1] = arguments[i];
              }
              apply.call(listeners, this, args);
          }
        }
      };
      methods = {
        on,
        once,
        off,
        emit: emit2
      };
      descriptors = {
        on: d(on),
        once: d(once),
        off: d(off),
        emit: d(emit2)
      };
      base = defineProperties({}, descriptors);
      module.exports = exports = function(o) {
        return o == null ? create(base) : defineProperties(Object(o), descriptors);
      };
      exports.methods = methods;
    }
  });

  // ../library_management/node_modules/@xmldom/xmldom/lib/conventions.js
  var require_conventions = __commonJS({
    "../library_management/node_modules/@xmldom/xmldom/lib/conventions.js"(exports) {
      "use strict";
      function find(list, predicate, ac) {
        if (ac === void 0) {
          ac = Array.prototype;
        }
        if (list && typeof ac.find === "function") {
          return ac.find.call(list, predicate);
        }
        for (var i = 0; i < list.length; i++) {
          if (Object.prototype.hasOwnProperty.call(list, i)) {
            var item = list[i];
            if (predicate.call(void 0, item, i, list)) {
              return item;
            }
          }
        }
      }
      function freeze(object, oc) {
        if (oc === void 0) {
          oc = Object;
        }
        return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
      }
      var MIME_TYPE = freeze({
        HTML: "text/html",
        isHTML: function(value) {
          return value === MIME_TYPE.HTML;
        },
        XML_APPLICATION: "application/xml",
        XML_TEXT: "text/xml",
        XML_XHTML_APPLICATION: "application/xhtml+xml",
        XML_SVG_IMAGE: "image/svg+xml"
      });
      var NAMESPACE = freeze({
        HTML: "http://www.w3.org/1999/xhtml",
        isHTML: function(uri) {
          return uri === NAMESPACE.HTML;
        },
        SVG: "http://www.w3.org/2000/svg",
        XML: "http://www.w3.org/XML/1998/namespace",
        XMLNS: "http://www.w3.org/2000/xmlns/"
      });
      exports.find = find;
      exports.freeze = freeze;
      exports.MIME_TYPE = MIME_TYPE;
      exports.NAMESPACE = NAMESPACE;
    }
  });

  // ../library_management/node_modules/@xmldom/xmldom/lib/dom.js
  var require_dom = __commonJS({
    "../library_management/node_modules/@xmldom/xmldom/lib/dom.js"(exports) {
      var conventions = require_conventions();
      var find = conventions.find;
      var NAMESPACE = conventions.NAMESPACE;
      function notEmptyString(input) {
        return input !== "";
      }
      function splitOnASCIIWhitespace(input) {
        return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
      }
      function orderedSetReducer(current, element) {
        if (!current.hasOwnProperty(element)) {
          current[element] = true;
        }
        return current;
      }
      function toOrderedSet(input) {
        if (!input)
          return [];
        var list = splitOnASCIIWhitespace(input);
        return Object.keys(list.reduce(orderedSetReducer, {}));
      }
      function arrayIncludes(list) {
        return function(element) {
          return list && list.indexOf(element) !== -1;
        };
      }
      function copy(src, dest) {
        for (var p2 in src) {
          if (Object.prototype.hasOwnProperty.call(src, p2)) {
            dest[p2] = src[p2];
          }
        }
      }
      function _extends(Class, Super) {
        var pt = Class.prototype;
        if (!(pt instanceof Super)) {
          let t2 = function() {
          };
          var t = t2;
          ;
          t2.prototype = Super.prototype;
          t2 = new t2();
          copy(pt, t2);
          Class.prototype = pt = t2;
        }
        if (pt.constructor != Class) {
          if (typeof Class != "function") {
            console.error("unknown Class:" + Class);
          }
          pt.constructor = Class;
        }
      }
      var NodeType = {};
      var ELEMENT_NODE4 = NodeType.ELEMENT_NODE = 1;
      var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
      var TEXT_NODE3 = NodeType.TEXT_NODE = 3;
      var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
      var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
      var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
      var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
      var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
      var DOCUMENT_NODE2 = NodeType.DOCUMENT_NODE = 9;
      var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
      var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
      var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
      var ExceptionCode = {};
      var ExceptionMessage = {};
      var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
      var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
      var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
      var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
      var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
      var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
      var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
      var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
      var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
      var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
      var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
      var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
      var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
      var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
      var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
      function DOMException(code, message) {
        if (message instanceof Error) {
          var error = message;
        } else {
          error = this;
          Error.call(this, ExceptionMessage[code]);
          this.message = ExceptionMessage[code];
          if (Error.captureStackTrace)
            Error.captureStackTrace(this, DOMException);
        }
        error.code = code;
        if (message)
          this.message = this.message + ": " + message;
        return error;
      }
      DOMException.prototype = Error.prototype;
      copy(ExceptionCode, DOMException);
      function NodeList() {
      }
      NodeList.prototype = {
        length: 0,
        item: function(index) {
          return index >= 0 && index < this.length ? this[index] : null;
        },
        toString: function(isHTML, nodeFilter) {
          for (var buf = [], i = 0; i < this.length; i++) {
            serializeToString(this[i], buf, isHTML, nodeFilter);
          }
          return buf.join("");
        },
        filter: function(predicate) {
          return Array.prototype.filter.call(this, predicate);
        },
        indexOf: function(item) {
          return Array.prototype.indexOf.call(this, item);
        }
      };
      function LiveNodeList(node, refresh) {
        this._node = node;
        this._refresh = refresh;
        _updateLiveList(this);
      }
      function _updateLiveList(list) {
        var inc = list._node._inc || list._node.ownerDocument._inc;
        if (list._inc !== inc) {
          var ls = list._refresh(list._node);
          __set__(list, "length", ls.length);
          if (!list.$$length || ls.length < list.$$length) {
            for (var i = ls.length; i in list; i++) {
              if (Object.prototype.hasOwnProperty.call(list, i)) {
                delete list[i];
              }
            }
          }
          copy(ls, list);
          list._inc = inc;
        }
      }
      LiveNodeList.prototype.item = function(i) {
        _updateLiveList(this);
        return this[i] || null;
      };
      _extends(LiveNodeList, NodeList);
      function NamedNodeMap() {
      }
      function _findNodeIndex(list, node) {
        var i = list.length;
        while (i--) {
          if (list[i] === node) {
            return i;
          }
        }
      }
      function _addNamedNode(el, list, newAttr, oldAttr) {
        if (oldAttr) {
          list[_findNodeIndex(list, oldAttr)] = newAttr;
        } else {
          list[list.length++] = newAttr;
        }
        if (el) {
          newAttr.ownerElement = el;
          var doc2 = el.ownerDocument;
          if (doc2) {
            oldAttr && _onRemoveAttribute(doc2, el, oldAttr);
            _onAddAttribute(doc2, el, newAttr);
          }
        }
      }
      function _removeNamedNode(el, list, attr) {
        var i = _findNodeIndex(list, attr);
        if (i >= 0) {
          var lastIndex = list.length - 1;
          while (i < lastIndex) {
            list[i] = list[++i];
          }
          list.length = lastIndex;
          if (el) {
            var doc2 = el.ownerDocument;
            if (doc2) {
              _onRemoveAttribute(doc2, el, attr);
              attr.ownerElement = null;
            }
          }
        } else {
          throw new DOMException(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
        }
      }
      NamedNodeMap.prototype = {
        length: 0,
        item: NodeList.prototype.item,
        getNamedItem: function(key) {
          var i = this.length;
          while (i--) {
            var attr = this[i];
            if (attr.nodeName == key) {
              return attr;
            }
          }
        },
        setNamedItem: function(attr) {
          var el = attr.ownerElement;
          if (el && el != this._ownerElement) {
            throw new DOMException(INUSE_ATTRIBUTE_ERR);
          }
          var oldAttr = this.getNamedItem(attr.nodeName);
          _addNamedNode(this._ownerElement, this, attr, oldAttr);
          return oldAttr;
        },
        setNamedItemNS: function(attr) {
          var el = attr.ownerElement, oldAttr;
          if (el && el != this._ownerElement) {
            throw new DOMException(INUSE_ATTRIBUTE_ERR);
          }
          oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
          _addNamedNode(this._ownerElement, this, attr, oldAttr);
          return oldAttr;
        },
        removeNamedItem: function(key) {
          var attr = this.getNamedItem(key);
          _removeNamedNode(this._ownerElement, this, attr);
          return attr;
        },
        removeNamedItemNS: function(namespaceURI, localName) {
          var attr = this.getNamedItemNS(namespaceURI, localName);
          _removeNamedNode(this._ownerElement, this, attr);
          return attr;
        },
        getNamedItemNS: function(namespaceURI, localName) {
          var i = this.length;
          while (i--) {
            var node = this[i];
            if (node.localName == localName && node.namespaceURI == namespaceURI) {
              return node;
            }
          }
          return null;
        }
      };
      function DOMImplementation() {
      }
      DOMImplementation.prototype = {
        hasFeature: function(feature, version3) {
          return true;
        },
        createDocument: function(namespaceURI, qualifiedName, doctype) {
          var doc2 = new Document2();
          doc2.implementation = this;
          doc2.childNodes = new NodeList();
          doc2.doctype = doctype || null;
          if (doctype) {
            doc2.appendChild(doctype);
          }
          if (qualifiedName) {
            var root = doc2.createElementNS(namespaceURI, qualifiedName);
            doc2.appendChild(root);
          }
          return doc2;
        },
        createDocumentType: function(qualifiedName, publicId, systemId) {
          var node = new DocumentType();
          node.name = qualifiedName;
          node.nodeName = qualifiedName;
          node.publicId = publicId || "";
          node.systemId = systemId || "";
          return node;
        }
      };
      function Node2() {
      }
      Node2.prototype = {
        firstChild: null,
        lastChild: null,
        previousSibling: null,
        nextSibling: null,
        attributes: null,
        parentNode: null,
        childNodes: null,
        ownerDocument: null,
        nodeValue: null,
        namespaceURI: null,
        prefix: null,
        localName: null,
        insertBefore: function(newChild, refChild) {
          return _insertBefore(this, newChild, refChild);
        },
        replaceChild: function(newChild, oldChild) {
          _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
          if (oldChild) {
            this.removeChild(oldChild);
          }
        },
        removeChild: function(oldChild) {
          return _removeChild(this, oldChild);
        },
        appendChild: function(newChild) {
          return this.insertBefore(newChild, null);
        },
        hasChildNodes: function() {
          return this.firstChild != null;
        },
        cloneNode: function(deep) {
          return cloneNode(this.ownerDocument || this, this, deep);
        },
        normalize: function() {
          var child = this.firstChild;
          while (child) {
            var next = child.nextSibling;
            if (next && next.nodeType == TEXT_NODE3 && child.nodeType == TEXT_NODE3) {
              this.removeChild(next);
              child.appendData(next.data);
            } else {
              child.normalize();
              child = next;
            }
          }
        },
        isSupported: function(feature, version3) {
          return this.ownerDocument.implementation.hasFeature(feature, version3);
        },
        hasAttributes: function() {
          return this.attributes.length > 0;
        },
        lookupPrefix: function(namespaceURI) {
          var el = this;
          while (el) {
            var map2 = el._nsMap;
            if (map2) {
              for (var n in map2) {
                if (Object.prototype.hasOwnProperty.call(map2, n) && map2[n] === namespaceURI) {
                  return n;
                }
              }
            }
            el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
          }
          return null;
        },
        lookupNamespaceURI: function(prefix) {
          var el = this;
          while (el) {
            var map2 = el._nsMap;
            if (map2) {
              if (prefix in map2) {
                if (Object.prototype.hasOwnProperty.call(map2, prefix)) {
                  return map2[prefix];
                }
              }
            }
            el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
          }
          return null;
        },
        isDefaultNamespace: function(namespaceURI) {
          var prefix = this.lookupPrefix(namespaceURI);
          return prefix == null;
        }
      };
      function _xmlEncoder(c) {
        return c == "<" && "&lt;" || c == ">" && "&gt;" || c == "&" && "&amp;" || c == '"' && "&quot;" || "&#" + c.charCodeAt() + ";";
      }
      copy(NodeType, Node2);
      copy(NodeType, Node2.prototype);
      function _visitNode(node, callback) {
        if (callback(node)) {
          return true;
        }
        if (node = node.firstChild) {
          do {
            if (_visitNode(node, callback)) {
              return true;
            }
          } while (node = node.nextSibling);
        }
      }
      function Document2() {
        this.ownerDocument = this;
      }
      function _onAddAttribute(doc2, el, newAttr) {
        doc2 && doc2._inc++;
        var ns = newAttr.namespaceURI;
        if (ns === NAMESPACE.XMLNS) {
          el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
        }
      }
      function _onRemoveAttribute(doc2, el, newAttr, remove2) {
        doc2 && doc2._inc++;
        var ns = newAttr.namespaceURI;
        if (ns === NAMESPACE.XMLNS) {
          delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
        }
      }
      function _onUpdateChild(doc2, el, newChild) {
        if (doc2 && doc2._inc) {
          doc2._inc++;
          var cs = el.childNodes;
          if (newChild) {
            cs[cs.length++] = newChild;
          } else {
            var child = el.firstChild;
            var i = 0;
            while (child) {
              cs[i++] = child;
              child = child.nextSibling;
            }
            cs.length = i;
            delete cs[cs.length];
          }
        }
      }
      function _removeChild(parentNode, child) {
        var previous = child.previousSibling;
        var next = child.nextSibling;
        if (previous) {
          previous.nextSibling = next;
        } else {
          parentNode.firstChild = next;
        }
        if (next) {
          next.previousSibling = previous;
        } else {
          parentNode.lastChild = previous;
        }
        child.parentNode = null;
        child.previousSibling = null;
        child.nextSibling = null;
        _onUpdateChild(parentNode.ownerDocument, parentNode);
        return child;
      }
      function hasValidParentNodeType(node) {
        return node && (node.nodeType === Node2.DOCUMENT_NODE || node.nodeType === Node2.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node2.ELEMENT_NODE);
      }
      function hasInsertableNodeType(node) {
        return node && (isElementNode(node) || isTextNode(node) || isDocTypeNode(node) || node.nodeType === Node2.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node2.COMMENT_NODE || node.nodeType === Node2.PROCESSING_INSTRUCTION_NODE);
      }
      function isDocTypeNode(node) {
        return node && node.nodeType === Node2.DOCUMENT_TYPE_NODE;
      }
      function isElementNode(node) {
        return node && node.nodeType === Node2.ELEMENT_NODE;
      }
      function isTextNode(node) {
        return node && node.nodeType === Node2.TEXT_NODE;
      }
      function isElementInsertionPossible(doc2, child) {
        var parentChildNodes = doc2.childNodes || [];
        if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
          return false;
        }
        var docTypeNode = find(parentChildNodes, isDocTypeNode);
        return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
      }
      function isElementReplacementPossible(doc2, child) {
        var parentChildNodes = doc2.childNodes || [];
        function hasElementChildThatIsNotChild(node) {
          return isElementNode(node) && node !== child;
        }
        if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
          return false;
        }
        var docTypeNode = find(parentChildNodes, isDocTypeNode);
        return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
      }
      function assertPreInsertionValidity1to5(parent2, node, child) {
        if (!hasValidParentNodeType(parent2)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent2.nodeType);
        }
        if (child && child.parentNode !== parent2) {
          throw new DOMException(NOT_FOUND_ERR, "child not in parent");
        }
        if (!hasInsertableNodeType(node) || isDocTypeNode(node) && parent2.nodeType !== Node2.DOCUMENT_NODE) {
          throw new DOMException(
            HIERARCHY_REQUEST_ERR,
            "Unexpected node type " + node.nodeType + " for parent node type " + parent2.nodeType
          );
        }
      }
      function assertPreInsertionValidityInDocument(parent2, node, child) {
        var parentChildNodes = parent2.childNodes || [];
        var nodeChildNodes = node.childNodes || [];
        if (node.nodeType === Node2.DOCUMENT_FRAGMENT_NODE) {
          var nodeChildElements = nodeChildNodes.filter(isElementNode);
          if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
          }
          if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent2, child)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
          }
        }
        if (isElementNode(node)) {
          if (!isElementInsertionPossible(parent2, child)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
          }
        }
        if (isDocTypeNode(node)) {
          if (find(parentChildNodes, isDocTypeNode)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
          }
          var parentElementChild = find(parentChildNodes, isElementNode);
          if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
          }
          if (!child && parentElementChild) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
          }
        }
      }
      function assertPreReplacementValidityInDocument(parent2, node, child) {
        var parentChildNodes = parent2.childNodes || [];
        var nodeChildNodes = node.childNodes || [];
        if (node.nodeType === Node2.DOCUMENT_FRAGMENT_NODE) {
          var nodeChildElements = nodeChildNodes.filter(isElementNode);
          if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
          }
          if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent2, child)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
          }
        }
        if (isElementNode(node)) {
          if (!isElementReplacementPossible(parent2, child)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
          }
        }
        if (isDocTypeNode(node)) {
          let hasDoctypeChildThatIsNotChild2 = function(node2) {
            return isDocTypeNode(node2) && node2 !== child;
          };
          var hasDoctypeChildThatIsNotChild = hasDoctypeChildThatIsNotChild2;
          if (find(parentChildNodes, hasDoctypeChildThatIsNotChild2)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
          }
          var parentElementChild = find(parentChildNodes, isElementNode);
          if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
          }
        }
      }
      function _insertBefore(parent2, node, child, _inDocumentAssertion) {
        assertPreInsertionValidity1to5(parent2, node, child);
        if (parent2.nodeType === Node2.DOCUMENT_NODE) {
          (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent2, node, child);
        }
        var cp = node.parentNode;
        if (cp) {
          cp.removeChild(node);
        }
        if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
          var newFirst = node.firstChild;
          if (newFirst == null) {
            return node;
          }
          var newLast = node.lastChild;
        } else {
          newFirst = newLast = node;
        }
        var pre = child ? child.previousSibling : parent2.lastChild;
        newFirst.previousSibling = pre;
        newLast.nextSibling = child;
        if (pre) {
          pre.nextSibling = newFirst;
        } else {
          parent2.firstChild = newFirst;
        }
        if (child == null) {
          parent2.lastChild = newLast;
        } else {
          child.previousSibling = newLast;
        }
        do {
          newFirst.parentNode = parent2;
        } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
        _onUpdateChild(parent2.ownerDocument || parent2, parent2);
        if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
          node.firstChild = node.lastChild = null;
        }
        return node;
      }
      function _appendSingleChild(parentNode, newChild) {
        if (newChild.parentNode) {
          newChild.parentNode.removeChild(newChild);
        }
        newChild.parentNode = parentNode;
        newChild.previousSibling = parentNode.lastChild;
        newChild.nextSibling = null;
        if (newChild.previousSibling) {
          newChild.previousSibling.nextSibling = newChild;
        } else {
          parentNode.firstChild = newChild;
        }
        parentNode.lastChild = newChild;
        _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
        return newChild;
      }
      Document2.prototype = {
        nodeName: "#document",
        nodeType: DOCUMENT_NODE2,
        doctype: null,
        documentElement: null,
        _inc: 1,
        insertBefore: function(newChild, refChild) {
          if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
            var child = newChild.firstChild;
            while (child) {
              var next = child.nextSibling;
              this.insertBefore(child, refChild);
              child = next;
            }
            return newChild;
          }
          _insertBefore(this, newChild, refChild);
          newChild.ownerDocument = this;
          if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE4) {
            this.documentElement = newChild;
          }
          return newChild;
        },
        removeChild: function(oldChild) {
          if (this.documentElement == oldChild) {
            this.documentElement = null;
          }
          return _removeChild(this, oldChild);
        },
        replaceChild: function(newChild, oldChild) {
          _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
          newChild.ownerDocument = this;
          if (oldChild) {
            this.removeChild(oldChild);
          }
          if (isElementNode(newChild)) {
            this.documentElement = newChild;
          }
        },
        importNode: function(importedNode, deep) {
          return importNode(this, importedNode, deep);
        },
        getElementById: function(id) {
          var rtv = null;
          _visitNode(this.documentElement, function(node) {
            if (node.nodeType == ELEMENT_NODE4) {
              if (node.getAttribute("id") == id) {
                rtv = node;
                return true;
              }
            }
          });
          return rtv;
        },
        getElementsByClassName: function(classNames) {
          var classNamesSet = toOrderedSet(classNames);
          return new LiveNodeList(this, function(base) {
            var ls = [];
            if (classNamesSet.length > 0) {
              _visitNode(base.documentElement, function(node) {
                if (node !== base && node.nodeType === ELEMENT_NODE4) {
                  var nodeClassNames = node.getAttribute("class");
                  if (nodeClassNames) {
                    var matches = classNames === nodeClassNames;
                    if (!matches) {
                      var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                      matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                    }
                    if (matches) {
                      ls.push(node);
                    }
                  }
                }
              });
            }
            return ls;
          });
        },
        createElement: function(tagName) {
          var node = new Element2();
          node.ownerDocument = this;
          node.nodeName = tagName;
          node.tagName = tagName;
          node.localName = tagName;
          node.childNodes = new NodeList();
          var attrs = node.attributes = new NamedNodeMap();
          attrs._ownerElement = node;
          return node;
        },
        createDocumentFragment: function() {
          var node = new DocumentFragment();
          node.ownerDocument = this;
          node.childNodes = new NodeList();
          return node;
        },
        createTextNode: function(data) {
          var node = new Text2();
          node.ownerDocument = this;
          node.appendData(data);
          return node;
        },
        createComment: function(data) {
          var node = new Comment2();
          node.ownerDocument = this;
          node.appendData(data);
          return node;
        },
        createCDATASection: function(data) {
          var node = new CDATASection();
          node.ownerDocument = this;
          node.appendData(data);
          return node;
        },
        createProcessingInstruction: function(target, data) {
          var node = new ProcessingInstruction();
          node.ownerDocument = this;
          node.tagName = node.nodeName = node.target = target;
          node.nodeValue = node.data = data;
          return node;
        },
        createAttribute: function(name) {
          var node = new Attr();
          node.ownerDocument = this;
          node.name = name;
          node.nodeName = name;
          node.localName = name;
          node.specified = true;
          return node;
        },
        createEntityReference: function(name) {
          var node = new EntityReference();
          node.ownerDocument = this;
          node.nodeName = name;
          return node;
        },
        createElementNS: function(namespaceURI, qualifiedName) {
          var node = new Element2();
          var pl = qualifiedName.split(":");
          var attrs = node.attributes = new NamedNodeMap();
          node.childNodes = new NodeList();
          node.ownerDocument = this;
          node.nodeName = qualifiedName;
          node.tagName = qualifiedName;
          node.namespaceURI = namespaceURI;
          if (pl.length == 2) {
            node.prefix = pl[0];
            node.localName = pl[1];
          } else {
            node.localName = qualifiedName;
          }
          attrs._ownerElement = node;
          return node;
        },
        createAttributeNS: function(namespaceURI, qualifiedName) {
          var node = new Attr();
          var pl = qualifiedName.split(":");
          node.ownerDocument = this;
          node.nodeName = qualifiedName;
          node.name = qualifiedName;
          node.namespaceURI = namespaceURI;
          node.specified = true;
          if (pl.length == 2) {
            node.prefix = pl[0];
            node.localName = pl[1];
          } else {
            node.localName = qualifiedName;
          }
          return node;
        }
      };
      _extends(Document2, Node2);
      function Element2() {
        this._nsMap = {};
      }
      Element2.prototype = {
        nodeType: ELEMENT_NODE4,
        hasAttribute: function(name) {
          return this.getAttributeNode(name) != null;
        },
        getAttribute: function(name) {
          var attr = this.getAttributeNode(name);
          return attr && attr.value || "";
        },
        getAttributeNode: function(name) {
          return this.attributes.getNamedItem(name);
        },
        setAttribute: function(name, value) {
          var attr = this.ownerDocument.createAttribute(name);
          attr.value = attr.nodeValue = "" + value;
          this.setAttributeNode(attr);
        },
        removeAttribute: function(name) {
          var attr = this.getAttributeNode(name);
          attr && this.removeAttributeNode(attr);
        },
        appendChild: function(newChild) {
          if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
            return this.insertBefore(newChild, null);
          } else {
            return _appendSingleChild(this, newChild);
          }
        },
        setAttributeNode: function(newAttr) {
          return this.attributes.setNamedItem(newAttr);
        },
        setAttributeNodeNS: function(newAttr) {
          return this.attributes.setNamedItemNS(newAttr);
        },
        removeAttributeNode: function(oldAttr) {
          return this.attributes.removeNamedItem(oldAttr.nodeName);
        },
        removeAttributeNS: function(namespaceURI, localName) {
          var old = this.getAttributeNodeNS(namespaceURI, localName);
          old && this.removeAttributeNode(old);
        },
        hasAttributeNS: function(namespaceURI, localName) {
          return this.getAttributeNodeNS(namespaceURI, localName) != null;
        },
        getAttributeNS: function(namespaceURI, localName) {
          var attr = this.getAttributeNodeNS(namespaceURI, localName);
          return attr && attr.value || "";
        },
        setAttributeNS: function(namespaceURI, qualifiedName, value) {
          var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
          attr.value = attr.nodeValue = "" + value;
          this.setAttributeNode(attr);
        },
        getAttributeNodeNS: function(namespaceURI, localName) {
          return this.attributes.getNamedItemNS(namespaceURI, localName);
        },
        getElementsByTagName: function(tagName) {
          return new LiveNodeList(this, function(base) {
            var ls = [];
            _visitNode(base, function(node) {
              if (node !== base && node.nodeType == ELEMENT_NODE4 && (tagName === "*" || node.tagName == tagName)) {
                ls.push(node);
              }
            });
            return ls;
          });
        },
        getElementsByTagNameNS: function(namespaceURI, localName) {
          return new LiveNodeList(this, function(base) {
            var ls = [];
            _visitNode(base, function(node) {
              if (node !== base && node.nodeType === ELEMENT_NODE4 && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
                ls.push(node);
              }
            });
            return ls;
          });
        }
      };
      Document2.prototype.getElementsByTagName = Element2.prototype.getElementsByTagName;
      Document2.prototype.getElementsByTagNameNS = Element2.prototype.getElementsByTagNameNS;
      _extends(Element2, Node2);
      function Attr() {
      }
      Attr.prototype.nodeType = ATTRIBUTE_NODE;
      _extends(Attr, Node2);
      function CharacterData() {
      }
      CharacterData.prototype = {
        data: "",
        substringData: function(offset, count) {
          return this.data.substring(offset, offset + count);
        },
        appendData: function(text) {
          text = this.data + text;
          this.nodeValue = this.data = text;
          this.length = text.length;
        },
        insertData: function(offset, text) {
          this.replaceData(offset, 0, text);
        },
        appendChild: function(newChild) {
          throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
        },
        deleteData: function(offset, count) {
          this.replaceData(offset, count, "");
        },
        replaceData: function(offset, count, text) {
          var start = this.data.substring(0, offset);
          var end = this.data.substring(offset + count);
          text = start + text + end;
          this.nodeValue = this.data = text;
          this.length = text.length;
        }
      };
      _extends(CharacterData, Node2);
      function Text2() {
      }
      Text2.prototype = {
        nodeName: "#text",
        nodeType: TEXT_NODE3,
        splitText: function(offset) {
          var text = this.data;
          var newText = text.substring(offset);
          text = text.substring(0, offset);
          this.data = this.nodeValue = text;
          this.length = text.length;
          var newNode = this.ownerDocument.createTextNode(newText);
          if (this.parentNode) {
            this.parentNode.insertBefore(newNode, this.nextSibling);
          }
          return newNode;
        }
      };
      _extends(Text2, CharacterData);
      function Comment2() {
      }
      Comment2.prototype = {
        nodeName: "#comment",
        nodeType: COMMENT_NODE
      };
      _extends(Comment2, CharacterData);
      function CDATASection() {
      }
      CDATASection.prototype = {
        nodeName: "#cdata-section",
        nodeType: CDATA_SECTION_NODE
      };
      _extends(CDATASection, CharacterData);
      function DocumentType() {
      }
      DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
      _extends(DocumentType, Node2);
      function Notation() {
      }
      Notation.prototype.nodeType = NOTATION_NODE;
      _extends(Notation, Node2);
      function Entity() {
      }
      Entity.prototype.nodeType = ENTITY_NODE;
      _extends(Entity, Node2);
      function EntityReference() {
      }
      EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
      _extends(EntityReference, Node2);
      function DocumentFragment() {
      }
      DocumentFragment.prototype.nodeName = "#document-fragment";
      DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
      _extends(DocumentFragment, Node2);
      function ProcessingInstruction() {
      }
      ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
      _extends(ProcessingInstruction, Node2);
      function XMLSerializer2() {
      }
      XMLSerializer2.prototype.serializeToString = function(node, isHtml, nodeFilter) {
        return nodeSerializeToString.call(node, isHtml, nodeFilter);
      };
      Node2.prototype.toString = nodeSerializeToString;
      function nodeSerializeToString(isHtml, nodeFilter) {
        var buf = [];
        var refNode = this.nodeType == 9 && this.documentElement || this;
        var prefix = refNode.prefix;
        var uri = refNode.namespaceURI;
        if (uri && prefix == null) {
          var prefix = refNode.lookupPrefix(uri);
          if (prefix == null) {
            var visibleNamespaces = [
              { namespace: uri, prefix: null }
            ];
          }
        }
        serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
        return buf.join("");
      }
      function needNamespaceDefine(node, isHTML, visibleNamespaces) {
        var prefix = node.prefix || "";
        var uri = node.namespaceURI;
        if (!uri) {
          return false;
        }
        if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
          return false;
        }
        var i = visibleNamespaces.length;
        while (i--) {
          var ns = visibleNamespaces[i];
          if (ns.prefix === prefix) {
            return ns.namespace !== uri;
          }
        }
        return true;
      }
      function addSerializedAttribute(buf, qualifiedName, value) {
        buf.push(" ", qualifiedName, '="', value.replace(/[<&"]/g, _xmlEncoder), '"');
      }
      function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
        if (!visibleNamespaces) {
          visibleNamespaces = [];
        }
        if (nodeFilter) {
          node = nodeFilter(node);
          if (node) {
            if (typeof node == "string") {
              buf.push(node);
              return;
            }
          } else {
            return;
          }
        }
        switch (node.nodeType) {
          case ELEMENT_NODE4:
            var attrs = node.attributes;
            var len = attrs.length;
            var child = node.firstChild;
            var nodeName = node.tagName;
            isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;
            var prefixedNodeName = nodeName;
            if (!isHTML && !node.prefix && node.namespaceURI) {
              var defaultNS;
              for (var ai = 0; ai < attrs.length; ai++) {
                if (attrs.item(ai).name === "xmlns") {
                  defaultNS = attrs.item(ai).value;
                  break;
                }
              }
              if (!defaultNS) {
                for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                  var namespace = visibleNamespaces[nsi];
                  if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                    defaultNS = namespace.namespace;
                    break;
                  }
                }
              }
              if (defaultNS !== node.namespaceURI) {
                for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                  var namespace = visibleNamespaces[nsi];
                  if (namespace.namespace === node.namespaceURI) {
                    if (namespace.prefix) {
                      prefixedNodeName = namespace.prefix + ":" + nodeName;
                    }
                    break;
                  }
                }
              }
            }
            buf.push("<", prefixedNodeName);
            for (var i = 0; i < len; i++) {
              var attr = attrs.item(i);
              if (attr.prefix == "xmlns") {
                visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
              } else if (attr.nodeName == "xmlns") {
                visibleNamespaces.push({ prefix: "", namespace: attr.value });
              }
            }
            for (var i = 0; i < len; i++) {
              var attr = attrs.item(i);
              if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
                var prefix = attr.prefix || "";
                var uri = attr.namespaceURI;
                addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
                visibleNamespaces.push({ prefix, namespace: uri });
              }
              serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
            }
            if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
              var prefix = node.prefix || "";
              var uri = node.namespaceURI;
              addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
              visibleNamespaces.push({ prefix, namespace: uri });
            }
            if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
              buf.push(">");
              if (isHTML && /^script$/i.test(nodeName)) {
                while (child) {
                  if (child.data) {
                    buf.push(child.data);
                  } else {
                    serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                  }
                  child = child.nextSibling;
                }
              } else {
                while (child) {
                  serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                  child = child.nextSibling;
                }
              }
              buf.push("</", prefixedNodeName, ">");
            } else {
              buf.push("/>");
            }
            return;
          case DOCUMENT_NODE2:
          case DOCUMENT_FRAGMENT_NODE:
            var child = node.firstChild;
            while (child) {
              serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
              child = child.nextSibling;
            }
            return;
          case ATTRIBUTE_NODE:
            return addSerializedAttribute(buf, node.name, node.value);
          case TEXT_NODE3:
            return buf.push(
              node.data.replace(/[<&]/g, _xmlEncoder).replace(/]]>/g, "]]&gt;")
            );
          case CDATA_SECTION_NODE:
            return buf.push("<![CDATA[", node.data, "]]>");
          case COMMENT_NODE:
            return buf.push("<!--", node.data, "-->");
          case DOCUMENT_TYPE_NODE:
            var pubid = node.publicId;
            var sysid = node.systemId;
            buf.push("<!DOCTYPE ", node.name);
            if (pubid) {
              buf.push(" PUBLIC ", pubid);
              if (sysid && sysid != ".") {
                buf.push(" ", sysid);
              }
              buf.push(">");
            } else if (sysid && sysid != ".") {
              buf.push(" SYSTEM ", sysid, ">");
            } else {
              var sub = node.internalSubset;
              if (sub) {
                buf.push(" [", sub, "]");
              }
              buf.push(">");
            }
            return;
          case PROCESSING_INSTRUCTION_NODE:
            return buf.push("<?", node.target, " ", node.data, "?>");
          case ENTITY_REFERENCE_NODE:
            return buf.push("&", node.nodeName, ";");
          default:
            buf.push("??", node.nodeName);
        }
      }
      function importNode(doc2, node, deep) {
        var node2;
        switch (node.nodeType) {
          case ELEMENT_NODE4:
            node2 = node.cloneNode(false);
            node2.ownerDocument = doc2;
          case DOCUMENT_FRAGMENT_NODE:
            break;
          case ATTRIBUTE_NODE:
            deep = true;
            break;
        }
        if (!node2) {
          node2 = node.cloneNode(false);
        }
        node2.ownerDocument = doc2;
        node2.parentNode = null;
        if (deep) {
          var child = node.firstChild;
          while (child) {
            node2.appendChild(importNode(doc2, child, deep));
            child = child.nextSibling;
          }
        }
        return node2;
      }
      function cloneNode(doc2, node, deep) {
        var node2 = new node.constructor();
        for (var n in node) {
          if (Object.prototype.hasOwnProperty.call(node, n)) {
            var v = node[n];
            if (typeof v != "object") {
              if (v != node2[n]) {
                node2[n] = v;
              }
            }
          }
        }
        if (node.childNodes) {
          node2.childNodes = new NodeList();
        }
        node2.ownerDocument = doc2;
        switch (node2.nodeType) {
          case ELEMENT_NODE4:
            var attrs = node.attributes;
            var attrs2 = node2.attributes = new NamedNodeMap();
            var len = attrs.length;
            attrs2._ownerElement = node2;
            for (var i = 0; i < len; i++) {
              node2.setAttributeNode(cloneNode(doc2, attrs.item(i), true));
            }
            break;
            ;
          case ATTRIBUTE_NODE:
            deep = true;
        }
        if (deep) {
          var child = node.firstChild;
          while (child) {
            node2.appendChild(cloneNode(doc2, child, deep));
            child = child.nextSibling;
          }
        }
        return node2;
      }
      function __set__(object, key, value) {
        object[key] = value;
      }
      try {
        if (Object.defineProperty) {
          let getTextContent2 = function(node) {
            switch (node.nodeType) {
              case ELEMENT_NODE4:
              case DOCUMENT_FRAGMENT_NODE:
                var buf = [];
                node = node.firstChild;
                while (node) {
                  if (node.nodeType !== 7 && node.nodeType !== 8) {
                    buf.push(getTextContent2(node));
                  }
                  node = node.nextSibling;
                }
                return buf.join("");
              default:
                return node.nodeValue;
            }
          };
          getTextContent = getTextContent2;
          Object.defineProperty(LiveNodeList.prototype, "length", {
            get: function() {
              _updateLiveList(this);
              return this.$$length;
            }
          });
          Object.defineProperty(Node2.prototype, "textContent", {
            get: function() {
              return getTextContent2(this);
            },
            set: function(data) {
              switch (this.nodeType) {
                case ELEMENT_NODE4:
                case DOCUMENT_FRAGMENT_NODE:
                  while (this.firstChild) {
                    this.removeChild(this.firstChild);
                  }
                  if (data || String(data)) {
                    this.appendChild(this.ownerDocument.createTextNode(data));
                  }
                  break;
                default:
                  this.data = data;
                  this.value = data;
                  this.nodeValue = data;
              }
            }
          });
          __set__ = function(object, key, value) {
            object["$$" + key] = value;
          };
        }
      } catch (e) {
      }
      var getTextContent;
      exports.DocumentType = DocumentType;
      exports.DOMException = DOMException;
      exports.DOMImplementation = DOMImplementation;
      exports.Element = Element2;
      exports.Node = Node2;
      exports.NodeList = NodeList;
      exports.XMLSerializer = XMLSerializer2;
    }
  });

  // ../library_management/node_modules/@xmldom/xmldom/lib/entities.js
  var require_entities = __commonJS({
    "../library_management/node_modules/@xmldom/xmldom/lib/entities.js"(exports) {
      "use strict";
      var freeze = require_conventions().freeze;
      exports.XML_ENTITIES = freeze({
        amp: "&",
        apos: "'",
        gt: ">",
        lt: "<",
        quot: '"'
      });
      exports.HTML_ENTITIES = freeze({
        Aacute: "\xC1",
        aacute: "\xE1",
        Abreve: "\u0102",
        abreve: "\u0103",
        ac: "\u223E",
        acd: "\u223F",
        acE: "\u223E\u0333",
        Acirc: "\xC2",
        acirc: "\xE2",
        acute: "\xB4",
        Acy: "\u0410",
        acy: "\u0430",
        AElig: "\xC6",
        aelig: "\xE6",
        af: "\u2061",
        Afr: "\u{1D504}",
        afr: "\u{1D51E}",
        Agrave: "\xC0",
        agrave: "\xE0",
        alefsym: "\u2135",
        aleph: "\u2135",
        Alpha: "\u0391",
        alpha: "\u03B1",
        Amacr: "\u0100",
        amacr: "\u0101",
        amalg: "\u2A3F",
        AMP: "&",
        amp: "&",
        And: "\u2A53",
        and: "\u2227",
        andand: "\u2A55",
        andd: "\u2A5C",
        andslope: "\u2A58",
        andv: "\u2A5A",
        ang: "\u2220",
        ange: "\u29A4",
        angle: "\u2220",
        angmsd: "\u2221",
        angmsdaa: "\u29A8",
        angmsdab: "\u29A9",
        angmsdac: "\u29AA",
        angmsdad: "\u29AB",
        angmsdae: "\u29AC",
        angmsdaf: "\u29AD",
        angmsdag: "\u29AE",
        angmsdah: "\u29AF",
        angrt: "\u221F",
        angrtvb: "\u22BE",
        angrtvbd: "\u299D",
        angsph: "\u2222",
        angst: "\xC5",
        angzarr: "\u237C",
        Aogon: "\u0104",
        aogon: "\u0105",
        Aopf: "\u{1D538}",
        aopf: "\u{1D552}",
        ap: "\u2248",
        apacir: "\u2A6F",
        apE: "\u2A70",
        ape: "\u224A",
        apid: "\u224B",
        apos: "'",
        ApplyFunction: "\u2061",
        approx: "\u2248",
        approxeq: "\u224A",
        Aring: "\xC5",
        aring: "\xE5",
        Ascr: "\u{1D49C}",
        ascr: "\u{1D4B6}",
        Assign: "\u2254",
        ast: "*",
        asymp: "\u2248",
        asympeq: "\u224D",
        Atilde: "\xC3",
        atilde: "\xE3",
        Auml: "\xC4",
        auml: "\xE4",
        awconint: "\u2233",
        awint: "\u2A11",
        backcong: "\u224C",
        backepsilon: "\u03F6",
        backprime: "\u2035",
        backsim: "\u223D",
        backsimeq: "\u22CD",
        Backslash: "\u2216",
        Barv: "\u2AE7",
        barvee: "\u22BD",
        Barwed: "\u2306",
        barwed: "\u2305",
        barwedge: "\u2305",
        bbrk: "\u23B5",
        bbrktbrk: "\u23B6",
        bcong: "\u224C",
        Bcy: "\u0411",
        bcy: "\u0431",
        bdquo: "\u201E",
        becaus: "\u2235",
        Because: "\u2235",
        because: "\u2235",
        bemptyv: "\u29B0",
        bepsi: "\u03F6",
        bernou: "\u212C",
        Bernoullis: "\u212C",
        Beta: "\u0392",
        beta: "\u03B2",
        beth: "\u2136",
        between: "\u226C",
        Bfr: "\u{1D505}",
        bfr: "\u{1D51F}",
        bigcap: "\u22C2",
        bigcirc: "\u25EF",
        bigcup: "\u22C3",
        bigodot: "\u2A00",
        bigoplus: "\u2A01",
        bigotimes: "\u2A02",
        bigsqcup: "\u2A06",
        bigstar: "\u2605",
        bigtriangledown: "\u25BD",
        bigtriangleup: "\u25B3",
        biguplus: "\u2A04",
        bigvee: "\u22C1",
        bigwedge: "\u22C0",
        bkarow: "\u290D",
        blacklozenge: "\u29EB",
        blacksquare: "\u25AA",
        blacktriangle: "\u25B4",
        blacktriangledown: "\u25BE",
        blacktriangleleft: "\u25C2",
        blacktriangleright: "\u25B8",
        blank: "\u2423",
        blk12: "\u2592",
        blk14: "\u2591",
        blk34: "\u2593",
        block: "\u2588",
        bne: "=\u20E5",
        bnequiv: "\u2261\u20E5",
        bNot: "\u2AED",
        bnot: "\u2310",
        Bopf: "\u{1D539}",
        bopf: "\u{1D553}",
        bot: "\u22A5",
        bottom: "\u22A5",
        bowtie: "\u22C8",
        boxbox: "\u29C9",
        boxDL: "\u2557",
        boxDl: "\u2556",
        boxdL: "\u2555",
        boxdl: "\u2510",
        boxDR: "\u2554",
        boxDr: "\u2553",
        boxdR: "\u2552",
        boxdr: "\u250C",
        boxH: "\u2550",
        boxh: "\u2500",
        boxHD: "\u2566",
        boxHd: "\u2564",
        boxhD: "\u2565",
        boxhd: "\u252C",
        boxHU: "\u2569",
        boxHu: "\u2567",
        boxhU: "\u2568",
        boxhu: "\u2534",
        boxminus: "\u229F",
        boxplus: "\u229E",
        boxtimes: "\u22A0",
        boxUL: "\u255D",
        boxUl: "\u255C",
        boxuL: "\u255B",
        boxul: "\u2518",
        boxUR: "\u255A",
        boxUr: "\u2559",
        boxuR: "\u2558",
        boxur: "\u2514",
        boxV: "\u2551",
        boxv: "\u2502",
        boxVH: "\u256C",
        boxVh: "\u256B",
        boxvH: "\u256A",
        boxvh: "\u253C",
        boxVL: "\u2563",
        boxVl: "\u2562",
        boxvL: "\u2561",
        boxvl: "\u2524",
        boxVR: "\u2560",
        boxVr: "\u255F",
        boxvR: "\u255E",
        boxvr: "\u251C",
        bprime: "\u2035",
        Breve: "\u02D8",
        breve: "\u02D8",
        brvbar: "\xA6",
        Bscr: "\u212C",
        bscr: "\u{1D4B7}",
        bsemi: "\u204F",
        bsim: "\u223D",
        bsime: "\u22CD",
        bsol: "\\",
        bsolb: "\u29C5",
        bsolhsub: "\u27C8",
        bull: "\u2022",
        bullet: "\u2022",
        bump: "\u224E",
        bumpE: "\u2AAE",
        bumpe: "\u224F",
        Bumpeq: "\u224E",
        bumpeq: "\u224F",
        Cacute: "\u0106",
        cacute: "\u0107",
        Cap: "\u22D2",
        cap: "\u2229",
        capand: "\u2A44",
        capbrcup: "\u2A49",
        capcap: "\u2A4B",
        capcup: "\u2A47",
        capdot: "\u2A40",
        CapitalDifferentialD: "\u2145",
        caps: "\u2229\uFE00",
        caret: "\u2041",
        caron: "\u02C7",
        Cayleys: "\u212D",
        ccaps: "\u2A4D",
        Ccaron: "\u010C",
        ccaron: "\u010D",
        Ccedil: "\xC7",
        ccedil: "\xE7",
        Ccirc: "\u0108",
        ccirc: "\u0109",
        Cconint: "\u2230",
        ccups: "\u2A4C",
        ccupssm: "\u2A50",
        Cdot: "\u010A",
        cdot: "\u010B",
        cedil: "\xB8",
        Cedilla: "\xB8",
        cemptyv: "\u29B2",
        cent: "\xA2",
        CenterDot: "\xB7",
        centerdot: "\xB7",
        Cfr: "\u212D",
        cfr: "\u{1D520}",
        CHcy: "\u0427",
        chcy: "\u0447",
        check: "\u2713",
        checkmark: "\u2713",
        Chi: "\u03A7",
        chi: "\u03C7",
        cir: "\u25CB",
        circ: "\u02C6",
        circeq: "\u2257",
        circlearrowleft: "\u21BA",
        circlearrowright: "\u21BB",
        circledast: "\u229B",
        circledcirc: "\u229A",
        circleddash: "\u229D",
        CircleDot: "\u2299",
        circledR: "\xAE",
        circledS: "\u24C8",
        CircleMinus: "\u2296",
        CirclePlus: "\u2295",
        CircleTimes: "\u2297",
        cirE: "\u29C3",
        cire: "\u2257",
        cirfnint: "\u2A10",
        cirmid: "\u2AEF",
        cirscir: "\u29C2",
        ClockwiseContourIntegral: "\u2232",
        CloseCurlyDoubleQuote: "\u201D",
        CloseCurlyQuote: "\u2019",
        clubs: "\u2663",
        clubsuit: "\u2663",
        Colon: "\u2237",
        colon: ":",
        Colone: "\u2A74",
        colone: "\u2254",
        coloneq: "\u2254",
        comma: ",",
        commat: "@",
        comp: "\u2201",
        compfn: "\u2218",
        complement: "\u2201",
        complexes: "\u2102",
        cong: "\u2245",
        congdot: "\u2A6D",
        Congruent: "\u2261",
        Conint: "\u222F",
        conint: "\u222E",
        ContourIntegral: "\u222E",
        Copf: "\u2102",
        copf: "\u{1D554}",
        coprod: "\u2210",
        Coproduct: "\u2210",
        COPY: "\xA9",
        copy: "\xA9",
        copysr: "\u2117",
        CounterClockwiseContourIntegral: "\u2233",
        crarr: "\u21B5",
        Cross: "\u2A2F",
        cross: "\u2717",
        Cscr: "\u{1D49E}",
        cscr: "\u{1D4B8}",
        csub: "\u2ACF",
        csube: "\u2AD1",
        csup: "\u2AD0",
        csupe: "\u2AD2",
        ctdot: "\u22EF",
        cudarrl: "\u2938",
        cudarrr: "\u2935",
        cuepr: "\u22DE",
        cuesc: "\u22DF",
        cularr: "\u21B6",
        cularrp: "\u293D",
        Cup: "\u22D3",
        cup: "\u222A",
        cupbrcap: "\u2A48",
        CupCap: "\u224D",
        cupcap: "\u2A46",
        cupcup: "\u2A4A",
        cupdot: "\u228D",
        cupor: "\u2A45",
        cups: "\u222A\uFE00",
        curarr: "\u21B7",
        curarrm: "\u293C",
        curlyeqprec: "\u22DE",
        curlyeqsucc: "\u22DF",
        curlyvee: "\u22CE",
        curlywedge: "\u22CF",
        curren: "\xA4",
        curvearrowleft: "\u21B6",
        curvearrowright: "\u21B7",
        cuvee: "\u22CE",
        cuwed: "\u22CF",
        cwconint: "\u2232",
        cwint: "\u2231",
        cylcty: "\u232D",
        Dagger: "\u2021",
        dagger: "\u2020",
        daleth: "\u2138",
        Darr: "\u21A1",
        dArr: "\u21D3",
        darr: "\u2193",
        dash: "\u2010",
        Dashv: "\u2AE4",
        dashv: "\u22A3",
        dbkarow: "\u290F",
        dblac: "\u02DD",
        Dcaron: "\u010E",
        dcaron: "\u010F",
        Dcy: "\u0414",
        dcy: "\u0434",
        DD: "\u2145",
        dd: "\u2146",
        ddagger: "\u2021",
        ddarr: "\u21CA",
        DDotrahd: "\u2911",
        ddotseq: "\u2A77",
        deg: "\xB0",
        Del: "\u2207",
        Delta: "\u0394",
        delta: "\u03B4",
        demptyv: "\u29B1",
        dfisht: "\u297F",
        Dfr: "\u{1D507}",
        dfr: "\u{1D521}",
        dHar: "\u2965",
        dharl: "\u21C3",
        dharr: "\u21C2",
        DiacriticalAcute: "\xB4",
        DiacriticalDot: "\u02D9",
        DiacriticalDoubleAcute: "\u02DD",
        DiacriticalGrave: "`",
        DiacriticalTilde: "\u02DC",
        diam: "\u22C4",
        Diamond: "\u22C4",
        diamond: "\u22C4",
        diamondsuit: "\u2666",
        diams: "\u2666",
        die: "\xA8",
        DifferentialD: "\u2146",
        digamma: "\u03DD",
        disin: "\u22F2",
        div: "\xF7",
        divide: "\xF7",
        divideontimes: "\u22C7",
        divonx: "\u22C7",
        DJcy: "\u0402",
        djcy: "\u0452",
        dlcorn: "\u231E",
        dlcrop: "\u230D",
        dollar: "$",
        Dopf: "\u{1D53B}",
        dopf: "\u{1D555}",
        Dot: "\xA8",
        dot: "\u02D9",
        DotDot: "\u20DC",
        doteq: "\u2250",
        doteqdot: "\u2251",
        DotEqual: "\u2250",
        dotminus: "\u2238",
        dotplus: "\u2214",
        dotsquare: "\u22A1",
        doublebarwedge: "\u2306",
        DoubleContourIntegral: "\u222F",
        DoubleDot: "\xA8",
        DoubleDownArrow: "\u21D3",
        DoubleLeftArrow: "\u21D0",
        DoubleLeftRightArrow: "\u21D4",
        DoubleLeftTee: "\u2AE4",
        DoubleLongLeftArrow: "\u27F8",
        DoubleLongLeftRightArrow: "\u27FA",
        DoubleLongRightArrow: "\u27F9",
        DoubleRightArrow: "\u21D2",
        DoubleRightTee: "\u22A8",
        DoubleUpArrow: "\u21D1",
        DoubleUpDownArrow: "\u21D5",
        DoubleVerticalBar: "\u2225",
        DownArrow: "\u2193",
        Downarrow: "\u21D3",
        downarrow: "\u2193",
        DownArrowBar: "\u2913",
        DownArrowUpArrow: "\u21F5",
        DownBreve: "\u0311",
        downdownarrows: "\u21CA",
        downharpoonleft: "\u21C3",
        downharpoonright: "\u21C2",
        DownLeftRightVector: "\u2950",
        DownLeftTeeVector: "\u295E",
        DownLeftVector: "\u21BD",
        DownLeftVectorBar: "\u2956",
        DownRightTeeVector: "\u295F",
        DownRightVector: "\u21C1",
        DownRightVectorBar: "\u2957",
        DownTee: "\u22A4",
        DownTeeArrow: "\u21A7",
        drbkarow: "\u2910",
        drcorn: "\u231F",
        drcrop: "\u230C",
        Dscr: "\u{1D49F}",
        dscr: "\u{1D4B9}",
        DScy: "\u0405",
        dscy: "\u0455",
        dsol: "\u29F6",
        Dstrok: "\u0110",
        dstrok: "\u0111",
        dtdot: "\u22F1",
        dtri: "\u25BF",
        dtrif: "\u25BE",
        duarr: "\u21F5",
        duhar: "\u296F",
        dwangle: "\u29A6",
        DZcy: "\u040F",
        dzcy: "\u045F",
        dzigrarr: "\u27FF",
        Eacute: "\xC9",
        eacute: "\xE9",
        easter: "\u2A6E",
        Ecaron: "\u011A",
        ecaron: "\u011B",
        ecir: "\u2256",
        Ecirc: "\xCA",
        ecirc: "\xEA",
        ecolon: "\u2255",
        Ecy: "\u042D",
        ecy: "\u044D",
        eDDot: "\u2A77",
        Edot: "\u0116",
        eDot: "\u2251",
        edot: "\u0117",
        ee: "\u2147",
        efDot: "\u2252",
        Efr: "\u{1D508}",
        efr: "\u{1D522}",
        eg: "\u2A9A",
        Egrave: "\xC8",
        egrave: "\xE8",
        egs: "\u2A96",
        egsdot: "\u2A98",
        el: "\u2A99",
        Element: "\u2208",
        elinters: "\u23E7",
        ell: "\u2113",
        els: "\u2A95",
        elsdot: "\u2A97",
        Emacr: "\u0112",
        emacr: "\u0113",
        empty: "\u2205",
        emptyset: "\u2205",
        EmptySmallSquare: "\u25FB",
        emptyv: "\u2205",
        EmptyVerySmallSquare: "\u25AB",
        emsp: "\u2003",
        emsp13: "\u2004",
        emsp14: "\u2005",
        ENG: "\u014A",
        eng: "\u014B",
        ensp: "\u2002",
        Eogon: "\u0118",
        eogon: "\u0119",
        Eopf: "\u{1D53C}",
        eopf: "\u{1D556}",
        epar: "\u22D5",
        eparsl: "\u29E3",
        eplus: "\u2A71",
        epsi: "\u03B5",
        Epsilon: "\u0395",
        epsilon: "\u03B5",
        epsiv: "\u03F5",
        eqcirc: "\u2256",
        eqcolon: "\u2255",
        eqsim: "\u2242",
        eqslantgtr: "\u2A96",
        eqslantless: "\u2A95",
        Equal: "\u2A75",
        equals: "=",
        EqualTilde: "\u2242",
        equest: "\u225F",
        Equilibrium: "\u21CC",
        equiv: "\u2261",
        equivDD: "\u2A78",
        eqvparsl: "\u29E5",
        erarr: "\u2971",
        erDot: "\u2253",
        Escr: "\u2130",
        escr: "\u212F",
        esdot: "\u2250",
        Esim: "\u2A73",
        esim: "\u2242",
        Eta: "\u0397",
        eta: "\u03B7",
        ETH: "\xD0",
        eth: "\xF0",
        Euml: "\xCB",
        euml: "\xEB",
        euro: "\u20AC",
        excl: "!",
        exist: "\u2203",
        Exists: "\u2203",
        expectation: "\u2130",
        ExponentialE: "\u2147",
        exponentiale: "\u2147",
        fallingdotseq: "\u2252",
        Fcy: "\u0424",
        fcy: "\u0444",
        female: "\u2640",
        ffilig: "\uFB03",
        fflig: "\uFB00",
        ffllig: "\uFB04",
        Ffr: "\u{1D509}",
        ffr: "\u{1D523}",
        filig: "\uFB01",
        FilledSmallSquare: "\u25FC",
        FilledVerySmallSquare: "\u25AA",
        fjlig: "fj",
        flat: "\u266D",
        fllig: "\uFB02",
        fltns: "\u25B1",
        fnof: "\u0192",
        Fopf: "\u{1D53D}",
        fopf: "\u{1D557}",
        ForAll: "\u2200",
        forall: "\u2200",
        fork: "\u22D4",
        forkv: "\u2AD9",
        Fouriertrf: "\u2131",
        fpartint: "\u2A0D",
        frac12: "\xBD",
        frac13: "\u2153",
        frac14: "\xBC",
        frac15: "\u2155",
        frac16: "\u2159",
        frac18: "\u215B",
        frac23: "\u2154",
        frac25: "\u2156",
        frac34: "\xBE",
        frac35: "\u2157",
        frac38: "\u215C",
        frac45: "\u2158",
        frac56: "\u215A",
        frac58: "\u215D",
        frac78: "\u215E",
        frasl: "\u2044",
        frown: "\u2322",
        Fscr: "\u2131",
        fscr: "\u{1D4BB}",
        gacute: "\u01F5",
        Gamma: "\u0393",
        gamma: "\u03B3",
        Gammad: "\u03DC",
        gammad: "\u03DD",
        gap: "\u2A86",
        Gbreve: "\u011E",
        gbreve: "\u011F",
        Gcedil: "\u0122",
        Gcirc: "\u011C",
        gcirc: "\u011D",
        Gcy: "\u0413",
        gcy: "\u0433",
        Gdot: "\u0120",
        gdot: "\u0121",
        gE: "\u2267",
        ge: "\u2265",
        gEl: "\u2A8C",
        gel: "\u22DB",
        geq: "\u2265",
        geqq: "\u2267",
        geqslant: "\u2A7E",
        ges: "\u2A7E",
        gescc: "\u2AA9",
        gesdot: "\u2A80",
        gesdoto: "\u2A82",
        gesdotol: "\u2A84",
        gesl: "\u22DB\uFE00",
        gesles: "\u2A94",
        Gfr: "\u{1D50A}",
        gfr: "\u{1D524}",
        Gg: "\u22D9",
        gg: "\u226B",
        ggg: "\u22D9",
        gimel: "\u2137",
        GJcy: "\u0403",
        gjcy: "\u0453",
        gl: "\u2277",
        gla: "\u2AA5",
        glE: "\u2A92",
        glj: "\u2AA4",
        gnap: "\u2A8A",
        gnapprox: "\u2A8A",
        gnE: "\u2269",
        gne: "\u2A88",
        gneq: "\u2A88",
        gneqq: "\u2269",
        gnsim: "\u22E7",
        Gopf: "\u{1D53E}",
        gopf: "\u{1D558}",
        grave: "`",
        GreaterEqual: "\u2265",
        GreaterEqualLess: "\u22DB",
        GreaterFullEqual: "\u2267",
        GreaterGreater: "\u2AA2",
        GreaterLess: "\u2277",
        GreaterSlantEqual: "\u2A7E",
        GreaterTilde: "\u2273",
        Gscr: "\u{1D4A2}",
        gscr: "\u210A",
        gsim: "\u2273",
        gsime: "\u2A8E",
        gsiml: "\u2A90",
        Gt: "\u226B",
        GT: ">",
        gt: ">",
        gtcc: "\u2AA7",
        gtcir: "\u2A7A",
        gtdot: "\u22D7",
        gtlPar: "\u2995",
        gtquest: "\u2A7C",
        gtrapprox: "\u2A86",
        gtrarr: "\u2978",
        gtrdot: "\u22D7",
        gtreqless: "\u22DB",
        gtreqqless: "\u2A8C",
        gtrless: "\u2277",
        gtrsim: "\u2273",
        gvertneqq: "\u2269\uFE00",
        gvnE: "\u2269\uFE00",
        Hacek: "\u02C7",
        hairsp: "\u200A",
        half: "\xBD",
        hamilt: "\u210B",
        HARDcy: "\u042A",
        hardcy: "\u044A",
        hArr: "\u21D4",
        harr: "\u2194",
        harrcir: "\u2948",
        harrw: "\u21AD",
        Hat: "^",
        hbar: "\u210F",
        Hcirc: "\u0124",
        hcirc: "\u0125",
        hearts: "\u2665",
        heartsuit: "\u2665",
        hellip: "\u2026",
        hercon: "\u22B9",
        Hfr: "\u210C",
        hfr: "\u{1D525}",
        HilbertSpace: "\u210B",
        hksearow: "\u2925",
        hkswarow: "\u2926",
        hoarr: "\u21FF",
        homtht: "\u223B",
        hookleftarrow: "\u21A9",
        hookrightarrow: "\u21AA",
        Hopf: "\u210D",
        hopf: "\u{1D559}",
        horbar: "\u2015",
        HorizontalLine: "\u2500",
        Hscr: "\u210B",
        hscr: "\u{1D4BD}",
        hslash: "\u210F",
        Hstrok: "\u0126",
        hstrok: "\u0127",
        HumpDownHump: "\u224E",
        HumpEqual: "\u224F",
        hybull: "\u2043",
        hyphen: "\u2010",
        Iacute: "\xCD",
        iacute: "\xED",
        ic: "\u2063",
        Icirc: "\xCE",
        icirc: "\xEE",
        Icy: "\u0418",
        icy: "\u0438",
        Idot: "\u0130",
        IEcy: "\u0415",
        iecy: "\u0435",
        iexcl: "\xA1",
        iff: "\u21D4",
        Ifr: "\u2111",
        ifr: "\u{1D526}",
        Igrave: "\xCC",
        igrave: "\xEC",
        ii: "\u2148",
        iiiint: "\u2A0C",
        iiint: "\u222D",
        iinfin: "\u29DC",
        iiota: "\u2129",
        IJlig: "\u0132",
        ijlig: "\u0133",
        Im: "\u2111",
        Imacr: "\u012A",
        imacr: "\u012B",
        image: "\u2111",
        ImaginaryI: "\u2148",
        imagline: "\u2110",
        imagpart: "\u2111",
        imath: "\u0131",
        imof: "\u22B7",
        imped: "\u01B5",
        Implies: "\u21D2",
        in: "\u2208",
        incare: "\u2105",
        infin: "\u221E",
        infintie: "\u29DD",
        inodot: "\u0131",
        Int: "\u222C",
        int: "\u222B",
        intcal: "\u22BA",
        integers: "\u2124",
        Integral: "\u222B",
        intercal: "\u22BA",
        Intersection: "\u22C2",
        intlarhk: "\u2A17",
        intprod: "\u2A3C",
        InvisibleComma: "\u2063",
        InvisibleTimes: "\u2062",
        IOcy: "\u0401",
        iocy: "\u0451",
        Iogon: "\u012E",
        iogon: "\u012F",
        Iopf: "\u{1D540}",
        iopf: "\u{1D55A}",
        Iota: "\u0399",
        iota: "\u03B9",
        iprod: "\u2A3C",
        iquest: "\xBF",
        Iscr: "\u2110",
        iscr: "\u{1D4BE}",
        isin: "\u2208",
        isindot: "\u22F5",
        isinE: "\u22F9",
        isins: "\u22F4",
        isinsv: "\u22F3",
        isinv: "\u2208",
        it: "\u2062",
        Itilde: "\u0128",
        itilde: "\u0129",
        Iukcy: "\u0406",
        iukcy: "\u0456",
        Iuml: "\xCF",
        iuml: "\xEF",
        Jcirc: "\u0134",
        jcirc: "\u0135",
        Jcy: "\u0419",
        jcy: "\u0439",
        Jfr: "\u{1D50D}",
        jfr: "\u{1D527}",
        jmath: "\u0237",
        Jopf: "\u{1D541}",
        jopf: "\u{1D55B}",
        Jscr: "\u{1D4A5}",
        jscr: "\u{1D4BF}",
        Jsercy: "\u0408",
        jsercy: "\u0458",
        Jukcy: "\u0404",
        jukcy: "\u0454",
        Kappa: "\u039A",
        kappa: "\u03BA",
        kappav: "\u03F0",
        Kcedil: "\u0136",
        kcedil: "\u0137",
        Kcy: "\u041A",
        kcy: "\u043A",
        Kfr: "\u{1D50E}",
        kfr: "\u{1D528}",
        kgreen: "\u0138",
        KHcy: "\u0425",
        khcy: "\u0445",
        KJcy: "\u040C",
        kjcy: "\u045C",
        Kopf: "\u{1D542}",
        kopf: "\u{1D55C}",
        Kscr: "\u{1D4A6}",
        kscr: "\u{1D4C0}",
        lAarr: "\u21DA",
        Lacute: "\u0139",
        lacute: "\u013A",
        laemptyv: "\u29B4",
        lagran: "\u2112",
        Lambda: "\u039B",
        lambda: "\u03BB",
        Lang: "\u27EA",
        lang: "\u27E8",
        langd: "\u2991",
        langle: "\u27E8",
        lap: "\u2A85",
        Laplacetrf: "\u2112",
        laquo: "\xAB",
        Larr: "\u219E",
        lArr: "\u21D0",
        larr: "\u2190",
        larrb: "\u21E4",
        larrbfs: "\u291F",
        larrfs: "\u291D",
        larrhk: "\u21A9",
        larrlp: "\u21AB",
        larrpl: "\u2939",
        larrsim: "\u2973",
        larrtl: "\u21A2",
        lat: "\u2AAB",
        lAtail: "\u291B",
        latail: "\u2919",
        late: "\u2AAD",
        lates: "\u2AAD\uFE00",
        lBarr: "\u290E",
        lbarr: "\u290C",
        lbbrk: "\u2772",
        lbrace: "{",
        lbrack: "[",
        lbrke: "\u298B",
        lbrksld: "\u298F",
        lbrkslu: "\u298D",
        Lcaron: "\u013D",
        lcaron: "\u013E",
        Lcedil: "\u013B",
        lcedil: "\u013C",
        lceil: "\u2308",
        lcub: "{",
        Lcy: "\u041B",
        lcy: "\u043B",
        ldca: "\u2936",
        ldquo: "\u201C",
        ldquor: "\u201E",
        ldrdhar: "\u2967",
        ldrushar: "\u294B",
        ldsh: "\u21B2",
        lE: "\u2266",
        le: "\u2264",
        LeftAngleBracket: "\u27E8",
        LeftArrow: "\u2190",
        Leftarrow: "\u21D0",
        leftarrow: "\u2190",
        LeftArrowBar: "\u21E4",
        LeftArrowRightArrow: "\u21C6",
        leftarrowtail: "\u21A2",
        LeftCeiling: "\u2308",
        LeftDoubleBracket: "\u27E6",
        LeftDownTeeVector: "\u2961",
        LeftDownVector: "\u21C3",
        LeftDownVectorBar: "\u2959",
        LeftFloor: "\u230A",
        leftharpoondown: "\u21BD",
        leftharpoonup: "\u21BC",
        leftleftarrows: "\u21C7",
        LeftRightArrow: "\u2194",
        Leftrightarrow: "\u21D4",
        leftrightarrow: "\u2194",
        leftrightarrows: "\u21C6",
        leftrightharpoons: "\u21CB",
        leftrightsquigarrow: "\u21AD",
        LeftRightVector: "\u294E",
        LeftTee: "\u22A3",
        LeftTeeArrow: "\u21A4",
        LeftTeeVector: "\u295A",
        leftthreetimes: "\u22CB",
        LeftTriangle: "\u22B2",
        LeftTriangleBar: "\u29CF",
        LeftTriangleEqual: "\u22B4",
        LeftUpDownVector: "\u2951",
        LeftUpTeeVector: "\u2960",
        LeftUpVector: "\u21BF",
        LeftUpVectorBar: "\u2958",
        LeftVector: "\u21BC",
        LeftVectorBar: "\u2952",
        lEg: "\u2A8B",
        leg: "\u22DA",
        leq: "\u2264",
        leqq: "\u2266",
        leqslant: "\u2A7D",
        les: "\u2A7D",
        lescc: "\u2AA8",
        lesdot: "\u2A7F",
        lesdoto: "\u2A81",
        lesdotor: "\u2A83",
        lesg: "\u22DA\uFE00",
        lesges: "\u2A93",
        lessapprox: "\u2A85",
        lessdot: "\u22D6",
        lesseqgtr: "\u22DA",
        lesseqqgtr: "\u2A8B",
        LessEqualGreater: "\u22DA",
        LessFullEqual: "\u2266",
        LessGreater: "\u2276",
        lessgtr: "\u2276",
        LessLess: "\u2AA1",
        lesssim: "\u2272",
        LessSlantEqual: "\u2A7D",
        LessTilde: "\u2272",
        lfisht: "\u297C",
        lfloor: "\u230A",
        Lfr: "\u{1D50F}",
        lfr: "\u{1D529}",
        lg: "\u2276",
        lgE: "\u2A91",
        lHar: "\u2962",
        lhard: "\u21BD",
        lharu: "\u21BC",
        lharul: "\u296A",
        lhblk: "\u2584",
        LJcy: "\u0409",
        ljcy: "\u0459",
        Ll: "\u22D8",
        ll: "\u226A",
        llarr: "\u21C7",
        llcorner: "\u231E",
        Lleftarrow: "\u21DA",
        llhard: "\u296B",
        lltri: "\u25FA",
        Lmidot: "\u013F",
        lmidot: "\u0140",
        lmoust: "\u23B0",
        lmoustache: "\u23B0",
        lnap: "\u2A89",
        lnapprox: "\u2A89",
        lnE: "\u2268",
        lne: "\u2A87",
        lneq: "\u2A87",
        lneqq: "\u2268",
        lnsim: "\u22E6",
        loang: "\u27EC",
        loarr: "\u21FD",
        lobrk: "\u27E6",
        LongLeftArrow: "\u27F5",
        Longleftarrow: "\u27F8",
        longleftarrow: "\u27F5",
        LongLeftRightArrow: "\u27F7",
        Longleftrightarrow: "\u27FA",
        longleftrightarrow: "\u27F7",
        longmapsto: "\u27FC",
        LongRightArrow: "\u27F6",
        Longrightarrow: "\u27F9",
        longrightarrow: "\u27F6",
        looparrowleft: "\u21AB",
        looparrowright: "\u21AC",
        lopar: "\u2985",
        Lopf: "\u{1D543}",
        lopf: "\u{1D55D}",
        loplus: "\u2A2D",
        lotimes: "\u2A34",
        lowast: "\u2217",
        lowbar: "_",
        LowerLeftArrow: "\u2199",
        LowerRightArrow: "\u2198",
        loz: "\u25CA",
        lozenge: "\u25CA",
        lozf: "\u29EB",
        lpar: "(",
        lparlt: "\u2993",
        lrarr: "\u21C6",
        lrcorner: "\u231F",
        lrhar: "\u21CB",
        lrhard: "\u296D",
        lrm: "\u200E",
        lrtri: "\u22BF",
        lsaquo: "\u2039",
        Lscr: "\u2112",
        lscr: "\u{1D4C1}",
        Lsh: "\u21B0",
        lsh: "\u21B0",
        lsim: "\u2272",
        lsime: "\u2A8D",
        lsimg: "\u2A8F",
        lsqb: "[",
        lsquo: "\u2018",
        lsquor: "\u201A",
        Lstrok: "\u0141",
        lstrok: "\u0142",
        Lt: "\u226A",
        LT: "<",
        lt: "<",
        ltcc: "\u2AA6",
        ltcir: "\u2A79",
        ltdot: "\u22D6",
        lthree: "\u22CB",
        ltimes: "\u22C9",
        ltlarr: "\u2976",
        ltquest: "\u2A7B",
        ltri: "\u25C3",
        ltrie: "\u22B4",
        ltrif: "\u25C2",
        ltrPar: "\u2996",
        lurdshar: "\u294A",
        luruhar: "\u2966",
        lvertneqq: "\u2268\uFE00",
        lvnE: "\u2268\uFE00",
        macr: "\xAF",
        male: "\u2642",
        malt: "\u2720",
        maltese: "\u2720",
        Map: "\u2905",
        map: "\u21A6",
        mapsto: "\u21A6",
        mapstodown: "\u21A7",
        mapstoleft: "\u21A4",
        mapstoup: "\u21A5",
        marker: "\u25AE",
        mcomma: "\u2A29",
        Mcy: "\u041C",
        mcy: "\u043C",
        mdash: "\u2014",
        mDDot: "\u223A",
        measuredangle: "\u2221",
        MediumSpace: "\u205F",
        Mellintrf: "\u2133",
        Mfr: "\u{1D510}",
        mfr: "\u{1D52A}",
        mho: "\u2127",
        micro: "\xB5",
        mid: "\u2223",
        midast: "*",
        midcir: "\u2AF0",
        middot: "\xB7",
        minus: "\u2212",
        minusb: "\u229F",
        minusd: "\u2238",
        minusdu: "\u2A2A",
        MinusPlus: "\u2213",
        mlcp: "\u2ADB",
        mldr: "\u2026",
        mnplus: "\u2213",
        models: "\u22A7",
        Mopf: "\u{1D544}",
        mopf: "\u{1D55E}",
        mp: "\u2213",
        Mscr: "\u2133",
        mscr: "\u{1D4C2}",
        mstpos: "\u223E",
        Mu: "\u039C",
        mu: "\u03BC",
        multimap: "\u22B8",
        mumap: "\u22B8",
        nabla: "\u2207",
        Nacute: "\u0143",
        nacute: "\u0144",
        nang: "\u2220\u20D2",
        nap: "\u2249",
        napE: "\u2A70\u0338",
        napid: "\u224B\u0338",
        napos: "\u0149",
        napprox: "\u2249",
        natur: "\u266E",
        natural: "\u266E",
        naturals: "\u2115",
        nbsp: "\xA0",
        nbump: "\u224E\u0338",
        nbumpe: "\u224F\u0338",
        ncap: "\u2A43",
        Ncaron: "\u0147",
        ncaron: "\u0148",
        Ncedil: "\u0145",
        ncedil: "\u0146",
        ncong: "\u2247",
        ncongdot: "\u2A6D\u0338",
        ncup: "\u2A42",
        Ncy: "\u041D",
        ncy: "\u043D",
        ndash: "\u2013",
        ne: "\u2260",
        nearhk: "\u2924",
        neArr: "\u21D7",
        nearr: "\u2197",
        nearrow: "\u2197",
        nedot: "\u2250\u0338",
        NegativeMediumSpace: "\u200B",
        NegativeThickSpace: "\u200B",
        NegativeThinSpace: "\u200B",
        NegativeVeryThinSpace: "\u200B",
        nequiv: "\u2262",
        nesear: "\u2928",
        nesim: "\u2242\u0338",
        NestedGreaterGreater: "\u226B",
        NestedLessLess: "\u226A",
        NewLine: "\n",
        nexist: "\u2204",
        nexists: "\u2204",
        Nfr: "\u{1D511}",
        nfr: "\u{1D52B}",
        ngE: "\u2267\u0338",
        nge: "\u2271",
        ngeq: "\u2271",
        ngeqq: "\u2267\u0338",
        ngeqslant: "\u2A7E\u0338",
        nges: "\u2A7E\u0338",
        nGg: "\u22D9\u0338",
        ngsim: "\u2275",
        nGt: "\u226B\u20D2",
        ngt: "\u226F",
        ngtr: "\u226F",
        nGtv: "\u226B\u0338",
        nhArr: "\u21CE",
        nharr: "\u21AE",
        nhpar: "\u2AF2",
        ni: "\u220B",
        nis: "\u22FC",
        nisd: "\u22FA",
        niv: "\u220B",
        NJcy: "\u040A",
        njcy: "\u045A",
        nlArr: "\u21CD",
        nlarr: "\u219A",
        nldr: "\u2025",
        nlE: "\u2266\u0338",
        nle: "\u2270",
        nLeftarrow: "\u21CD",
        nleftarrow: "\u219A",
        nLeftrightarrow: "\u21CE",
        nleftrightarrow: "\u21AE",
        nleq: "\u2270",
        nleqq: "\u2266\u0338",
        nleqslant: "\u2A7D\u0338",
        nles: "\u2A7D\u0338",
        nless: "\u226E",
        nLl: "\u22D8\u0338",
        nlsim: "\u2274",
        nLt: "\u226A\u20D2",
        nlt: "\u226E",
        nltri: "\u22EA",
        nltrie: "\u22EC",
        nLtv: "\u226A\u0338",
        nmid: "\u2224",
        NoBreak: "\u2060",
        NonBreakingSpace: "\xA0",
        Nopf: "\u2115",
        nopf: "\u{1D55F}",
        Not: "\u2AEC",
        not: "\xAC",
        NotCongruent: "\u2262",
        NotCupCap: "\u226D",
        NotDoubleVerticalBar: "\u2226",
        NotElement: "\u2209",
        NotEqual: "\u2260",
        NotEqualTilde: "\u2242\u0338",
        NotExists: "\u2204",
        NotGreater: "\u226F",
        NotGreaterEqual: "\u2271",
        NotGreaterFullEqual: "\u2267\u0338",
        NotGreaterGreater: "\u226B\u0338",
        NotGreaterLess: "\u2279",
        NotGreaterSlantEqual: "\u2A7E\u0338",
        NotGreaterTilde: "\u2275",
        NotHumpDownHump: "\u224E\u0338",
        NotHumpEqual: "\u224F\u0338",
        notin: "\u2209",
        notindot: "\u22F5\u0338",
        notinE: "\u22F9\u0338",
        notinva: "\u2209",
        notinvb: "\u22F7",
        notinvc: "\u22F6",
        NotLeftTriangle: "\u22EA",
        NotLeftTriangleBar: "\u29CF\u0338",
        NotLeftTriangleEqual: "\u22EC",
        NotLess: "\u226E",
        NotLessEqual: "\u2270",
        NotLessGreater: "\u2278",
        NotLessLess: "\u226A\u0338",
        NotLessSlantEqual: "\u2A7D\u0338",
        NotLessTilde: "\u2274",
        NotNestedGreaterGreater: "\u2AA2\u0338",
        NotNestedLessLess: "\u2AA1\u0338",
        notni: "\u220C",
        notniva: "\u220C",
        notnivb: "\u22FE",
        notnivc: "\u22FD",
        NotPrecedes: "\u2280",
        NotPrecedesEqual: "\u2AAF\u0338",
        NotPrecedesSlantEqual: "\u22E0",
        NotReverseElement: "\u220C",
        NotRightTriangle: "\u22EB",
        NotRightTriangleBar: "\u29D0\u0338",
        NotRightTriangleEqual: "\u22ED",
        NotSquareSubset: "\u228F\u0338",
        NotSquareSubsetEqual: "\u22E2",
        NotSquareSuperset: "\u2290\u0338",
        NotSquareSupersetEqual: "\u22E3",
        NotSubset: "\u2282\u20D2",
        NotSubsetEqual: "\u2288",
        NotSucceeds: "\u2281",
        NotSucceedsEqual: "\u2AB0\u0338",
        NotSucceedsSlantEqual: "\u22E1",
        NotSucceedsTilde: "\u227F\u0338",
        NotSuperset: "\u2283\u20D2",
        NotSupersetEqual: "\u2289",
        NotTilde: "\u2241",
        NotTildeEqual: "\u2244",
        NotTildeFullEqual: "\u2247",
        NotTildeTilde: "\u2249",
        NotVerticalBar: "\u2224",
        npar: "\u2226",
        nparallel: "\u2226",
        nparsl: "\u2AFD\u20E5",
        npart: "\u2202\u0338",
        npolint: "\u2A14",
        npr: "\u2280",
        nprcue: "\u22E0",
        npre: "\u2AAF\u0338",
        nprec: "\u2280",
        npreceq: "\u2AAF\u0338",
        nrArr: "\u21CF",
        nrarr: "\u219B",
        nrarrc: "\u2933\u0338",
        nrarrw: "\u219D\u0338",
        nRightarrow: "\u21CF",
        nrightarrow: "\u219B",
        nrtri: "\u22EB",
        nrtrie: "\u22ED",
        nsc: "\u2281",
        nsccue: "\u22E1",
        nsce: "\u2AB0\u0338",
        Nscr: "\u{1D4A9}",
        nscr: "\u{1D4C3}",
        nshortmid: "\u2224",
        nshortparallel: "\u2226",
        nsim: "\u2241",
        nsime: "\u2244",
        nsimeq: "\u2244",
        nsmid: "\u2224",
        nspar: "\u2226",
        nsqsube: "\u22E2",
        nsqsupe: "\u22E3",
        nsub: "\u2284",
        nsubE: "\u2AC5\u0338",
        nsube: "\u2288",
        nsubset: "\u2282\u20D2",
        nsubseteq: "\u2288",
        nsubseteqq: "\u2AC5\u0338",
        nsucc: "\u2281",
        nsucceq: "\u2AB0\u0338",
        nsup: "\u2285",
        nsupE: "\u2AC6\u0338",
        nsupe: "\u2289",
        nsupset: "\u2283\u20D2",
        nsupseteq: "\u2289",
        nsupseteqq: "\u2AC6\u0338",
        ntgl: "\u2279",
        Ntilde: "\xD1",
        ntilde: "\xF1",
        ntlg: "\u2278",
        ntriangleleft: "\u22EA",
        ntrianglelefteq: "\u22EC",
        ntriangleright: "\u22EB",
        ntrianglerighteq: "\u22ED",
        Nu: "\u039D",
        nu: "\u03BD",
        num: "#",
        numero: "\u2116",
        numsp: "\u2007",
        nvap: "\u224D\u20D2",
        nVDash: "\u22AF",
        nVdash: "\u22AE",
        nvDash: "\u22AD",
        nvdash: "\u22AC",
        nvge: "\u2265\u20D2",
        nvgt: ">\u20D2",
        nvHarr: "\u2904",
        nvinfin: "\u29DE",
        nvlArr: "\u2902",
        nvle: "\u2264\u20D2",
        nvlt: "<\u20D2",
        nvltrie: "\u22B4\u20D2",
        nvrArr: "\u2903",
        nvrtrie: "\u22B5\u20D2",
        nvsim: "\u223C\u20D2",
        nwarhk: "\u2923",
        nwArr: "\u21D6",
        nwarr: "\u2196",
        nwarrow: "\u2196",
        nwnear: "\u2927",
        Oacute: "\xD3",
        oacute: "\xF3",
        oast: "\u229B",
        ocir: "\u229A",
        Ocirc: "\xD4",
        ocirc: "\xF4",
        Ocy: "\u041E",
        ocy: "\u043E",
        odash: "\u229D",
        Odblac: "\u0150",
        odblac: "\u0151",
        odiv: "\u2A38",
        odot: "\u2299",
        odsold: "\u29BC",
        OElig: "\u0152",
        oelig: "\u0153",
        ofcir: "\u29BF",
        Ofr: "\u{1D512}",
        ofr: "\u{1D52C}",
        ogon: "\u02DB",
        Ograve: "\xD2",
        ograve: "\xF2",
        ogt: "\u29C1",
        ohbar: "\u29B5",
        ohm: "\u03A9",
        oint: "\u222E",
        olarr: "\u21BA",
        olcir: "\u29BE",
        olcross: "\u29BB",
        oline: "\u203E",
        olt: "\u29C0",
        Omacr: "\u014C",
        omacr: "\u014D",
        Omega: "\u03A9",
        omega: "\u03C9",
        Omicron: "\u039F",
        omicron: "\u03BF",
        omid: "\u29B6",
        ominus: "\u2296",
        Oopf: "\u{1D546}",
        oopf: "\u{1D560}",
        opar: "\u29B7",
        OpenCurlyDoubleQuote: "\u201C",
        OpenCurlyQuote: "\u2018",
        operp: "\u29B9",
        oplus: "\u2295",
        Or: "\u2A54",
        or: "\u2228",
        orarr: "\u21BB",
        ord: "\u2A5D",
        order: "\u2134",
        orderof: "\u2134",
        ordf: "\xAA",
        ordm: "\xBA",
        origof: "\u22B6",
        oror: "\u2A56",
        orslope: "\u2A57",
        orv: "\u2A5B",
        oS: "\u24C8",
        Oscr: "\u{1D4AA}",
        oscr: "\u2134",
        Oslash: "\xD8",
        oslash: "\xF8",
        osol: "\u2298",
        Otilde: "\xD5",
        otilde: "\xF5",
        Otimes: "\u2A37",
        otimes: "\u2297",
        otimesas: "\u2A36",
        Ouml: "\xD6",
        ouml: "\xF6",
        ovbar: "\u233D",
        OverBar: "\u203E",
        OverBrace: "\u23DE",
        OverBracket: "\u23B4",
        OverParenthesis: "\u23DC",
        par: "\u2225",
        para: "\xB6",
        parallel: "\u2225",
        parsim: "\u2AF3",
        parsl: "\u2AFD",
        part: "\u2202",
        PartialD: "\u2202",
        Pcy: "\u041F",
        pcy: "\u043F",
        percnt: "%",
        period: ".",
        permil: "\u2030",
        perp: "\u22A5",
        pertenk: "\u2031",
        Pfr: "\u{1D513}",
        pfr: "\u{1D52D}",
        Phi: "\u03A6",
        phi: "\u03C6",
        phiv: "\u03D5",
        phmmat: "\u2133",
        phone: "\u260E",
        Pi: "\u03A0",
        pi: "\u03C0",
        pitchfork: "\u22D4",
        piv: "\u03D6",
        planck: "\u210F",
        planckh: "\u210E",
        plankv: "\u210F",
        plus: "+",
        plusacir: "\u2A23",
        plusb: "\u229E",
        pluscir: "\u2A22",
        plusdo: "\u2214",
        plusdu: "\u2A25",
        pluse: "\u2A72",
        PlusMinus: "\xB1",
        plusmn: "\xB1",
        plussim: "\u2A26",
        plustwo: "\u2A27",
        pm: "\xB1",
        Poincareplane: "\u210C",
        pointint: "\u2A15",
        Popf: "\u2119",
        popf: "\u{1D561}",
        pound: "\xA3",
        Pr: "\u2ABB",
        pr: "\u227A",
        prap: "\u2AB7",
        prcue: "\u227C",
        prE: "\u2AB3",
        pre: "\u2AAF",
        prec: "\u227A",
        precapprox: "\u2AB7",
        preccurlyeq: "\u227C",
        Precedes: "\u227A",
        PrecedesEqual: "\u2AAF",
        PrecedesSlantEqual: "\u227C",
        PrecedesTilde: "\u227E",
        preceq: "\u2AAF",
        precnapprox: "\u2AB9",
        precneqq: "\u2AB5",
        precnsim: "\u22E8",
        precsim: "\u227E",
        Prime: "\u2033",
        prime: "\u2032",
        primes: "\u2119",
        prnap: "\u2AB9",
        prnE: "\u2AB5",
        prnsim: "\u22E8",
        prod: "\u220F",
        Product: "\u220F",
        profalar: "\u232E",
        profline: "\u2312",
        profsurf: "\u2313",
        prop: "\u221D",
        Proportion: "\u2237",
        Proportional: "\u221D",
        propto: "\u221D",
        prsim: "\u227E",
        prurel: "\u22B0",
        Pscr: "\u{1D4AB}",
        pscr: "\u{1D4C5}",
        Psi: "\u03A8",
        psi: "\u03C8",
        puncsp: "\u2008",
        Qfr: "\u{1D514}",
        qfr: "\u{1D52E}",
        qint: "\u2A0C",
        Qopf: "\u211A",
        qopf: "\u{1D562}",
        qprime: "\u2057",
        Qscr: "\u{1D4AC}",
        qscr: "\u{1D4C6}",
        quaternions: "\u210D",
        quatint: "\u2A16",
        quest: "?",
        questeq: "\u225F",
        QUOT: '"',
        quot: '"',
        rAarr: "\u21DB",
        race: "\u223D\u0331",
        Racute: "\u0154",
        racute: "\u0155",
        radic: "\u221A",
        raemptyv: "\u29B3",
        Rang: "\u27EB",
        rang: "\u27E9",
        rangd: "\u2992",
        range: "\u29A5",
        rangle: "\u27E9",
        raquo: "\xBB",
        Rarr: "\u21A0",
        rArr: "\u21D2",
        rarr: "\u2192",
        rarrap: "\u2975",
        rarrb: "\u21E5",
        rarrbfs: "\u2920",
        rarrc: "\u2933",
        rarrfs: "\u291E",
        rarrhk: "\u21AA",
        rarrlp: "\u21AC",
        rarrpl: "\u2945",
        rarrsim: "\u2974",
        Rarrtl: "\u2916",
        rarrtl: "\u21A3",
        rarrw: "\u219D",
        rAtail: "\u291C",
        ratail: "\u291A",
        ratio: "\u2236",
        rationals: "\u211A",
        RBarr: "\u2910",
        rBarr: "\u290F",
        rbarr: "\u290D",
        rbbrk: "\u2773",
        rbrace: "}",
        rbrack: "]",
        rbrke: "\u298C",
        rbrksld: "\u298E",
        rbrkslu: "\u2990",
        Rcaron: "\u0158",
        rcaron: "\u0159",
        Rcedil: "\u0156",
        rcedil: "\u0157",
        rceil: "\u2309",
        rcub: "}",
        Rcy: "\u0420",
        rcy: "\u0440",
        rdca: "\u2937",
        rdldhar: "\u2969",
        rdquo: "\u201D",
        rdquor: "\u201D",
        rdsh: "\u21B3",
        Re: "\u211C",
        real: "\u211C",
        realine: "\u211B",
        realpart: "\u211C",
        reals: "\u211D",
        rect: "\u25AD",
        REG: "\xAE",
        reg: "\xAE",
        ReverseElement: "\u220B",
        ReverseEquilibrium: "\u21CB",
        ReverseUpEquilibrium: "\u296F",
        rfisht: "\u297D",
        rfloor: "\u230B",
        Rfr: "\u211C",
        rfr: "\u{1D52F}",
        rHar: "\u2964",
        rhard: "\u21C1",
        rharu: "\u21C0",
        rharul: "\u296C",
        Rho: "\u03A1",
        rho: "\u03C1",
        rhov: "\u03F1",
        RightAngleBracket: "\u27E9",
        RightArrow: "\u2192",
        Rightarrow: "\u21D2",
        rightarrow: "\u2192",
        RightArrowBar: "\u21E5",
        RightArrowLeftArrow: "\u21C4",
        rightarrowtail: "\u21A3",
        RightCeiling: "\u2309",
        RightDoubleBracket: "\u27E7",
        RightDownTeeVector: "\u295D",
        RightDownVector: "\u21C2",
        RightDownVectorBar: "\u2955",
        RightFloor: "\u230B",
        rightharpoondown: "\u21C1",
        rightharpoonup: "\u21C0",
        rightleftarrows: "\u21C4",
        rightleftharpoons: "\u21CC",
        rightrightarrows: "\u21C9",
        rightsquigarrow: "\u219D",
        RightTee: "\u22A2",
        RightTeeArrow: "\u21A6",
        RightTeeVector: "\u295B",
        rightthreetimes: "\u22CC",
        RightTriangle: "\u22B3",
        RightTriangleBar: "\u29D0",
        RightTriangleEqual: "\u22B5",
        RightUpDownVector: "\u294F",
        RightUpTeeVector: "\u295C",
        RightUpVector: "\u21BE",
        RightUpVectorBar: "\u2954",
        RightVector: "\u21C0",
        RightVectorBar: "\u2953",
        ring: "\u02DA",
        risingdotseq: "\u2253",
        rlarr: "\u21C4",
        rlhar: "\u21CC",
        rlm: "\u200F",
        rmoust: "\u23B1",
        rmoustache: "\u23B1",
        rnmid: "\u2AEE",
        roang: "\u27ED",
        roarr: "\u21FE",
        robrk: "\u27E7",
        ropar: "\u2986",
        Ropf: "\u211D",
        ropf: "\u{1D563}",
        roplus: "\u2A2E",
        rotimes: "\u2A35",
        RoundImplies: "\u2970",
        rpar: ")",
        rpargt: "\u2994",
        rppolint: "\u2A12",
        rrarr: "\u21C9",
        Rrightarrow: "\u21DB",
        rsaquo: "\u203A",
        Rscr: "\u211B",
        rscr: "\u{1D4C7}",
        Rsh: "\u21B1",
        rsh: "\u21B1",
        rsqb: "]",
        rsquo: "\u2019",
        rsquor: "\u2019",
        rthree: "\u22CC",
        rtimes: "\u22CA",
        rtri: "\u25B9",
        rtrie: "\u22B5",
        rtrif: "\u25B8",
        rtriltri: "\u29CE",
        RuleDelayed: "\u29F4",
        ruluhar: "\u2968",
        rx: "\u211E",
        Sacute: "\u015A",
        sacute: "\u015B",
        sbquo: "\u201A",
        Sc: "\u2ABC",
        sc: "\u227B",
        scap: "\u2AB8",
        Scaron: "\u0160",
        scaron: "\u0161",
        sccue: "\u227D",
        scE: "\u2AB4",
        sce: "\u2AB0",
        Scedil: "\u015E",
        scedil: "\u015F",
        Scirc: "\u015C",
        scirc: "\u015D",
        scnap: "\u2ABA",
        scnE: "\u2AB6",
        scnsim: "\u22E9",
        scpolint: "\u2A13",
        scsim: "\u227F",
        Scy: "\u0421",
        scy: "\u0441",
        sdot: "\u22C5",
        sdotb: "\u22A1",
        sdote: "\u2A66",
        searhk: "\u2925",
        seArr: "\u21D8",
        searr: "\u2198",
        searrow: "\u2198",
        sect: "\xA7",
        semi: ";",
        seswar: "\u2929",
        setminus: "\u2216",
        setmn: "\u2216",
        sext: "\u2736",
        Sfr: "\u{1D516}",
        sfr: "\u{1D530}",
        sfrown: "\u2322",
        sharp: "\u266F",
        SHCHcy: "\u0429",
        shchcy: "\u0449",
        SHcy: "\u0428",
        shcy: "\u0448",
        ShortDownArrow: "\u2193",
        ShortLeftArrow: "\u2190",
        shortmid: "\u2223",
        shortparallel: "\u2225",
        ShortRightArrow: "\u2192",
        ShortUpArrow: "\u2191",
        shy: "\xAD",
        Sigma: "\u03A3",
        sigma: "\u03C3",
        sigmaf: "\u03C2",
        sigmav: "\u03C2",
        sim: "\u223C",
        simdot: "\u2A6A",
        sime: "\u2243",
        simeq: "\u2243",
        simg: "\u2A9E",
        simgE: "\u2AA0",
        siml: "\u2A9D",
        simlE: "\u2A9F",
        simne: "\u2246",
        simplus: "\u2A24",
        simrarr: "\u2972",
        slarr: "\u2190",
        SmallCircle: "\u2218",
        smallsetminus: "\u2216",
        smashp: "\u2A33",
        smeparsl: "\u29E4",
        smid: "\u2223",
        smile: "\u2323",
        smt: "\u2AAA",
        smte: "\u2AAC",
        smtes: "\u2AAC\uFE00",
        SOFTcy: "\u042C",
        softcy: "\u044C",
        sol: "/",
        solb: "\u29C4",
        solbar: "\u233F",
        Sopf: "\u{1D54A}",
        sopf: "\u{1D564}",
        spades: "\u2660",
        spadesuit: "\u2660",
        spar: "\u2225",
        sqcap: "\u2293",
        sqcaps: "\u2293\uFE00",
        sqcup: "\u2294",
        sqcups: "\u2294\uFE00",
        Sqrt: "\u221A",
        sqsub: "\u228F",
        sqsube: "\u2291",
        sqsubset: "\u228F",
        sqsubseteq: "\u2291",
        sqsup: "\u2290",
        sqsupe: "\u2292",
        sqsupset: "\u2290",
        sqsupseteq: "\u2292",
        squ: "\u25A1",
        Square: "\u25A1",
        square: "\u25A1",
        SquareIntersection: "\u2293",
        SquareSubset: "\u228F",
        SquareSubsetEqual: "\u2291",
        SquareSuperset: "\u2290",
        SquareSupersetEqual: "\u2292",
        SquareUnion: "\u2294",
        squarf: "\u25AA",
        squf: "\u25AA",
        srarr: "\u2192",
        Sscr: "\u{1D4AE}",
        sscr: "\u{1D4C8}",
        ssetmn: "\u2216",
        ssmile: "\u2323",
        sstarf: "\u22C6",
        Star: "\u22C6",
        star: "\u2606",
        starf: "\u2605",
        straightepsilon: "\u03F5",
        straightphi: "\u03D5",
        strns: "\xAF",
        Sub: "\u22D0",
        sub: "\u2282",
        subdot: "\u2ABD",
        subE: "\u2AC5",
        sube: "\u2286",
        subedot: "\u2AC3",
        submult: "\u2AC1",
        subnE: "\u2ACB",
        subne: "\u228A",
        subplus: "\u2ABF",
        subrarr: "\u2979",
        Subset: "\u22D0",
        subset: "\u2282",
        subseteq: "\u2286",
        subseteqq: "\u2AC5",
        SubsetEqual: "\u2286",
        subsetneq: "\u228A",
        subsetneqq: "\u2ACB",
        subsim: "\u2AC7",
        subsub: "\u2AD5",
        subsup: "\u2AD3",
        succ: "\u227B",
        succapprox: "\u2AB8",
        succcurlyeq: "\u227D",
        Succeeds: "\u227B",
        SucceedsEqual: "\u2AB0",
        SucceedsSlantEqual: "\u227D",
        SucceedsTilde: "\u227F",
        succeq: "\u2AB0",
        succnapprox: "\u2ABA",
        succneqq: "\u2AB6",
        succnsim: "\u22E9",
        succsim: "\u227F",
        SuchThat: "\u220B",
        Sum: "\u2211",
        sum: "\u2211",
        sung: "\u266A",
        Sup: "\u22D1",
        sup: "\u2283",
        sup1: "\xB9",
        sup2: "\xB2",
        sup3: "\xB3",
        supdot: "\u2ABE",
        supdsub: "\u2AD8",
        supE: "\u2AC6",
        supe: "\u2287",
        supedot: "\u2AC4",
        Superset: "\u2283",
        SupersetEqual: "\u2287",
        suphsol: "\u27C9",
        suphsub: "\u2AD7",
        suplarr: "\u297B",
        supmult: "\u2AC2",
        supnE: "\u2ACC",
        supne: "\u228B",
        supplus: "\u2AC0",
        Supset: "\u22D1",
        supset: "\u2283",
        supseteq: "\u2287",
        supseteqq: "\u2AC6",
        supsetneq: "\u228B",
        supsetneqq: "\u2ACC",
        supsim: "\u2AC8",
        supsub: "\u2AD4",
        supsup: "\u2AD6",
        swarhk: "\u2926",
        swArr: "\u21D9",
        swarr: "\u2199",
        swarrow: "\u2199",
        swnwar: "\u292A",
        szlig: "\xDF",
        Tab: "	",
        target: "\u2316",
        Tau: "\u03A4",
        tau: "\u03C4",
        tbrk: "\u23B4",
        Tcaron: "\u0164",
        tcaron: "\u0165",
        Tcedil: "\u0162",
        tcedil: "\u0163",
        Tcy: "\u0422",
        tcy: "\u0442",
        tdot: "\u20DB",
        telrec: "\u2315",
        Tfr: "\u{1D517}",
        tfr: "\u{1D531}",
        there4: "\u2234",
        Therefore: "\u2234",
        therefore: "\u2234",
        Theta: "\u0398",
        theta: "\u03B8",
        thetasym: "\u03D1",
        thetav: "\u03D1",
        thickapprox: "\u2248",
        thicksim: "\u223C",
        ThickSpace: "\u205F\u200A",
        thinsp: "\u2009",
        ThinSpace: "\u2009",
        thkap: "\u2248",
        thksim: "\u223C",
        THORN: "\xDE",
        thorn: "\xFE",
        Tilde: "\u223C",
        tilde: "\u02DC",
        TildeEqual: "\u2243",
        TildeFullEqual: "\u2245",
        TildeTilde: "\u2248",
        times: "\xD7",
        timesb: "\u22A0",
        timesbar: "\u2A31",
        timesd: "\u2A30",
        tint: "\u222D",
        toea: "\u2928",
        top: "\u22A4",
        topbot: "\u2336",
        topcir: "\u2AF1",
        Topf: "\u{1D54B}",
        topf: "\u{1D565}",
        topfork: "\u2ADA",
        tosa: "\u2929",
        tprime: "\u2034",
        TRADE: "\u2122",
        trade: "\u2122",
        triangle: "\u25B5",
        triangledown: "\u25BF",
        triangleleft: "\u25C3",
        trianglelefteq: "\u22B4",
        triangleq: "\u225C",
        triangleright: "\u25B9",
        trianglerighteq: "\u22B5",
        tridot: "\u25EC",
        trie: "\u225C",
        triminus: "\u2A3A",
        TripleDot: "\u20DB",
        triplus: "\u2A39",
        trisb: "\u29CD",
        tritime: "\u2A3B",
        trpezium: "\u23E2",
        Tscr: "\u{1D4AF}",
        tscr: "\u{1D4C9}",
        TScy: "\u0426",
        tscy: "\u0446",
        TSHcy: "\u040B",
        tshcy: "\u045B",
        Tstrok: "\u0166",
        tstrok: "\u0167",
        twixt: "\u226C",
        twoheadleftarrow: "\u219E",
        twoheadrightarrow: "\u21A0",
        Uacute: "\xDA",
        uacute: "\xFA",
        Uarr: "\u219F",
        uArr: "\u21D1",
        uarr: "\u2191",
        Uarrocir: "\u2949",
        Ubrcy: "\u040E",
        ubrcy: "\u045E",
        Ubreve: "\u016C",
        ubreve: "\u016D",
        Ucirc: "\xDB",
        ucirc: "\xFB",
        Ucy: "\u0423",
        ucy: "\u0443",
        udarr: "\u21C5",
        Udblac: "\u0170",
        udblac: "\u0171",
        udhar: "\u296E",
        ufisht: "\u297E",
        Ufr: "\u{1D518}",
        ufr: "\u{1D532}",
        Ugrave: "\xD9",
        ugrave: "\xF9",
        uHar: "\u2963",
        uharl: "\u21BF",
        uharr: "\u21BE",
        uhblk: "\u2580",
        ulcorn: "\u231C",
        ulcorner: "\u231C",
        ulcrop: "\u230F",
        ultri: "\u25F8",
        Umacr: "\u016A",
        umacr: "\u016B",
        uml: "\xA8",
        UnderBar: "_",
        UnderBrace: "\u23DF",
        UnderBracket: "\u23B5",
        UnderParenthesis: "\u23DD",
        Union: "\u22C3",
        UnionPlus: "\u228E",
        Uogon: "\u0172",
        uogon: "\u0173",
        Uopf: "\u{1D54C}",
        uopf: "\u{1D566}",
        UpArrow: "\u2191",
        Uparrow: "\u21D1",
        uparrow: "\u2191",
        UpArrowBar: "\u2912",
        UpArrowDownArrow: "\u21C5",
        UpDownArrow: "\u2195",
        Updownarrow: "\u21D5",
        updownarrow: "\u2195",
        UpEquilibrium: "\u296E",
        upharpoonleft: "\u21BF",
        upharpoonright: "\u21BE",
        uplus: "\u228E",
        UpperLeftArrow: "\u2196",
        UpperRightArrow: "\u2197",
        Upsi: "\u03D2",
        upsi: "\u03C5",
        upsih: "\u03D2",
        Upsilon: "\u03A5",
        upsilon: "\u03C5",
        UpTee: "\u22A5",
        UpTeeArrow: "\u21A5",
        upuparrows: "\u21C8",
        urcorn: "\u231D",
        urcorner: "\u231D",
        urcrop: "\u230E",
        Uring: "\u016E",
        uring: "\u016F",
        urtri: "\u25F9",
        Uscr: "\u{1D4B0}",
        uscr: "\u{1D4CA}",
        utdot: "\u22F0",
        Utilde: "\u0168",
        utilde: "\u0169",
        utri: "\u25B5",
        utrif: "\u25B4",
        uuarr: "\u21C8",
        Uuml: "\xDC",
        uuml: "\xFC",
        uwangle: "\u29A7",
        vangrt: "\u299C",
        varepsilon: "\u03F5",
        varkappa: "\u03F0",
        varnothing: "\u2205",
        varphi: "\u03D5",
        varpi: "\u03D6",
        varpropto: "\u221D",
        vArr: "\u21D5",
        varr: "\u2195",
        varrho: "\u03F1",
        varsigma: "\u03C2",
        varsubsetneq: "\u228A\uFE00",
        varsubsetneqq: "\u2ACB\uFE00",
        varsupsetneq: "\u228B\uFE00",
        varsupsetneqq: "\u2ACC\uFE00",
        vartheta: "\u03D1",
        vartriangleleft: "\u22B2",
        vartriangleright: "\u22B3",
        Vbar: "\u2AEB",
        vBar: "\u2AE8",
        vBarv: "\u2AE9",
        Vcy: "\u0412",
        vcy: "\u0432",
        VDash: "\u22AB",
        Vdash: "\u22A9",
        vDash: "\u22A8",
        vdash: "\u22A2",
        Vdashl: "\u2AE6",
        Vee: "\u22C1",
        vee: "\u2228",
        veebar: "\u22BB",
        veeeq: "\u225A",
        vellip: "\u22EE",
        Verbar: "\u2016",
        verbar: "|",
        Vert: "\u2016",
        vert: "|",
        VerticalBar: "\u2223",
        VerticalLine: "|",
        VerticalSeparator: "\u2758",
        VerticalTilde: "\u2240",
        VeryThinSpace: "\u200A",
        Vfr: "\u{1D519}",
        vfr: "\u{1D533}",
        vltri: "\u22B2",
        vnsub: "\u2282\u20D2",
        vnsup: "\u2283\u20D2",
        Vopf: "\u{1D54D}",
        vopf: "\u{1D567}",
        vprop: "\u221D",
        vrtri: "\u22B3",
        Vscr: "\u{1D4B1}",
        vscr: "\u{1D4CB}",
        vsubnE: "\u2ACB\uFE00",
        vsubne: "\u228A\uFE00",
        vsupnE: "\u2ACC\uFE00",
        vsupne: "\u228B\uFE00",
        Vvdash: "\u22AA",
        vzigzag: "\u299A",
        Wcirc: "\u0174",
        wcirc: "\u0175",
        wedbar: "\u2A5F",
        Wedge: "\u22C0",
        wedge: "\u2227",
        wedgeq: "\u2259",
        weierp: "\u2118",
        Wfr: "\u{1D51A}",
        wfr: "\u{1D534}",
        Wopf: "\u{1D54E}",
        wopf: "\u{1D568}",
        wp: "\u2118",
        wr: "\u2240",
        wreath: "\u2240",
        Wscr: "\u{1D4B2}",
        wscr: "\u{1D4CC}",
        xcap: "\u22C2",
        xcirc: "\u25EF",
        xcup: "\u22C3",
        xdtri: "\u25BD",
        Xfr: "\u{1D51B}",
        xfr: "\u{1D535}",
        xhArr: "\u27FA",
        xharr: "\u27F7",
        Xi: "\u039E",
        xi: "\u03BE",
        xlArr: "\u27F8",
        xlarr: "\u27F5",
        xmap: "\u27FC",
        xnis: "\u22FB",
        xodot: "\u2A00",
        Xopf: "\u{1D54F}",
        xopf: "\u{1D569}",
        xoplus: "\u2A01",
        xotime: "\u2A02",
        xrArr: "\u27F9",
        xrarr: "\u27F6",
        Xscr: "\u{1D4B3}",
        xscr: "\u{1D4CD}",
        xsqcup: "\u2A06",
        xuplus: "\u2A04",
        xutri: "\u25B3",
        xvee: "\u22C1",
        xwedge: "\u22C0",
        Yacute: "\xDD",
        yacute: "\xFD",
        YAcy: "\u042F",
        yacy: "\u044F",
        Ycirc: "\u0176",
        ycirc: "\u0177",
        Ycy: "\u042B",
        ycy: "\u044B",
        yen: "\xA5",
        Yfr: "\u{1D51C}",
        yfr: "\u{1D536}",
        YIcy: "\u0407",
        yicy: "\u0457",
        Yopf: "\u{1D550}",
        yopf: "\u{1D56A}",
        Yscr: "\u{1D4B4}",
        yscr: "\u{1D4CE}",
        YUcy: "\u042E",
        yucy: "\u044E",
        Yuml: "\u0178",
        yuml: "\xFF",
        Zacute: "\u0179",
        zacute: "\u017A",
        Zcaron: "\u017D",
        zcaron: "\u017E",
        Zcy: "\u0417",
        zcy: "\u0437",
        Zdot: "\u017B",
        zdot: "\u017C",
        zeetrf: "\u2128",
        ZeroWidthSpace: "\u200B",
        Zeta: "\u0396",
        zeta: "\u03B6",
        Zfr: "\u2128",
        zfr: "\u{1D537}",
        ZHcy: "\u0416",
        zhcy: "\u0436",
        zigrarr: "\u21DD",
        Zopf: "\u2124",
        zopf: "\u{1D56B}",
        Zscr: "\u{1D4B5}",
        zscr: "\u{1D4CF}",
        zwj: "\u200D",
        zwnj: "\u200C"
      });
      exports.entityMap = exports.HTML_ENTITIES;
    }
  });

  // ../library_management/node_modules/@xmldom/xmldom/lib/sax.js
  var require_sax = __commonJS({
    "../library_management/node_modules/@xmldom/xmldom/lib/sax.js"(exports) {
      var NAMESPACE = require_conventions().NAMESPACE;
      var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
      var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
      var S_TAG = 0;
      var S_ATTR = 1;
      var S_ATTR_SPACE = 2;
      var S_EQ = 3;
      var S_ATTR_NOQUOT_VALUE = 4;
      var S_ATTR_END = 5;
      var S_TAG_SPACE = 6;
      var S_TAG_CLOSE = 7;
      function ParseError(message, locator) {
        this.message = message;
        this.locator = locator;
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, ParseError);
      }
      ParseError.prototype = new Error();
      ParseError.prototype.name = ParseError.name;
      function XMLReader() {
      }
      XMLReader.prototype = {
        parse: function(source, defaultNSMap, entityMap) {
          var domBuilder = this.domBuilder;
          domBuilder.startDocument();
          _copy(defaultNSMap, defaultNSMap = {});
          parse3(
            source,
            defaultNSMap,
            entityMap,
            domBuilder,
            this.errorHandler
          );
          domBuilder.endDocument();
        }
      };
      function parse3(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
        function fixedFromCharCode(code) {
          if (code > 65535) {
            code -= 65536;
            var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
            return String.fromCharCode(surrogate1, surrogate2);
          } else {
            return String.fromCharCode(code);
          }
        }
        function entityReplacer(a2) {
          var k = a2.slice(1, -1);
          if (k in entityMap) {
            return entityMap[k];
          } else if (k.charAt(0) === "#") {
            return fixedFromCharCode(parseInt(k.substr(1).replace("x", "0x")));
          } else {
            errorHandler.error("entity not found:" + a2);
            return a2;
          }
        }
        function appendText(end2) {
          if (end2 > start) {
            var xt = source.substring(start, end2).replace(/&#?\w+;/g, entityReplacer);
            locator && position(start);
            domBuilder.characters(xt, 0, end2 - start);
            start = end2;
          }
        }
        function position(p2, m) {
          while (p2 >= lineEnd && (m = linePattern.exec(source))) {
            lineStart = m.index;
            lineEnd = lineStart + m[0].length;
            locator.lineNumber++;
          }
          locator.columnNumber = p2 - lineStart + 1;
        }
        var lineStart = 0;
        var lineEnd = 0;
        var linePattern = /.*(?:\r\n?|\n)|.*$/g;
        var locator = domBuilder.locator;
        var parseStack = [{ currentNSMap: defaultNSMapCopy }];
        var closeMap = {};
        var start = 0;
        while (true) {
          try {
            var tagStart = source.indexOf("<", start);
            if (tagStart < 0) {
              if (!source.substr(start).match(/^\s*$/)) {
                var doc2 = domBuilder.doc;
                var text = doc2.createTextNode(source.substr(start));
                doc2.appendChild(text);
                domBuilder.currentElement = text;
              }
              return;
            }
            if (tagStart > start) {
              appendText(tagStart);
            }
            switch (source.charAt(tagStart + 1)) {
              case "/":
                var end = source.indexOf(">", tagStart + 3);
                var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
                var config = parseStack.pop();
                if (end < 0) {
                  tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
                  errorHandler.error("end tag name: " + tagName + " is not complete:" + config.tagName);
                  end = tagStart + 1 + tagName.length;
                } else if (tagName.match(/\s</)) {
                  tagName = tagName.replace(/[\s<].*/, "");
                  errorHandler.error("end tag name: " + tagName + " maybe not complete");
                  end = tagStart + 1 + tagName.length;
                }
                var localNSMap = config.localNSMap;
                var endMatch = config.tagName == tagName;
                var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
                if (endIgnoreCaseMach) {
                  domBuilder.endElement(config.uri, config.localName, tagName);
                  if (localNSMap) {
                    for (var prefix in localNSMap) {
                      if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                        domBuilder.endPrefixMapping(prefix);
                      }
                    }
                  }
                  if (!endMatch) {
                    errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config.tagName);
                  }
                } else {
                  parseStack.push(config);
                }
                end++;
                break;
              case "?":
                locator && position(tagStart);
                end = parseInstruction(source, tagStart, domBuilder);
                break;
              case "!":
                locator && position(tagStart);
                end = parseDCC(source, tagStart, domBuilder, errorHandler);
                break;
              default:
                locator && position(tagStart);
                var el = new ElementAttributes();
                var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
                var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
                var len = el.length;
                if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
                  el.closed = true;
                  if (!entityMap.nbsp) {
                    errorHandler.warning("unclosed xml attribute");
                  }
                }
                if (locator && len) {
                  var locator2 = copyLocator(locator, {});
                  for (var i = 0; i < len; i++) {
                    var a = el[i];
                    position(a.offset);
                    a.locator = copyLocator(locator, {});
                  }
                  domBuilder.locator = locator2;
                  if (appendElement(el, domBuilder, currentNSMap)) {
                    parseStack.push(el);
                  }
                  domBuilder.locator = locator;
                } else {
                  if (appendElement(el, domBuilder, currentNSMap)) {
                    parseStack.push(el);
                  }
                }
                if (NAMESPACE.isHTML(el.uri) && !el.closed) {
                  end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
                } else {
                  end++;
                }
            }
          } catch (e) {
            if (e instanceof ParseError) {
              throw e;
            }
            errorHandler.error("element parse error: " + e);
            end = -1;
          }
          if (end > start) {
            start = end;
          } else {
            appendText(Math.max(tagStart, start) + 1);
          }
        }
      }
      function copyLocator(f, t) {
        t.lineNumber = f.lineNumber;
        t.columnNumber = f.columnNumber;
        return t;
      }
      function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {
        function addAttribute(qname, value2, startIndex) {
          if (el.attributeNames.hasOwnProperty(qname)) {
            errorHandler.fatalError("Attribute " + qname + " redefined");
          }
          el.addValue(qname, value2, startIndex);
        }
        var attrName;
        var value;
        var p2 = ++start;
        var s = S_TAG;
        while (true) {
          var c = source.charAt(p2);
          switch (c) {
            case "=":
              if (s === S_ATTR) {
                attrName = source.slice(start, p2);
                s = S_EQ;
              } else if (s === S_ATTR_SPACE) {
                s = S_EQ;
              } else {
                throw new Error("attribute equal must after attrName");
              }
              break;
            case "'":
            case '"':
              if (s === S_EQ || s === S_ATTR) {
                if (s === S_ATTR) {
                  errorHandler.warning('attribute value must after "="');
                  attrName = source.slice(start, p2);
                }
                start = p2 + 1;
                p2 = source.indexOf(c, start);
                if (p2 > 0) {
                  value = source.slice(start, p2).replace(/&#?\w+;/g, entityReplacer);
                  addAttribute(attrName, value, start - 1);
                  s = S_ATTR_END;
                } else {
                  throw new Error("attribute value no end '" + c + "' match");
                }
              } else if (s == S_ATTR_NOQUOT_VALUE) {
                value = source.slice(start, p2).replace(/&#?\w+;/g, entityReplacer);
                addAttribute(attrName, value, start);
                errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ")!!");
                start = p2 + 1;
                s = S_ATTR_END;
              } else {
                throw new Error('attribute value must after "="');
              }
              break;
            case "/":
              switch (s) {
                case S_TAG:
                  el.setTagName(source.slice(start, p2));
                case S_ATTR_END:
                case S_TAG_SPACE:
                case S_TAG_CLOSE:
                  s = S_TAG_CLOSE;
                  el.closed = true;
                case S_ATTR_NOQUOT_VALUE:
                case S_ATTR:
                  break;
                case S_ATTR_SPACE:
                  el.closed = true;
                  break;
                default:
                  throw new Error("attribute invalid close char('/')");
              }
              break;
            case "":
              errorHandler.error("unexpected end of input");
              if (s == S_TAG) {
                el.setTagName(source.slice(start, p2));
              }
              return p2;
            case ">":
              switch (s) {
                case S_TAG:
                  el.setTagName(source.slice(start, p2));
                case S_ATTR_END:
                case S_TAG_SPACE:
                case S_TAG_CLOSE:
                  break;
                case S_ATTR_NOQUOT_VALUE:
                case S_ATTR:
                  value = source.slice(start, p2);
                  if (value.slice(-1) === "/") {
                    el.closed = true;
                    value = value.slice(0, -1);
                  }
                case S_ATTR_SPACE:
                  if (s === S_ATTR_SPACE) {
                    value = attrName;
                  }
                  if (s == S_ATTR_NOQUOT_VALUE) {
                    errorHandler.warning('attribute "' + value + '" missed quot(")!');
                    addAttribute(attrName, value.replace(/&#?\w+;/g, entityReplacer), start);
                  } else {
                    if (!NAMESPACE.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                      errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                    }
                    addAttribute(value, value, start);
                  }
                  break;
                case S_EQ:
                  throw new Error("attribute value missed!!");
              }
              return p2;
            case "\x80":
              c = " ";
            default:
              if (c <= " ") {
                switch (s) {
                  case S_TAG:
                    el.setTagName(source.slice(start, p2));
                    s = S_TAG_SPACE;
                    break;
                  case S_ATTR:
                    attrName = source.slice(start, p2);
                    s = S_ATTR_SPACE;
                    break;
                  case S_ATTR_NOQUOT_VALUE:
                    var value = source.slice(start, p2).replace(/&#?\w+;/g, entityReplacer);
                    errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                    addAttribute(attrName, value, start);
                  case S_ATTR_END:
                    s = S_TAG_SPACE;
                    break;
                }
              } else {
                switch (s) {
                  case S_ATTR_SPACE:
                    var tagName = el.tagName;
                    if (!NAMESPACE.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                      errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                    }
                    addAttribute(attrName, attrName, start);
                    start = p2;
                    s = S_ATTR;
                    break;
                  case S_ATTR_END:
                    errorHandler.warning('attribute space is required"' + attrName + '"!!');
                  case S_TAG_SPACE:
                    s = S_ATTR;
                    start = p2;
                    break;
                  case S_EQ:
                    s = S_ATTR_NOQUOT_VALUE;
                    start = p2;
                    break;
                  case S_TAG_CLOSE:
                    throw new Error("elements closed character '/' and '>' must be connected to");
                }
              }
          }
          p2++;
        }
      }
      function appendElement(el, domBuilder, currentNSMap) {
        var tagName = el.tagName;
        var localNSMap = null;
        var i = el.length;
        while (i--) {
          var a = el[i];
          var qName = a.qName;
          var value = a.value;
          var nsp = qName.indexOf(":");
          if (nsp > 0) {
            var prefix = a.prefix = qName.slice(0, nsp);
            var localName = qName.slice(nsp + 1);
            var nsPrefix = prefix === "xmlns" && localName;
          } else {
            localName = qName;
            prefix = null;
            nsPrefix = qName === "xmlns" && "";
          }
          a.localName = localName;
          if (nsPrefix !== false) {
            if (localNSMap == null) {
              localNSMap = {};
              _copy(currentNSMap, currentNSMap = {});
            }
            currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
            a.uri = NAMESPACE.XMLNS;
            domBuilder.startPrefixMapping(nsPrefix, value);
          }
        }
        var i = el.length;
        while (i--) {
          a = el[i];
          var prefix = a.prefix;
          if (prefix) {
            if (prefix === "xml") {
              a.uri = NAMESPACE.XML;
            }
            if (prefix !== "xmlns") {
              a.uri = currentNSMap[prefix || ""];
            }
          }
        }
        var nsp = tagName.indexOf(":");
        if (nsp > 0) {
          prefix = el.prefix = tagName.slice(0, nsp);
          localName = el.localName = tagName.slice(nsp + 1);
        } else {
          prefix = null;
          localName = el.localName = tagName;
        }
        var ns = el.uri = currentNSMap[prefix || ""];
        domBuilder.startElement(ns, localName, tagName, el);
        if (el.closed) {
          domBuilder.endElement(ns, localName, tagName);
          if (localNSMap) {
            for (prefix in localNSMap) {
              if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                domBuilder.endPrefixMapping(prefix);
              }
            }
          }
        } else {
          el.currentNSMap = currentNSMap;
          el.localNSMap = localNSMap;
          return true;
        }
      }
      function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
        if (/^(?:script|textarea)$/i.test(tagName)) {
          var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
          var text = source.substring(elStartEnd + 1, elEndStart);
          if (/[&<]/.test(text)) {
            if (/^script$/i.test(tagName)) {
              domBuilder.characters(text, 0, text.length);
              return elEndStart;
            }
            text = text.replace(/&#?\w+;/g, entityReplacer);
            domBuilder.characters(text, 0, text.length);
            return elEndStart;
          }
        }
        return elStartEnd + 1;
      }
      function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
        var pos = closeMap[tagName];
        if (pos == null) {
          pos = source.lastIndexOf("</" + tagName + ">");
          if (pos < elStartEnd) {
            pos = source.lastIndexOf("</" + tagName);
          }
          closeMap[tagName] = pos;
        }
        return pos < elStartEnd;
      }
      function _copy(source, target) {
        for (var n in source) {
          if (Object.prototype.hasOwnProperty.call(source, n)) {
            target[n] = source[n];
          }
        }
      }
      function parseDCC(source, start, domBuilder, errorHandler) {
        var next = source.charAt(start + 2);
        switch (next) {
          case "-":
            if (source.charAt(start + 3) === "-") {
              var end = source.indexOf("-->", start + 4);
              if (end > start) {
                domBuilder.comment(source, start + 4, end - start - 4);
                return end + 3;
              } else {
                errorHandler.error("Unclosed comment");
                return -1;
              }
            } else {
              return -1;
            }
          default:
            if (source.substr(start + 3, 6) == "CDATA[") {
              var end = source.indexOf("]]>", start + 9);
              domBuilder.startCDATA();
              domBuilder.characters(source, start + 9, end - start - 9);
              domBuilder.endCDATA();
              return end + 3;
            }
            var matchs = split(source, start);
            var len = matchs.length;
            if (len > 1 && /!doctype/i.test(matchs[0][0])) {
              var name = matchs[1][0];
              var pubid = false;
              var sysid = false;
              if (len > 3) {
                if (/^public$/i.test(matchs[2][0])) {
                  pubid = matchs[3][0];
                  sysid = len > 4 && matchs[4][0];
                } else if (/^system$/i.test(matchs[2][0])) {
                  sysid = matchs[3][0];
                }
              }
              var lastMatch = matchs[len - 1];
              domBuilder.startDTD(name, pubid, sysid);
              domBuilder.endDTD();
              return lastMatch.index + lastMatch[0].length;
            }
        }
        return -1;
      }
      function parseInstruction(source, start, domBuilder) {
        var end = source.indexOf("?>", start);
        if (end) {
          var match = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
          if (match) {
            var len = match[0].length;
            domBuilder.processingInstruction(match[1], match[2]);
            return end + 2;
          } else {
            return -1;
          }
        }
        return -1;
      }
      function ElementAttributes() {
        this.attributeNames = {};
      }
      ElementAttributes.prototype = {
        setTagName: function(tagName) {
          if (!tagNamePattern.test(tagName)) {
            throw new Error("invalid tagName:" + tagName);
          }
          this.tagName = tagName;
        },
        addValue: function(qName, value, offset) {
          if (!tagNamePattern.test(qName)) {
            throw new Error("invalid attribute:" + qName);
          }
          this.attributeNames[qName] = this.length;
          this[this.length++] = { qName, value, offset };
        },
        length: 0,
        getLocalName: function(i) {
          return this[i].localName;
        },
        getLocator: function(i) {
          return this[i].locator;
        },
        getQName: function(i) {
          return this[i].qName;
        },
        getURI: function(i) {
          return this[i].uri;
        },
        getValue: function(i) {
          return this[i].value;
        }
      };
      function split(source, start) {
        var match;
        var buf = [];
        var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
        reg.lastIndex = start;
        reg.exec(source);
        while (match = reg.exec(source)) {
          buf.push(match);
          if (match[1])
            return buf;
        }
      }
      exports.XMLReader = XMLReader;
      exports.ParseError = ParseError;
    }
  });

  // ../library_management/node_modules/@xmldom/xmldom/lib/dom-parser.js
  var require_dom_parser = __commonJS({
    "../library_management/node_modules/@xmldom/xmldom/lib/dom-parser.js"(exports) {
      var conventions = require_conventions();
      var dom = require_dom();
      var entities = require_entities();
      var sax = require_sax();
      var DOMImplementation = dom.DOMImplementation;
      var NAMESPACE = conventions.NAMESPACE;
      var ParseError = sax.ParseError;
      var XMLReader = sax.XMLReader;
      function DOMParser2(options) {
        this.options = options || { locator: {} };
      }
      DOMParser2.prototype.parseFromString = function(source, mimeType) {
        var options = this.options;
        var sax2 = new XMLReader();
        var domBuilder = options.domBuilder || new DOMHandler();
        var errorHandler = options.errorHandler;
        var locator = options.locator;
        var defaultNSMap = options.xmlns || {};
        var isHTML = /\/x?html?$/.test(mimeType);
        var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
        if (locator) {
          domBuilder.setDocumentLocator(locator);
        }
        sax2.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
        sax2.domBuilder = options.domBuilder || domBuilder;
        if (isHTML) {
          defaultNSMap[""] = NAMESPACE.HTML;
        }
        defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
        if (source && typeof source === "string") {
          sax2.parse(source, defaultNSMap, entityMap);
        } else {
          sax2.errorHandler.error("invalid doc source");
        }
        return domBuilder.doc;
      };
      function buildErrorHandler(errorImpl, domBuilder, locator) {
        if (!errorImpl) {
          if (domBuilder instanceof DOMHandler) {
            return domBuilder;
          }
          errorImpl = domBuilder;
        }
        var errorHandler = {};
        var isCallback = errorImpl instanceof Function;
        locator = locator || {};
        function build(key) {
          var fn = errorImpl[key];
          if (!fn && isCallback) {
            fn = errorImpl.length == 2 ? function(msg) {
              errorImpl(key, msg);
            } : errorImpl;
          }
          errorHandler[key] = fn && function(msg) {
            fn("[xmldom " + key + "]	" + msg + _locator(locator));
          } || function() {
          };
        }
        build("warning");
        build("error");
        build("fatalError");
        return errorHandler;
      }
      function DOMHandler() {
        this.cdata = false;
      }
      function position(locator, node) {
        node.lineNumber = locator.lineNumber;
        node.columnNumber = locator.columnNumber;
      }
      DOMHandler.prototype = {
        startDocument: function() {
          this.doc = new DOMImplementation().createDocument(null, null, null);
          if (this.locator) {
            this.doc.documentURI = this.locator.systemId;
          }
        },
        startElement: function(namespaceURI, localName, qName, attrs) {
          var doc2 = this.doc;
          var el = doc2.createElementNS(namespaceURI, qName || localName);
          var len = attrs.length;
          appendElement(this, el);
          this.currentElement = el;
          this.locator && position(this.locator, el);
          for (var i = 0; i < len; i++) {
            var namespaceURI = attrs.getURI(i);
            var value = attrs.getValue(i);
            var qName = attrs.getQName(i);
            var attr = doc2.createAttributeNS(namespaceURI, qName);
            this.locator && position(attrs.getLocator(i), attr);
            attr.value = attr.nodeValue = value;
            el.setAttributeNode(attr);
          }
        },
        endElement: function(namespaceURI, localName, qName) {
          var current = this.currentElement;
          var tagName = current.tagName;
          this.currentElement = current.parentNode;
        },
        startPrefixMapping: function(prefix, uri) {
        },
        endPrefixMapping: function(prefix) {
        },
        processingInstruction: function(target, data) {
          var ins = this.doc.createProcessingInstruction(target, data);
          this.locator && position(this.locator, ins);
          appendElement(this, ins);
        },
        ignorableWhitespace: function(ch, start, length) {
        },
        characters: function(chars, start, length) {
          chars = _toString.apply(this, arguments);
          if (chars) {
            if (this.cdata) {
              var charNode = this.doc.createCDATASection(chars);
            } else {
              var charNode = this.doc.createTextNode(chars);
            }
            if (this.currentElement) {
              this.currentElement.appendChild(charNode);
            } else if (/^\s*$/.test(chars)) {
              this.doc.appendChild(charNode);
            }
            this.locator && position(this.locator, charNode);
          }
        },
        skippedEntity: function(name) {
        },
        endDocument: function() {
          this.doc.normalize();
        },
        setDocumentLocator: function(locator) {
          if (this.locator = locator) {
            locator.lineNumber = 0;
          }
        },
        comment: function(chars, start, length) {
          chars = _toString.apply(this, arguments);
          var comm = this.doc.createComment(chars);
          this.locator && position(this.locator, comm);
          appendElement(this, comm);
        },
        startCDATA: function() {
          this.cdata = true;
        },
        endCDATA: function() {
          this.cdata = false;
        },
        startDTD: function(name, publicId, systemId) {
          var impl = this.doc.implementation;
          if (impl && impl.createDocumentType) {
            var dt = impl.createDocumentType(name, publicId, systemId);
            this.locator && position(this.locator, dt);
            appendElement(this, dt);
            this.doc.doctype = dt;
          }
        },
        warning: function(error) {
          console.warn("[xmldom warning]	" + error, _locator(this.locator));
        },
        error: function(error) {
          console.error("[xmldom error]	" + error, _locator(this.locator));
        },
        fatalError: function(error) {
          throw new ParseError(error, this.locator);
        }
      };
      function _locator(l) {
        if (l) {
          return "\n@" + (l.systemId || "") + "#[line:" + l.lineNumber + ",col:" + l.columnNumber + "]";
        }
      }
      function _toString(chars, start, length) {
        if (typeof chars == "string") {
          return chars.substr(start, length);
        } else {
          if (chars.length >= start + length || start) {
            return new java.lang.String(chars, start, length) + "";
          }
          return chars;
        }
      }
      "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
        DOMHandler.prototype[key] = function() {
          return null;
        };
      });
      function appendElement(hander, node) {
        if (!hander.currentElement) {
          hander.doc.appendChild(node);
        } else {
          hander.currentElement.appendChild(node);
        }
      }
      exports.__DOMHandler = DOMHandler;
      exports.DOMParser = DOMParser2;
      exports.DOMImplementation = dom.DOMImplementation;
      exports.XMLSerializer = dom.XMLSerializer;
    }
  });

  // ../library_management/node_modules/@xmldom/xmldom/lib/index.js
  var require_lib = __commonJS({
    "../library_management/node_modules/@xmldom/xmldom/lib/index.js"(exports) {
      var dom = require_dom();
      exports.DOMImplementation = dom.DOMImplementation;
      exports.XMLSerializer = dom.XMLSerializer;
      exports.DOMParser = require_dom_parser().DOMParser;
    }
  });

  // ../library_management/node_modules/path-webpack/path.js
  var require_path = __commonJS({
    "../library_management/node_modules/path-webpack/path.js"(exports, module) {
      "use strict";
      if (!process2) {
        process2 = {
          "cwd": function() {
            return "/";
          }
        };
      }
      var process2;
      function assertPath(path5) {
        if (typeof path5 !== "string") {
          throw new TypeError("Path must be a string. Received " + path5);
        }
      }
      function normalizeStringPosix(path5, allowAboveRoot) {
        var res = "";
        var lastSlash = -1;
        var dots = 0;
        var code;
        for (var i = 0; i <= path5.length; ++i) {
          if (i < path5.length)
            code = path5.charCodeAt(i);
          else if (code === 47)
            break;
          else
            code = 47;
          if (code === 47) {
            if (lastSlash === i - 1 || dots === 1) {
            } else if (lastSlash !== i - 1 && dots === 2) {
              if (res.length < 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                if (res.length > 2) {
                  var start = res.length - 1;
                  var j = start;
                  for (; j >= 0; --j) {
                    if (res.charCodeAt(j) === 47)
                      break;
                  }
                  if (j !== start) {
                    if (j === -1)
                      res = "";
                    else
                      res = res.slice(0, j);
                    lastSlash = i;
                    dots = 0;
                    continue;
                  }
                } else if (res.length === 2 || res.length === 1) {
                  res = "";
                  lastSlash = i;
                  dots = 0;
                  continue;
                }
              }
              if (allowAboveRoot) {
                if (res.length > 0)
                  res += "/..";
                else
                  res = "..";
              }
            } else {
              if (res.length > 0)
                res += "/" + path5.slice(lastSlash + 1, i);
              else
                res = path5.slice(lastSlash + 1, i);
            }
            lastSlash = i;
            dots = 0;
          } else if (code === 46 && dots !== -1) {
            ++dots;
          } else {
            dots = -1;
          }
        }
        return res;
      }
      function _format(sep, pathObject) {
        var dir = pathObject.dir || pathObject.root;
        var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
        if (!dir) {
          return base;
        }
        if (dir === pathObject.root) {
          return dir + base;
        }
        return dir + sep + base;
      }
      var posix = {
        resolve: function resolve2() {
          var resolvedPath = "";
          var resolvedAbsolute = false;
          var cwd;
          for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            var path5;
            if (i >= 0)
              path5 = arguments[i];
            else {
              if (cwd === void 0)
                cwd = process2.cwd();
              path5 = cwd;
            }
            assertPath(path5);
            if (path5.length === 0) {
              continue;
            }
            resolvedPath = path5 + "/" + resolvedPath;
            resolvedAbsolute = path5.charCodeAt(0) === 47;
          }
          resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
          if (resolvedAbsolute) {
            if (resolvedPath.length > 0)
              return "/" + resolvedPath;
            else
              return "/";
          } else if (resolvedPath.length > 0) {
            return resolvedPath;
          } else {
            return ".";
          }
        },
        normalize: function normalize(path5) {
          assertPath(path5);
          if (path5.length === 0)
            return ".";
          var isAbsolute = path5.charCodeAt(0) === 47;
          var trailingSeparator = path5.charCodeAt(path5.length - 1) === 47;
          path5 = normalizeStringPosix(path5, !isAbsolute);
          if (path5.length === 0 && !isAbsolute)
            path5 = ".";
          if (path5.length > 0 && trailingSeparator)
            path5 += "/";
          if (isAbsolute)
            return "/" + path5;
          return path5;
        },
        isAbsolute: function isAbsolute(path5) {
          assertPath(path5);
          return path5.length > 0 && path5.charCodeAt(0) === 47;
        },
        join: function join() {
          if (arguments.length === 0)
            return ".";
          var joined;
          for (var i = 0; i < arguments.length; ++i) {
            var arg = arguments[i];
            assertPath(arg);
            if (arg.length > 0) {
              if (joined === void 0)
                joined = arg;
              else
                joined += "/" + arg;
            }
          }
          if (joined === void 0)
            return ".";
          return posix.normalize(joined);
        },
        relative: function relative(from, to) {
          assertPath(from);
          assertPath(to);
          if (from === to)
            return "";
          from = posix.resolve(from);
          to = posix.resolve(to);
          if (from === to)
            return "";
          var fromStart = 1;
          for (; fromStart < from.length; ++fromStart) {
            if (from.charCodeAt(fromStart) !== 47)
              break;
          }
          var fromEnd = from.length;
          var fromLen = fromEnd - fromStart;
          var toStart = 1;
          for (; toStart < to.length; ++toStart) {
            if (to.charCodeAt(toStart) !== 47)
              break;
          }
          var toEnd = to.length;
          var toLen = toEnd - toStart;
          var length = fromLen < toLen ? fromLen : toLen;
          var lastCommonSep = -1;
          var i = 0;
          for (; i <= length; ++i) {
            if (i === length) {
              if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 47) {
                  return to.slice(toStart + i + 1);
                } else if (i === 0) {
                  return to.slice(toStart + i);
                }
              } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 47) {
                  lastCommonSep = i;
                } else if (i === 0) {
                  lastCommonSep = 0;
                }
              }
              break;
            }
            var fromCode = from.charCodeAt(fromStart + i);
            var toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode)
              break;
            else if (fromCode === 47)
              lastCommonSep = i;
          }
          var out = "";
          for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === 47) {
              if (out.length === 0)
                out += "..";
              else
                out += "/..";
            }
          }
          if (out.length > 0)
            return out + to.slice(toStart + lastCommonSep);
          else {
            toStart += lastCommonSep;
            if (to.charCodeAt(toStart) === 47)
              ++toStart;
            return to.slice(toStart);
          }
        },
        _makeLong: function _makeLong(path5) {
          return path5;
        },
        dirname: function dirname(path5) {
          assertPath(path5);
          if (path5.length === 0)
            return ".";
          var code = path5.charCodeAt(0);
          var hasRoot = code === 47;
          var end = -1;
          var matchedSlash = true;
          for (var i = path5.length - 1; i >= 1; --i) {
            code = path5.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                end = i;
                break;
              }
            } else {
              matchedSlash = false;
            }
          }
          if (end === -1)
            return hasRoot ? "/" : ".";
          if (hasRoot && end === 1)
            return "//";
          return path5.slice(0, end);
        },
        basename: function basename(path5, ext) {
          if (ext !== void 0 && typeof ext !== "string")
            throw new TypeError('"ext" argument must be a string');
          assertPath(path5);
          var start = 0;
          var end = -1;
          var matchedSlash = true;
          var i;
          if (ext !== void 0 && ext.length > 0 && ext.length <= path5.length) {
            if (ext.length === path5.length && ext === path5)
              return "";
            var extIdx = ext.length - 1;
            var firstNonSlashEnd = -1;
            for (i = path5.length - 1; i >= 0; --i) {
              var code = path5.charCodeAt(i);
              if (code === 47) {
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else {
                if (firstNonSlashEnd === -1) {
                  matchedSlash = false;
                  firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                  if (code === ext.charCodeAt(extIdx)) {
                    if (--extIdx === -1) {
                      end = i;
                    }
                  } else {
                    extIdx = -1;
                    end = firstNonSlashEnd;
                  }
                }
              }
            }
            if (start === end)
              end = firstNonSlashEnd;
            else if (end === -1)
              end = path5.length;
            return path5.slice(start, end);
          } else {
            for (i = path5.length - 1; i >= 0; --i) {
              if (path5.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
              }
            }
            if (end === -1)
              return "";
            return path5.slice(start, end);
          }
        },
        extname: function extname(path5) {
          assertPath(path5);
          var startDot = -1;
          var startPart = 0;
          var end = -1;
          var matchedSlash = true;
          var preDotState = 0;
          for (var i = path5.length - 1; i >= 0; --i) {
            var code = path5.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
            if (code === 46) {
              if (startDot === -1)
                startDot = i;
              else if (preDotState !== 1)
                preDotState = 1;
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            return "";
          }
          return path5.slice(startDot, end);
        },
        format: function format2(pathObject) {
          if (pathObject === null || typeof pathObject !== "object") {
            throw new TypeError(
              'Parameter "pathObject" must be an object, not ' + typeof pathObject
            );
          }
          return _format("/", pathObject);
        },
        parse: function parse3(path5) {
          assertPath(path5);
          var ret = { root: "", dir: "", base: "", ext: "", name: "" };
          if (path5.length === 0)
            return ret;
          var code = path5.charCodeAt(0);
          var isAbsolute = code === 47;
          var start;
          if (isAbsolute) {
            ret.root = "/";
            start = 1;
          } else {
            start = 0;
          }
          var startDot = -1;
          var startPart = 0;
          var end = -1;
          var matchedSlash = true;
          var i = path5.length - 1;
          var preDotState = 0;
          for (; i >= start; --i) {
            code = path5.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
            if (code === 46) {
              if (startDot === -1)
                startDot = i;
              else if (preDotState !== 1)
                preDotState = 1;
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            if (end !== -1) {
              if (startPart === 0 && isAbsolute)
                ret.base = ret.name = path5.slice(1, end);
              else
                ret.base = ret.name = path5.slice(startPart, end);
            }
          } else {
            if (startPart === 0 && isAbsolute) {
              ret.name = path5.slice(1, startDot);
              ret.base = path5.slice(1, end);
            } else {
              ret.name = path5.slice(startPart, startDot);
              ret.base = path5.slice(startPart, end);
            }
            ret.ext = path5.slice(startDot, end);
          }
          if (startPart > 0)
            ret.dir = path5.slice(0, startPart - 1);
          else if (isAbsolute)
            ret.dir = "/";
          return ret;
        },
        sep: "/",
        delimiter: ":",
        posix: null
      };
      module.exports = posix;
    }
  });

  // ../library_management/node_modules/marks-pane/lib/svg.js
  var require_svg = __commonJS({
    "../library_management/node_modules/marks-pane/lib/svg.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createElement = createElement;
      function createElement(name) {
        return document.createElementNS("http://www.w3.org/2000/svg", name);
      }
      exports.default = {
        createElement
      };
    }
  });

  // ../library_management/node_modules/marks-pane/lib/events.js
  var require_events = __commonJS({
    "../library_management/node_modules/marks-pane/lib/events.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.proxyMouse = proxyMouse;
      exports.clone = clone;
      exports.default = {
        proxyMouse
      };
      function proxyMouse(target, tracked) {
        function dispatch(e) {
          for (var i = tracked.length - 1; i >= 0; i--) {
            var t = tracked[i];
            var x = e.clientX;
            var y = e.clientY;
            if (e.touches && e.touches.length) {
              x = e.touches[0].clientX;
              y = e.touches[0].clientY;
            }
            if (!contains(t, target, x, y)) {
              continue;
            }
            t.dispatchEvent(clone(e));
            break;
          }
        }
        if (target.nodeName === "iframe" || target.nodeName === "IFRAME") {
          try {
            this.target = target.contentDocument;
          } catch (err) {
            this.target = target;
          }
        } else {
          this.target = target;
        }
        var _arr2 = ["mouseup", "mousedown", "click", "touchstart"];
        for (var _i = 0; _i < _arr2.length; _i++) {
          var ev = _arr2[_i];
          this.target.addEventListener(ev, function(e) {
            return dispatch(e);
          }, false);
        }
      }
      function clone(e) {
        var opts = Object.assign({}, e, { bubbles: false });
        try {
          return new MouseEvent(e.type, opts);
        } catch (err) {
          var copy = document.createEvent("MouseEvents");
          copy.initMouseEvent(e.type, false, opts.cancelable, opts.view, opts.detail, opts.screenX, opts.screenY, opts.clientX, opts.clientY, opts.ctrlKey, opts.altKey, opts.shiftKey, opts.metaKey, opts.button, opts.relatedTarget);
          return copy;
        }
      }
      function contains(item, target, x, y) {
        var offset = target.getBoundingClientRect();
        function rectContains(r, x2, y2) {
          var top = r.top - offset.top;
          var left = r.left - offset.left;
          var bottom = top + r.height;
          var right = left + r.width;
          return top <= y2 && left <= x2 && bottom > y2 && right > x2;
        }
        var rect = item.getBoundingClientRect();
        if (!rectContains(rect, x, y)) {
          return false;
        }
        var rects = item.getClientRects();
        for (var i = 0, len = rects.length; i < len; i++) {
          if (rectContains(rects[i], x, y)) {
            return true;
          }
        }
        return false;
      }
    }
  });

  // ../library_management/node_modules/marks-pane/lib/marks.js
  var require_marks = __commonJS({
    "../library_management/node_modules/marks-pane/lib/marks.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Underline = exports.Highlight = exports.Mark = exports.Pane = void 0;
      var _get = function get2(object, property, receiver) {
        if (object === null)
          object = Function.prototype;
        var desc = Object.getOwnPropertyDescriptor(object, property);
        if (desc === void 0) {
          var parent2 = Object.getPrototypeOf(object);
          if (parent2 === null) {
            return void 0;
          } else {
            return get2(parent2, property, receiver);
          }
        } else if ("value" in desc) {
          return desc.value;
        } else {
          var getter = desc.get;
          if (getter === void 0) {
            return void 0;
          }
          return getter.call(receiver);
        }
      };
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      var _svg = require_svg();
      var _svg2 = _interopRequireDefault(_svg);
      var _events = require_events();
      var _events2 = _interopRequireDefault(_events);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _possibleConstructorReturn(self2, call) {
        if (!self2) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self2;
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
        if (superClass)
          Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var Pane2 = exports.Pane = function() {
        function Pane3(target) {
          var container = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : document.body;
          _classCallCheck(this, Pane3);
          this.target = target;
          this.element = _svg2.default.createElement("svg");
          this.marks = [];
          this.element.style.position = "absolute";
          this.element.setAttribute("pointer-events", "none");
          _events2.default.proxyMouse(this.target, this.marks);
          this.container = container;
          this.container.appendChild(this.element);
          this.render();
        }
        _createClass(Pane3, [{
          key: "addMark",
          value: function addMark(mark) {
            var g = _svg2.default.createElement("g");
            this.element.appendChild(g);
            mark.bind(g, this.container);
            this.marks.push(mark);
            mark.render();
            return mark;
          }
        }, {
          key: "removeMark",
          value: function removeMark(mark) {
            var idx = this.marks.indexOf(mark);
            if (idx === -1) {
              return;
            }
            var el = mark.unbind();
            this.element.removeChild(el);
            this.marks.splice(idx, 1);
          }
        }, {
          key: "render",
          value: function render7() {
            setCoords(this.element, coords(this.target, this.container));
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = void 0;
            try {
              for (var _iterator = this.marks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var m = _step.value;
                m.render();
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }
        }]);
        return Pane3;
      }();
      var Mark = exports.Mark = function() {
        function Mark2() {
          _classCallCheck(this, Mark2);
          this.element = null;
        }
        _createClass(Mark2, [{
          key: "bind",
          value: function bind(element, container) {
            this.element = element;
            this.container = container;
          }
        }, {
          key: "unbind",
          value: function unbind() {
            var el = this.element;
            this.element = null;
            return el;
          }
        }, {
          key: "render",
          value: function render7() {
          }
        }, {
          key: "dispatchEvent",
          value: function dispatchEvent(e) {
            if (!this.element)
              return;
            this.element.dispatchEvent(e);
          }
        }, {
          key: "getBoundingClientRect",
          value: function getBoundingClientRect() {
            return this.element.getBoundingClientRect();
          }
        }, {
          key: "getClientRects",
          value: function getClientRects() {
            var rects = [];
            var el = this.element.firstChild;
            while (el) {
              rects.push(el.getBoundingClientRect());
              el = el.nextSibling;
            }
            return rects;
          }
        }, {
          key: "filteredRanges",
          value: function filteredRanges() {
            var rects = Array.from(this.range.getClientRects());
            return rects.filter(function(box) {
              for (var i = 0; i < rects.length; i++) {
                if (rects[i] === box) {
                  return true;
                }
                var contained = contains(rects[i], box);
                if (contained) {
                  return false;
                }
              }
              return true;
            });
          }
        }]);
        return Mark2;
      }();
      var Highlight2 = exports.Highlight = function(_Mark) {
        _inherits(Highlight3, _Mark);
        function Highlight3(range, className, data, attributes) {
          _classCallCheck(this, Highlight3);
          var _this = _possibleConstructorReturn(this, (Highlight3.__proto__ || Object.getPrototypeOf(Highlight3)).call(this));
          _this.range = range;
          _this.className = className;
          _this.data = data || {};
          _this.attributes = attributes || {};
          return _this;
        }
        _createClass(Highlight3, [{
          key: "bind",
          value: function bind(element, container) {
            _get(Highlight3.prototype.__proto__ || Object.getPrototypeOf(Highlight3.prototype), "bind", this).call(this, element, container);
            for (var attr in this.data) {
              if (this.data.hasOwnProperty(attr)) {
                this.element.dataset[attr] = this.data[attr];
              }
            }
            for (var attr in this.attributes) {
              if (this.attributes.hasOwnProperty(attr)) {
                this.element.setAttribute(attr, this.attributes[attr]);
              }
            }
            if (this.className) {
              this.element.classList.add(this.className);
            }
          }
        }, {
          key: "render",
          value: function render7() {
            while (this.element.firstChild) {
              this.element.removeChild(this.element.firstChild);
            }
            var docFrag = this.element.ownerDocument.createDocumentFragment();
            var filtered = this.filteredRanges();
            var offset = this.element.getBoundingClientRect();
            var container = this.container.getBoundingClientRect();
            for (var i = 0, len = filtered.length; i < len; i++) {
              var r = filtered[i];
              var el = _svg2.default.createElement("rect");
              el.setAttribute("x", r.left - offset.left + container.left);
              el.setAttribute("y", r.top - offset.top + container.top);
              el.setAttribute("height", r.height);
              el.setAttribute("width", r.width);
              docFrag.appendChild(el);
            }
            this.element.appendChild(docFrag);
          }
        }]);
        return Highlight3;
      }(Mark);
      var Underline2 = exports.Underline = function(_Highlight) {
        _inherits(Underline3, _Highlight);
        function Underline3(range, className, data, attributes) {
          _classCallCheck(this, Underline3);
          return _possibleConstructorReturn(this, (Underline3.__proto__ || Object.getPrototypeOf(Underline3)).call(this, range, className, data, attributes));
        }
        _createClass(Underline3, [{
          key: "render",
          value: function render7() {
            while (this.element.firstChild) {
              this.element.removeChild(this.element.firstChild);
            }
            var docFrag = this.element.ownerDocument.createDocumentFragment();
            var filtered = this.filteredRanges();
            var offset = this.element.getBoundingClientRect();
            var container = this.container.getBoundingClientRect();
            for (var i = 0, len = filtered.length; i < len; i++) {
              var r = filtered[i];
              var rect = _svg2.default.createElement("rect");
              rect.setAttribute("x", r.left - offset.left + container.left);
              rect.setAttribute("y", r.top - offset.top + container.top);
              rect.setAttribute("height", r.height);
              rect.setAttribute("width", r.width);
              rect.setAttribute("fill", "none");
              var line = _svg2.default.createElement("line");
              line.setAttribute("x1", r.left - offset.left + container.left);
              line.setAttribute("x2", r.left - offset.left + container.left + r.width);
              line.setAttribute("y1", r.top - offset.top + container.top + r.height - 1);
              line.setAttribute("y2", r.top - offset.top + container.top + r.height - 1);
              line.setAttribute("stroke-width", 1);
              line.setAttribute("stroke", "black");
              line.setAttribute("stroke-linecap", "square");
              docFrag.appendChild(rect);
              docFrag.appendChild(line);
            }
            this.element.appendChild(docFrag);
          }
        }]);
        return Underline3;
      }(Highlight2);
      function coords(el, container) {
        var offset = container.getBoundingClientRect();
        var rect = el.getBoundingClientRect();
        return {
          top: rect.top - offset.top,
          left: rect.left - offset.left,
          height: el.scrollHeight,
          width: el.scrollWidth
        };
      }
      function setCoords(el, coords2) {
        el.style.setProperty("top", coords2.top + "px", "important");
        el.style.setProperty("left", coords2.left + "px", "important");
        el.style.setProperty("height", coords2.height + "px", "important");
        el.style.setProperty("width", coords2.width + "px", "important");
      }
      function contains(rect1, rect2) {
        return rect2.right <= rect1.right && rect2.left >= rect1.left && rect2.top >= rect1.top && rect2.bottom <= rect1.bottom;
      }
    }
  });

  // ../library_management/node_modules/lodash/isObject.js
  var require_isObject = __commonJS({
    "../library_management/node_modules/lodash/isObject.js"(exports, module) {
      function isObject3(value) {
        var type2 = typeof value;
        return value != null && (type2 == "object" || type2 == "function");
      }
      module.exports = isObject3;
    }
  });

  // ../library_management/node_modules/lodash/_freeGlobal.js
  var require_freeGlobal = __commonJS({
    "../library_management/node_modules/lodash/_freeGlobal.js"(exports, module) {
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      module.exports = freeGlobal;
    }
  });

  // ../library_management/node_modules/lodash/_root.js
  var require_root = __commonJS({
    "../library_management/node_modules/lodash/_root.js"(exports, module) {
      var freeGlobal = require_freeGlobal();
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      module.exports = root;
    }
  });

  // ../library_management/node_modules/lodash/now.js
  var require_now = __commonJS({
    "../library_management/node_modules/lodash/now.js"(exports, module) {
      var root = require_root();
      var now2 = function() {
        return root.Date.now();
      };
      module.exports = now2;
    }
  });

  // ../library_management/node_modules/lodash/_trimmedEndIndex.js
  var require_trimmedEndIndex = __commonJS({
    "../library_management/node_modules/lodash/_trimmedEndIndex.js"(exports, module) {
      var reWhitespace = /\s/;
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      module.exports = trimmedEndIndex;
    }
  });

  // ../library_management/node_modules/lodash/_baseTrim.js
  var require_baseTrim = __commonJS({
    "../library_management/node_modules/lodash/_baseTrim.js"(exports, module) {
      var trimmedEndIndex = require_trimmedEndIndex();
      var reTrimStart = /^\s+/;
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      module.exports = baseTrim;
    }
  });

  // ../library_management/node_modules/lodash/_Symbol.js
  var require_Symbol = __commonJS({
    "../library_management/node_modules/lodash/_Symbol.js"(exports, module) {
      var root = require_root();
      var Symbol2 = root.Symbol;
      module.exports = Symbol2;
    }
  });

  // ../library_management/node_modules/lodash/_getRawTag.js
  var require_getRawTag = __commonJS({
    "../library_management/node_modules/lodash/_getRawTag.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var objectProto = Object.prototype;
      var hasOwnProperty4 = objectProto.hasOwnProperty;
      var nativeObjectToString = objectProto.toString;
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty4.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }
      module.exports = getRawTag;
    }
  });

  // ../library_management/node_modules/lodash/_objectToString.js
  var require_objectToString = __commonJS({
    "../library_management/node_modules/lodash/_objectToString.js"(exports, module) {
      var objectProto = Object.prototype;
      var nativeObjectToString = objectProto.toString;
      function objectToString2(value) {
        return nativeObjectToString.call(value);
      }
      module.exports = objectToString2;
    }
  });

  // ../library_management/node_modules/lodash/_baseGetTag.js
  var require_baseGetTag = __commonJS({
    "../library_management/node_modules/lodash/_baseGetTag.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var getRawTag = require_getRawTag();
      var objectToString2 = require_objectToString();
      var nullTag = "[object Null]";
      var undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString2(value);
      }
      module.exports = baseGetTag;
    }
  });

  // ../library_management/node_modules/lodash/isObjectLike.js
  var require_isObjectLike = __commonJS({
    "../library_management/node_modules/lodash/isObjectLike.js"(exports, module) {
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      module.exports = isObjectLike;
    }
  });

  // ../library_management/node_modules/lodash/isSymbol.js
  var require_isSymbol = __commonJS({
    "../library_management/node_modules/lodash/isSymbol.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isObjectLike = require_isObjectLike();
      var symbolTag = "[object Symbol]";
      function isSymbol2(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      module.exports = isSymbol2;
    }
  });

  // ../library_management/node_modules/lodash/toNumber.js
  var require_toNumber = __commonJS({
    "../library_management/node_modules/lodash/toNumber.js"(exports, module) {
      var baseTrim = require_baseTrim();
      var isObject3 = require_isObject();
      var isSymbol2 = require_isSymbol();
      var NAN = 0 / 0;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      function toNumber2(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN;
        }
        if (isObject3(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject3(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      module.exports = toNumber2;
    }
  });

  // ../library_management/node_modules/lodash/debounce.js
  var require_debounce = __commonJS({
    "../library_management/node_modules/lodash/debounce.js"(exports, module) {
      var isObject3 = require_isObject();
      var now2 = require_now();
      var toNumber2 = require_toNumber();
      var FUNC_ERROR_TEXT = "Expected a function";
      var nativeMax = Math.max;
      var nativeMin = Math.min;
      function debounce3(func, wait, options) {
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber2(wait) || 0;
        if (isObject3(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber2(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = void 0;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time) : result;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now2();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = void 0;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = void 0;
          return result;
        }
        function cancel() {
          if (timerId !== void 0) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = void 0;
        }
        function flush() {
          return timerId === void 0 ? result : trailingEdge(now2());
        }
        function debounced() {
          var time = now2(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === void 0) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout(timerId);
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      module.exports = debounce3;
    }
  });

  // ../library_management/node_modules/lodash/throttle.js
  var require_throttle = __commonJS({
    "../library_management/node_modules/lodash/throttle.js"(exports, module) {
      var debounce3 = require_debounce();
      var isObject3 = require_isObject();
      var FUNC_ERROR_TEXT = "Expected a function";
      function throttle2(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        if (isObject3(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce3(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      module.exports = throttle2;
    }
  });

  // ../library_management/node_modules/jszip/dist/jszip.js
  var require_jszip = __commonJS({
    "../library_management/node_modules/jszip/dist/jszip.js"(exports, module) {
      (function(f) {
        if (typeof exports === "object" && typeof module !== "undefined") {
          module.exports = f();
        } else if (typeof define === "function" && define.amd) {
          define([], f);
        } else {
          var g;
          if (typeof window !== "undefined") {
            g = window;
          } else if (typeof global !== "undefined") {
            g = global;
          } else if (typeof self !== "undefined") {
            g = self;
          } else {
            g = this;
          }
          g.JSZip = f();
        }
      })(function() {
        var define2, module2, exports2;
        return function e(t, n, r) {
          function s(o2, u) {
            if (!n[o2]) {
              if (!t[o2]) {
                var a = typeof __require == "function" && __require;
                if (!u && a)
                  return a(o2, true);
                if (i)
                  return i(o2, true);
                var f = new Error("Cannot find module '" + o2 + "'");
                throw f.code = "MODULE_NOT_FOUND", f;
              }
              var l = n[o2] = { exports: {} };
              t[o2][0].call(l.exports, function(e2) {
                var n2 = t[o2][1][e2];
                return s(n2 ? n2 : e2);
              }, l, l.exports, e, t, n, r);
            }
            return n[o2].exports;
          }
          var i = typeof __require == "function" && __require;
          for (var o = 0; o < r.length; o++)
            s(r[o]);
          return s;
        }({ 1: [function(require2, module3, exports3) {
          "use strict";
          var utils = require2("./utils");
          var support = require2("./support");
          var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          exports3.encode = function(input) {
            var output = [];
            var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
            var i = 0, len = input.length, remainingBytes = len;
            var isArray2 = utils.getTypeOf(input) !== "string";
            while (i < input.length) {
              remainingBytes = len - i;
              if (!isArray2) {
                chr1 = input.charCodeAt(i++);
                chr2 = i < len ? input.charCodeAt(i++) : 0;
                chr3 = i < len ? input.charCodeAt(i++) : 0;
              } else {
                chr1 = input[i++];
                chr2 = i < len ? input[i++] : 0;
                chr3 = i < len ? input[i++] : 0;
              }
              enc1 = chr1 >> 2;
              enc2 = (chr1 & 3) << 4 | chr2 >> 4;
              enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
              enc4 = remainingBytes > 2 ? chr3 & 63 : 64;
              output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
            }
            return output.join("");
          };
          exports3.decode = function(input) {
            var chr1, chr2, chr3;
            var enc1, enc2, enc3, enc4;
            var i = 0, resultIndex = 0;
            var dataUrlPrefix = "data:";
            if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
              throw new Error("Invalid base64 input, it looks like a data url.");
            }
            input = input.replace(/[^A-Za-z0-9+/=]/g, "");
            var totalLength = input.length * 3 / 4;
            if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
              totalLength--;
            }
            if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
              totalLength--;
            }
            if (totalLength % 1 !== 0) {
              throw new Error("Invalid base64 input, bad content length.");
            }
            var output;
            if (support.uint8array) {
              output = new Uint8Array(totalLength | 0);
            } else {
              output = new Array(totalLength | 0);
            }
            while (i < input.length) {
              enc1 = _keyStr.indexOf(input.charAt(i++));
              enc2 = _keyStr.indexOf(input.charAt(i++));
              enc3 = _keyStr.indexOf(input.charAt(i++));
              enc4 = _keyStr.indexOf(input.charAt(i++));
              chr1 = enc1 << 2 | enc2 >> 4;
              chr2 = (enc2 & 15) << 4 | enc3 >> 2;
              chr3 = (enc3 & 3) << 6 | enc4;
              output[resultIndex++] = chr1;
              if (enc3 !== 64) {
                output[resultIndex++] = chr2;
              }
              if (enc4 !== 64) {
                output[resultIndex++] = chr3;
              }
            }
            return output;
          };
        }, { "./support": 30, "./utils": 32 }], 2: [function(require2, module3, exports3) {
          "use strict";
          var external = require2("./external");
          var DataWorker = require2("./stream/DataWorker");
          var Crc32Probe = require2("./stream/Crc32Probe");
          var DataLengthProbe = require2("./stream/DataLengthProbe");
          function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
            this.compressedSize = compressedSize;
            this.uncompressedSize = uncompressedSize;
            this.crc32 = crc32;
            this.compression = compression;
            this.compressedContent = data;
          }
          CompressedObject.prototype = {
            getContentWorker: function() {
              var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));
              var that = this;
              worker.on("end", function() {
                if (this.streamInfo["data_length"] !== that.uncompressedSize) {
                  throw new Error("Bug : uncompressed data size mismatch");
                }
              });
              return worker;
            },
            getCompressedWorker: function() {
              return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
            }
          };
          CompressedObject.createWorkerFrom = function(uncompressedWorker, compression, compressionOptions) {
            return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression);
          };
          module3.exports = CompressedObject;
        }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(require2, module3, exports3) {
          "use strict";
          var GenericWorker = require2("./stream/GenericWorker");
          exports3.STORE = {
            magic: "\0\0",
            compressWorker: function() {
              return new GenericWorker("STORE compression");
            },
            uncompressWorker: function() {
              return new GenericWorker("STORE decompression");
            }
          };
          exports3.DEFLATE = require2("./flate");
        }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(require2, module3, exports3) {
          "use strict";
          var utils = require2("./utils");
          function makeTable() {
            var c, table2 = [];
            for (var n = 0; n < 256; n++) {
              c = n;
              for (var k = 0; k < 8; k++) {
                c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
              }
              table2[n] = c;
            }
            return table2;
          }
          var crcTable = makeTable();
          function crc32(crc, buf, len, pos) {
            var t = crcTable, end = pos + len;
            crc = crc ^ -1;
            for (var i = pos; i < end; i++) {
              crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
            }
            return crc ^ -1;
          }
          function crc32str(crc, str, len, pos) {
            var t = crcTable, end = pos + len;
            crc = crc ^ -1;
            for (var i = pos; i < end; i++) {
              crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 255];
            }
            return crc ^ -1;
          }
          module3.exports = function crc32wrapper(input, crc) {
            if (typeof input === "undefined" || !input.length) {
              return 0;
            }
            var isArray2 = utils.getTypeOf(input) !== "string";
            if (isArray2) {
              return crc32(crc | 0, input, input.length, 0);
            } else {
              return crc32str(crc | 0, input, input.length, 0);
            }
          };
        }, { "./utils": 32 }], 5: [function(require2, module3, exports3) {
          "use strict";
          exports3.base64 = false;
          exports3.binary = false;
          exports3.dir = false;
          exports3.createFolders = true;
          exports3.date = null;
          exports3.compression = null;
          exports3.compressionOptions = null;
          exports3.comment = null;
          exports3.unixPermissions = null;
          exports3.dosPermissions = null;
        }, {}], 6: [function(require2, module3, exports3) {
          "use strict";
          var ES6Promise = null;
          if (typeof Promise !== "undefined") {
            ES6Promise = Promise;
          } else {
            ES6Promise = require2("lie");
          }
          module3.exports = {
            Promise: ES6Promise
          };
        }, { "lie": 37 }], 7: [function(require2, module3, exports3) {
          "use strict";
          var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
          var pako = require2("pako");
          var utils = require2("./utils");
          var GenericWorker = require2("./stream/GenericWorker");
          var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";
          exports3.magic = "\b\0";
          function FlateWorker(action, options) {
            GenericWorker.call(this, "FlateWorker/" + action);
            this._pako = null;
            this._pakoAction = action;
            this._pakoOptions = options;
            this.meta = {};
          }
          utils.inherits(FlateWorker, GenericWorker);
          FlateWorker.prototype.processChunk = function(chunk2) {
            this.meta = chunk2.meta;
            if (this._pako === null) {
              this._createPako();
            }
            this._pako.push(utils.transformTo(ARRAY_TYPE, chunk2.data), false);
          };
          FlateWorker.prototype.flush = function() {
            GenericWorker.prototype.flush.call(this);
            if (this._pako === null) {
              this._createPako();
            }
            this._pako.push([], true);
          };
          FlateWorker.prototype.cleanUp = function() {
            GenericWorker.prototype.cleanUp.call(this);
            this._pako = null;
          };
          FlateWorker.prototype._createPako = function() {
            this._pako = new pako[this._pakoAction]({
              raw: true,
              level: this._pakoOptions.level || -1
            });
            var self2 = this;
            this._pako.onData = function(data) {
              self2.push({
                data,
                meta: self2.meta
              });
            };
          };
          exports3.compressWorker = function(compressionOptions) {
            return new FlateWorker("Deflate", compressionOptions);
          };
          exports3.uncompressWorker = function() {
            return new FlateWorker("Inflate", {});
          };
        }, { "./stream/GenericWorker": 28, "./utils": 32, "pako": 38 }], 8: [function(require2, module3, exports3) {
          "use strict";
          var utils = require2("../utils");
          var GenericWorker = require2("../stream/GenericWorker");
          var utf8 = require2("../utf8");
          var crc32 = require2("../crc32");
          var signature = require2("../signature");
          var decToHex = function(dec, bytes) {
            var hex2 = "", i;
            for (i = 0; i < bytes; i++) {
              hex2 += String.fromCharCode(dec & 255);
              dec = dec >>> 8;
            }
            return hex2;
          };
          var generateUnixExternalFileAttr = function(unixPermissions, isDir) {
            var result = unixPermissions;
            if (!unixPermissions) {
              result = isDir ? 16893 : 33204;
            }
            return (result & 65535) << 16;
          };
          var generateDosExternalFileAttr = function(dosPermissions) {
            return (dosPermissions || 0) & 63;
          };
          var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
            var file = streamInfo["file"], compression = streamInfo["compression"], useCustomEncoding = encodeFileName !== utf8.utf8encode, encodedFileName = utils.transformTo("string", encodeFileName(file.name)), utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)), comment = file.comment, encodedComment = utils.transformTo("string", encodeFileName(comment)), utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, dosTime, dosDate, extraFields = "", unicodePathExtraField = "", unicodeCommentExtraField = "", dir = file.dir, date2 = file.date;
            var dataInfo = {
              crc32: 0,
              compressedSize: 0,
              uncompressedSize: 0
            };
            if (!streamedContent || streamingEnded) {
              dataInfo.crc32 = streamInfo["crc32"];
              dataInfo.compressedSize = streamInfo["compressedSize"];
              dataInfo.uncompressedSize = streamInfo["uncompressedSize"];
            }
            var bitflag = 0;
            if (streamedContent) {
              bitflag |= 8;
            }
            if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
              bitflag |= 2048;
            }
            var extFileAttr = 0;
            var versionMadeBy = 0;
            if (dir) {
              extFileAttr |= 16;
            }
            if (platform === "UNIX") {
              versionMadeBy = 798;
              extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
            } else {
              versionMadeBy = 20;
              extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
            }
            dosTime = date2.getUTCHours();
            dosTime = dosTime << 6;
            dosTime = dosTime | date2.getUTCMinutes();
            dosTime = dosTime << 5;
            dosTime = dosTime | date2.getUTCSeconds() / 2;
            dosDate = date2.getUTCFullYear() - 1980;
            dosDate = dosDate << 4;
            dosDate = dosDate | date2.getUTCMonth() + 1;
            dosDate = dosDate << 5;
            dosDate = dosDate | date2.getUTCDate();
            if (useUTF8ForFileName) {
              unicodePathExtraField = decToHex(1, 1) + decToHex(crc32(encodedFileName), 4) + utfEncodedFileName;
              extraFields += "up" + decToHex(unicodePathExtraField.length, 2) + unicodePathExtraField;
            }
            if (useUTF8ForComment) {
              unicodeCommentExtraField = decToHex(1, 1) + decToHex(crc32(encodedComment), 4) + utfEncodedComment;
              extraFields += "uc" + decToHex(unicodeCommentExtraField.length, 2) + unicodeCommentExtraField;
            }
            var header = "";
            header += "\n\0";
            header += decToHex(bitflag, 2);
            header += compression.magic;
            header += decToHex(dosTime, 2);
            header += decToHex(dosDate, 2);
            header += decToHex(dataInfo.crc32, 4);
            header += decToHex(dataInfo.compressedSize, 4);
            header += decToHex(dataInfo.uncompressedSize, 4);
            header += decToHex(encodedFileName.length, 2);
            header += decToHex(extraFields.length, 2);
            var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
            var dirRecord = signature.CENTRAL_FILE_HEADER + decToHex(versionMadeBy, 2) + header + decToHex(encodedComment.length, 2) + "\0\0\0\0" + decToHex(extFileAttr, 4) + decToHex(offset, 4) + encodedFileName + extraFields + encodedComment;
            return {
              fileRecord,
              dirRecord
            };
          };
          var generateCentralDirectoryEnd = function(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
            var dirEnd = "";
            var encodedComment = utils.transformTo("string", encodeFileName(comment));
            dirEnd = signature.CENTRAL_DIRECTORY_END + "\0\0\0\0" + decToHex(entriesCount, 2) + decToHex(entriesCount, 2) + decToHex(centralDirLength, 4) + decToHex(localDirLength, 4) + decToHex(encodedComment.length, 2) + encodedComment;
            return dirEnd;
          };
          var generateDataDescriptors = function(streamInfo) {
            var descriptor = "";
            descriptor = signature.DATA_DESCRIPTOR + decToHex(streamInfo["crc32"], 4) + decToHex(streamInfo["compressedSize"], 4) + decToHex(streamInfo["uncompressedSize"], 4);
            return descriptor;
          };
          function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
            GenericWorker.call(this, "ZipFileWorker");
            this.bytesWritten = 0;
            this.zipComment = comment;
            this.zipPlatform = platform;
            this.encodeFileName = encodeFileName;
            this.streamFiles = streamFiles;
            this.accumulate = false;
            this.contentBuffer = [];
            this.dirRecords = [];
            this.currentSourceOffset = 0;
            this.entriesCount = 0;
            this.currentFile = null;
            this._sources = [];
          }
          utils.inherits(ZipFileWorker, GenericWorker);
          ZipFileWorker.prototype.push = function(chunk2) {
            var currentFilePercent = chunk2.meta.percent || 0;
            var entriesCount = this.entriesCount;
            var remainingFiles = this._sources.length;
            if (this.accumulate) {
              this.contentBuffer.push(chunk2);
            } else {
              this.bytesWritten += chunk2.data.length;
              GenericWorker.prototype.push.call(this, {
                data: chunk2.data,
                meta: {
                  currentFile: this.currentFile,
                  percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
                }
              });
            }
          };
          ZipFileWorker.prototype.openedSource = function(streamInfo) {
            this.currentSourceOffset = this.bytesWritten;
            this.currentFile = streamInfo["file"].name;
            var streamedContent = this.streamFiles && !streamInfo["file"].dir;
            if (streamedContent) {
              var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
              this.push({
                data: record.fileRecord,
                meta: { percent: 0 }
              });
            } else {
              this.accumulate = true;
            }
          };
          ZipFileWorker.prototype.closedSource = function(streamInfo) {
            this.accumulate = false;
            var streamedContent = this.streamFiles && !streamInfo["file"].dir;
            var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.dirRecords.push(record.dirRecord);
            if (streamedContent) {
              this.push({
                data: generateDataDescriptors(streamInfo),
                meta: { percent: 100 }
              });
            } else {
              this.push({
                data: record.fileRecord,
                meta: { percent: 0 }
              });
              while (this.contentBuffer.length) {
                this.push(this.contentBuffer.shift());
              }
            }
            this.currentFile = null;
          };
          ZipFileWorker.prototype.flush = function() {
            var localDirLength = this.bytesWritten;
            for (var i = 0; i < this.dirRecords.length; i++) {
              this.push({
                data: this.dirRecords[i],
                meta: { percent: 100 }
              });
            }
            var centralDirLength = this.bytesWritten - localDirLength;
            var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
            this.push({
              data: dirEnd,
              meta: { percent: 100 }
            });
          };
          ZipFileWorker.prototype.prepareNextSource = function() {
            this.previous = this._sources.shift();
            this.openedSource(this.previous.streamInfo);
            if (this.isPaused) {
              this.previous.pause();
            } else {
              this.previous.resume();
            }
          };
          ZipFileWorker.prototype.registerPrevious = function(previous) {
            this._sources.push(previous);
            var self2 = this;
            previous.on("data", function(chunk2) {
              self2.processChunk(chunk2);
            });
            previous.on("end", function() {
              self2.closedSource(self2.previous.streamInfo);
              if (self2._sources.length) {
                self2.prepareNextSource();
              } else {
                self2.end();
              }
            });
            previous.on("error", function(e) {
              self2.error(e);
            });
            return this;
          };
          ZipFileWorker.prototype.resume = function() {
            if (!GenericWorker.prototype.resume.call(this)) {
              return false;
            }
            if (!this.previous && this._sources.length) {
              this.prepareNextSource();
              return true;
            }
            if (!this.previous && !this._sources.length && !this.generatedError) {
              this.end();
              return true;
            }
          };
          ZipFileWorker.prototype.error = function(e) {
            var sources = this._sources;
            if (!GenericWorker.prototype.error.call(this, e)) {
              return false;
            }
            for (var i = 0; i < sources.length; i++) {
              try {
                sources[i].error(e);
              } catch (e2) {
              }
            }
            return true;
          };
          ZipFileWorker.prototype.lock = function() {
            GenericWorker.prototype.lock.call(this);
            var sources = this._sources;
            for (var i = 0; i < sources.length; i++) {
              sources[i].lock();
            }
          };
          module3.exports = ZipFileWorker;
        }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(require2, module3, exports3) {
          "use strict";
          var compressions = require2("../compressions");
          var ZipFileWorker = require2("./ZipFileWorker");
          var getCompression = function(fileCompression, zipCompression) {
            var compressionName = fileCompression || zipCompression;
            var compression = compressions[compressionName];
            if (!compression) {
              throw new Error(compressionName + " is not a valid compression method !");
            }
            return compression;
          };
          exports3.generateWorker = function(zip, options, comment) {
            var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
            var entriesCount = 0;
            try {
              zip.forEach(function(relativePath, file) {
                entriesCount++;
                var compression = getCompression(file.options.compression, options.compression);
                var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
                var dir = file.dir, date2 = file.date;
                file._compressWorker(compression, compressionOptions).withStreamInfo("file", {
                  name: relativePath,
                  dir,
                  date: date2,
                  comment: file.comment || "",
                  unixPermissions: file.unixPermissions,
                  dosPermissions: file.dosPermissions
                }).pipe(zipFileWorker);
              });
              zipFileWorker.entriesCount = entriesCount;
            } catch (e) {
              zipFileWorker.error(e);
            }
            return zipFileWorker;
          };
        }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(require2, module3, exports3) {
          "use strict";
          function JSZip2() {
            if (!(this instanceof JSZip2)) {
              return new JSZip2();
            }
            if (arguments.length) {
              throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
            }
            this.files = /* @__PURE__ */ Object.create(null);
            this.comment = null;
            this.root = "";
            this.clone = function() {
              var newObj = new JSZip2();
              for (var i in this) {
                if (typeof this[i] !== "function") {
                  newObj[i] = this[i];
                }
              }
              return newObj;
            };
          }
          JSZip2.prototype = require2("./object");
          JSZip2.prototype.loadAsync = require2("./load");
          JSZip2.support = require2("./support");
          JSZip2.defaults = require2("./defaults");
          JSZip2.version = "3.10.1";
          JSZip2.loadAsync = function(content, options) {
            return new JSZip2().loadAsync(content, options);
          };
          JSZip2.external = require2("./external");
          module3.exports = JSZip2;
        }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(require2, module3, exports3) {
          "use strict";
          var utils = require2("./utils");
          var external = require2("./external");
          var utf8 = require2("./utf8");
          var ZipEntries = require2("./zipEntries");
          var Crc32Probe = require2("./stream/Crc32Probe");
          var nodejsUtils = require2("./nodejsUtils");
          function checkEntryCRC32(zipEntry) {
            return new external.Promise(function(resolve2, reject) {
              var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
              worker.on("error", function(e) {
                reject(e);
              }).on("end", function() {
                if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
                  reject(new Error("Corrupted zip : CRC32 mismatch"));
                } else {
                  resolve2();
                }
              }).resume();
            });
          }
          module3.exports = function(data, options) {
            var zip = this;
            options = utils.extend(options || {}, {
              base64: false,
              checkCRC32: false,
              optimizedBinaryString: false,
              createFolders: false,
              decodeFileName: utf8.utf8decode
            });
            if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
              return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
            }
            return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function(data2) {
              var zipEntries = new ZipEntries(options);
              zipEntries.load(data2);
              return zipEntries;
            }).then(function checkCRC32(zipEntries) {
              var promises = [external.Promise.resolve(zipEntries)];
              var files = zipEntries.files;
              if (options.checkCRC32) {
                for (var i = 0; i < files.length; i++) {
                  promises.push(checkEntryCRC32(files[i]));
                }
              }
              return external.Promise.all(promises);
            }).then(function addFiles(results) {
              var zipEntries = results.shift();
              var files = zipEntries.files;
              for (var i = 0; i < files.length; i++) {
                var input = files[i];
                var unsafeName = input.fileNameStr;
                var safeName = utils.resolve(input.fileNameStr);
                zip.file(safeName, input.decompressed, {
                  binary: true,
                  optimizedBinaryString: true,
                  date: input.date,
                  dir: input.dir,
                  comment: input.fileCommentStr.length ? input.fileCommentStr : null,
                  unixPermissions: input.unixPermissions,
                  dosPermissions: input.dosPermissions,
                  createFolders: options.createFolders
                });
                if (!input.dir) {
                  zip.file(safeName).unsafeOriginalName = unsafeName;
                }
              }
              if (zipEntries.zipComment.length) {
                zip.comment = zipEntries.zipComment;
              }
              return zip;
            });
          };
        }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(require2, module3, exports3) {
          "use strict";
          var utils = require2("../utils");
          var GenericWorker = require2("../stream/GenericWorker");
          function NodejsStreamInputAdapter(filename, stream) {
            GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
            this._upstreamEnded = false;
            this._bindStream(stream);
          }
          utils.inherits(NodejsStreamInputAdapter, GenericWorker);
          NodejsStreamInputAdapter.prototype._bindStream = function(stream) {
            var self2 = this;
            this._stream = stream;
            stream.pause();
            stream.on("data", function(chunk2) {
              self2.push({
                data: chunk2,
                meta: {
                  percent: 0
                }
              });
            }).on("error", function(e) {
              if (self2.isPaused) {
                this.generatedError = e;
              } else {
                self2.error(e);
              }
            }).on("end", function() {
              if (self2.isPaused) {
                self2._upstreamEnded = true;
              } else {
                self2.end();
              }
            });
          };
          NodejsStreamInputAdapter.prototype.pause = function() {
            if (!GenericWorker.prototype.pause.call(this)) {
              return false;
            }
            this._stream.pause();
            return true;
          };
          NodejsStreamInputAdapter.prototype.resume = function() {
            if (!GenericWorker.prototype.resume.call(this)) {
              return false;
            }
            if (this._upstreamEnded) {
              this.end();
            } else {
              this._stream.resume();
            }
            return true;
          };
          module3.exports = NodejsStreamInputAdapter;
        }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(require2, module3, exports3) {
          "use strict";
          var Readable = require2("readable-stream").Readable;
          var utils = require2("../utils");
          utils.inherits(NodejsStreamOutputAdapter, Readable);
          function NodejsStreamOutputAdapter(helper, options, updateCb) {
            Readable.call(this, options);
            this._helper = helper;
            var self2 = this;
            helper.on("data", function(data, meta) {
              if (!self2.push(data)) {
                self2._helper.pause();
              }
              if (updateCb) {
                updateCb(meta);
              }
            }).on("error", function(e) {
              self2.emit("error", e);
            }).on("end", function() {
              self2.push(null);
            });
          }
          NodejsStreamOutputAdapter.prototype._read = function() {
            this._helper.resume();
          };
          module3.exports = NodejsStreamOutputAdapter;
        }, { "../utils": 32, "readable-stream": 16 }], 14: [function(require2, module3, exports3) {
          "use strict";
          module3.exports = {
            isNode: typeof Buffer !== "undefined",
            newBufferFrom: function(data, encoding) {
              if (Buffer.from && Buffer.from !== Uint8Array.from) {
                return Buffer.from(data, encoding);
              } else {
                if (typeof data === "number") {
                  throw new Error('The "data" argument must not be a number');
                }
                return new Buffer(data, encoding);
              }
            },
            allocBuffer: function(size2) {
              if (Buffer.alloc) {
                return Buffer.alloc(size2);
              } else {
                var buf = new Buffer(size2);
                buf.fill(0);
                return buf;
              }
            },
            isBuffer: function(b) {
              return Buffer.isBuffer(b);
            },
            isStream: function(obj) {
              return obj && typeof obj.on === "function" && typeof obj.pause === "function" && typeof obj.resume === "function";
            }
          };
        }, {}], 15: [function(require2, module3, exports3) {
          "use strict";
          var utf8 = require2("./utf8");
          var utils = require2("./utils");
          var GenericWorker = require2("./stream/GenericWorker");
          var StreamHelper = require2("./stream/StreamHelper");
          var defaults2 = require2("./defaults");
          var CompressedObject = require2("./compressedObject");
          var ZipObject = require2("./zipObject");
          var generate = require2("./generate");
          var nodejsUtils = require2("./nodejsUtils");
          var NodejsStreamInputAdapter = require2("./nodejs/NodejsStreamInputAdapter");
          var fileAdd = function(name, data, originalOptions) {
            var dataType = utils.getTypeOf(data), parent2;
            var o = utils.extend(originalOptions || {}, defaults2);
            o.date = o.date || new Date();
            if (o.compression !== null) {
              o.compression = o.compression.toUpperCase();
            }
            if (typeof o.unixPermissions === "string") {
              o.unixPermissions = parseInt(o.unixPermissions, 8);
            }
            if (o.unixPermissions && o.unixPermissions & 16384) {
              o.dir = true;
            }
            if (o.dosPermissions && o.dosPermissions & 16) {
              o.dir = true;
            }
            if (o.dir) {
              name = forceTrailingSlash(name);
            }
            if (o.createFolders && (parent2 = parentFolder(name))) {
              folderAdd.call(this, parent2, true);
            }
            var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
            if (!originalOptions || typeof originalOptions.binary === "undefined") {
              o.binary = !isUnicodeString;
            }
            var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;
            if (isCompressedEmpty || o.dir || !data || data.length === 0) {
              o.base64 = false;
              o.binary = true;
              data = "";
              o.compression = "STORE";
              dataType = "string";
            }
            var zipObjectContent = null;
            if (data instanceof CompressedObject || data instanceof GenericWorker) {
              zipObjectContent = data;
            } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
              zipObjectContent = new NodejsStreamInputAdapter(name, data);
            } else {
              zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
            }
            var object = new ZipObject(name, zipObjectContent, o);
            this.files[name] = object;
          };
          var parentFolder = function(path5) {
            if (path5.slice(-1) === "/") {
              path5 = path5.substring(0, path5.length - 1);
            }
            var lastSlash = path5.lastIndexOf("/");
            return lastSlash > 0 ? path5.substring(0, lastSlash) : "";
          };
          var forceTrailingSlash = function(path5) {
            if (path5.slice(-1) !== "/") {
              path5 += "/";
            }
            return path5;
          };
          var folderAdd = function(name, createFolders) {
            createFolders = typeof createFolders !== "undefined" ? createFolders : defaults2.createFolders;
            name = forceTrailingSlash(name);
            if (!this.files[name]) {
              fileAdd.call(this, name, null, {
                dir: true,
                createFolders
              });
            }
            return this.files[name];
          };
          function isRegExp2(object) {
            return Object.prototype.toString.call(object) === "[object RegExp]";
          }
          var out = {
            load: function() {
              throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
            },
            forEach: function(cb) {
              var filename, relativePath, file;
              for (filename in this.files) {
                file = this.files[filename];
                relativePath = filename.slice(this.root.length, filename.length);
                if (relativePath && filename.slice(0, this.root.length) === this.root) {
                  cb(relativePath, file);
                }
              }
            },
            filter: function(search) {
              var result = [];
              this.forEach(function(relativePath, entry) {
                if (search(relativePath, entry)) {
                  result.push(entry);
                }
              });
              return result;
            },
            file: function(name, data, o) {
              if (arguments.length === 1) {
                if (isRegExp2(name)) {
                  var regexp = name;
                  return this.filter(function(relativePath, file) {
                    return !file.dir && regexp.test(relativePath);
                  });
                } else {
                  var obj = this.files[this.root + name];
                  if (obj && !obj.dir) {
                    return obj;
                  } else {
                    return null;
                  }
                }
              } else {
                name = this.root + name;
                fileAdd.call(this, name, data, o);
              }
              return this;
            },
            folder: function(arg) {
              if (!arg) {
                return this;
              }
              if (isRegExp2(arg)) {
                return this.filter(function(relativePath, file) {
                  return file.dir && arg.test(relativePath);
                });
              }
              var name = this.root + arg;
              var newFolder = folderAdd.call(this, name);
              var ret = this.clone();
              ret.root = newFolder.name;
              return ret;
            },
            remove: function(name) {
              name = this.root + name;
              var file = this.files[name];
              if (!file) {
                if (name.slice(-1) !== "/") {
                  name += "/";
                }
                file = this.files[name];
              }
              if (file && !file.dir) {
                delete this.files[name];
              } else {
                var kids = this.filter(function(relativePath, file2) {
                  return file2.name.slice(0, name.length) === name;
                });
                for (var i = 0; i < kids.length; i++) {
                  delete this.files[kids[i].name];
                }
              }
              return this;
            },
            generate: function() {
              throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
            },
            generateInternalStream: function(options) {
              var worker, opts = {};
              try {
                opts = utils.extend(options || {}, {
                  streamFiles: false,
                  compression: "STORE",
                  compressionOptions: null,
                  type: "",
                  platform: "DOS",
                  comment: null,
                  mimeType: "application/zip",
                  encodeFileName: utf8.utf8encode
                });
                opts.type = opts.type.toLowerCase();
                opts.compression = opts.compression.toUpperCase();
                if (opts.type === "binarystring") {
                  opts.type = "string";
                }
                if (!opts.type) {
                  throw new Error("No output type specified.");
                }
                utils.checkSupport(opts.type);
                if (opts.platform === "darwin" || opts.platform === "freebsd" || opts.platform === "linux" || opts.platform === "sunos") {
                  opts.platform = "UNIX";
                }
                if (opts.platform === "win32") {
                  opts.platform = "DOS";
                }
                var comment = opts.comment || this.comment || "";
                worker = generate.generateWorker(this, opts, comment);
              } catch (e) {
                worker = new GenericWorker("error");
                worker.error(e);
              }
              return new StreamHelper(worker, opts.type || "string", opts.mimeType);
            },
            generateAsync: function(options, onUpdate) {
              return this.generateInternalStream(options).accumulate(onUpdate);
            },
            generateNodeStream: function(options, onUpdate) {
              options = options || {};
              if (!options.type) {
                options.type = "nodebuffer";
              }
              return this.generateInternalStream(options).toNodejsStream(onUpdate);
            }
          };
          module3.exports = out;
        }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(require2, module3, exports3) {
          "use strict";
          module3.exports = require2("stream");
        }, { "stream": void 0 }], 17: [function(require2, module3, exports3) {
          "use strict";
          var DataReader = require2("./DataReader");
          var utils = require2("../utils");
          function ArrayReader(data) {
            DataReader.call(this, data);
            for (var i = 0; i < this.data.length; i++) {
              data[i] = data[i] & 255;
            }
          }
          utils.inherits(ArrayReader, DataReader);
          ArrayReader.prototype.byteAt = function(i) {
            return this.data[this.zero + i];
          };
          ArrayReader.prototype.lastIndexOfSignature = function(sig) {
            var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);
            for (var i = this.length - 4; i >= 0; --i) {
              if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
                return i - this.zero;
              }
            }
            return -1;
          };
          ArrayReader.prototype.readAndCheckSignature = function(sig) {
            var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3), data = this.readData(4);
            return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
          };
          ArrayReader.prototype.readData = function(size2) {
            this.checkOffset(size2);
            if (size2 === 0) {
              return [];
            }
            var result = this.data.slice(this.zero + this.index, this.zero + this.index + size2);
            this.index += size2;
            return result;
          };
          module3.exports = ArrayReader;
        }, { "../utils": 32, "./DataReader": 18 }], 18: [function(require2, module3, exports3) {
          "use strict";
          var utils = require2("../utils");
          function DataReader(data) {
            this.data = data;
            this.length = data.length;
            this.index = 0;
            this.zero = 0;
          }
          DataReader.prototype = {
            checkOffset: function(offset) {
              this.checkIndex(this.index + offset);
            },
            checkIndex: function(newIndex) {
              if (this.length < this.zero + newIndex || newIndex < 0) {
                throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
              }
            },
            setIndex: function(newIndex) {
              this.checkIndex(newIndex);
              this.index = newIndex;
            },
            skip: function(n) {
              this.setIndex(this.index + n);
            },
            byteAt: function() {
            },
            readInt: function(size2) {
              var result = 0, i;
              this.checkOffset(size2);
              for (i = this.index + size2 - 1; i >= this.index; i--) {
                result = (result << 8) + this.byteAt(i);
              }
              this.index += size2;
              return result;
            },
            readString: function(size2) {
              return utils.transformTo("string", this.readData(size2));
            },
            readData: function() {
            },
            lastIndexOfSignature: function() {
            },
            readAndCheckSignature: function() {
            },
            readDate: function() {
              var dostime = this.readInt(4);
              return new Date(Date.UTC(
                (dostime >> 25 & 127) + 1980,
                (dostime >> 21 & 15) - 1,
                dostime >> 16 & 31,
                dostime >> 11 & 31,
                dostime >> 5 & 63,
                (dostime & 31) << 1
              ));
            }
          };
          module3.exports = DataReader;
        }, { "../utils": 32 }], 19: [function(require2, module3, exports3) {
          "use strict";
          var Uint8ArrayReader = require2("./Uint8ArrayReader");
          var utils = require2("../utils");
          function NodeBufferReader(data) {
            Uint8ArrayReader.call(this, data);
          }
          utils.inherits(NodeBufferReader, Uint8ArrayReader);
          NodeBufferReader.prototype.readData = function(size2) {
            this.checkOffset(size2);
            var result = this.data.slice(this.zero + this.index, this.zero + this.index + size2);
            this.index += size2;
            return result;
          };
          module3.exports = NodeBufferReader;
        }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(require2, module3, exports3) {
          "use strict";
          var DataReader = require2("./DataReader");
          var utils = require2("../utils");
          function StringReader(data) {
            DataReader.call(this, data);
          }
          utils.inherits(StringReader, DataReader);
          StringReader.prototype.byteAt = function(i) {
            return this.data.charCodeAt(this.zero + i);
          };
          StringReader.prototype.lastIndexOfSignature = function(sig) {
            return this.data.lastIndexOf(sig) - this.zero;
          };
          StringReader.prototype.readAndCheckSignature = function(sig) {
            var data = this.readData(4);
            return sig === data;
          };
          StringReader.prototype.readData = function(size2) {
            this.checkOffset(size2);
            var result = this.data.slice(this.zero + this.index, this.zero + this.index + size2);
            this.index += size2;
            return result;
          };
          module3.exports = StringReader;
        }, { "../utils": 32, "./DataReader": 18 }], 21: [function(require2, module3, exports3) {
          "use strict";
          var ArrayReader = require2("./ArrayReader");
          var utils = require2("../utils");
          function Uint8ArrayReader(data) {
            ArrayReader.call(this, data);
          }
          utils.inherits(Uint8ArrayReader, ArrayReader);
          Uint8ArrayReader.prototype.readData = function(size2) {
            this.checkOffset(size2);
            if (size2 === 0) {
              return new Uint8Array(0);
            }
            var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size2);
            this.index += size2;
            return result;
          };
          module3.exports = Uint8ArrayReader;
        }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(require2, module3, exports3) {
          "use strict";
          var utils = require2("../utils");
          var support = require2("../support");
          var ArrayReader = require2("./ArrayReader");
          var StringReader = require2("./StringReader");
          var NodeBufferReader = require2("./NodeBufferReader");
          var Uint8ArrayReader = require2("./Uint8ArrayReader");
          module3.exports = function(data) {
            var type2 = utils.getTypeOf(data);
            utils.checkSupport(type2);
            if (type2 === "string" && !support.uint8array) {
              return new StringReader(data);
            }
            if (type2 === "nodebuffer") {
              return new NodeBufferReader(data);
            }
            if (support.uint8array) {
              return new Uint8ArrayReader(utils.transformTo("uint8array", data));
            }
            return new ArrayReader(utils.transformTo("array", data));
          };
        }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(require2, module3, exports3) {
          "use strict";
          exports3.LOCAL_FILE_HEADER = "PK";
          exports3.CENTRAL_FILE_HEADER = "PK";
          exports3.CENTRAL_DIRECTORY_END = "PK";
          exports3.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07";
          exports3.ZIP64_CENTRAL_DIRECTORY_END = "PK";
          exports3.DATA_DESCRIPTOR = "PK\x07\b";
        }, {}], 24: [function(require2, module3, exports3) {
          "use strict";
          var GenericWorker = require2("./GenericWorker");
          var utils = require2("../utils");
          function ConvertWorker(destType) {
            GenericWorker.call(this, "ConvertWorker to " + destType);
            this.destType = destType;
          }
          utils.inherits(ConvertWorker, GenericWorker);
          ConvertWorker.prototype.processChunk = function(chunk2) {
            this.push({
              data: utils.transformTo(this.destType, chunk2.data),
              meta: chunk2.meta
            });
          };
          module3.exports = ConvertWorker;
        }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(require2, module3, exports3) {
          "use strict";
          var GenericWorker = require2("./GenericWorker");
          var crc32 = require2("../crc32");
          var utils = require2("../utils");
          function Crc32Probe() {
            GenericWorker.call(this, "Crc32Probe");
            this.withStreamInfo("crc32", 0);
          }
          utils.inherits(Crc32Probe, GenericWorker);
          Crc32Probe.prototype.processChunk = function(chunk2) {
            this.streamInfo.crc32 = crc32(chunk2.data, this.streamInfo.crc32 || 0);
            this.push(chunk2);
          };
          module3.exports = Crc32Probe;
        }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(require2, module3, exports3) {
          "use strict";
          var utils = require2("../utils");
          var GenericWorker = require2("./GenericWorker");
          function DataLengthProbe(propName) {
            GenericWorker.call(this, "DataLengthProbe for " + propName);
            this.propName = propName;
            this.withStreamInfo(propName, 0);
          }
          utils.inherits(DataLengthProbe, GenericWorker);
          DataLengthProbe.prototype.processChunk = function(chunk2) {
            if (chunk2) {
              var length = this.streamInfo[this.propName] || 0;
              this.streamInfo[this.propName] = length + chunk2.data.length;
            }
            GenericWorker.prototype.processChunk.call(this, chunk2);
          };
          module3.exports = DataLengthProbe;
        }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(require2, module3, exports3) {
          "use strict";
          var utils = require2("../utils");
          var GenericWorker = require2("./GenericWorker");
          var DEFAULT_BLOCK_SIZE = 16 * 1024;
          function DataWorker(dataP) {
            GenericWorker.call(this, "DataWorker");
            var self2 = this;
            this.dataIsReady = false;
            this.index = 0;
            this.max = 0;
            this.data = null;
            this.type = "";
            this._tickScheduled = false;
            dataP.then(function(data) {
              self2.dataIsReady = true;
              self2.data = data;
              self2.max = data && data.length || 0;
              self2.type = utils.getTypeOf(data);
              if (!self2.isPaused) {
                self2._tickAndRepeat();
              }
            }, function(e) {
              self2.error(e);
            });
          }
          utils.inherits(DataWorker, GenericWorker);
          DataWorker.prototype.cleanUp = function() {
            GenericWorker.prototype.cleanUp.call(this);
            this.data = null;
          };
          DataWorker.prototype.resume = function() {
            if (!GenericWorker.prototype.resume.call(this)) {
              return false;
            }
            if (!this._tickScheduled && this.dataIsReady) {
              this._tickScheduled = true;
              utils.delay(this._tickAndRepeat, [], this);
            }
            return true;
          };
          DataWorker.prototype._tickAndRepeat = function() {
            this._tickScheduled = false;
            if (this.isPaused || this.isFinished) {
              return;
            }
            this._tick();
            if (!this.isFinished) {
              utils.delay(this._tickAndRepeat, [], this);
              this._tickScheduled = true;
            }
          };
          DataWorker.prototype._tick = function() {
            if (this.isPaused || this.isFinished) {
              return false;
            }
            var size2 = DEFAULT_BLOCK_SIZE;
            var data = null, nextIndex = Math.min(this.max, this.index + size2);
            if (this.index >= this.max) {
              return this.end();
            } else {
              switch (this.type) {
                case "string":
                  data = this.data.substring(this.index, nextIndex);
                  break;
                case "uint8array":
                  data = this.data.subarray(this.index, nextIndex);
                  break;
                case "array":
                case "nodebuffer":
                  data = this.data.slice(this.index, nextIndex);
                  break;
              }
              this.index = nextIndex;
              return this.push({
                data,
                meta: {
                  percent: this.max ? this.index / this.max * 100 : 0
                }
              });
            }
          };
          module3.exports = DataWorker;
        }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(require2, module3, exports3) {
          "use strict";
          function GenericWorker(name) {
            this.name = name || "default";
            this.streamInfo = {};
            this.generatedError = null;
            this.extraStreamInfo = {};
            this.isPaused = true;
            this.isFinished = false;
            this.isLocked = false;
            this._listeners = {
              "data": [],
              "end": [],
              "error": []
            };
            this.previous = null;
          }
          GenericWorker.prototype = {
            push: function(chunk2) {
              this.emit("data", chunk2);
            },
            end: function() {
              if (this.isFinished) {
                return false;
              }
              this.flush();
              try {
                this.emit("end");
                this.cleanUp();
                this.isFinished = true;
              } catch (e) {
                this.emit("error", e);
              }
              return true;
            },
            error: function(e) {
              if (this.isFinished) {
                return false;
              }
              if (this.isPaused) {
                this.generatedError = e;
              } else {
                this.isFinished = true;
                this.emit("error", e);
                if (this.previous) {
                  this.previous.error(e);
                }
                this.cleanUp();
              }
              return true;
            },
            on: function(name, listener) {
              this._listeners[name].push(listener);
              return this;
            },
            cleanUp: function() {
              this.streamInfo = this.generatedError = this.extraStreamInfo = null;
              this._listeners = [];
            },
            emit: function(name, arg) {
              if (this._listeners[name]) {
                for (var i = 0; i < this._listeners[name].length; i++) {
                  this._listeners[name][i].call(this, arg);
                }
              }
            },
            pipe: function(next) {
              return next.registerPrevious(this);
            },
            registerPrevious: function(previous) {
              if (this.isLocked) {
                throw new Error("The stream '" + this + "' has already been used.");
              }
              this.streamInfo = previous.streamInfo;
              this.mergeStreamInfo();
              this.previous = previous;
              var self2 = this;
              previous.on("data", function(chunk2) {
                self2.processChunk(chunk2);
              });
              previous.on("end", function() {
                self2.end();
              });
              previous.on("error", function(e) {
                self2.error(e);
              });
              return this;
            },
            pause: function() {
              if (this.isPaused || this.isFinished) {
                return false;
              }
              this.isPaused = true;
              if (this.previous) {
                this.previous.pause();
              }
              return true;
            },
            resume: function() {
              if (!this.isPaused || this.isFinished) {
                return false;
              }
              this.isPaused = false;
              var withError = false;
              if (this.generatedError) {
                this.error(this.generatedError);
                withError = true;
              }
              if (this.previous) {
                this.previous.resume();
              }
              return !withError;
            },
            flush: function() {
            },
            processChunk: function(chunk2) {
              this.push(chunk2);
            },
            withStreamInfo: function(key, value) {
              this.extraStreamInfo[key] = value;
              this.mergeStreamInfo();
              return this;
            },
            mergeStreamInfo: function() {
              for (var key in this.extraStreamInfo) {
                if (!Object.prototype.hasOwnProperty.call(this.extraStreamInfo, key)) {
                  continue;
                }
                this.streamInfo[key] = this.extraStreamInfo[key];
              }
            },
            lock: function() {
              if (this.isLocked) {
                throw new Error("The stream '" + this + "' has already been used.");
              }
              this.isLocked = true;
              if (this.previous) {
                this.previous.lock();
              }
            },
            toString: function() {
              var me = "Worker " + this.name;
              if (this.previous) {
                return this.previous + " -> " + me;
              } else {
                return me;
              }
            }
          };
          module3.exports = GenericWorker;
        }, {}], 29: [function(require2, module3, exports3) {
          "use strict";
          var utils = require2("../utils");
          var ConvertWorker = require2("./ConvertWorker");
          var GenericWorker = require2("./GenericWorker");
          var base64 = require2("../base64");
          var support = require2("../support");
          var external = require2("../external");
          var NodejsStreamOutputAdapter = null;
          if (support.nodestream) {
            try {
              NodejsStreamOutputAdapter = require2("../nodejs/NodejsStreamOutputAdapter");
            } catch (e) {
            }
          }
          function transformZipOutput(type2, content, mimeType) {
            switch (type2) {
              case "blob":
                return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);
              case "base64":
                return base64.encode(content);
              default:
                return utils.transformTo(type2, content);
            }
          }
          function concat(type2, dataArray) {
            var i, index = 0, res = null, totalLength = 0;
            for (i = 0; i < dataArray.length; i++) {
              totalLength += dataArray[i].length;
            }
            switch (type2) {
              case "string":
                return dataArray.join("");
              case "array":
                return Array.prototype.concat.apply([], dataArray);
              case "uint8array":
                res = new Uint8Array(totalLength);
                for (i = 0; i < dataArray.length; i++) {
                  res.set(dataArray[i], index);
                  index += dataArray[i].length;
                }
                return res;
              case "nodebuffer":
                return Buffer.concat(dataArray);
              default:
                throw new Error("concat : unsupported type '" + type2 + "'");
            }
          }
          function accumulate(helper, updateCallback) {
            return new external.Promise(function(resolve2, reject) {
              var dataArray = [];
              var chunkType = helper._internalType, resultType = helper._outputType, mimeType = helper._mimeType;
              helper.on("data", function(data, meta) {
                dataArray.push(data);
                if (updateCallback) {
                  updateCallback(meta);
                }
              }).on("error", function(err) {
                dataArray = [];
                reject(err);
              }).on("end", function() {
                try {
                  var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
                  resolve2(result);
                } catch (e) {
                  reject(e);
                }
                dataArray = [];
              }).resume();
            });
          }
          function StreamHelper(worker, outputType, mimeType) {
            var internalType = outputType;
            switch (outputType) {
              case "blob":
              case "arraybuffer":
                internalType = "uint8array";
                break;
              case "base64":
                internalType = "string";
                break;
            }
            try {
              this._internalType = internalType;
              this._outputType = outputType;
              this._mimeType = mimeType;
              utils.checkSupport(internalType);
              this._worker = worker.pipe(new ConvertWorker(internalType));
              worker.lock();
            } catch (e) {
              this._worker = new GenericWorker("error");
              this._worker.error(e);
            }
          }
          StreamHelper.prototype = {
            accumulate: function(updateCb) {
              return accumulate(this, updateCb);
            },
            on: function(evt, fn) {
              var self2 = this;
              if (evt === "data") {
                this._worker.on(evt, function(chunk2) {
                  fn.call(self2, chunk2.data, chunk2.meta);
                });
              } else {
                this._worker.on(evt, function() {
                  utils.delay(fn, arguments, self2);
                });
              }
              return this;
            },
            resume: function() {
              utils.delay(this._worker.resume, [], this._worker);
              return this;
            },
            pause: function() {
              this._worker.pause();
              return this;
            },
            toNodejsStream: function(updateCb) {
              utils.checkSupport("nodestream");
              if (this._outputType !== "nodebuffer") {
                throw new Error(this._outputType + " is not supported by this method");
              }
              return new NodejsStreamOutputAdapter(this, {
                objectMode: this._outputType !== "nodebuffer"
              }, updateCb);
            }
          };
          module3.exports = StreamHelper;
        }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(require2, module3, exports3) {
          "use strict";
          exports3.base64 = true;
          exports3.array = true;
          exports3.string = true;
          exports3.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
          exports3.nodebuffer = typeof Buffer !== "undefined";
          exports3.uint8array = typeof Uint8Array !== "undefined";
          if (typeof ArrayBuffer === "undefined") {
            exports3.blob = false;
          } else {
            var buffer2 = new ArrayBuffer(0);
            try {
              exports3.blob = new Blob([buffer2], {
                type: "application/zip"
              }).size === 0;
            } catch (e) {
              try {
                var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
                var builder = new Builder();
                builder.append(buffer2);
                exports3.blob = builder.getBlob("application/zip").size === 0;
              } catch (e2) {
                exports3.blob = false;
              }
            }
          }
          try {
            exports3.nodestream = !!require2("readable-stream").Readable;
          } catch (e) {
            exports3.nodestream = false;
          }
        }, { "readable-stream": 16 }], 31: [function(require2, module3, exports3) {
          "use strict";
          var utils = require2("./utils");
          var support = require2("./support");
          var nodejsUtils = require2("./nodejsUtils");
          var GenericWorker = require2("./stream/GenericWorker");
          var _utf8len = new Array(256);
          for (var i = 0; i < 256; i++) {
            _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
          }
          _utf8len[254] = _utf8len[254] = 1;
          var string2buf = function(str) {
            var buf, c, c2, m_pos, i2, str_len = str.length, buf_len = 0;
            for (m_pos = 0; m_pos < str_len; m_pos++) {
              c = str.charCodeAt(m_pos);
              if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
                c2 = str.charCodeAt(m_pos + 1);
                if ((c2 & 64512) === 56320) {
                  c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                  m_pos++;
                }
              }
              buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
            }
            if (support.uint8array) {
              buf = new Uint8Array(buf_len);
            } else {
              buf = new Array(buf_len);
            }
            for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
              c = str.charCodeAt(m_pos);
              if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
                c2 = str.charCodeAt(m_pos + 1);
                if ((c2 & 64512) === 56320) {
                  c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                  m_pos++;
                }
              }
              if (c < 128) {
                buf[i2++] = c;
              } else if (c < 2048) {
                buf[i2++] = 192 | c >>> 6;
                buf[i2++] = 128 | c & 63;
              } else if (c < 65536) {
                buf[i2++] = 224 | c >>> 12;
                buf[i2++] = 128 | c >>> 6 & 63;
                buf[i2++] = 128 | c & 63;
              } else {
                buf[i2++] = 240 | c >>> 18;
                buf[i2++] = 128 | c >>> 12 & 63;
                buf[i2++] = 128 | c >>> 6 & 63;
                buf[i2++] = 128 | c & 63;
              }
            }
            return buf;
          };
          var utf8border = function(buf, max) {
            var pos;
            max = max || buf.length;
            if (max > buf.length) {
              max = buf.length;
            }
            pos = max - 1;
            while (pos >= 0 && (buf[pos] & 192) === 128) {
              pos--;
            }
            if (pos < 0) {
              return max;
            }
            if (pos === 0) {
              return max;
            }
            return pos + _utf8len[buf[pos]] > max ? pos : max;
          };
          var buf2string = function(buf) {
            var i2, out, c, c_len;
            var len = buf.length;
            var utf16buf = new Array(len * 2);
            for (out = 0, i2 = 0; i2 < len; ) {
              c = buf[i2++];
              if (c < 128) {
                utf16buf[out++] = c;
                continue;
              }
              c_len = _utf8len[c];
              if (c_len > 4) {
                utf16buf[out++] = 65533;
                i2 += c_len - 1;
                continue;
              }
              c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
              while (c_len > 1 && i2 < len) {
                c = c << 6 | buf[i2++] & 63;
                c_len--;
              }
              if (c_len > 1) {
                utf16buf[out++] = 65533;
                continue;
              }
              if (c < 65536) {
                utf16buf[out++] = c;
              } else {
                c -= 65536;
                utf16buf[out++] = 55296 | c >> 10 & 1023;
                utf16buf[out++] = 56320 | c & 1023;
              }
            }
            if (utf16buf.length !== out) {
              if (utf16buf.subarray) {
                utf16buf = utf16buf.subarray(0, out);
              } else {
                utf16buf.length = out;
              }
            }
            return utils.applyFromCharCode(utf16buf);
          };
          exports3.utf8encode = function utf8encode(str) {
            if (support.nodebuffer) {
              return nodejsUtils.newBufferFrom(str, "utf-8");
            }
            return string2buf(str);
          };
          exports3.utf8decode = function utf8decode(buf) {
            if (support.nodebuffer) {
              return utils.transformTo("nodebuffer", buf).toString("utf-8");
            }
            buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);
            return buf2string(buf);
          };
          function Utf8DecodeWorker() {
            GenericWorker.call(this, "utf-8 decode");
            this.leftOver = null;
          }
          utils.inherits(Utf8DecodeWorker, GenericWorker);
          Utf8DecodeWorker.prototype.processChunk = function(chunk2) {
            var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk2.data);
            if (this.leftOver && this.leftOver.length) {
              if (support.uint8array) {
                var previousData = data;
                data = new Uint8Array(previousData.length + this.leftOver.length);
                data.set(this.leftOver, 0);
                data.set(previousData, this.leftOver.length);
              } else {
                data = this.leftOver.concat(data);
              }
              this.leftOver = null;
            }
            var nextBoundary = utf8border(data);
            var usableData = data;
            if (nextBoundary !== data.length) {
              if (support.uint8array) {
                usableData = data.subarray(0, nextBoundary);
                this.leftOver = data.subarray(nextBoundary, data.length);
              } else {
                usableData = data.slice(0, nextBoundary);
                this.leftOver = data.slice(nextBoundary, data.length);
              }
            }
            this.push({
              data: exports3.utf8decode(usableData),
              meta: chunk2.meta
            });
          };
          Utf8DecodeWorker.prototype.flush = function() {
            if (this.leftOver && this.leftOver.length) {
              this.push({
                data: exports3.utf8decode(this.leftOver),
                meta: {}
              });
              this.leftOver = null;
            }
          };
          exports3.Utf8DecodeWorker = Utf8DecodeWorker;
          function Utf8EncodeWorker() {
            GenericWorker.call(this, "utf-8 encode");
          }
          utils.inherits(Utf8EncodeWorker, GenericWorker);
          Utf8EncodeWorker.prototype.processChunk = function(chunk2) {
            this.push({
              data: exports3.utf8encode(chunk2.data),
              meta: chunk2.meta
            });
          };
          exports3.Utf8EncodeWorker = Utf8EncodeWorker;
        }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(require2, module3, exports3) {
          "use strict";
          var support = require2("./support");
          var base64 = require2("./base64");
          var nodejsUtils = require2("./nodejsUtils");
          var external = require2("./external");
          require2("setimmediate");
          function string2binary(str) {
            var result = null;
            if (support.uint8array) {
              result = new Uint8Array(str.length);
            } else {
              result = new Array(str.length);
            }
            return stringToArrayLike(str, result);
          }
          exports3.newBlob = function(part, type2) {
            exports3.checkSupport("blob");
            try {
              return new Blob([part], {
                type: type2
              });
            } catch (e) {
              try {
                var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
                var builder = new Builder();
                builder.append(part);
                return builder.getBlob(type2);
              } catch (e2) {
                throw new Error("Bug : can't construct the Blob.");
              }
            }
          };
          function identity(input) {
            return input;
          }
          function stringToArrayLike(str, array) {
            for (var i = 0; i < str.length; ++i) {
              array[i] = str.charCodeAt(i) & 255;
            }
            return array;
          }
          var arrayToStringHelper = {
            stringifyByChunk: function(array, type2, chunk2) {
              var result = [], k = 0, len = array.length;
              if (len <= chunk2) {
                return String.fromCharCode.apply(null, array);
              }
              while (k < len) {
                if (type2 === "array" || type2 === "nodebuffer") {
                  result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk2, len))));
                } else {
                  result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk2, len))));
                }
                k += chunk2;
              }
              return result.join("");
            },
            stringifyByChar: function(array) {
              var resultStr = "";
              for (var i = 0; i < array.length; i++) {
                resultStr += String.fromCharCode(array[i]);
              }
              return resultStr;
            },
            applyCanBeUsed: {
              uint8array: function() {
                try {
                  return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
                } catch (e) {
                  return false;
                }
              }(),
              nodebuffer: function() {
                try {
                  return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
                } catch (e) {
                  return false;
                }
              }()
            }
          };
          function arrayLikeToString(array) {
            var chunk2 = 65536, type2 = exports3.getTypeOf(array), canUseApply = true;
            if (type2 === "uint8array") {
              canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
            } else if (type2 === "nodebuffer") {
              canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
            }
            if (canUseApply) {
              while (chunk2 > 1) {
                try {
                  return arrayToStringHelper.stringifyByChunk(array, type2, chunk2);
                } catch (e) {
                  chunk2 = Math.floor(chunk2 / 2);
                }
              }
            }
            return arrayToStringHelper.stringifyByChar(array);
          }
          exports3.applyFromCharCode = arrayLikeToString;
          function arrayLikeToArrayLike(arrayFrom, arrayTo) {
            for (var i = 0; i < arrayFrom.length; i++) {
              arrayTo[i] = arrayFrom[i];
            }
            return arrayTo;
          }
          var transform2 = {};
          transform2["string"] = {
            "string": identity,
            "array": function(input) {
              return stringToArrayLike(input, new Array(input.length));
            },
            "arraybuffer": function(input) {
              return transform2["string"]["uint8array"](input).buffer;
            },
            "uint8array": function(input) {
              return stringToArrayLike(input, new Uint8Array(input.length));
            },
            "nodebuffer": function(input) {
              return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
            }
          };
          transform2["array"] = {
            "string": arrayLikeToString,
            "array": identity,
            "arraybuffer": function(input) {
              return new Uint8Array(input).buffer;
            },
            "uint8array": function(input) {
              return new Uint8Array(input);
            },
            "nodebuffer": function(input) {
              return nodejsUtils.newBufferFrom(input);
            }
          };
          transform2["arraybuffer"] = {
            "string": function(input) {
              return arrayLikeToString(new Uint8Array(input));
            },
            "array": function(input) {
              return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
            },
            "arraybuffer": identity,
            "uint8array": function(input) {
              return new Uint8Array(input);
            },
            "nodebuffer": function(input) {
              return nodejsUtils.newBufferFrom(new Uint8Array(input));
            }
          };
          transform2["uint8array"] = {
            "string": arrayLikeToString,
            "array": function(input) {
              return arrayLikeToArrayLike(input, new Array(input.length));
            },
            "arraybuffer": function(input) {
              return input.buffer;
            },
            "uint8array": identity,
            "nodebuffer": function(input) {
              return nodejsUtils.newBufferFrom(input);
            }
          };
          transform2["nodebuffer"] = {
            "string": arrayLikeToString,
            "array": function(input) {
              return arrayLikeToArrayLike(input, new Array(input.length));
            },
            "arraybuffer": function(input) {
              return transform2["nodebuffer"]["uint8array"](input).buffer;
            },
            "uint8array": function(input) {
              return arrayLikeToArrayLike(input, new Uint8Array(input.length));
            },
            "nodebuffer": identity
          };
          exports3.transformTo = function(outputType, input) {
            if (!input) {
              input = "";
            }
            if (!outputType) {
              return input;
            }
            exports3.checkSupport(outputType);
            var inputType = exports3.getTypeOf(input);
            var result = transform2[inputType][outputType](input);
            return result;
          };
          exports3.resolve = function(path5) {
            var parts = path5.split("/");
            var result = [];
            for (var index = 0; index < parts.length; index++) {
              var part = parts[index];
              if (part === "." || part === "" && index !== 0 && index !== parts.length - 1) {
                continue;
              } else if (part === "..") {
                result.pop();
              } else {
                result.push(part);
              }
            }
            return result.join("/");
          };
          exports3.getTypeOf = function(input) {
            if (typeof input === "string") {
              return "string";
            }
            if (Object.prototype.toString.call(input) === "[object Array]") {
              return "array";
            }
            if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
              return "nodebuffer";
            }
            if (support.uint8array && input instanceof Uint8Array) {
              return "uint8array";
            }
            if (support.arraybuffer && input instanceof ArrayBuffer) {
              return "arraybuffer";
            }
          };
          exports3.checkSupport = function(type2) {
            var supported3 = support[type2.toLowerCase()];
            if (!supported3) {
              throw new Error(type2 + " is not supported by this platform");
            }
          };
          exports3.MAX_VALUE_16BITS = 65535;
          exports3.MAX_VALUE_32BITS = -1;
          exports3.pretty = function(str) {
            var res = "", code, i;
            for (i = 0; i < (str || "").length; i++) {
              code = str.charCodeAt(i);
              res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
            }
            return res;
          };
          exports3.delay = function(callback, args, self2) {
            setImmediate(function() {
              callback.apply(self2 || null, args || []);
            });
          };
          exports3.inherits = function(ctor, superCtor) {
            var Obj = function() {
            };
            Obj.prototype = superCtor.prototype;
            ctor.prototype = new Obj();
          };
          exports3.extend = function() {
            var result = {}, i, attr;
            for (i = 0; i < arguments.length; i++) {
              for (attr in arguments[i]) {
                if (Object.prototype.hasOwnProperty.call(arguments[i], attr) && typeof result[attr] === "undefined") {
                  result[attr] = arguments[i][attr];
                }
              }
            }
            return result;
          };
          exports3.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {
            var promise = external.Promise.resolve(inputData).then(function(data) {
              var isBlob = support.blob && (data instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(data)) !== -1);
              if (isBlob && typeof FileReader !== "undefined") {
                return new external.Promise(function(resolve2, reject) {
                  var reader = new FileReader();
                  reader.onload = function(e) {
                    resolve2(e.target.result);
                  };
                  reader.onerror = function(e) {
                    reject(e.target.error);
                  };
                  reader.readAsArrayBuffer(data);
                });
              } else {
                return data;
              }
            });
            return promise.then(function(data) {
              var dataType = exports3.getTypeOf(data);
              if (!dataType) {
                return external.Promise.reject(
                  new Error("Can't read the data of '" + name + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?")
                );
              }
              if (dataType === "arraybuffer") {
                data = exports3.transformTo("uint8array", data);
              } else if (dataType === "string") {
                if (isBase64) {
                  data = base64.decode(data);
                } else if (isBinary) {
                  if (isOptimizedBinaryString !== true) {
                    data = string2binary(data);
                  }
                }
              }
              return data;
            });
          };
        }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, "setimmediate": 54 }], 33: [function(require2, module3, exports3) {
          "use strict";
          var readerFor = require2("./reader/readerFor");
          var utils = require2("./utils");
          var sig = require2("./signature");
          var ZipEntry = require2("./zipEntry");
          var support = require2("./support");
          function ZipEntries(loadOptions) {
            this.files = [];
            this.loadOptions = loadOptions;
          }
          ZipEntries.prototype = {
            checkSignature: function(expectedSignature) {
              if (!this.reader.readAndCheckSignature(expectedSignature)) {
                this.reader.index -= 4;
                var signature = this.reader.readString(4);
                throw new Error("Corrupted zip or bug: unexpected signature (" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
              }
            },
            isSignature: function(askedIndex, expectedSignature) {
              var currentIndex = this.reader.index;
              this.reader.setIndex(askedIndex);
              var signature = this.reader.readString(4);
              var result = signature === expectedSignature;
              this.reader.setIndex(currentIndex);
              return result;
            },
            readBlockEndOfCentral: function() {
              this.diskNumber = this.reader.readInt(2);
              this.diskWithCentralDirStart = this.reader.readInt(2);
              this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
              this.centralDirRecords = this.reader.readInt(2);
              this.centralDirSize = this.reader.readInt(4);
              this.centralDirOffset = this.reader.readInt(4);
              this.zipCommentLength = this.reader.readInt(2);
              var zipComment = this.reader.readData(this.zipCommentLength);
              var decodeParamType = support.uint8array ? "uint8array" : "array";
              var decodeContent = utils.transformTo(decodeParamType, zipComment);
              this.zipComment = this.loadOptions.decodeFileName(decodeContent);
            },
            readBlockZip64EndOfCentral: function() {
              this.zip64EndOfCentralSize = this.reader.readInt(8);
              this.reader.skip(4);
              this.diskNumber = this.reader.readInt(4);
              this.diskWithCentralDirStart = this.reader.readInt(4);
              this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
              this.centralDirRecords = this.reader.readInt(8);
              this.centralDirSize = this.reader.readInt(8);
              this.centralDirOffset = this.reader.readInt(8);
              this.zip64ExtensibleData = {};
              var extraDataSize = this.zip64EndOfCentralSize - 44, index = 0, extraFieldId, extraFieldLength, extraFieldValue;
              while (index < extraDataSize) {
                extraFieldId = this.reader.readInt(2);
                extraFieldLength = this.reader.readInt(4);
                extraFieldValue = this.reader.readData(extraFieldLength);
                this.zip64ExtensibleData[extraFieldId] = {
                  id: extraFieldId,
                  length: extraFieldLength,
                  value: extraFieldValue
                };
              }
            },
            readBlockZip64EndOfCentralLocator: function() {
              this.diskWithZip64CentralDirStart = this.reader.readInt(4);
              this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
              this.disksCount = this.reader.readInt(4);
              if (this.disksCount > 1) {
                throw new Error("Multi-volumes zip are not supported");
              }
            },
            readLocalFiles: function() {
              var i, file;
              for (i = 0; i < this.files.length; i++) {
                file = this.files[i];
                this.reader.setIndex(file.localHeaderOffset);
                this.checkSignature(sig.LOCAL_FILE_HEADER);
                file.readLocalPart(this.reader);
                file.handleUTF8();
                file.processAttributes();
              }
            },
            readCentralDir: function() {
              var file;
              this.reader.setIndex(this.centralDirOffset);
              while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
                file = new ZipEntry({
                  zip64: this.zip64
                }, this.loadOptions);
                file.readCentralPart(this.reader);
                this.files.push(file);
              }
              if (this.centralDirRecords !== this.files.length) {
                if (this.centralDirRecords !== 0 && this.files.length === 0) {
                  throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
                } else {
                }
              }
            },
            readEndOfCentral: function() {
              var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
              if (offset < 0) {
                var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
                if (isGarbage) {
                  throw new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
                } else {
                  throw new Error("Corrupted zip: can't find end of central directory");
                }
              }
              this.reader.setIndex(offset);
              var endOfCentralDirOffset = offset;
              this.checkSignature(sig.CENTRAL_DIRECTORY_END);
              this.readBlockEndOfCentral();
              if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
                this.zip64 = true;
                offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
                if (offset < 0) {
                  throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
                }
                this.reader.setIndex(offset);
                this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
                this.readBlockZip64EndOfCentralLocator();
                if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
                  this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
                  if (this.relativeOffsetEndOfZip64CentralDir < 0) {
                    throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                  }
                }
                this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
                this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
                this.readBlockZip64EndOfCentral();
              }
              var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
              if (this.zip64) {
                expectedEndOfCentralDirOffset += 20;
                expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;
              }
              var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
              if (extraBytes > 0) {
                if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {
                } else {
                  this.reader.zero = extraBytes;
                }
              } else if (extraBytes < 0) {
                throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
              }
            },
            prepareReader: function(data) {
              this.reader = readerFor(data);
            },
            load: function(data) {
              this.prepareReader(data);
              this.readEndOfCentral();
              this.readCentralDir();
              this.readLocalFiles();
            }
          };
          module3.exports = ZipEntries;
        }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(require2, module3, exports3) {
          "use strict";
          var readerFor = require2("./reader/readerFor");
          var utils = require2("./utils");
          var CompressedObject = require2("./compressedObject");
          var crc32fn = require2("./crc32");
          var utf8 = require2("./utf8");
          var compressions = require2("./compressions");
          var support = require2("./support");
          var MADE_BY_DOS = 0;
          var MADE_BY_UNIX = 3;
          var findCompression = function(compressionMethod) {
            for (var method in compressions) {
              if (!Object.prototype.hasOwnProperty.call(compressions, method)) {
                continue;
              }
              if (compressions[method].magic === compressionMethod) {
                return compressions[method];
              }
            }
            return null;
          };
          function ZipEntry(options, loadOptions) {
            this.options = options;
            this.loadOptions = loadOptions;
          }
          ZipEntry.prototype = {
            isEncrypted: function() {
              return (this.bitFlag & 1) === 1;
            },
            useUTF8: function() {
              return (this.bitFlag & 2048) === 2048;
            },
            readLocalPart: function(reader) {
              var compression, localExtraFieldsLength;
              reader.skip(22);
              this.fileNameLength = reader.readInt(2);
              localExtraFieldsLength = reader.readInt(2);
              this.fileName = reader.readData(this.fileNameLength);
              reader.skip(localExtraFieldsLength);
              if (this.compressedSize === -1 || this.uncompressedSize === -1) {
                throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
              }
              compression = findCompression(this.compressionMethod);
              if (compression === null) {
                throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
              }
              this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
            },
            readCentralPart: function(reader) {
              this.versionMadeBy = reader.readInt(2);
              reader.skip(2);
              this.bitFlag = reader.readInt(2);
              this.compressionMethod = reader.readString(2);
              this.date = reader.readDate();
              this.crc32 = reader.readInt(4);
              this.compressedSize = reader.readInt(4);
              this.uncompressedSize = reader.readInt(4);
              var fileNameLength = reader.readInt(2);
              this.extraFieldsLength = reader.readInt(2);
              this.fileCommentLength = reader.readInt(2);
              this.diskNumberStart = reader.readInt(2);
              this.internalFileAttributes = reader.readInt(2);
              this.externalFileAttributes = reader.readInt(4);
              this.localHeaderOffset = reader.readInt(4);
              if (this.isEncrypted()) {
                throw new Error("Encrypted zip are not supported");
              }
              reader.skip(fileNameLength);
              this.readExtraFields(reader);
              this.parseZIP64ExtraField(reader);
              this.fileComment = reader.readData(this.fileCommentLength);
            },
            processAttributes: function() {
              this.unixPermissions = null;
              this.dosPermissions = null;
              var madeBy = this.versionMadeBy >> 8;
              this.dir = this.externalFileAttributes & 16 ? true : false;
              if (madeBy === MADE_BY_DOS) {
                this.dosPermissions = this.externalFileAttributes & 63;
              }
              if (madeBy === MADE_BY_UNIX) {
                this.unixPermissions = this.externalFileAttributes >> 16 & 65535;
              }
              if (!this.dir && this.fileNameStr.slice(-1) === "/") {
                this.dir = true;
              }
            },
            parseZIP64ExtraField: function() {
              if (!this.extraFields[1]) {
                return;
              }
              var extraReader = readerFor(this.extraFields[1].value);
              if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
                this.uncompressedSize = extraReader.readInt(8);
              }
              if (this.compressedSize === utils.MAX_VALUE_32BITS) {
                this.compressedSize = extraReader.readInt(8);
              }
              if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
                this.localHeaderOffset = extraReader.readInt(8);
              }
              if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
                this.diskNumberStart = extraReader.readInt(4);
              }
            },
            readExtraFields: function(reader) {
              var end = reader.index + this.extraFieldsLength, extraFieldId, extraFieldLength, extraFieldValue;
              if (!this.extraFields) {
                this.extraFields = {};
              }
              while (reader.index + 4 < end) {
                extraFieldId = reader.readInt(2);
                extraFieldLength = reader.readInt(2);
                extraFieldValue = reader.readData(extraFieldLength);
                this.extraFields[extraFieldId] = {
                  id: extraFieldId,
                  length: extraFieldLength,
                  value: extraFieldValue
                };
              }
              reader.setIndex(end);
            },
            handleUTF8: function() {
              var decodeParamType = support.uint8array ? "uint8array" : "array";
              if (this.useUTF8()) {
                this.fileNameStr = utf8.utf8decode(this.fileName);
                this.fileCommentStr = utf8.utf8decode(this.fileComment);
              } else {
                var upath = this.findExtraFieldUnicodePath();
                if (upath !== null) {
                  this.fileNameStr = upath;
                } else {
                  var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
                  this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
                }
                var ucomment = this.findExtraFieldUnicodeComment();
                if (ucomment !== null) {
                  this.fileCommentStr = ucomment;
                } else {
                  var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
                  this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
                }
              }
            },
            findExtraFieldUnicodePath: function() {
              var upathField = this.extraFields[28789];
              if (upathField) {
                var extraReader = readerFor(upathField.value);
                if (extraReader.readInt(1) !== 1) {
                  return null;
                }
                if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
                  return null;
                }
                return utf8.utf8decode(extraReader.readData(upathField.length - 5));
              }
              return null;
            },
            findExtraFieldUnicodeComment: function() {
              var ucommentField = this.extraFields[25461];
              if (ucommentField) {
                var extraReader = readerFor(ucommentField.value);
                if (extraReader.readInt(1) !== 1) {
                  return null;
                }
                if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
                  return null;
                }
                return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
              }
              return null;
            }
          };
          module3.exports = ZipEntry;
        }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(require2, module3, exports3) {
          "use strict";
          var StreamHelper = require2("./stream/StreamHelper");
          var DataWorker = require2("./stream/DataWorker");
          var utf8 = require2("./utf8");
          var CompressedObject = require2("./compressedObject");
          var GenericWorker = require2("./stream/GenericWorker");
          var ZipObject = function(name, data, options) {
            this.name = name;
            this.dir = options.dir;
            this.date = options.date;
            this.comment = options.comment;
            this.unixPermissions = options.unixPermissions;
            this.dosPermissions = options.dosPermissions;
            this._data = data;
            this._dataBinary = options.binary;
            this.options = {
              compression: options.compression,
              compressionOptions: options.compressionOptions
            };
          };
          ZipObject.prototype = {
            internalStream: function(type2) {
              var result = null, outputType = "string";
              try {
                if (!type2) {
                  throw new Error("No output type specified.");
                }
                outputType = type2.toLowerCase();
                var askUnicodeString = outputType === "string" || outputType === "text";
                if (outputType === "binarystring" || outputType === "text") {
                  outputType = "string";
                }
                result = this._decompressWorker();
                var isUnicodeString = !this._dataBinary;
                if (isUnicodeString && !askUnicodeString) {
                  result = result.pipe(new utf8.Utf8EncodeWorker());
                }
                if (!isUnicodeString && askUnicodeString) {
                  result = result.pipe(new utf8.Utf8DecodeWorker());
                }
              } catch (e) {
                result = new GenericWorker("error");
                result.error(e);
              }
              return new StreamHelper(result, outputType, "");
            },
            async: function(type2, onUpdate) {
              return this.internalStream(type2).accumulate(onUpdate);
            },
            nodeStream: function(type2, onUpdate) {
              return this.internalStream(type2 || "nodebuffer").toNodejsStream(onUpdate);
            },
            _compressWorker: function(compression, compressionOptions) {
              if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {
                return this._data.getCompressedWorker();
              } else {
                var result = this._decompressWorker();
                if (!this._dataBinary) {
                  result = result.pipe(new utf8.Utf8EncodeWorker());
                }
                return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
              }
            },
            _decompressWorker: function() {
              if (this._data instanceof CompressedObject) {
                return this._data.getContentWorker();
              } else if (this._data instanceof GenericWorker) {
                return this._data;
              } else {
                return new DataWorker(this._data);
              }
            }
          };
          var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
          var removedFn = function() {
            throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
          };
          for (var i = 0; i < removedMethods.length; i++) {
            ZipObject.prototype[removedMethods[i]] = removedFn;
          }
          module3.exports = ZipObject;
        }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(require2, module3, exports3) {
          (function(global2) {
            "use strict";
            var Mutation = global2.MutationObserver || global2.WebKitMutationObserver;
            var scheduleDrain;
            {
              if (Mutation) {
                var called = 0;
                var observer = new Mutation(nextTick2);
                var element = global2.document.createTextNode("");
                observer.observe(element, {
                  characterData: true
                });
                scheduleDrain = function() {
                  element.data = called = ++called % 2;
                };
              } else if (!global2.setImmediate && typeof global2.MessageChannel !== "undefined") {
                var channel = new global2.MessageChannel();
                channel.port1.onmessage = nextTick2;
                scheduleDrain = function() {
                  channel.port2.postMessage(0);
                };
              } else if ("document" in global2 && "onreadystatechange" in global2.document.createElement("script")) {
                scheduleDrain = function() {
                  var scriptEl = global2.document.createElement("script");
                  scriptEl.onreadystatechange = function() {
                    nextTick2();
                    scriptEl.onreadystatechange = null;
                    scriptEl.parentNode.removeChild(scriptEl);
                    scriptEl = null;
                  };
                  global2.document.documentElement.appendChild(scriptEl);
                };
              } else {
                scheduleDrain = function() {
                  setTimeout(nextTick2, 0);
                };
              }
            }
            var draining;
            var queue2 = [];
            function nextTick2() {
              draining = true;
              var i, oldQueue;
              var len = queue2.length;
              while (len) {
                oldQueue = queue2;
                queue2 = [];
                i = -1;
                while (++i < len) {
                  oldQueue[i]();
                }
                len = queue2.length;
              }
              draining = false;
            }
            module3.exports = immediate;
            function immediate(task) {
              if (queue2.push(task) === 1 && !draining) {
                scheduleDrain();
              }
            }
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {}], 37: [function(require2, module3, exports3) {
          "use strict";
          var immediate = require2("immediate");
          function INTERNAL() {
          }
          var handlers2 = {};
          var REJECTED = ["REJECTED"];
          var FULFILLED = ["FULFILLED"];
          var PENDING = ["PENDING"];
          module3.exports = Promise2;
          function Promise2(resolver) {
            if (typeof resolver !== "function") {
              throw new TypeError("resolver must be a function");
            }
            this.state = PENDING;
            this.queue = [];
            this.outcome = void 0;
            if (resolver !== INTERNAL) {
              safelyResolveThenable(this, resolver);
            }
          }
          Promise2.prototype["finally"] = function(callback) {
            if (typeof callback !== "function") {
              return this;
            }
            var p2 = this.constructor;
            return this.then(resolve3, reject2);
            function resolve3(value) {
              function yes() {
                return value;
              }
              return p2.resolve(callback()).then(yes);
            }
            function reject2(reason) {
              function no() {
                throw reason;
              }
              return p2.resolve(callback()).then(no);
            }
          };
          Promise2.prototype["catch"] = function(onRejected) {
            return this.then(null, onRejected);
          };
          Promise2.prototype.then = function(onFulfilled, onRejected) {
            if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
              return this;
            }
            var promise = new this.constructor(INTERNAL);
            if (this.state !== PENDING) {
              var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
              unwrap(promise, resolver, this.outcome);
            } else {
              this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
            }
            return promise;
          };
          function QueueItem(promise, onFulfilled, onRejected) {
            this.promise = promise;
            if (typeof onFulfilled === "function") {
              this.onFulfilled = onFulfilled;
              this.callFulfilled = this.otherCallFulfilled;
            }
            if (typeof onRejected === "function") {
              this.onRejected = onRejected;
              this.callRejected = this.otherCallRejected;
            }
          }
          QueueItem.prototype.callFulfilled = function(value) {
            handlers2.resolve(this.promise, value);
          };
          QueueItem.prototype.otherCallFulfilled = function(value) {
            unwrap(this.promise, this.onFulfilled, value);
          };
          QueueItem.prototype.callRejected = function(value) {
            handlers2.reject(this.promise, value);
          };
          QueueItem.prototype.otherCallRejected = function(value) {
            unwrap(this.promise, this.onRejected, value);
          };
          function unwrap(promise, func, value) {
            immediate(function() {
              var returnValue;
              try {
                returnValue = func(value);
              } catch (e) {
                return handlers2.reject(promise, e);
              }
              if (returnValue === promise) {
                handlers2.reject(promise, new TypeError("Cannot resolve promise with itself"));
              } else {
                handlers2.resolve(promise, returnValue);
              }
            });
          }
          handlers2.resolve = function(self2, value) {
            var result = tryCatch(getThen, value);
            if (result.status === "error") {
              return handlers2.reject(self2, result.value);
            }
            var thenable = result.value;
            if (thenable) {
              safelyResolveThenable(self2, thenable);
            } else {
              self2.state = FULFILLED;
              self2.outcome = value;
              var i = -1;
              var len = self2.queue.length;
              while (++i < len) {
                self2.queue[i].callFulfilled(value);
              }
            }
            return self2;
          };
          handlers2.reject = function(self2, error) {
            self2.state = REJECTED;
            self2.outcome = error;
            var i = -1;
            var len = self2.queue.length;
            while (++i < len) {
              self2.queue[i].callRejected(error);
            }
            return self2;
          };
          function getThen(obj) {
            var then = obj && obj.then;
            if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
              return function appyThen() {
                then.apply(obj, arguments);
              };
            }
          }
          function safelyResolveThenable(self2, thenable) {
            var called = false;
            function onError(value) {
              if (called) {
                return;
              }
              called = true;
              handlers2.reject(self2, value);
            }
            function onSuccess(value) {
              if (called) {
                return;
              }
              called = true;
              handlers2.resolve(self2, value);
            }
            function tryToUnwrap() {
              thenable(onSuccess, onError);
            }
            var result = tryCatch(tryToUnwrap);
            if (result.status === "error") {
              onError(result.value);
            }
          }
          function tryCatch(func, value) {
            var out = {};
            try {
              out.value = func(value);
              out.status = "success";
            } catch (e) {
              out.status = "error";
              out.value = e;
            }
            return out;
          }
          Promise2.resolve = resolve2;
          function resolve2(value) {
            if (value instanceof this) {
              return value;
            }
            return handlers2.resolve(new this(INTERNAL), value);
          }
          Promise2.reject = reject;
          function reject(reason) {
            var promise = new this(INTERNAL);
            return handlers2.reject(promise, reason);
          }
          Promise2.all = all;
          function all(iterable) {
            var self2 = this;
            if (Object.prototype.toString.call(iterable) !== "[object Array]") {
              return this.reject(new TypeError("must be an array"));
            }
            var len = iterable.length;
            var called = false;
            if (!len) {
              return this.resolve([]);
            }
            var values = new Array(len);
            var resolved = 0;
            var i = -1;
            var promise = new this(INTERNAL);
            while (++i < len) {
              allResolver(iterable[i], i);
            }
            return promise;
            function allResolver(value, i2) {
              self2.resolve(value).then(resolveFromAll, function(error) {
                if (!called) {
                  called = true;
                  handlers2.reject(promise, error);
                }
              });
              function resolveFromAll(outValue) {
                values[i2] = outValue;
                if (++resolved === len && !called) {
                  called = true;
                  handlers2.resolve(promise, values);
                }
              }
            }
          }
          Promise2.race = race;
          function race(iterable) {
            var self2 = this;
            if (Object.prototype.toString.call(iterable) !== "[object Array]") {
              return this.reject(new TypeError("must be an array"));
            }
            var len = iterable.length;
            var called = false;
            if (!len) {
              return this.resolve([]);
            }
            var i = -1;
            var promise = new this(INTERNAL);
            while (++i < len) {
              resolver(iterable[i]);
            }
            return promise;
            function resolver(value) {
              self2.resolve(value).then(function(response) {
                if (!called) {
                  called = true;
                  handlers2.resolve(promise, response);
                }
              }, function(error) {
                if (!called) {
                  called = true;
                  handlers2.reject(promise, error);
                }
              });
            }
          }
        }, { "immediate": 36 }], 38: [function(require2, module3, exports3) {
          "use strict";
          var assign2 = require2("./lib/utils/common").assign;
          var deflate = require2("./lib/deflate");
          var inflate = require2("./lib/inflate");
          var constants = require2("./lib/zlib/constants");
          var pako = {};
          assign2(pako, deflate, inflate, constants);
          module3.exports = pako;
        }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(require2, module3, exports3) {
          "use strict";
          var zlib_deflate = require2("./zlib/deflate");
          var utils = require2("./utils/common");
          var strings = require2("./utils/strings");
          var msg = require2("./zlib/messages");
          var ZStream = require2("./zlib/zstream");
          var toString = Object.prototype.toString;
          var Z_NO_FLUSH = 0;
          var Z_FINISH = 4;
          var Z_OK = 0;
          var Z_STREAM_END = 1;
          var Z_SYNC_FLUSH = 2;
          var Z_DEFAULT_COMPRESSION = -1;
          var Z_DEFAULT_STRATEGY = 0;
          var Z_DEFLATED = 8;
          function Deflate(options) {
            if (!(this instanceof Deflate))
              return new Deflate(options);
            this.options = utils.assign({
              level: Z_DEFAULT_COMPRESSION,
              method: Z_DEFLATED,
              chunkSize: 16384,
              windowBits: 15,
              memLevel: 8,
              strategy: Z_DEFAULT_STRATEGY,
              to: ""
            }, options || {});
            var opt = this.options;
            if (opt.raw && opt.windowBits > 0) {
              opt.windowBits = -opt.windowBits;
            } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
              opt.windowBits += 16;
            }
            this.err = 0;
            this.msg = "";
            this.ended = false;
            this.chunks = [];
            this.strm = new ZStream();
            this.strm.avail_out = 0;
            var status = zlib_deflate.deflateInit2(
              this.strm,
              opt.level,
              opt.method,
              opt.windowBits,
              opt.memLevel,
              opt.strategy
            );
            if (status !== Z_OK) {
              throw new Error(msg[status]);
            }
            if (opt.header) {
              zlib_deflate.deflateSetHeader(this.strm, opt.header);
            }
            if (opt.dictionary) {
              var dict;
              if (typeof opt.dictionary === "string") {
                dict = strings.string2buf(opt.dictionary);
              } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
                dict = new Uint8Array(opt.dictionary);
              } else {
                dict = opt.dictionary;
              }
              status = zlib_deflate.deflateSetDictionary(this.strm, dict);
              if (status !== Z_OK) {
                throw new Error(msg[status]);
              }
              this._dict_set = true;
            }
          }
          Deflate.prototype.push = function(data, mode) {
            var strm = this.strm;
            var chunkSize = this.options.chunkSize;
            var status, _mode;
            if (this.ended) {
              return false;
            }
            _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
            if (typeof data === "string") {
              strm.input = strings.string2buf(data);
            } else if (toString.call(data) === "[object ArrayBuffer]") {
              strm.input = new Uint8Array(data);
            } else {
              strm.input = data;
            }
            strm.next_in = 0;
            strm.avail_in = strm.input.length;
            do {
              if (strm.avail_out === 0) {
                strm.output = new utils.Buf8(chunkSize);
                strm.next_out = 0;
                strm.avail_out = chunkSize;
              }
              status = zlib_deflate.deflate(strm, _mode);
              if (status !== Z_STREAM_END && status !== Z_OK) {
                this.onEnd(status);
                this.ended = true;
                return false;
              }
              if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
                if (this.options.to === "string") {
                  this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
                } else {
                  this.onData(utils.shrinkBuf(strm.output, strm.next_out));
                }
              }
            } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
            if (_mode === Z_FINISH) {
              status = zlib_deflate.deflateEnd(this.strm);
              this.onEnd(status);
              this.ended = true;
              return status === Z_OK;
            }
            if (_mode === Z_SYNC_FLUSH) {
              this.onEnd(Z_OK);
              strm.avail_out = 0;
              return true;
            }
            return true;
          };
          Deflate.prototype.onData = function(chunk2) {
            this.chunks.push(chunk2);
          };
          Deflate.prototype.onEnd = function(status) {
            if (status === Z_OK) {
              if (this.options.to === "string") {
                this.result = this.chunks.join("");
              } else {
                this.result = utils.flattenChunks(this.chunks);
              }
            }
            this.chunks = [];
            this.err = status;
            this.msg = this.strm.msg;
          };
          function deflate(input, options) {
            var deflator = new Deflate(options);
            deflator.push(input, true);
            if (deflator.err) {
              throw deflator.msg || msg[deflator.err];
            }
            return deflator.result;
          }
          function deflateRaw(input, options) {
            options = options || {};
            options.raw = true;
            return deflate(input, options);
          }
          function gzip(input, options) {
            options = options || {};
            options.gzip = true;
            return deflate(input, options);
          }
          exports3.Deflate = Deflate;
          exports3.deflate = deflate;
          exports3.deflateRaw = deflateRaw;
          exports3.gzip = gzip;
        }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(require2, module3, exports3) {
          "use strict";
          var zlib_inflate = require2("./zlib/inflate");
          var utils = require2("./utils/common");
          var strings = require2("./utils/strings");
          var c = require2("./zlib/constants");
          var msg = require2("./zlib/messages");
          var ZStream = require2("./zlib/zstream");
          var GZheader = require2("./zlib/gzheader");
          var toString = Object.prototype.toString;
          function Inflate(options) {
            if (!(this instanceof Inflate))
              return new Inflate(options);
            this.options = utils.assign({
              chunkSize: 16384,
              windowBits: 0,
              to: ""
            }, options || {});
            var opt = this.options;
            if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
              opt.windowBits = -opt.windowBits;
              if (opt.windowBits === 0) {
                opt.windowBits = -15;
              }
            }
            if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
              opt.windowBits += 32;
            }
            if (opt.windowBits > 15 && opt.windowBits < 48) {
              if ((opt.windowBits & 15) === 0) {
                opt.windowBits |= 15;
              }
            }
            this.err = 0;
            this.msg = "";
            this.ended = false;
            this.chunks = [];
            this.strm = new ZStream();
            this.strm.avail_out = 0;
            var status = zlib_inflate.inflateInit2(
              this.strm,
              opt.windowBits
            );
            if (status !== c.Z_OK) {
              throw new Error(msg[status]);
            }
            this.header = new GZheader();
            zlib_inflate.inflateGetHeader(this.strm, this.header);
          }
          Inflate.prototype.push = function(data, mode) {
            var strm = this.strm;
            var chunkSize = this.options.chunkSize;
            var dictionary = this.options.dictionary;
            var status, _mode;
            var next_out_utf8, tail, utf8str;
            var dict;
            var allowBufError = false;
            if (this.ended) {
              return false;
            }
            _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
            if (typeof data === "string") {
              strm.input = strings.binstring2buf(data);
            } else if (toString.call(data) === "[object ArrayBuffer]") {
              strm.input = new Uint8Array(data);
            } else {
              strm.input = data;
            }
            strm.next_in = 0;
            strm.avail_in = strm.input.length;
            do {
              if (strm.avail_out === 0) {
                strm.output = new utils.Buf8(chunkSize);
                strm.next_out = 0;
                strm.avail_out = chunkSize;
              }
              status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
              if (status === c.Z_NEED_DICT && dictionary) {
                if (typeof dictionary === "string") {
                  dict = strings.string2buf(dictionary);
                } else if (toString.call(dictionary) === "[object ArrayBuffer]") {
                  dict = new Uint8Array(dictionary);
                } else {
                  dict = dictionary;
                }
                status = zlib_inflate.inflateSetDictionary(this.strm, dict);
              }
              if (status === c.Z_BUF_ERROR && allowBufError === true) {
                status = c.Z_OK;
                allowBufError = false;
              }
              if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
                this.onEnd(status);
                this.ended = true;
                return false;
              }
              if (strm.next_out) {
                if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
                  if (this.options.to === "string") {
                    next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                    tail = strm.next_out - next_out_utf8;
                    utf8str = strings.buf2string(strm.output, next_out_utf8);
                    strm.next_out = tail;
                    strm.avail_out = chunkSize - tail;
                    if (tail) {
                      utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
                    }
                    this.onData(utf8str);
                  } else {
                    this.onData(utils.shrinkBuf(strm.output, strm.next_out));
                  }
                }
              }
              if (strm.avail_in === 0 && strm.avail_out === 0) {
                allowBufError = true;
              }
            } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
            if (status === c.Z_STREAM_END) {
              _mode = c.Z_FINISH;
            }
            if (_mode === c.Z_FINISH) {
              status = zlib_inflate.inflateEnd(this.strm);
              this.onEnd(status);
              this.ended = true;
              return status === c.Z_OK;
            }
            if (_mode === c.Z_SYNC_FLUSH) {
              this.onEnd(c.Z_OK);
              strm.avail_out = 0;
              return true;
            }
            return true;
          };
          Inflate.prototype.onData = function(chunk2) {
            this.chunks.push(chunk2);
          };
          Inflate.prototype.onEnd = function(status) {
            if (status === c.Z_OK) {
              if (this.options.to === "string") {
                this.result = this.chunks.join("");
              } else {
                this.result = utils.flattenChunks(this.chunks);
              }
            }
            this.chunks = [];
            this.err = status;
            this.msg = this.strm.msg;
          };
          function inflate(input, options) {
            var inflator = new Inflate(options);
            inflator.push(input, true);
            if (inflator.err) {
              throw inflator.msg || msg[inflator.err];
            }
            return inflator.result;
          }
          function inflateRaw(input, options) {
            options = options || {};
            options.raw = true;
            return inflate(input, options);
          }
          exports3.Inflate = Inflate;
          exports3.inflate = inflate;
          exports3.inflateRaw = inflateRaw;
          exports3.ungzip = inflate;
        }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(require2, module3, exports3) {
          "use strict";
          var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
          exports3.assign = function(obj) {
            var sources = Array.prototype.slice.call(arguments, 1);
            while (sources.length) {
              var source = sources.shift();
              if (!source) {
                continue;
              }
              if (typeof source !== "object") {
                throw new TypeError(source + "must be non-object");
              }
              for (var p2 in source) {
                if (source.hasOwnProperty(p2)) {
                  obj[p2] = source[p2];
                }
              }
            }
            return obj;
          };
          exports3.shrinkBuf = function(buf, size2) {
            if (buf.length === size2) {
              return buf;
            }
            if (buf.subarray) {
              return buf.subarray(0, size2);
            }
            buf.length = size2;
            return buf;
          };
          var fnTyped = {
            arraySet: function(dest, src, src_offs, len, dest_offs) {
              if (src.subarray && dest.subarray) {
                dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
                return;
              }
              for (var i = 0; i < len; i++) {
                dest[dest_offs + i] = src[src_offs + i];
              }
            },
            flattenChunks: function(chunks) {
              var i, l, len, pos, chunk2, result;
              len = 0;
              for (i = 0, l = chunks.length; i < l; i++) {
                len += chunks[i].length;
              }
              result = new Uint8Array(len);
              pos = 0;
              for (i = 0, l = chunks.length; i < l; i++) {
                chunk2 = chunks[i];
                result.set(chunk2, pos);
                pos += chunk2.length;
              }
              return result;
            }
          };
          var fnUntyped = {
            arraySet: function(dest, src, src_offs, len, dest_offs) {
              for (var i = 0; i < len; i++) {
                dest[dest_offs + i] = src[src_offs + i];
              }
            },
            flattenChunks: function(chunks) {
              return [].concat.apply([], chunks);
            }
          };
          exports3.setTyped = function(on) {
            if (on) {
              exports3.Buf8 = Uint8Array;
              exports3.Buf16 = Uint16Array;
              exports3.Buf32 = Int32Array;
              exports3.assign(exports3, fnTyped);
            } else {
              exports3.Buf8 = Array;
              exports3.Buf16 = Array;
              exports3.Buf32 = Array;
              exports3.assign(exports3, fnUntyped);
            }
          };
          exports3.setTyped(TYPED_OK);
        }, {}], 42: [function(require2, module3, exports3) {
          "use strict";
          var utils = require2("./common");
          var STR_APPLY_OK = true;
          var STR_APPLY_UIA_OK = true;
          try {
            String.fromCharCode.apply(null, [0]);
          } catch (__) {
            STR_APPLY_OK = false;
          }
          try {
            String.fromCharCode.apply(null, new Uint8Array(1));
          } catch (__) {
            STR_APPLY_UIA_OK = false;
          }
          var _utf8len = new utils.Buf8(256);
          for (var q = 0; q < 256; q++) {
            _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
          }
          _utf8len[254] = _utf8len[254] = 1;
          exports3.string2buf = function(str) {
            var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
            for (m_pos = 0; m_pos < str_len; m_pos++) {
              c = str.charCodeAt(m_pos);
              if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
                c2 = str.charCodeAt(m_pos + 1);
                if ((c2 & 64512) === 56320) {
                  c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                  m_pos++;
                }
              }
              buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
            }
            buf = new utils.Buf8(buf_len);
            for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
              c = str.charCodeAt(m_pos);
              if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
                c2 = str.charCodeAt(m_pos + 1);
                if ((c2 & 64512) === 56320) {
                  c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                  m_pos++;
                }
              }
              if (c < 128) {
                buf[i++] = c;
              } else if (c < 2048) {
                buf[i++] = 192 | c >>> 6;
                buf[i++] = 128 | c & 63;
              } else if (c < 65536) {
                buf[i++] = 224 | c >>> 12;
                buf[i++] = 128 | c >>> 6 & 63;
                buf[i++] = 128 | c & 63;
              } else {
                buf[i++] = 240 | c >>> 18;
                buf[i++] = 128 | c >>> 12 & 63;
                buf[i++] = 128 | c >>> 6 & 63;
                buf[i++] = 128 | c & 63;
              }
            }
            return buf;
          };
          function buf2binstring(buf, len) {
            if (len < 65537) {
              if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
                return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
              }
            }
            var result = "";
            for (var i = 0; i < len; i++) {
              result += String.fromCharCode(buf[i]);
            }
            return result;
          }
          exports3.buf2binstring = function(buf) {
            return buf2binstring(buf, buf.length);
          };
          exports3.binstring2buf = function(str) {
            var buf = new utils.Buf8(str.length);
            for (var i = 0, len = buf.length; i < len; i++) {
              buf[i] = str.charCodeAt(i);
            }
            return buf;
          };
          exports3.buf2string = function(buf, max) {
            var i, out, c, c_len;
            var len = max || buf.length;
            var utf16buf = new Array(len * 2);
            for (out = 0, i = 0; i < len; ) {
              c = buf[i++];
              if (c < 128) {
                utf16buf[out++] = c;
                continue;
              }
              c_len = _utf8len[c];
              if (c_len > 4) {
                utf16buf[out++] = 65533;
                i += c_len - 1;
                continue;
              }
              c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
              while (c_len > 1 && i < len) {
                c = c << 6 | buf[i++] & 63;
                c_len--;
              }
              if (c_len > 1) {
                utf16buf[out++] = 65533;
                continue;
              }
              if (c < 65536) {
                utf16buf[out++] = c;
              } else {
                c -= 65536;
                utf16buf[out++] = 55296 | c >> 10 & 1023;
                utf16buf[out++] = 56320 | c & 1023;
              }
            }
            return buf2binstring(utf16buf, out);
          };
          exports3.utf8border = function(buf, max) {
            var pos;
            max = max || buf.length;
            if (max > buf.length) {
              max = buf.length;
            }
            pos = max - 1;
            while (pos >= 0 && (buf[pos] & 192) === 128) {
              pos--;
            }
            if (pos < 0) {
              return max;
            }
            if (pos === 0) {
              return max;
            }
            return pos + _utf8len[buf[pos]] > max ? pos : max;
          };
        }, { "./common": 41 }], 43: [function(require2, module3, exports3) {
          "use strict";
          function adler32(adler, buf, len, pos) {
            var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
            while (len !== 0) {
              n = len > 2e3 ? 2e3 : len;
              len -= n;
              do {
                s1 = s1 + buf[pos++] | 0;
                s2 = s2 + s1 | 0;
              } while (--n);
              s1 %= 65521;
              s2 %= 65521;
            }
            return s1 | s2 << 16 | 0;
          }
          module3.exports = adler32;
        }, {}], 44: [function(require2, module3, exports3) {
          "use strict";
          module3.exports = {
            Z_NO_FLUSH: 0,
            Z_PARTIAL_FLUSH: 1,
            Z_SYNC_FLUSH: 2,
            Z_FULL_FLUSH: 3,
            Z_FINISH: 4,
            Z_BLOCK: 5,
            Z_TREES: 6,
            Z_OK: 0,
            Z_STREAM_END: 1,
            Z_NEED_DICT: 2,
            Z_ERRNO: -1,
            Z_STREAM_ERROR: -2,
            Z_DATA_ERROR: -3,
            Z_BUF_ERROR: -5,
            Z_NO_COMPRESSION: 0,
            Z_BEST_SPEED: 1,
            Z_BEST_COMPRESSION: 9,
            Z_DEFAULT_COMPRESSION: -1,
            Z_FILTERED: 1,
            Z_HUFFMAN_ONLY: 2,
            Z_RLE: 3,
            Z_FIXED: 4,
            Z_DEFAULT_STRATEGY: 0,
            Z_BINARY: 0,
            Z_TEXT: 1,
            Z_UNKNOWN: 2,
            Z_DEFLATED: 8
          };
        }, {}], 45: [function(require2, module3, exports3) {
          "use strict";
          function makeTable() {
            var c, table2 = [];
            for (var n = 0; n < 256; n++) {
              c = n;
              for (var k = 0; k < 8; k++) {
                c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
              }
              table2[n] = c;
            }
            return table2;
          }
          var crcTable = makeTable();
          function crc32(crc, buf, len, pos) {
            var t = crcTable, end = pos + len;
            crc ^= -1;
            for (var i = pos; i < end; i++) {
              crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
            }
            return crc ^ -1;
          }
          module3.exports = crc32;
        }, {}], 46: [function(require2, module3, exports3) {
          "use strict";
          var utils = require2("../utils/common");
          var trees = require2("./trees");
          var adler32 = require2("./adler32");
          var crc32 = require2("./crc32");
          var msg = require2("./messages");
          var Z_NO_FLUSH = 0;
          var Z_PARTIAL_FLUSH = 1;
          var Z_FULL_FLUSH = 3;
          var Z_FINISH = 4;
          var Z_BLOCK = 5;
          var Z_OK = 0;
          var Z_STREAM_END = 1;
          var Z_STREAM_ERROR = -2;
          var Z_DATA_ERROR = -3;
          var Z_BUF_ERROR = -5;
          var Z_DEFAULT_COMPRESSION = -1;
          var Z_FILTERED = 1;
          var Z_HUFFMAN_ONLY = 2;
          var Z_RLE = 3;
          var Z_FIXED = 4;
          var Z_DEFAULT_STRATEGY = 0;
          var Z_UNKNOWN = 2;
          var Z_DEFLATED = 8;
          var MAX_MEM_LEVEL = 9;
          var MAX_WBITS = 15;
          var DEF_MEM_LEVEL = 8;
          var LENGTH_CODES = 29;
          var LITERALS = 256;
          var L_CODES = LITERALS + 1 + LENGTH_CODES;
          var D_CODES = 30;
          var BL_CODES = 19;
          var HEAP_SIZE = 2 * L_CODES + 1;
          var MAX_BITS = 15;
          var MIN_MATCH = 3;
          var MAX_MATCH = 258;
          var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
          var PRESET_DICT = 32;
          var INIT_STATE = 42;
          var EXTRA_STATE = 69;
          var NAME_STATE = 73;
          var COMMENT_STATE = 91;
          var HCRC_STATE = 103;
          var BUSY_STATE = 113;
          var FINISH_STATE = 666;
          var BS_NEED_MORE = 1;
          var BS_BLOCK_DONE = 2;
          var BS_FINISH_STARTED = 3;
          var BS_FINISH_DONE = 4;
          var OS_CODE = 3;
          function err(strm, errorCode) {
            strm.msg = msg[errorCode];
            return errorCode;
          }
          function rank(f) {
            return (f << 1) - (f > 4 ? 9 : 0);
          }
          function zero(buf) {
            var len = buf.length;
            while (--len >= 0) {
              buf[len] = 0;
            }
          }
          function flush_pending(strm) {
            var s = strm.state;
            var len = s.pending;
            if (len > strm.avail_out) {
              len = strm.avail_out;
            }
            if (len === 0) {
              return;
            }
            utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
            strm.next_out += len;
            s.pending_out += len;
            strm.total_out += len;
            strm.avail_out -= len;
            s.pending -= len;
            if (s.pending === 0) {
              s.pending_out = 0;
            }
          }
          function flush_block_only(s, last) {
            trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
            s.block_start = s.strstart;
            flush_pending(s.strm);
          }
          function put_byte(s, b) {
            s.pending_buf[s.pending++] = b;
          }
          function putShortMSB(s, b) {
            s.pending_buf[s.pending++] = b >>> 8 & 255;
            s.pending_buf[s.pending++] = b & 255;
          }
          function read_buf(strm, buf, start, size2) {
            var len = strm.avail_in;
            if (len > size2) {
              len = size2;
            }
            if (len === 0) {
              return 0;
            }
            strm.avail_in -= len;
            utils.arraySet(buf, strm.input, strm.next_in, len, start);
            if (strm.state.wrap === 1) {
              strm.adler = adler32(strm.adler, buf, len, start);
            } else if (strm.state.wrap === 2) {
              strm.adler = crc32(strm.adler, buf, len, start);
            }
            strm.next_in += len;
            strm.total_in += len;
            return len;
          }
          function longest_match(s, cur_match) {
            var chain_length = s.max_chain_length;
            var scan = s.strstart;
            var match;
            var len;
            var best_len = s.prev_length;
            var nice_match = s.nice_match;
            var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
            var _win = s.window;
            var wmask = s.w_mask;
            var prev = s.prev;
            var strend = s.strstart + MAX_MATCH;
            var scan_end1 = _win[scan + best_len - 1];
            var scan_end = _win[scan + best_len];
            if (s.prev_length >= s.good_match) {
              chain_length >>= 2;
            }
            if (nice_match > s.lookahead) {
              nice_match = s.lookahead;
            }
            do {
              match = cur_match;
              if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
                continue;
              }
              scan += 2;
              match++;
              do {
              } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
              len = MAX_MATCH - (strend - scan);
              scan = strend - MAX_MATCH;
              if (len > best_len) {
                s.match_start = cur_match;
                best_len = len;
                if (len >= nice_match) {
                  break;
                }
                scan_end1 = _win[scan + best_len - 1];
                scan_end = _win[scan + best_len];
              }
            } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
            if (best_len <= s.lookahead) {
              return best_len;
            }
            return s.lookahead;
          }
          function fill_window(s) {
            var _w_size = s.w_size;
            var p2, n, m, more, str;
            do {
              more = s.window_size - s.lookahead - s.strstart;
              if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
                utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
                s.match_start -= _w_size;
                s.strstart -= _w_size;
                s.block_start -= _w_size;
                n = s.hash_size;
                p2 = n;
                do {
                  m = s.head[--p2];
                  s.head[p2] = m >= _w_size ? m - _w_size : 0;
                } while (--n);
                n = _w_size;
                p2 = n;
                do {
                  m = s.prev[--p2];
                  s.prev[p2] = m >= _w_size ? m - _w_size : 0;
                } while (--n);
                more += _w_size;
              }
              if (s.strm.avail_in === 0) {
                break;
              }
              n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
              s.lookahead += n;
              if (s.lookahead + s.insert >= MIN_MATCH) {
                str = s.strstart - s.insert;
                s.ins_h = s.window[str];
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
                while (s.insert) {
                  s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
                  s.prev[str & s.w_mask] = s.head[s.ins_h];
                  s.head[s.ins_h] = str;
                  str++;
                  s.insert--;
                  if (s.lookahead + s.insert < MIN_MATCH) {
                    break;
                  }
                }
              }
            } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
          }
          function deflate_stored(s, flush) {
            var max_block_size = 65535;
            if (max_block_size > s.pending_buf_size - 5) {
              max_block_size = s.pending_buf_size - 5;
            }
            for (; ; ) {
              if (s.lookahead <= 1) {
                fill_window(s);
                if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
                  return BS_NEED_MORE;
                }
                if (s.lookahead === 0) {
                  break;
                }
              }
              s.strstart += s.lookahead;
              s.lookahead = 0;
              var max_start = s.block_start + max_block_size;
              if (s.strstart === 0 || s.strstart >= max_start) {
                s.lookahead = s.strstart - max_start;
                s.strstart = max_start;
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE;
                }
              }
              if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE;
                }
              }
            }
            s.insert = 0;
            if (flush === Z_FINISH) {
              flush_block_only(s, true);
              if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
              }
              return BS_FINISH_DONE;
            }
            if (s.strstart > s.block_start) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
            return BS_NEED_MORE;
          }
          function deflate_fast(s, flush) {
            var hash_head;
            var bflush;
            for (; ; ) {
              if (s.lookahead < MIN_LOOKAHEAD) {
                fill_window(s);
                if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                  return BS_NEED_MORE;
                }
                if (s.lookahead === 0) {
                  break;
                }
              }
              hash_head = 0;
              if (s.lookahead >= MIN_MATCH) {
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
              }
              if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
                s.match_length = longest_match(s, hash_head);
              }
              if (s.match_length >= MIN_MATCH) {
                bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
                s.lookahead -= s.match_length;
                if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
                  s.match_length--;
                  do {
                    s.strstart++;
                    s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = s.strstart;
                  } while (--s.match_length !== 0);
                  s.strstart++;
                } else {
                  s.strstart += s.match_length;
                  s.match_length = 0;
                  s.ins_h = s.window[s.strstart];
                  s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
                }
              } else {
                bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                s.lookahead--;
                s.strstart++;
              }
              if (bflush) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE;
                }
              }
            }
            s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
            if (flush === Z_FINISH) {
              flush_block_only(s, true);
              if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
              }
              return BS_FINISH_DONE;
            }
            if (s.last_lit) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
            return BS_BLOCK_DONE;
          }
          function deflate_slow(s, flush) {
            var hash_head;
            var bflush;
            var max_insert;
            for (; ; ) {
              if (s.lookahead < MIN_LOOKAHEAD) {
                fill_window(s);
                if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                  return BS_NEED_MORE;
                }
                if (s.lookahead === 0) {
                  break;
                }
              }
              hash_head = 0;
              if (s.lookahead >= MIN_MATCH) {
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
              }
              s.prev_length = s.match_length;
              s.prev_match = s.match_start;
              s.match_length = MIN_MATCH - 1;
              if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
                s.match_length = longest_match(s, hash_head);
                if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
                  s.match_length = MIN_MATCH - 1;
                }
              }
              if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
                max_insert = s.strstart + s.lookahead - MIN_MATCH;
                bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
                s.lookahead -= s.prev_length - 1;
                s.prev_length -= 2;
                do {
                  if (++s.strstart <= max_insert) {
                    s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = s.strstart;
                  }
                } while (--s.prev_length !== 0);
                s.match_available = 0;
                s.match_length = MIN_MATCH - 1;
                s.strstart++;
                if (bflush) {
                  flush_block_only(s, false);
                  if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                  }
                }
              } else if (s.match_available) {
                bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
                if (bflush) {
                  flush_block_only(s, false);
                }
                s.strstart++;
                s.lookahead--;
                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE;
                }
              } else {
                s.match_available = 1;
                s.strstart++;
                s.lookahead--;
              }
            }
            if (s.match_available) {
              bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
              s.match_available = 0;
            }
            s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
            if (flush === Z_FINISH) {
              flush_block_only(s, true);
              if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
              }
              return BS_FINISH_DONE;
            }
            if (s.last_lit) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
            return BS_BLOCK_DONE;
          }
          function deflate_rle(s, flush) {
            var bflush;
            var prev;
            var scan, strend;
            var _win = s.window;
            for (; ; ) {
              if (s.lookahead <= MAX_MATCH) {
                fill_window(s);
                if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
                  return BS_NEED_MORE;
                }
                if (s.lookahead === 0) {
                  break;
                }
              }
              s.match_length = 0;
              if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
                scan = s.strstart - 1;
                prev = _win[scan];
                if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                  strend = s.strstart + MAX_MATCH;
                  do {
                  } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
                  s.match_length = MAX_MATCH - (strend - scan);
                  if (s.match_length > s.lookahead) {
                    s.match_length = s.lookahead;
                  }
                }
              }
              if (s.match_length >= MIN_MATCH) {
                bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
                s.lookahead -= s.match_length;
                s.strstart += s.match_length;
                s.match_length = 0;
              } else {
                bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                s.lookahead--;
                s.strstart++;
              }
              if (bflush) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE;
                }
              }
            }
            s.insert = 0;
            if (flush === Z_FINISH) {
              flush_block_only(s, true);
              if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
              }
              return BS_FINISH_DONE;
            }
            if (s.last_lit) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
            return BS_BLOCK_DONE;
          }
          function deflate_huff(s, flush) {
            var bflush;
            for (; ; ) {
              if (s.lookahead === 0) {
                fill_window(s);
                if (s.lookahead === 0) {
                  if (flush === Z_NO_FLUSH) {
                    return BS_NEED_MORE;
                  }
                  break;
                }
              }
              s.match_length = 0;
              bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
              s.lookahead--;
              s.strstart++;
              if (bflush) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE;
                }
              }
            }
            s.insert = 0;
            if (flush === Z_FINISH) {
              flush_block_only(s, true);
              if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
              }
              return BS_FINISH_DONE;
            }
            if (s.last_lit) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
            return BS_BLOCK_DONE;
          }
          function Config(good_length, max_lazy, nice_length, max_chain, func) {
            this.good_length = good_length;
            this.max_lazy = max_lazy;
            this.nice_length = nice_length;
            this.max_chain = max_chain;
            this.func = func;
          }
          var configuration_table;
          configuration_table = [
            new Config(0, 0, 0, 0, deflate_stored),
            new Config(4, 4, 8, 4, deflate_fast),
            new Config(4, 5, 16, 8, deflate_fast),
            new Config(4, 6, 32, 32, deflate_fast),
            new Config(4, 4, 16, 16, deflate_slow),
            new Config(8, 16, 32, 32, deflate_slow),
            new Config(8, 16, 128, 128, deflate_slow),
            new Config(8, 32, 128, 256, deflate_slow),
            new Config(32, 128, 258, 1024, deflate_slow),
            new Config(32, 258, 258, 4096, deflate_slow)
          ];
          function lm_init(s) {
            s.window_size = 2 * s.w_size;
            zero(s.head);
            s.max_lazy_match = configuration_table[s.level].max_lazy;
            s.good_match = configuration_table[s.level].good_length;
            s.nice_match = configuration_table[s.level].nice_length;
            s.max_chain_length = configuration_table[s.level].max_chain;
            s.strstart = 0;
            s.block_start = 0;
            s.lookahead = 0;
            s.insert = 0;
            s.match_length = s.prev_length = MIN_MATCH - 1;
            s.match_available = 0;
            s.ins_h = 0;
          }
          function DeflateState() {
            this.strm = null;
            this.status = 0;
            this.pending_buf = null;
            this.pending_buf_size = 0;
            this.pending_out = 0;
            this.pending = 0;
            this.wrap = 0;
            this.gzhead = null;
            this.gzindex = 0;
            this.method = Z_DEFLATED;
            this.last_flush = -1;
            this.w_size = 0;
            this.w_bits = 0;
            this.w_mask = 0;
            this.window = null;
            this.window_size = 0;
            this.prev = null;
            this.head = null;
            this.ins_h = 0;
            this.hash_size = 0;
            this.hash_bits = 0;
            this.hash_mask = 0;
            this.hash_shift = 0;
            this.block_start = 0;
            this.match_length = 0;
            this.prev_match = 0;
            this.match_available = 0;
            this.strstart = 0;
            this.match_start = 0;
            this.lookahead = 0;
            this.prev_length = 0;
            this.max_chain_length = 0;
            this.max_lazy_match = 0;
            this.level = 0;
            this.strategy = 0;
            this.good_match = 0;
            this.nice_match = 0;
            this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
            this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
            this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
            zero(this.dyn_ltree);
            zero(this.dyn_dtree);
            zero(this.bl_tree);
            this.l_desc = null;
            this.d_desc = null;
            this.bl_desc = null;
            this.bl_count = new utils.Buf16(MAX_BITS + 1);
            this.heap = new utils.Buf16(2 * L_CODES + 1);
            zero(this.heap);
            this.heap_len = 0;
            this.heap_max = 0;
            this.depth = new utils.Buf16(2 * L_CODES + 1);
            zero(this.depth);
            this.l_buf = 0;
            this.lit_bufsize = 0;
            this.last_lit = 0;
            this.d_buf = 0;
            this.opt_len = 0;
            this.static_len = 0;
            this.matches = 0;
            this.insert = 0;
            this.bi_buf = 0;
            this.bi_valid = 0;
          }
          function deflateResetKeep(strm) {
            var s;
            if (!strm || !strm.state) {
              return err(strm, Z_STREAM_ERROR);
            }
            strm.total_in = strm.total_out = 0;
            strm.data_type = Z_UNKNOWN;
            s = strm.state;
            s.pending = 0;
            s.pending_out = 0;
            if (s.wrap < 0) {
              s.wrap = -s.wrap;
            }
            s.status = s.wrap ? INIT_STATE : BUSY_STATE;
            strm.adler = s.wrap === 2 ? 0 : 1;
            s.last_flush = Z_NO_FLUSH;
            trees._tr_init(s);
            return Z_OK;
          }
          function deflateReset(strm) {
            var ret = deflateResetKeep(strm);
            if (ret === Z_OK) {
              lm_init(strm.state);
            }
            return ret;
          }
          function deflateSetHeader(strm, head) {
            if (!strm || !strm.state) {
              return Z_STREAM_ERROR;
            }
            if (strm.state.wrap !== 2) {
              return Z_STREAM_ERROR;
            }
            strm.state.gzhead = head;
            return Z_OK;
          }
          function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
            if (!strm) {
              return Z_STREAM_ERROR;
            }
            var wrap = 1;
            if (level === Z_DEFAULT_COMPRESSION) {
              level = 6;
            }
            if (windowBits < 0) {
              wrap = 0;
              windowBits = -windowBits;
            } else if (windowBits > 15) {
              wrap = 2;
              windowBits -= 16;
            }
            if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
              return err(strm, Z_STREAM_ERROR);
            }
            if (windowBits === 8) {
              windowBits = 9;
            }
            var s = new DeflateState();
            strm.state = s;
            s.strm = strm;
            s.wrap = wrap;
            s.gzhead = null;
            s.w_bits = windowBits;
            s.w_size = 1 << s.w_bits;
            s.w_mask = s.w_size - 1;
            s.hash_bits = memLevel + 7;
            s.hash_size = 1 << s.hash_bits;
            s.hash_mask = s.hash_size - 1;
            s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
            s.window = new utils.Buf8(s.w_size * 2);
            s.head = new utils.Buf16(s.hash_size);
            s.prev = new utils.Buf16(s.w_size);
            s.lit_bufsize = 1 << memLevel + 6;
            s.pending_buf_size = s.lit_bufsize * 4;
            s.pending_buf = new utils.Buf8(s.pending_buf_size);
            s.d_buf = 1 * s.lit_bufsize;
            s.l_buf = (1 + 2) * s.lit_bufsize;
            s.level = level;
            s.strategy = strategy;
            s.method = method;
            return deflateReset(strm);
          }
          function deflateInit(strm, level) {
            return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
          }
          function deflate(strm, flush) {
            var old_flush, s;
            var beg, val;
            if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
              return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
            }
            s = strm.state;
            if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
              return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
            }
            s.strm = strm;
            old_flush = s.last_flush;
            s.last_flush = flush;
            if (s.status === INIT_STATE) {
              if (s.wrap === 2) {
                strm.adler = 0;
                put_byte(s, 31);
                put_byte(s, 139);
                put_byte(s, 8);
                if (!s.gzhead) {
                  put_byte(s, 0);
                  put_byte(s, 0);
                  put_byte(s, 0);
                  put_byte(s, 0);
                  put_byte(s, 0);
                  put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                  put_byte(s, OS_CODE);
                  s.status = BUSY_STATE;
                } else {
                  put_byte(
                    s,
                    (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
                  );
                  put_byte(s, s.gzhead.time & 255);
                  put_byte(s, s.gzhead.time >> 8 & 255);
                  put_byte(s, s.gzhead.time >> 16 & 255);
                  put_byte(s, s.gzhead.time >> 24 & 255);
                  put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                  put_byte(s, s.gzhead.os & 255);
                  if (s.gzhead.extra && s.gzhead.extra.length) {
                    put_byte(s, s.gzhead.extra.length & 255);
                    put_byte(s, s.gzhead.extra.length >> 8 & 255);
                  }
                  if (s.gzhead.hcrc) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
                  }
                  s.gzindex = 0;
                  s.status = EXTRA_STATE;
                }
              } else {
                var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
                var level_flags = -1;
                if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
                  level_flags = 0;
                } else if (s.level < 6) {
                  level_flags = 1;
                } else if (s.level === 6) {
                  level_flags = 2;
                } else {
                  level_flags = 3;
                }
                header |= level_flags << 6;
                if (s.strstart !== 0) {
                  header |= PRESET_DICT;
                }
                header += 31 - header % 31;
                s.status = BUSY_STATE;
                putShortMSB(s, header);
                if (s.strstart !== 0) {
                  putShortMSB(s, strm.adler >>> 16);
                  putShortMSB(s, strm.adler & 65535);
                }
                strm.adler = 1;
              }
            }
            if (s.status === EXTRA_STATE) {
              if (s.gzhead.extra) {
                beg = s.pending;
                while (s.gzindex < (s.gzhead.extra.length & 65535)) {
                  if (s.pending === s.pending_buf_size) {
                    if (s.gzhead.hcrc && s.pending > beg) {
                      strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    flush_pending(strm);
                    beg = s.pending;
                    if (s.pending === s.pending_buf_size) {
                      break;
                    }
                  }
                  put_byte(s, s.gzhead.extra[s.gzindex] & 255);
                  s.gzindex++;
                }
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                if (s.gzindex === s.gzhead.extra.length) {
                  s.gzindex = 0;
                  s.status = NAME_STATE;
                }
              } else {
                s.status = NAME_STATE;
              }
            }
            if (s.status === NAME_STATE) {
              if (s.gzhead.name) {
                beg = s.pending;
                do {
                  if (s.pending === s.pending_buf_size) {
                    if (s.gzhead.hcrc && s.pending > beg) {
                      strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    flush_pending(strm);
                    beg = s.pending;
                    if (s.pending === s.pending_buf_size) {
                      val = 1;
                      break;
                    }
                  }
                  if (s.gzindex < s.gzhead.name.length) {
                    val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
                  } else {
                    val = 0;
                  }
                  put_byte(s, val);
                } while (val !== 0);
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                if (val === 0) {
                  s.gzindex = 0;
                  s.status = COMMENT_STATE;
                }
              } else {
                s.status = COMMENT_STATE;
              }
            }
            if (s.status === COMMENT_STATE) {
              if (s.gzhead.comment) {
                beg = s.pending;
                do {
                  if (s.pending === s.pending_buf_size) {
                    if (s.gzhead.hcrc && s.pending > beg) {
                      strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    flush_pending(strm);
                    beg = s.pending;
                    if (s.pending === s.pending_buf_size) {
                      val = 1;
                      break;
                    }
                  }
                  if (s.gzindex < s.gzhead.comment.length) {
                    val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
                  } else {
                    val = 0;
                  }
                  put_byte(s, val);
                } while (val !== 0);
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                if (val === 0) {
                  s.status = HCRC_STATE;
                }
              } else {
                s.status = HCRC_STATE;
              }
            }
            if (s.status === HCRC_STATE) {
              if (s.gzhead.hcrc) {
                if (s.pending + 2 > s.pending_buf_size) {
                  flush_pending(strm);
                }
                if (s.pending + 2 <= s.pending_buf_size) {
                  put_byte(s, strm.adler & 255);
                  put_byte(s, strm.adler >> 8 & 255);
                  strm.adler = 0;
                  s.status = BUSY_STATE;
                }
              } else {
                s.status = BUSY_STATE;
              }
            }
            if (s.pending !== 0) {
              flush_pending(strm);
              if (strm.avail_out === 0) {
                s.last_flush = -1;
                return Z_OK;
              }
            } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
              return err(strm, Z_BUF_ERROR);
            }
            if (s.status === FINISH_STATE && strm.avail_in !== 0) {
              return err(strm, Z_BUF_ERROR);
            }
            if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
              var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
              if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
                s.status = FINISH_STATE;
              }
              if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
                if (strm.avail_out === 0) {
                  s.last_flush = -1;
                }
                return Z_OK;
              }
              if (bstate === BS_BLOCK_DONE) {
                if (flush === Z_PARTIAL_FLUSH) {
                  trees._tr_align(s);
                } else if (flush !== Z_BLOCK) {
                  trees._tr_stored_block(s, 0, 0, false);
                  if (flush === Z_FULL_FLUSH) {
                    zero(s.head);
                    if (s.lookahead === 0) {
                      s.strstart = 0;
                      s.block_start = 0;
                      s.insert = 0;
                    }
                  }
                }
                flush_pending(strm);
                if (strm.avail_out === 0) {
                  s.last_flush = -1;
                  return Z_OK;
                }
              }
            }
            if (flush !== Z_FINISH) {
              return Z_OK;
            }
            if (s.wrap <= 0) {
              return Z_STREAM_END;
            }
            if (s.wrap === 2) {
              put_byte(s, strm.adler & 255);
              put_byte(s, strm.adler >> 8 & 255);
              put_byte(s, strm.adler >> 16 & 255);
              put_byte(s, strm.adler >> 24 & 255);
              put_byte(s, strm.total_in & 255);
              put_byte(s, strm.total_in >> 8 & 255);
              put_byte(s, strm.total_in >> 16 & 255);
              put_byte(s, strm.total_in >> 24 & 255);
            } else {
              putShortMSB(s, strm.adler >>> 16);
              putShortMSB(s, strm.adler & 65535);
            }
            flush_pending(strm);
            if (s.wrap > 0) {
              s.wrap = -s.wrap;
            }
            return s.pending !== 0 ? Z_OK : Z_STREAM_END;
          }
          function deflateEnd(strm) {
            var status;
            if (!strm || !strm.state) {
              return Z_STREAM_ERROR;
            }
            status = strm.state.status;
            if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
              return err(strm, Z_STREAM_ERROR);
            }
            strm.state = null;
            return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
          }
          function deflateSetDictionary(strm, dictionary) {
            var dictLength = dictionary.length;
            var s;
            var str, n;
            var wrap;
            var avail;
            var next;
            var input;
            var tmpDict;
            if (!strm || !strm.state) {
              return Z_STREAM_ERROR;
            }
            s = strm.state;
            wrap = s.wrap;
            if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
              return Z_STREAM_ERROR;
            }
            if (wrap === 1) {
              strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
            }
            s.wrap = 0;
            if (dictLength >= s.w_size) {
              if (wrap === 0) {
                zero(s.head);
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
              tmpDict = new utils.Buf8(s.w_size);
              utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
              dictionary = tmpDict;
              dictLength = s.w_size;
            }
            avail = strm.avail_in;
            next = strm.next_in;
            input = strm.input;
            strm.avail_in = dictLength;
            strm.next_in = 0;
            strm.input = dictionary;
            fill_window(s);
            while (s.lookahead >= MIN_MATCH) {
              str = s.strstart;
              n = s.lookahead - (MIN_MATCH - 1);
              do {
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
                s.prev[str & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = str;
                str++;
              } while (--n);
              s.strstart = str;
              s.lookahead = MIN_MATCH - 1;
              fill_window(s);
            }
            s.strstart += s.lookahead;
            s.block_start = s.strstart;
            s.insert = s.lookahead;
            s.lookahead = 0;
            s.match_length = s.prev_length = MIN_MATCH - 1;
            s.match_available = 0;
            strm.next_in = next;
            strm.input = input;
            strm.avail_in = avail;
            s.wrap = wrap;
            return Z_OK;
          }
          exports3.deflateInit = deflateInit;
          exports3.deflateInit2 = deflateInit2;
          exports3.deflateReset = deflateReset;
          exports3.deflateResetKeep = deflateResetKeep;
          exports3.deflateSetHeader = deflateSetHeader;
          exports3.deflate = deflate;
          exports3.deflateEnd = deflateEnd;
          exports3.deflateSetDictionary = deflateSetDictionary;
          exports3.deflateInfo = "pako deflate (from Nodeca project)";
        }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(require2, module3, exports3) {
          "use strict";
          function GZheader() {
            this.text = 0;
            this.time = 0;
            this.xflags = 0;
            this.os = 0;
            this.extra = null;
            this.extra_len = 0;
            this.name = "";
            this.comment = "";
            this.hcrc = 0;
            this.done = false;
          }
          module3.exports = GZheader;
        }, {}], 48: [function(require2, module3, exports3) {
          "use strict";
          var BAD = 30;
          var TYPE = 12;
          module3.exports = function inflate_fast(strm, start) {
            var state;
            var _in;
            var last;
            var _out;
            var beg;
            var end;
            var dmax;
            var wsize;
            var whave;
            var wnext;
            var s_window;
            var hold;
            var bits;
            var lcode;
            var dcode;
            var lmask;
            var dmask;
            var here;
            var op;
            var len;
            var dist;
            var from;
            var from_source;
            var input, output;
            state = strm.state;
            _in = strm.next_in;
            input = strm.input;
            last = _in + (strm.avail_in - 5);
            _out = strm.next_out;
            output = strm.output;
            beg = _out - (start - strm.avail_out);
            end = _out + (strm.avail_out - 257);
            dmax = state.dmax;
            wsize = state.wsize;
            whave = state.whave;
            wnext = state.wnext;
            s_window = state.window;
            hold = state.hold;
            bits = state.bits;
            lcode = state.lencode;
            dcode = state.distcode;
            lmask = (1 << state.lenbits) - 1;
            dmask = (1 << state.distbits) - 1;
            top:
              do {
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = lcode[hold & lmask];
                dolen:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op === 0) {
                      output[_out++] = here & 65535;
                    } else if (op & 16) {
                      len = here & 65535;
                      op &= 15;
                      if (op) {
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                        len += hold & (1 << op) - 1;
                        hold >>>= op;
                        bits -= op;
                      }
                      if (bits < 15) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                      here = dcode[hold & dmask];
                      dodist:
                        for (; ; ) {
                          op = here >>> 24;
                          hold >>>= op;
                          bits -= op;
                          op = here >>> 16 & 255;
                          if (op & 16) {
                            dist = here & 65535;
                            op &= 15;
                            if (bits < op) {
                              hold += input[_in++] << bits;
                              bits += 8;
                              if (bits < op) {
                                hold += input[_in++] << bits;
                                bits += 8;
                              }
                            }
                            dist += hold & (1 << op) - 1;
                            if (dist > dmax) {
                              strm.msg = "invalid distance too far back";
                              state.mode = BAD;
                              break top;
                            }
                            hold >>>= op;
                            bits -= op;
                            op = _out - beg;
                            if (dist > op) {
                              op = dist - op;
                              if (op > whave) {
                                if (state.sane) {
                                  strm.msg = "invalid distance too far back";
                                  state.mode = BAD;
                                  break top;
                                }
                              }
                              from = 0;
                              from_source = s_window;
                              if (wnext === 0) {
                                from += wsize - op;
                                if (op < len) {
                                  len -= op;
                                  do {
                                    output[_out++] = s_window[from++];
                                  } while (--op);
                                  from = _out - dist;
                                  from_source = output;
                                }
                              } else if (wnext < op) {
                                from += wsize + wnext - op;
                                op -= wnext;
                                if (op < len) {
                                  len -= op;
                                  do {
                                    output[_out++] = s_window[from++];
                                  } while (--op);
                                  from = 0;
                                  if (wnext < len) {
                                    op = wnext;
                                    len -= op;
                                    do {
                                      output[_out++] = s_window[from++];
                                    } while (--op);
                                    from = _out - dist;
                                    from_source = output;
                                  }
                                }
                              } else {
                                from += wnext - op;
                                if (op < len) {
                                  len -= op;
                                  do {
                                    output[_out++] = s_window[from++];
                                  } while (--op);
                                  from = _out - dist;
                                  from_source = output;
                                }
                              }
                              while (len > 2) {
                                output[_out++] = from_source[from++];
                                output[_out++] = from_source[from++];
                                output[_out++] = from_source[from++];
                                len -= 3;
                              }
                              if (len) {
                                output[_out++] = from_source[from++];
                                if (len > 1) {
                                  output[_out++] = from_source[from++];
                                }
                              }
                            } else {
                              from = _out - dist;
                              do {
                                output[_out++] = output[from++];
                                output[_out++] = output[from++];
                                output[_out++] = output[from++];
                                len -= 3;
                              } while (len > 2);
                              if (len) {
                                output[_out++] = output[from++];
                                if (len > 1) {
                                  output[_out++] = output[from++];
                                }
                              }
                            }
                          } else if ((op & 64) === 0) {
                            here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                            continue dodist;
                          } else {
                            strm.msg = "invalid distance code";
                            state.mode = BAD;
                            break top;
                          }
                          break;
                        }
                    } else if ((op & 64) === 0) {
                      here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dolen;
                    } else if (op & 32) {
                      state.mode = TYPE;
                      break top;
                    } else {
                      strm.msg = "invalid literal/length code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } while (_in < last && _out < end);
            len = bits >> 3;
            _in -= len;
            bits -= len << 3;
            hold &= (1 << bits) - 1;
            strm.next_in = _in;
            strm.next_out = _out;
            strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
            strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
            state.hold = hold;
            state.bits = bits;
            return;
          };
        }, {}], 49: [function(require2, module3, exports3) {
          "use strict";
          var utils = require2("../utils/common");
          var adler32 = require2("./adler32");
          var crc32 = require2("./crc32");
          var inflate_fast = require2("./inffast");
          var inflate_table = require2("./inftrees");
          var CODES = 0;
          var LENS = 1;
          var DISTS = 2;
          var Z_FINISH = 4;
          var Z_BLOCK = 5;
          var Z_TREES = 6;
          var Z_OK = 0;
          var Z_STREAM_END = 1;
          var Z_NEED_DICT = 2;
          var Z_STREAM_ERROR = -2;
          var Z_DATA_ERROR = -3;
          var Z_MEM_ERROR = -4;
          var Z_BUF_ERROR = -5;
          var Z_DEFLATED = 8;
          var HEAD = 1;
          var FLAGS = 2;
          var TIME = 3;
          var OS = 4;
          var EXLEN = 5;
          var EXTRA = 6;
          var NAME = 7;
          var COMMENT = 8;
          var HCRC = 9;
          var DICTID = 10;
          var DICT = 11;
          var TYPE = 12;
          var TYPEDO = 13;
          var STORED = 14;
          var COPY_ = 15;
          var COPY = 16;
          var TABLE = 17;
          var LENLENS = 18;
          var CODELENS = 19;
          var LEN_ = 20;
          var LEN = 21;
          var LENEXT = 22;
          var DIST = 23;
          var DISTEXT = 24;
          var MATCH = 25;
          var LIT = 26;
          var CHECK = 27;
          var LENGTH = 28;
          var DONE = 29;
          var BAD = 30;
          var MEM = 31;
          var SYNC = 32;
          var ENOUGH_LENS = 852;
          var ENOUGH_DISTS = 592;
          var MAX_WBITS = 15;
          var DEF_WBITS = MAX_WBITS;
          function zswap32(q) {
            return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
          }
          function InflateState() {
            this.mode = 0;
            this.last = false;
            this.wrap = 0;
            this.havedict = false;
            this.flags = 0;
            this.dmax = 0;
            this.check = 0;
            this.total = 0;
            this.head = null;
            this.wbits = 0;
            this.wsize = 0;
            this.whave = 0;
            this.wnext = 0;
            this.window = null;
            this.hold = 0;
            this.bits = 0;
            this.length = 0;
            this.offset = 0;
            this.extra = 0;
            this.lencode = null;
            this.distcode = null;
            this.lenbits = 0;
            this.distbits = 0;
            this.ncode = 0;
            this.nlen = 0;
            this.ndist = 0;
            this.have = 0;
            this.next = null;
            this.lens = new utils.Buf16(320);
            this.work = new utils.Buf16(288);
            this.lendyn = null;
            this.distdyn = null;
            this.sane = 0;
            this.back = 0;
            this.was = 0;
          }
          function inflateResetKeep(strm) {
            var state;
            if (!strm || !strm.state) {
              return Z_STREAM_ERROR;
            }
            state = strm.state;
            strm.total_in = strm.total_out = state.total = 0;
            strm.msg = "";
            if (state.wrap) {
              strm.adler = state.wrap & 1;
            }
            state.mode = HEAD;
            state.last = 0;
            state.havedict = 0;
            state.dmax = 32768;
            state.head = null;
            state.hold = 0;
            state.bits = 0;
            state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
            state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
            state.sane = 1;
            state.back = -1;
            return Z_OK;
          }
          function inflateReset(strm) {
            var state;
            if (!strm || !strm.state) {
              return Z_STREAM_ERROR;
            }
            state = strm.state;
            state.wsize = 0;
            state.whave = 0;
            state.wnext = 0;
            return inflateResetKeep(strm);
          }
          function inflateReset2(strm, windowBits) {
            var wrap;
            var state;
            if (!strm || !strm.state) {
              return Z_STREAM_ERROR;
            }
            state = strm.state;
            if (windowBits < 0) {
              wrap = 0;
              windowBits = -windowBits;
            } else {
              wrap = (windowBits >> 4) + 1;
              if (windowBits < 48) {
                windowBits &= 15;
              }
            }
            if (windowBits && (windowBits < 8 || windowBits > 15)) {
              return Z_STREAM_ERROR;
            }
            if (state.window !== null && state.wbits !== windowBits) {
              state.window = null;
            }
            state.wrap = wrap;
            state.wbits = windowBits;
            return inflateReset(strm);
          }
          function inflateInit2(strm, windowBits) {
            var ret;
            var state;
            if (!strm) {
              return Z_STREAM_ERROR;
            }
            state = new InflateState();
            strm.state = state;
            state.window = null;
            ret = inflateReset2(strm, windowBits);
            if (ret !== Z_OK) {
              strm.state = null;
            }
            return ret;
          }
          function inflateInit(strm) {
            return inflateInit2(strm, DEF_WBITS);
          }
          var virgin = true;
          var lenfix, distfix;
          function fixedtables(state) {
            if (virgin) {
              var sym;
              lenfix = new utils.Buf32(512);
              distfix = new utils.Buf32(32);
              sym = 0;
              while (sym < 144) {
                state.lens[sym++] = 8;
              }
              while (sym < 256) {
                state.lens[sym++] = 9;
              }
              while (sym < 280) {
                state.lens[sym++] = 7;
              }
              while (sym < 288) {
                state.lens[sym++] = 8;
              }
              inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
              sym = 0;
              while (sym < 32) {
                state.lens[sym++] = 5;
              }
              inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
              virgin = false;
            }
            state.lencode = lenfix;
            state.lenbits = 9;
            state.distcode = distfix;
            state.distbits = 5;
          }
          function updatewindow(strm, src, end, copy) {
            var dist;
            var state = strm.state;
            if (state.window === null) {
              state.wsize = 1 << state.wbits;
              state.wnext = 0;
              state.whave = 0;
              state.window = new utils.Buf8(state.wsize);
            }
            if (copy >= state.wsize) {
              utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
              state.wnext = 0;
              state.whave = state.wsize;
            } else {
              dist = state.wsize - state.wnext;
              if (dist > copy) {
                dist = copy;
              }
              utils.arraySet(state.window, src, end - copy, dist, state.wnext);
              copy -= dist;
              if (copy) {
                utils.arraySet(state.window, src, end - copy, copy, 0);
                state.wnext = copy;
                state.whave = state.wsize;
              } else {
                state.wnext += dist;
                if (state.wnext === state.wsize) {
                  state.wnext = 0;
                }
                if (state.whave < state.wsize) {
                  state.whave += dist;
                }
              }
            }
            return 0;
          }
          function inflate(strm, flush) {
            var state;
            var input, output;
            var next;
            var put;
            var have, left;
            var hold;
            var bits;
            var _in, _out;
            var copy;
            var from;
            var from_source;
            var here = 0;
            var here_bits, here_op, here_val;
            var last_bits, last_op, last_val;
            var len;
            var ret;
            var hbuf = new utils.Buf8(4);
            var opts;
            var n;
            var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
            if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
              return Z_STREAM_ERROR;
            }
            state = strm.state;
            if (state.mode === TYPE) {
              state.mode = TYPEDO;
            }
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            _in = have;
            _out = left;
            ret = Z_OK;
            inf_leave:
              for (; ; ) {
                switch (state.mode) {
                  case HEAD:
                    if (state.wrap === 0) {
                      state.mode = TYPEDO;
                      break;
                    }
                    while (bits < 16) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    if (state.wrap & 2 && hold === 35615) {
                      state.check = 0;
                      hbuf[0] = hold & 255;
                      hbuf[1] = hold >>> 8 & 255;
                      state.check = crc32(state.check, hbuf, 2, 0);
                      hold = 0;
                      bits = 0;
                      state.mode = FLAGS;
                      break;
                    }
                    state.flags = 0;
                    if (state.head) {
                      state.head.done = false;
                    }
                    if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                      strm.msg = "incorrect header check";
                      state.mode = BAD;
                      break;
                    }
                    if ((hold & 15) !== Z_DEFLATED) {
                      strm.msg = "unknown compression method";
                      state.mode = BAD;
                      break;
                    }
                    hold >>>= 4;
                    bits -= 4;
                    len = (hold & 15) + 8;
                    if (state.wbits === 0) {
                      state.wbits = len;
                    } else if (len > state.wbits) {
                      strm.msg = "invalid window size";
                      state.mode = BAD;
                      break;
                    }
                    state.dmax = 1 << len;
                    strm.adler = state.check = 1;
                    state.mode = hold & 512 ? DICTID : TYPE;
                    hold = 0;
                    bits = 0;
                    break;
                  case FLAGS:
                    while (bits < 16) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    state.flags = hold;
                    if ((state.flags & 255) !== Z_DEFLATED) {
                      strm.msg = "unknown compression method";
                      state.mode = BAD;
                      break;
                    }
                    if (state.flags & 57344) {
                      strm.msg = "unknown header flags set";
                      state.mode = BAD;
                      break;
                    }
                    if (state.head) {
                      state.head.text = hold >> 8 & 1;
                    }
                    if (state.flags & 512) {
                      hbuf[0] = hold & 255;
                      hbuf[1] = hold >>> 8 & 255;
                      state.check = crc32(state.check, hbuf, 2, 0);
                    }
                    hold = 0;
                    bits = 0;
                    state.mode = TIME;
                  case TIME:
                    while (bits < 32) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    if (state.head) {
                      state.head.time = hold;
                    }
                    if (state.flags & 512) {
                      hbuf[0] = hold & 255;
                      hbuf[1] = hold >>> 8 & 255;
                      hbuf[2] = hold >>> 16 & 255;
                      hbuf[3] = hold >>> 24 & 255;
                      state.check = crc32(state.check, hbuf, 4, 0);
                    }
                    hold = 0;
                    bits = 0;
                    state.mode = OS;
                  case OS:
                    while (bits < 16) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    if (state.head) {
                      state.head.xflags = hold & 255;
                      state.head.os = hold >> 8;
                    }
                    if (state.flags & 512) {
                      hbuf[0] = hold & 255;
                      hbuf[1] = hold >>> 8 & 255;
                      state.check = crc32(state.check, hbuf, 2, 0);
                    }
                    hold = 0;
                    bits = 0;
                    state.mode = EXLEN;
                  case EXLEN:
                    if (state.flags & 1024) {
                      while (bits < 16) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      state.length = hold;
                      if (state.head) {
                        state.head.extra_len = hold;
                      }
                      if (state.flags & 512) {
                        hbuf[0] = hold & 255;
                        hbuf[1] = hold >>> 8 & 255;
                        state.check = crc32(state.check, hbuf, 2, 0);
                      }
                      hold = 0;
                      bits = 0;
                    } else if (state.head) {
                      state.head.extra = null;
                    }
                    state.mode = EXTRA;
                  case EXTRA:
                    if (state.flags & 1024) {
                      copy = state.length;
                      if (copy > have) {
                        copy = have;
                      }
                      if (copy) {
                        if (state.head) {
                          len = state.head.extra_len - state.length;
                          if (!state.head.extra) {
                            state.head.extra = new Array(state.head.extra_len);
                          }
                          utils.arraySet(
                            state.head.extra,
                            input,
                            next,
                            copy,
                            len
                          );
                        }
                        if (state.flags & 512) {
                          state.check = crc32(state.check, input, copy, next);
                        }
                        have -= copy;
                        next += copy;
                        state.length -= copy;
                      }
                      if (state.length) {
                        break inf_leave;
                      }
                    }
                    state.length = 0;
                    state.mode = NAME;
                  case NAME:
                    if (state.flags & 2048) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      copy = 0;
                      do {
                        len = input[next + copy++];
                        if (state.head && len && state.length < 65536) {
                          state.head.name += String.fromCharCode(len);
                        }
                      } while (len && copy < have);
                      if (state.flags & 512) {
                        state.check = crc32(state.check, input, copy, next);
                      }
                      have -= copy;
                      next += copy;
                      if (len) {
                        break inf_leave;
                      }
                    } else if (state.head) {
                      state.head.name = null;
                    }
                    state.length = 0;
                    state.mode = COMMENT;
                  case COMMENT:
                    if (state.flags & 4096) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      copy = 0;
                      do {
                        len = input[next + copy++];
                        if (state.head && len && state.length < 65536) {
                          state.head.comment += String.fromCharCode(len);
                        }
                      } while (len && copy < have);
                      if (state.flags & 512) {
                        state.check = crc32(state.check, input, copy, next);
                      }
                      have -= copy;
                      next += copy;
                      if (len) {
                        break inf_leave;
                      }
                    } else if (state.head) {
                      state.head.comment = null;
                    }
                    state.mode = HCRC;
                  case HCRC:
                    if (state.flags & 512) {
                      while (bits < 16) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      if (hold !== (state.check & 65535)) {
                        strm.msg = "header crc mismatch";
                        state.mode = BAD;
                        break;
                      }
                      hold = 0;
                      bits = 0;
                    }
                    if (state.head) {
                      state.head.hcrc = state.flags >> 9 & 1;
                      state.head.done = true;
                    }
                    strm.adler = state.check = 0;
                    state.mode = TYPE;
                    break;
                  case DICTID:
                    while (bits < 32) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    strm.adler = state.check = zswap32(hold);
                    hold = 0;
                    bits = 0;
                    state.mode = DICT;
                  case DICT:
                    if (state.havedict === 0) {
                      strm.next_out = put;
                      strm.avail_out = left;
                      strm.next_in = next;
                      strm.avail_in = have;
                      state.hold = hold;
                      state.bits = bits;
                      return Z_NEED_DICT;
                    }
                    strm.adler = state.check = 1;
                    state.mode = TYPE;
                  case TYPE:
                    if (flush === Z_BLOCK || flush === Z_TREES) {
                      break inf_leave;
                    }
                  case TYPEDO:
                    if (state.last) {
                      hold >>>= bits & 7;
                      bits -= bits & 7;
                      state.mode = CHECK;
                      break;
                    }
                    while (bits < 3) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    state.last = hold & 1;
                    hold >>>= 1;
                    bits -= 1;
                    switch (hold & 3) {
                      case 0:
                        state.mode = STORED;
                        break;
                      case 1:
                        fixedtables(state);
                        state.mode = LEN_;
                        if (flush === Z_TREES) {
                          hold >>>= 2;
                          bits -= 2;
                          break inf_leave;
                        }
                        break;
                      case 2:
                        state.mode = TABLE;
                        break;
                      case 3:
                        strm.msg = "invalid block type";
                        state.mode = BAD;
                    }
                    hold >>>= 2;
                    bits -= 2;
                    break;
                  case STORED:
                    hold >>>= bits & 7;
                    bits -= bits & 7;
                    while (bits < 32) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                      strm.msg = "invalid stored block lengths";
                      state.mode = BAD;
                      break;
                    }
                    state.length = hold & 65535;
                    hold = 0;
                    bits = 0;
                    state.mode = COPY_;
                    if (flush === Z_TREES) {
                      break inf_leave;
                    }
                  case COPY_:
                    state.mode = COPY;
                  case COPY:
                    copy = state.length;
                    if (copy) {
                      if (copy > have) {
                        copy = have;
                      }
                      if (copy > left) {
                        copy = left;
                      }
                      if (copy === 0) {
                        break inf_leave;
                      }
                      utils.arraySet(output, input, next, copy, put);
                      have -= copy;
                      next += copy;
                      left -= copy;
                      put += copy;
                      state.length -= copy;
                      break;
                    }
                    state.mode = TYPE;
                    break;
                  case TABLE:
                    while (bits < 14) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    state.nlen = (hold & 31) + 257;
                    hold >>>= 5;
                    bits -= 5;
                    state.ndist = (hold & 31) + 1;
                    hold >>>= 5;
                    bits -= 5;
                    state.ncode = (hold & 15) + 4;
                    hold >>>= 4;
                    bits -= 4;
                    if (state.nlen > 286 || state.ndist > 30) {
                      strm.msg = "too many length or distance symbols";
                      state.mode = BAD;
                      break;
                    }
                    state.have = 0;
                    state.mode = LENLENS;
                  case LENLENS:
                    while (state.have < state.ncode) {
                      while (bits < 3) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      state.lens[order[state.have++]] = hold & 7;
                      hold >>>= 3;
                      bits -= 3;
                    }
                    while (state.have < 19) {
                      state.lens[order[state.have++]] = 0;
                    }
                    state.lencode = state.lendyn;
                    state.lenbits = 7;
                    opts = { bits: state.lenbits };
                    ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                    state.lenbits = opts.bits;
                    if (ret) {
                      strm.msg = "invalid code lengths set";
                      state.mode = BAD;
                      break;
                    }
                    state.have = 0;
                    state.mode = CODELENS;
                  case CODELENS:
                    while (state.have < state.nlen + state.ndist) {
                      for (; ; ) {
                        here = state.lencode[hold & (1 << state.lenbits) - 1];
                        here_bits = here >>> 24;
                        here_op = here >>> 16 & 255;
                        here_val = here & 65535;
                        if (here_bits <= bits) {
                          break;
                        }
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      if (here_val < 16) {
                        hold >>>= here_bits;
                        bits -= here_bits;
                        state.lens[state.have++] = here_val;
                      } else {
                        if (here_val === 16) {
                          n = here_bits + 2;
                          while (bits < n) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          hold >>>= here_bits;
                          bits -= here_bits;
                          if (state.have === 0) {
                            strm.msg = "invalid bit length repeat";
                            state.mode = BAD;
                            break;
                          }
                          len = state.lens[state.have - 1];
                          copy = 3 + (hold & 3);
                          hold >>>= 2;
                          bits -= 2;
                        } else if (here_val === 17) {
                          n = here_bits + 3;
                          while (bits < n) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          hold >>>= here_bits;
                          bits -= here_bits;
                          len = 0;
                          copy = 3 + (hold & 7);
                          hold >>>= 3;
                          bits -= 3;
                        } else {
                          n = here_bits + 7;
                          while (bits < n) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          hold >>>= here_bits;
                          bits -= here_bits;
                          len = 0;
                          copy = 11 + (hold & 127);
                          hold >>>= 7;
                          bits -= 7;
                        }
                        if (state.have + copy > state.nlen + state.ndist) {
                          strm.msg = "invalid bit length repeat";
                          state.mode = BAD;
                          break;
                        }
                        while (copy--) {
                          state.lens[state.have++] = len;
                        }
                      }
                    }
                    if (state.mode === BAD) {
                      break;
                    }
                    if (state.lens[256] === 0) {
                      strm.msg = "invalid code -- missing end-of-block";
                      state.mode = BAD;
                      break;
                    }
                    state.lenbits = 9;
                    opts = { bits: state.lenbits };
                    ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                    state.lenbits = opts.bits;
                    if (ret) {
                      strm.msg = "invalid literal/lengths set";
                      state.mode = BAD;
                      break;
                    }
                    state.distbits = 6;
                    state.distcode = state.distdyn;
                    opts = { bits: state.distbits };
                    ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                    state.distbits = opts.bits;
                    if (ret) {
                      strm.msg = "invalid distances set";
                      state.mode = BAD;
                      break;
                    }
                    state.mode = LEN_;
                    if (flush === Z_TREES) {
                      break inf_leave;
                    }
                  case LEN_:
                    state.mode = LEN;
                  case LEN:
                    if (have >= 6 && left >= 258) {
                      strm.next_out = put;
                      strm.avail_out = left;
                      strm.next_in = next;
                      strm.avail_in = have;
                      state.hold = hold;
                      state.bits = bits;
                      inflate_fast(strm, _out);
                      put = strm.next_out;
                      output = strm.output;
                      left = strm.avail_out;
                      next = strm.next_in;
                      input = strm.input;
                      have = strm.avail_in;
                      hold = state.hold;
                      bits = state.bits;
                      if (state.mode === TYPE) {
                        state.back = -1;
                      }
                      break;
                    }
                    state.back = 0;
                    for (; ; ) {
                      here = state.lencode[hold & (1 << state.lenbits) - 1];
                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 255;
                      here_val = here & 65535;
                      if (here_bits <= bits) {
                        break;
                      }
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    if (here_op && (here_op & 240) === 0) {
                      last_bits = here_bits;
                      last_op = here_op;
                      last_val = here_val;
                      for (; ; ) {
                        here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                        here_bits = here >>> 24;
                        here_op = here >>> 16 & 255;
                        here_val = here & 65535;
                        if (last_bits + here_bits <= bits) {
                          break;
                        }
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= last_bits;
                      bits -= last_bits;
                      state.back += last_bits;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    state.back += here_bits;
                    state.length = here_val;
                    if (here_op === 0) {
                      state.mode = LIT;
                      break;
                    }
                    if (here_op & 32) {
                      state.back = -1;
                      state.mode = TYPE;
                      break;
                    }
                    if (here_op & 64) {
                      strm.msg = "invalid literal/length code";
                      state.mode = BAD;
                      break;
                    }
                    state.extra = here_op & 15;
                    state.mode = LENEXT;
                  case LENEXT:
                    if (state.extra) {
                      n = state.extra;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      state.length += hold & (1 << state.extra) - 1;
                      hold >>>= state.extra;
                      bits -= state.extra;
                      state.back += state.extra;
                    }
                    state.was = state.length;
                    state.mode = DIST;
                  case DIST:
                    for (; ; ) {
                      here = state.distcode[hold & (1 << state.distbits) - 1];
                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 255;
                      here_val = here & 65535;
                      if (here_bits <= bits) {
                        break;
                      }
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    if ((here_op & 240) === 0) {
                      last_bits = here_bits;
                      last_op = here_op;
                      last_val = here_val;
                      for (; ; ) {
                        here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                        here_bits = here >>> 24;
                        here_op = here >>> 16 & 255;
                        here_val = here & 65535;
                        if (last_bits + here_bits <= bits) {
                          break;
                        }
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= last_bits;
                      bits -= last_bits;
                      state.back += last_bits;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    state.back += here_bits;
                    if (here_op & 64) {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break;
                    }
                    state.offset = here_val;
                    state.extra = here_op & 15;
                    state.mode = DISTEXT;
                  case DISTEXT:
                    if (state.extra) {
                      n = state.extra;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      state.offset += hold & (1 << state.extra) - 1;
                      hold >>>= state.extra;
                      bits -= state.extra;
                      state.back += state.extra;
                    }
                    if (state.offset > state.dmax) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break;
                    }
                    state.mode = MATCH;
                  case MATCH:
                    if (left === 0) {
                      break inf_leave;
                    }
                    copy = _out - left;
                    if (state.offset > copy) {
                      copy = state.offset - copy;
                      if (copy > state.whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break;
                        }
                      }
                      if (copy > state.wnext) {
                        copy -= state.wnext;
                        from = state.wsize - copy;
                      } else {
                        from = state.wnext - copy;
                      }
                      if (copy > state.length) {
                        copy = state.length;
                      }
                      from_source = state.window;
                    } else {
                      from_source = output;
                      from = put - state.offset;
                      copy = state.length;
                    }
                    if (copy > left) {
                      copy = left;
                    }
                    left -= copy;
                    state.length -= copy;
                    do {
                      output[put++] = from_source[from++];
                    } while (--copy);
                    if (state.length === 0) {
                      state.mode = LEN;
                    }
                    break;
                  case LIT:
                    if (left === 0) {
                      break inf_leave;
                    }
                    output[put++] = state.length;
                    left--;
                    state.mode = LEN;
                    break;
                  case CHECK:
                    if (state.wrap) {
                      while (bits < 32) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold |= input[next++] << bits;
                        bits += 8;
                      }
                      _out -= left;
                      strm.total_out += _out;
                      state.total += _out;
                      if (_out) {
                        strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                      }
                      _out = left;
                      if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                        strm.msg = "incorrect data check";
                        state.mode = BAD;
                        break;
                      }
                      hold = 0;
                      bits = 0;
                    }
                    state.mode = LENGTH;
                  case LENGTH:
                    if (state.wrap && state.flags) {
                      while (bits < 32) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      if (hold !== (state.total & 4294967295)) {
                        strm.msg = "incorrect length check";
                        state.mode = BAD;
                        break;
                      }
                      hold = 0;
                      bits = 0;
                    }
                    state.mode = DONE;
                  case DONE:
                    ret = Z_STREAM_END;
                    break inf_leave;
                  case BAD:
                    ret = Z_DATA_ERROR;
                    break inf_leave;
                  case MEM:
                    return Z_MEM_ERROR;
                  case SYNC:
                  default:
                    return Z_STREAM_ERROR;
                }
              }
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
              if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
                state.mode = MEM;
                return Z_MEM_ERROR;
              }
            }
            _in -= strm.avail_in;
            _out -= strm.avail_out;
            strm.total_in += _in;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap && _out) {
              strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
            }
            strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
            if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
              ret = Z_BUF_ERROR;
            }
            return ret;
          }
          function inflateEnd(strm) {
            if (!strm || !strm.state) {
              return Z_STREAM_ERROR;
            }
            var state = strm.state;
            if (state.window) {
              state.window = null;
            }
            strm.state = null;
            return Z_OK;
          }
          function inflateGetHeader(strm, head) {
            var state;
            if (!strm || !strm.state) {
              return Z_STREAM_ERROR;
            }
            state = strm.state;
            if ((state.wrap & 2) === 0) {
              return Z_STREAM_ERROR;
            }
            state.head = head;
            head.done = false;
            return Z_OK;
          }
          function inflateSetDictionary(strm, dictionary) {
            var dictLength = dictionary.length;
            var state;
            var dictid;
            var ret;
            if (!strm || !strm.state) {
              return Z_STREAM_ERROR;
            }
            state = strm.state;
            if (state.wrap !== 0 && state.mode !== DICT) {
              return Z_STREAM_ERROR;
            }
            if (state.mode === DICT) {
              dictid = 1;
              dictid = adler32(dictid, dictionary, dictLength, 0);
              if (dictid !== state.check) {
                return Z_DATA_ERROR;
              }
            }
            ret = updatewindow(strm, dictionary, dictLength, dictLength);
            if (ret) {
              state.mode = MEM;
              return Z_MEM_ERROR;
            }
            state.havedict = 1;
            return Z_OK;
          }
          exports3.inflateReset = inflateReset;
          exports3.inflateReset2 = inflateReset2;
          exports3.inflateResetKeep = inflateResetKeep;
          exports3.inflateInit = inflateInit;
          exports3.inflateInit2 = inflateInit2;
          exports3.inflate = inflate;
          exports3.inflateEnd = inflateEnd;
          exports3.inflateGetHeader = inflateGetHeader;
          exports3.inflateSetDictionary = inflateSetDictionary;
          exports3.inflateInfo = "pako inflate (from Nodeca project)";
        }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(require2, module3, exports3) {
          "use strict";
          var utils = require2("../utils/common");
          var MAXBITS = 15;
          var ENOUGH_LENS = 852;
          var ENOUGH_DISTS = 592;
          var CODES = 0;
          var LENS = 1;
          var DISTS = 2;
          var lbase = [
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            13,
            15,
            17,
            19,
            23,
            27,
            31,
            35,
            43,
            51,
            59,
            67,
            83,
            99,
            115,
            131,
            163,
            195,
            227,
            258,
            0,
            0
          ];
          var lext = [
            16,
            16,
            16,
            16,
            16,
            16,
            16,
            16,
            17,
            17,
            17,
            17,
            18,
            18,
            18,
            18,
            19,
            19,
            19,
            19,
            20,
            20,
            20,
            20,
            21,
            21,
            21,
            21,
            16,
            72,
            78
          ];
          var dbase = [
            1,
            2,
            3,
            4,
            5,
            7,
            9,
            13,
            17,
            25,
            33,
            49,
            65,
            97,
            129,
            193,
            257,
            385,
            513,
            769,
            1025,
            1537,
            2049,
            3073,
            4097,
            6145,
            8193,
            12289,
            16385,
            24577,
            0,
            0
          ];
          var dext = [
            16,
            16,
            16,
            16,
            17,
            17,
            18,
            18,
            19,
            19,
            20,
            20,
            21,
            21,
            22,
            22,
            23,
            23,
            24,
            24,
            25,
            25,
            26,
            26,
            27,
            27,
            28,
            28,
            29,
            29,
            64,
            64
          ];
          module3.exports = function inflate_table(type2, lens, lens_index, codes, table2, table_index, work, opts) {
            var bits = opts.bits;
            var len = 0;
            var sym = 0;
            var min = 0, max = 0;
            var root = 0;
            var curr = 0;
            var drop = 0;
            var left = 0;
            var used = 0;
            var huff = 0;
            var incr;
            var fill;
            var low;
            var mask;
            var next;
            var base = null;
            var base_index = 0;
            var end;
            var count = new utils.Buf16(MAXBITS + 1);
            var offs = new utils.Buf16(MAXBITS + 1);
            var extra = null;
            var extra_index = 0;
            var here_bits, here_op, here_val;
            for (len = 0; len <= MAXBITS; len++) {
              count[len] = 0;
            }
            for (sym = 0; sym < codes; sym++) {
              count[lens[lens_index + sym]]++;
            }
            root = bits;
            for (max = MAXBITS; max >= 1; max--) {
              if (count[max] !== 0) {
                break;
              }
            }
            if (root > max) {
              root = max;
            }
            if (max === 0) {
              table2[table_index++] = 1 << 24 | 64 << 16 | 0;
              table2[table_index++] = 1 << 24 | 64 << 16 | 0;
              opts.bits = 1;
              return 0;
            }
            for (min = 1; min < max; min++) {
              if (count[min] !== 0) {
                break;
              }
            }
            if (root < min) {
              root = min;
            }
            left = 1;
            for (len = 1; len <= MAXBITS; len++) {
              left <<= 1;
              left -= count[len];
              if (left < 0) {
                return -1;
              }
            }
            if (left > 0 && (type2 === CODES || max !== 1)) {
              return -1;
            }
            offs[1] = 0;
            for (len = 1; len < MAXBITS; len++) {
              offs[len + 1] = offs[len] + count[len];
            }
            for (sym = 0; sym < codes; sym++) {
              if (lens[lens_index + sym] !== 0) {
                work[offs[lens[lens_index + sym]]++] = sym;
              }
            }
            if (type2 === CODES) {
              base = extra = work;
              end = 19;
            } else if (type2 === LENS) {
              base = lbase;
              base_index -= 257;
              extra = lext;
              extra_index -= 257;
              end = 256;
            } else {
              base = dbase;
              extra = dext;
              end = -1;
            }
            huff = 0;
            sym = 0;
            len = min;
            next = table_index;
            curr = root;
            drop = 0;
            low = -1;
            used = 1 << root;
            mask = used - 1;
            if (type2 === LENS && used > ENOUGH_LENS || type2 === DISTS && used > ENOUGH_DISTS) {
              return 1;
            }
            for (; ; ) {
              here_bits = len - drop;
              if (work[sym] < end) {
                here_op = 0;
                here_val = work[sym];
              } else if (work[sym] > end) {
                here_op = extra[extra_index + work[sym]];
                here_val = base[base_index + work[sym]];
              } else {
                here_op = 32 + 64;
                here_val = 0;
              }
              incr = 1 << len - drop;
              fill = 1 << curr;
              min = fill;
              do {
                fill -= incr;
                table2[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
              } while (fill !== 0);
              incr = 1 << len - 1;
              while (huff & incr) {
                incr >>= 1;
              }
              if (incr !== 0) {
                huff &= incr - 1;
                huff += incr;
              } else {
                huff = 0;
              }
              sym++;
              if (--count[len] === 0) {
                if (len === max) {
                  break;
                }
                len = lens[lens_index + work[sym]];
              }
              if (len > root && (huff & mask) !== low) {
                if (drop === 0) {
                  drop = root;
                }
                next += min;
                curr = len - drop;
                left = 1 << curr;
                while (curr + drop < max) {
                  left -= count[curr + drop];
                  if (left <= 0) {
                    break;
                  }
                  curr++;
                  left <<= 1;
                }
                used += 1 << curr;
                if (type2 === LENS && used > ENOUGH_LENS || type2 === DISTS && used > ENOUGH_DISTS) {
                  return 1;
                }
                low = huff & mask;
                table2[low] = root << 24 | curr << 16 | next - table_index | 0;
              }
            }
            if (huff !== 0) {
              table2[next + huff] = len - drop << 24 | 64 << 16 | 0;
            }
            opts.bits = root;
            return 0;
          };
        }, { "../utils/common": 41 }], 51: [function(require2, module3, exports3) {
          "use strict";
          module3.exports = {
            2: "need dictionary",
            1: "stream end",
            0: "",
            "-1": "file error",
            "-2": "stream error",
            "-3": "data error",
            "-4": "insufficient memory",
            "-5": "buffer error",
            "-6": "incompatible version"
          };
        }, {}], 52: [function(require2, module3, exports3) {
          "use strict";
          var utils = require2("../utils/common");
          var Z_FIXED = 4;
          var Z_BINARY = 0;
          var Z_TEXT = 1;
          var Z_UNKNOWN = 2;
          function zero(buf) {
            var len = buf.length;
            while (--len >= 0) {
              buf[len] = 0;
            }
          }
          var STORED_BLOCK = 0;
          var STATIC_TREES = 1;
          var DYN_TREES = 2;
          var MIN_MATCH = 3;
          var MAX_MATCH = 258;
          var LENGTH_CODES = 29;
          var LITERALS = 256;
          var L_CODES = LITERALS + 1 + LENGTH_CODES;
          var D_CODES = 30;
          var BL_CODES = 19;
          var HEAP_SIZE = 2 * L_CODES + 1;
          var MAX_BITS = 15;
          var Buf_size = 16;
          var MAX_BL_BITS = 7;
          var END_BLOCK = 256;
          var REP_3_6 = 16;
          var REPZ_3_10 = 17;
          var REPZ_11_138 = 18;
          var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
          var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
          var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
          var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          var DIST_CODE_LEN = 512;
          var static_ltree = new Array((L_CODES + 2) * 2);
          zero(static_ltree);
          var static_dtree = new Array(D_CODES * 2);
          zero(static_dtree);
          var _dist_code = new Array(DIST_CODE_LEN);
          zero(_dist_code);
          var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
          zero(_length_code);
          var base_length = new Array(LENGTH_CODES);
          zero(base_length);
          var base_dist = new Array(D_CODES);
          zero(base_dist);
          function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
            this.static_tree = static_tree;
            this.extra_bits = extra_bits;
            this.extra_base = extra_base;
            this.elems = elems;
            this.max_length = max_length;
            this.has_stree = static_tree && static_tree.length;
          }
          var static_l_desc;
          var static_d_desc;
          var static_bl_desc;
          function TreeDesc(dyn_tree, stat_desc) {
            this.dyn_tree = dyn_tree;
            this.max_code = 0;
            this.stat_desc = stat_desc;
          }
          function d_code(dist) {
            return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
          }
          function put_short(s, w) {
            s.pending_buf[s.pending++] = w & 255;
            s.pending_buf[s.pending++] = w >>> 8 & 255;
          }
          function send_bits(s, value, length) {
            if (s.bi_valid > Buf_size - length) {
              s.bi_buf |= value << s.bi_valid & 65535;
              put_short(s, s.bi_buf);
              s.bi_buf = value >> Buf_size - s.bi_valid;
              s.bi_valid += length - Buf_size;
            } else {
              s.bi_buf |= value << s.bi_valid & 65535;
              s.bi_valid += length;
            }
          }
          function send_code(s, c, tree) {
            send_bits(s, tree[c * 2], tree[c * 2 + 1]);
          }
          function bi_reverse(code, len) {
            var res = 0;
            do {
              res |= code & 1;
              code >>>= 1;
              res <<= 1;
            } while (--len > 0);
            return res >>> 1;
          }
          function bi_flush(s) {
            if (s.bi_valid === 16) {
              put_short(s, s.bi_buf);
              s.bi_buf = 0;
              s.bi_valid = 0;
            } else if (s.bi_valid >= 8) {
              s.pending_buf[s.pending++] = s.bi_buf & 255;
              s.bi_buf >>= 8;
              s.bi_valid -= 8;
            }
          }
          function gen_bitlen(s, desc) {
            var tree = desc.dyn_tree;
            var max_code = desc.max_code;
            var stree = desc.stat_desc.static_tree;
            var has_stree = desc.stat_desc.has_stree;
            var extra = desc.stat_desc.extra_bits;
            var base = desc.stat_desc.extra_base;
            var max_length = desc.stat_desc.max_length;
            var h2;
            var n, m;
            var bits;
            var xbits;
            var f;
            var overflow = 0;
            for (bits = 0; bits <= MAX_BITS; bits++) {
              s.bl_count[bits] = 0;
            }
            tree[s.heap[s.heap_max] * 2 + 1] = 0;
            for (h2 = s.heap_max + 1; h2 < HEAP_SIZE; h2++) {
              n = s.heap[h2];
              bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
              if (bits > max_length) {
                bits = max_length;
                overflow++;
              }
              tree[n * 2 + 1] = bits;
              if (n > max_code) {
                continue;
              }
              s.bl_count[bits]++;
              xbits = 0;
              if (n >= base) {
                xbits = extra[n - base];
              }
              f = tree[n * 2];
              s.opt_len += f * (bits + xbits);
              if (has_stree) {
                s.static_len += f * (stree[n * 2 + 1] + xbits);
              }
            }
            if (overflow === 0) {
              return;
            }
            do {
              bits = max_length - 1;
              while (s.bl_count[bits] === 0) {
                bits--;
              }
              s.bl_count[bits]--;
              s.bl_count[bits + 1] += 2;
              s.bl_count[max_length]--;
              overflow -= 2;
            } while (overflow > 0);
            for (bits = max_length; bits !== 0; bits--) {
              n = s.bl_count[bits];
              while (n !== 0) {
                m = s.heap[--h2];
                if (m > max_code) {
                  continue;
                }
                if (tree[m * 2 + 1] !== bits) {
                  s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
                  tree[m * 2 + 1] = bits;
                }
                n--;
              }
            }
          }
          function gen_codes(tree, max_code, bl_count) {
            var next_code = new Array(MAX_BITS + 1);
            var code = 0;
            var bits;
            var n;
            for (bits = 1; bits <= MAX_BITS; bits++) {
              next_code[bits] = code = code + bl_count[bits - 1] << 1;
            }
            for (n = 0; n <= max_code; n++) {
              var len = tree[n * 2 + 1];
              if (len === 0) {
                continue;
              }
              tree[n * 2] = bi_reverse(next_code[len]++, len);
            }
          }
          function tr_static_init() {
            var n;
            var bits;
            var length;
            var code;
            var dist;
            var bl_count = new Array(MAX_BITS + 1);
            length = 0;
            for (code = 0; code < LENGTH_CODES - 1; code++) {
              base_length[code] = length;
              for (n = 0; n < 1 << extra_lbits[code]; n++) {
                _length_code[length++] = code;
              }
            }
            _length_code[length - 1] = code;
            dist = 0;
            for (code = 0; code < 16; code++) {
              base_dist[code] = dist;
              for (n = 0; n < 1 << extra_dbits[code]; n++) {
                _dist_code[dist++] = code;
              }
            }
            dist >>= 7;
            for (; code < D_CODES; code++) {
              base_dist[code] = dist << 7;
              for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
                _dist_code[256 + dist++] = code;
              }
            }
            for (bits = 0; bits <= MAX_BITS; bits++) {
              bl_count[bits] = 0;
            }
            n = 0;
            while (n <= 143) {
              static_ltree[n * 2 + 1] = 8;
              n++;
              bl_count[8]++;
            }
            while (n <= 255) {
              static_ltree[n * 2 + 1] = 9;
              n++;
              bl_count[9]++;
            }
            while (n <= 279) {
              static_ltree[n * 2 + 1] = 7;
              n++;
              bl_count[7]++;
            }
            while (n <= 287) {
              static_ltree[n * 2 + 1] = 8;
              n++;
              bl_count[8]++;
            }
            gen_codes(static_ltree, L_CODES + 1, bl_count);
            for (n = 0; n < D_CODES; n++) {
              static_dtree[n * 2 + 1] = 5;
              static_dtree[n * 2] = bi_reverse(n, 5);
            }
            static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
            static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
            static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
          }
          function init_block(s) {
            var n;
            for (n = 0; n < L_CODES; n++) {
              s.dyn_ltree[n * 2] = 0;
            }
            for (n = 0; n < D_CODES; n++) {
              s.dyn_dtree[n * 2] = 0;
            }
            for (n = 0; n < BL_CODES; n++) {
              s.bl_tree[n * 2] = 0;
            }
            s.dyn_ltree[END_BLOCK * 2] = 1;
            s.opt_len = s.static_len = 0;
            s.last_lit = s.matches = 0;
          }
          function bi_windup(s) {
            if (s.bi_valid > 8) {
              put_short(s, s.bi_buf);
            } else if (s.bi_valid > 0) {
              s.pending_buf[s.pending++] = s.bi_buf;
            }
            s.bi_buf = 0;
            s.bi_valid = 0;
          }
          function copy_block(s, buf, len, header) {
            bi_windup(s);
            if (header) {
              put_short(s, len);
              put_short(s, ~len);
            }
            utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
            s.pending += len;
          }
          function smaller(tree, n, m, depth) {
            var _n2 = n * 2;
            var _m2 = m * 2;
            return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
          }
          function pqdownheap(s, tree, k) {
            var v = s.heap[k];
            var j = k << 1;
            while (j <= s.heap_len) {
              if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
                j++;
              }
              if (smaller(tree, v, s.heap[j], s.depth)) {
                break;
              }
              s.heap[k] = s.heap[j];
              k = j;
              j <<= 1;
            }
            s.heap[k] = v;
          }
          function compress_block(s, ltree, dtree) {
            var dist;
            var lc;
            var lx = 0;
            var code;
            var extra;
            if (s.last_lit !== 0) {
              do {
                dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
                lc = s.pending_buf[s.l_buf + lx];
                lx++;
                if (dist === 0) {
                  send_code(s, lc, ltree);
                } else {
                  code = _length_code[lc];
                  send_code(s, code + LITERALS + 1, ltree);
                  extra = extra_lbits[code];
                  if (extra !== 0) {
                    lc -= base_length[code];
                    send_bits(s, lc, extra);
                  }
                  dist--;
                  code = d_code(dist);
                  send_code(s, code, dtree);
                  extra = extra_dbits[code];
                  if (extra !== 0) {
                    dist -= base_dist[code];
                    send_bits(s, dist, extra);
                  }
                }
              } while (lx < s.last_lit);
            }
            send_code(s, END_BLOCK, ltree);
          }
          function build_tree(s, desc) {
            var tree = desc.dyn_tree;
            var stree = desc.stat_desc.static_tree;
            var has_stree = desc.stat_desc.has_stree;
            var elems = desc.stat_desc.elems;
            var n, m;
            var max_code = -1;
            var node;
            s.heap_len = 0;
            s.heap_max = HEAP_SIZE;
            for (n = 0; n < elems; n++) {
              if (tree[n * 2] !== 0) {
                s.heap[++s.heap_len] = max_code = n;
                s.depth[n] = 0;
              } else {
                tree[n * 2 + 1] = 0;
              }
            }
            while (s.heap_len < 2) {
              node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
              tree[node * 2] = 1;
              s.depth[node] = 0;
              s.opt_len--;
              if (has_stree) {
                s.static_len -= stree[node * 2 + 1];
              }
            }
            desc.max_code = max_code;
            for (n = s.heap_len >> 1; n >= 1; n--) {
              pqdownheap(s, tree, n);
            }
            node = elems;
            do {
              n = s.heap[1];
              s.heap[1] = s.heap[s.heap_len--];
              pqdownheap(s, tree, 1);
              m = s.heap[1];
              s.heap[--s.heap_max] = n;
              s.heap[--s.heap_max] = m;
              tree[node * 2] = tree[n * 2] + tree[m * 2];
              s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
              tree[n * 2 + 1] = tree[m * 2 + 1] = node;
              s.heap[1] = node++;
              pqdownheap(s, tree, 1);
            } while (s.heap_len >= 2);
            s.heap[--s.heap_max] = s.heap[1];
            gen_bitlen(s, desc);
            gen_codes(tree, max_code, s.bl_count);
          }
          function scan_tree(s, tree, max_code) {
            var n;
            var prevlen = -1;
            var curlen;
            var nextlen = tree[0 * 2 + 1];
            var count = 0;
            var max_count = 7;
            var min_count = 4;
            if (nextlen === 0) {
              max_count = 138;
              min_count = 3;
            }
            tree[(max_code + 1) * 2 + 1] = 65535;
            for (n = 0; n <= max_code; n++) {
              curlen = nextlen;
              nextlen = tree[(n + 1) * 2 + 1];
              if (++count < max_count && curlen === nextlen) {
                continue;
              } else if (count < min_count) {
                s.bl_tree[curlen * 2] += count;
              } else if (curlen !== 0) {
                if (curlen !== prevlen) {
                  s.bl_tree[curlen * 2]++;
                }
                s.bl_tree[REP_3_6 * 2]++;
              } else if (count <= 10) {
                s.bl_tree[REPZ_3_10 * 2]++;
              } else {
                s.bl_tree[REPZ_11_138 * 2]++;
              }
              count = 0;
              prevlen = curlen;
              if (nextlen === 0) {
                max_count = 138;
                min_count = 3;
              } else if (curlen === nextlen) {
                max_count = 6;
                min_count = 3;
              } else {
                max_count = 7;
                min_count = 4;
              }
            }
          }
          function send_tree(s, tree, max_code) {
            var n;
            var prevlen = -1;
            var curlen;
            var nextlen = tree[0 * 2 + 1];
            var count = 0;
            var max_count = 7;
            var min_count = 4;
            if (nextlen === 0) {
              max_count = 138;
              min_count = 3;
            }
            for (n = 0; n <= max_code; n++) {
              curlen = nextlen;
              nextlen = tree[(n + 1) * 2 + 1];
              if (++count < max_count && curlen === nextlen) {
                continue;
              } else if (count < min_count) {
                do {
                  send_code(s, curlen, s.bl_tree);
                } while (--count !== 0);
              } else if (curlen !== 0) {
                if (curlen !== prevlen) {
                  send_code(s, curlen, s.bl_tree);
                  count--;
                }
                send_code(s, REP_3_6, s.bl_tree);
                send_bits(s, count - 3, 2);
              } else if (count <= 10) {
                send_code(s, REPZ_3_10, s.bl_tree);
                send_bits(s, count - 3, 3);
              } else {
                send_code(s, REPZ_11_138, s.bl_tree);
                send_bits(s, count - 11, 7);
              }
              count = 0;
              prevlen = curlen;
              if (nextlen === 0) {
                max_count = 138;
                min_count = 3;
              } else if (curlen === nextlen) {
                max_count = 6;
                min_count = 3;
              } else {
                max_count = 7;
                min_count = 4;
              }
            }
          }
          function build_bl_tree(s) {
            var max_blindex;
            scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
            scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
            build_tree(s, s.bl_desc);
            for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
              if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
                break;
              }
            }
            s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
            return max_blindex;
          }
          function send_all_trees(s, lcodes, dcodes, blcodes) {
            var rank;
            send_bits(s, lcodes - 257, 5);
            send_bits(s, dcodes - 1, 5);
            send_bits(s, blcodes - 4, 4);
            for (rank = 0; rank < blcodes; rank++) {
              send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
            }
            send_tree(s, s.dyn_ltree, lcodes - 1);
            send_tree(s, s.dyn_dtree, dcodes - 1);
          }
          function detect_data_type(s) {
            var black_mask = 4093624447;
            var n;
            for (n = 0; n <= 31; n++, black_mask >>>= 1) {
              if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
                return Z_BINARY;
              }
            }
            if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
              return Z_TEXT;
            }
            for (n = 32; n < LITERALS; n++) {
              if (s.dyn_ltree[n * 2] !== 0) {
                return Z_TEXT;
              }
            }
            return Z_BINARY;
          }
          var static_init_done = false;
          function _tr_init(s) {
            if (!static_init_done) {
              tr_static_init();
              static_init_done = true;
            }
            s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
            s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
            s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
            s.bi_buf = 0;
            s.bi_valid = 0;
            init_block(s);
          }
          function _tr_stored_block(s, buf, stored_len, last) {
            send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
            copy_block(s, buf, stored_len, true);
          }
          function _tr_align(s) {
            send_bits(s, STATIC_TREES << 1, 3);
            send_code(s, END_BLOCK, static_ltree);
            bi_flush(s);
          }
          function _tr_flush_block(s, buf, stored_len, last) {
            var opt_lenb, static_lenb;
            var max_blindex = 0;
            if (s.level > 0) {
              if (s.strm.data_type === Z_UNKNOWN) {
                s.strm.data_type = detect_data_type(s);
              }
              build_tree(s, s.l_desc);
              build_tree(s, s.d_desc);
              max_blindex = build_bl_tree(s);
              opt_lenb = s.opt_len + 3 + 7 >>> 3;
              static_lenb = s.static_len + 3 + 7 >>> 3;
              if (static_lenb <= opt_lenb) {
                opt_lenb = static_lenb;
              }
            } else {
              opt_lenb = static_lenb = stored_len + 5;
            }
            if (stored_len + 4 <= opt_lenb && buf !== -1) {
              _tr_stored_block(s, buf, stored_len, last);
            } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
              send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
              compress_block(s, static_ltree, static_dtree);
            } else {
              send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
              send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
              compress_block(s, s.dyn_ltree, s.dyn_dtree);
            }
            init_block(s);
            if (last) {
              bi_windup(s);
            }
          }
          function _tr_tally(s, dist, lc) {
            s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
            s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
            s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
            s.last_lit++;
            if (dist === 0) {
              s.dyn_ltree[lc * 2]++;
            } else {
              s.matches++;
              dist--;
              s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
              s.dyn_dtree[d_code(dist) * 2]++;
            }
            return s.last_lit === s.lit_bufsize - 1;
          }
          exports3._tr_init = _tr_init;
          exports3._tr_stored_block = _tr_stored_block;
          exports3._tr_flush_block = _tr_flush_block;
          exports3._tr_tally = _tr_tally;
          exports3._tr_align = _tr_align;
        }, { "../utils/common": 41 }], 53: [function(require2, module3, exports3) {
          "use strict";
          function ZStream() {
            this.input = null;
            this.next_in = 0;
            this.avail_in = 0;
            this.total_in = 0;
            this.output = null;
            this.next_out = 0;
            this.avail_out = 0;
            this.total_out = 0;
            this.msg = "";
            this.state = null;
            this.data_type = 2;
            this.adler = 0;
          }
          module3.exports = ZStream;
        }, {}], 54: [function(require2, module3, exports3) {
          (function(global2) {
            (function(global3, undefined2) {
              "use strict";
              if (global3.setImmediate) {
                return;
              }
              var nextHandle = 1;
              var tasksByHandle = {};
              var currentlyRunningATask = false;
              var doc2 = global3.document;
              var registerImmediate;
              function setImmediate2(callback) {
                if (typeof callback !== "function") {
                  callback = new Function("" + callback);
                }
                var args = new Array(arguments.length - 1);
                for (var i = 0; i < args.length; i++) {
                  args[i] = arguments[i + 1];
                }
                var task = { callback, args };
                tasksByHandle[nextHandle] = task;
                registerImmediate(nextHandle);
                return nextHandle++;
              }
              function clearImmediate(handle) {
                delete tasksByHandle[handle];
              }
              function run2(task) {
                var callback = task.callback;
                var args = task.args;
                switch (args.length) {
                  case 0:
                    callback();
                    break;
                  case 1:
                    callback(args[0]);
                    break;
                  case 2:
                    callback(args[0], args[1]);
                    break;
                  case 3:
                    callback(args[0], args[1], args[2]);
                    break;
                  default:
                    callback.apply(undefined2, args);
                    break;
                }
              }
              function runIfPresent(handle) {
                if (currentlyRunningATask) {
                  setTimeout(runIfPresent, 0, handle);
                } else {
                  var task = tasksByHandle[handle];
                  if (task) {
                    currentlyRunningATask = true;
                    try {
                      run2(task);
                    } finally {
                      clearImmediate(handle);
                      currentlyRunningATask = false;
                    }
                  }
                }
              }
              function installNextTickImplementation() {
                registerImmediate = function(handle) {
                  process.nextTick(function() {
                    runIfPresent(handle);
                  });
                };
              }
              function canUsePostMessage() {
                if (global3.postMessage && !global3.importScripts) {
                  var postMessageIsAsynchronous = true;
                  var oldOnMessage = global3.onmessage;
                  global3.onmessage = function() {
                    postMessageIsAsynchronous = false;
                  };
                  global3.postMessage("", "*");
                  global3.onmessage = oldOnMessage;
                  return postMessageIsAsynchronous;
                }
              }
              function installPostMessageImplementation() {
                var messagePrefix = "setImmediate$" + Math.random() + "$";
                var onGlobalMessage = function(event) {
                  if (event.source === global3 && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
                    runIfPresent(+event.data.slice(messagePrefix.length));
                  }
                };
                if (global3.addEventListener) {
                  global3.addEventListener("message", onGlobalMessage, false);
                } else {
                  global3.attachEvent("onmessage", onGlobalMessage);
                }
                registerImmediate = function(handle) {
                  global3.postMessage(messagePrefix + handle, "*");
                };
              }
              function installMessageChannelImplementation() {
                var channel = new MessageChannel();
                channel.port1.onmessage = function(event) {
                  var handle = event.data;
                  runIfPresent(handle);
                };
                registerImmediate = function(handle) {
                  channel.port2.postMessage(handle);
                };
              }
              function installReadyStateChangeImplementation() {
                var html = doc2.documentElement;
                registerImmediate = function(handle) {
                  var script = doc2.createElement("script");
                  script.onreadystatechange = function() {
                    runIfPresent(handle);
                    script.onreadystatechange = null;
                    html.removeChild(script);
                    script = null;
                  };
                  html.appendChild(script);
                };
              }
              function installSetTimeoutImplementation() {
                registerImmediate = function(handle) {
                  setTimeout(runIfPresent, 0, handle);
                };
              }
              var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global3);
              attachTo = attachTo && attachTo.setTimeout ? attachTo : global3;
              if ({}.toString.call(global3.process) === "[object process]") {
                installNextTickImplementation();
              } else if (canUsePostMessage()) {
                installPostMessageImplementation();
              } else if (global3.MessageChannel) {
                installMessageChannelImplementation();
              } else if (doc2 && "onreadystatechange" in doc2.createElement("script")) {
                installReadyStateChangeImplementation();
              } else {
                installSetTimeoutImplementation();
              }
              attachTo.setImmediate = setImmediate2;
              attachTo.clearImmediate = clearImmediate;
            })(typeof self === "undefined" ? typeof global2 === "undefined" ? this : global2 : self);
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {}] }, {}, [10])(10);
      });
    }
  });

  // ../library_management/node_modules/localforage/dist/localforage.js
  var require_localforage = __commonJS({
    "../library_management/node_modules/localforage/dist/localforage.js"(exports, module) {
      (function(f) {
        if (typeof exports === "object" && typeof module !== "undefined") {
          module.exports = f();
        } else if (typeof define === "function" && define.amd) {
          define([], f);
        } else {
          var g;
          if (typeof window !== "undefined") {
            g = window;
          } else if (typeof global !== "undefined") {
            g = global;
          } else if (typeof self !== "undefined") {
            g = self;
          } else {
            g = this;
          }
          g.localforage = f();
        }
      })(function() {
        var define2, module2, exports2;
        return function e(t, n, r) {
          function s(o2, u) {
            if (!n[o2]) {
              if (!t[o2]) {
                var a = typeof __require == "function" && __require;
                if (!u && a)
                  return a(o2, true);
                if (i)
                  return i(o2, true);
                var f = new Error("Cannot find module '" + o2 + "'");
                throw f.code = "MODULE_NOT_FOUND", f;
              }
              var l = n[o2] = { exports: {} };
              t[o2][0].call(l.exports, function(e2) {
                var n2 = t[o2][1][e2];
                return s(n2 ? n2 : e2);
              }, l, l.exports, e, t, n, r);
            }
            return n[o2].exports;
          }
          var i = typeof __require == "function" && __require;
          for (var o = 0; o < r.length; o++)
            s(r[o]);
          return s;
        }({ 1: [function(_dereq_, module3, exports3) {
          (function(global2) {
            "use strict";
            var Mutation = global2.MutationObserver || global2.WebKitMutationObserver;
            var scheduleDrain;
            {
              if (Mutation) {
                var called = 0;
                var observer = new Mutation(nextTick2);
                var element = global2.document.createTextNode("");
                observer.observe(element, {
                  characterData: true
                });
                scheduleDrain = function() {
                  element.data = called = ++called % 2;
                };
              } else if (!global2.setImmediate && typeof global2.MessageChannel !== "undefined") {
                var channel = new global2.MessageChannel();
                channel.port1.onmessage = nextTick2;
                scheduleDrain = function() {
                  channel.port2.postMessage(0);
                };
              } else if ("document" in global2 && "onreadystatechange" in global2.document.createElement("script")) {
                scheduleDrain = function() {
                  var scriptEl = global2.document.createElement("script");
                  scriptEl.onreadystatechange = function() {
                    nextTick2();
                    scriptEl.onreadystatechange = null;
                    scriptEl.parentNode.removeChild(scriptEl);
                    scriptEl = null;
                  };
                  global2.document.documentElement.appendChild(scriptEl);
                };
              } else {
                scheduleDrain = function() {
                  setTimeout(nextTick2, 0);
                };
              }
            }
            var draining;
            var queue2 = [];
            function nextTick2() {
              draining = true;
              var i, oldQueue;
              var len = queue2.length;
              while (len) {
                oldQueue = queue2;
                queue2 = [];
                i = -1;
                while (++i < len) {
                  oldQueue[i]();
                }
                len = queue2.length;
              }
              draining = false;
            }
            module3.exports = immediate;
            function immediate(task) {
              if (queue2.push(task) === 1 && !draining) {
                scheduleDrain();
              }
            }
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {}], 2: [function(_dereq_, module3, exports3) {
          "use strict";
          var immediate = _dereq_(1);
          function INTERNAL() {
          }
          var handlers2 = {};
          var REJECTED = ["REJECTED"];
          var FULFILLED = ["FULFILLED"];
          var PENDING = ["PENDING"];
          module3.exports = Promise2;
          function Promise2(resolver) {
            if (typeof resolver !== "function") {
              throw new TypeError("resolver must be a function");
            }
            this.state = PENDING;
            this.queue = [];
            this.outcome = void 0;
            if (resolver !== INTERNAL) {
              safelyResolveThenable(this, resolver);
            }
          }
          Promise2.prototype["catch"] = function(onRejected) {
            return this.then(null, onRejected);
          };
          Promise2.prototype.then = function(onFulfilled, onRejected) {
            if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
              return this;
            }
            var promise = new this.constructor(INTERNAL);
            if (this.state !== PENDING) {
              var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
              unwrap(promise, resolver, this.outcome);
            } else {
              this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
            }
            return promise;
          };
          function QueueItem(promise, onFulfilled, onRejected) {
            this.promise = promise;
            if (typeof onFulfilled === "function") {
              this.onFulfilled = onFulfilled;
              this.callFulfilled = this.otherCallFulfilled;
            }
            if (typeof onRejected === "function") {
              this.onRejected = onRejected;
              this.callRejected = this.otherCallRejected;
            }
          }
          QueueItem.prototype.callFulfilled = function(value) {
            handlers2.resolve(this.promise, value);
          };
          QueueItem.prototype.otherCallFulfilled = function(value) {
            unwrap(this.promise, this.onFulfilled, value);
          };
          QueueItem.prototype.callRejected = function(value) {
            handlers2.reject(this.promise, value);
          };
          QueueItem.prototype.otherCallRejected = function(value) {
            unwrap(this.promise, this.onRejected, value);
          };
          function unwrap(promise, func, value) {
            immediate(function() {
              var returnValue;
              try {
                returnValue = func(value);
              } catch (e) {
                return handlers2.reject(promise, e);
              }
              if (returnValue === promise) {
                handlers2.reject(promise, new TypeError("Cannot resolve promise with itself"));
              } else {
                handlers2.resolve(promise, returnValue);
              }
            });
          }
          handlers2.resolve = function(self2, value) {
            var result = tryCatch(getThen, value);
            if (result.status === "error") {
              return handlers2.reject(self2, result.value);
            }
            var thenable = result.value;
            if (thenable) {
              safelyResolveThenable(self2, thenable);
            } else {
              self2.state = FULFILLED;
              self2.outcome = value;
              var i = -1;
              var len = self2.queue.length;
              while (++i < len) {
                self2.queue[i].callFulfilled(value);
              }
            }
            return self2;
          };
          handlers2.reject = function(self2, error) {
            self2.state = REJECTED;
            self2.outcome = error;
            var i = -1;
            var len = self2.queue.length;
            while (++i < len) {
              self2.queue[i].callRejected(error);
            }
            return self2;
          };
          function getThen(obj) {
            var then = obj && obj.then;
            if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
              return function appyThen() {
                then.apply(obj, arguments);
              };
            }
          }
          function safelyResolveThenable(self2, thenable) {
            var called = false;
            function onError(value) {
              if (called) {
                return;
              }
              called = true;
              handlers2.reject(self2, value);
            }
            function onSuccess(value) {
              if (called) {
                return;
              }
              called = true;
              handlers2.resolve(self2, value);
            }
            function tryToUnwrap() {
              thenable(onSuccess, onError);
            }
            var result = tryCatch(tryToUnwrap);
            if (result.status === "error") {
              onError(result.value);
            }
          }
          function tryCatch(func, value) {
            var out = {};
            try {
              out.value = func(value);
              out.status = "success";
            } catch (e) {
              out.status = "error";
              out.value = e;
            }
            return out;
          }
          Promise2.resolve = resolve2;
          function resolve2(value) {
            if (value instanceof this) {
              return value;
            }
            return handlers2.resolve(new this(INTERNAL), value);
          }
          Promise2.reject = reject;
          function reject(reason) {
            var promise = new this(INTERNAL);
            return handlers2.reject(promise, reason);
          }
          Promise2.all = all;
          function all(iterable) {
            var self2 = this;
            if (Object.prototype.toString.call(iterable) !== "[object Array]") {
              return this.reject(new TypeError("must be an array"));
            }
            var len = iterable.length;
            var called = false;
            if (!len) {
              return this.resolve([]);
            }
            var values = new Array(len);
            var resolved = 0;
            var i = -1;
            var promise = new this(INTERNAL);
            while (++i < len) {
              allResolver(iterable[i], i);
            }
            return promise;
            function allResolver(value, i2) {
              self2.resolve(value).then(resolveFromAll, function(error) {
                if (!called) {
                  called = true;
                  handlers2.reject(promise, error);
                }
              });
              function resolveFromAll(outValue) {
                values[i2] = outValue;
                if (++resolved === len && !called) {
                  called = true;
                  handlers2.resolve(promise, values);
                }
              }
            }
          }
          Promise2.race = race;
          function race(iterable) {
            var self2 = this;
            if (Object.prototype.toString.call(iterable) !== "[object Array]") {
              return this.reject(new TypeError("must be an array"));
            }
            var len = iterable.length;
            var called = false;
            if (!len) {
              return this.resolve([]);
            }
            var i = -1;
            var promise = new this(INTERNAL);
            while (++i < len) {
              resolver(iterable[i]);
            }
            return promise;
            function resolver(value) {
              self2.resolve(value).then(function(response) {
                if (!called) {
                  called = true;
                  handlers2.resolve(promise, response);
                }
              }, function(error) {
                if (!called) {
                  called = true;
                  handlers2.reject(promise, error);
                }
              });
            }
          }
        }, { "1": 1 }], 3: [function(_dereq_, module3, exports3) {
          (function(global2) {
            "use strict";
            if (typeof global2.Promise !== "function") {
              global2.Promise = _dereq_(2);
            }
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, { "2": 2 }], 4: [function(_dereq_, module3, exports3) {
          "use strict";
          var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
            return typeof obj;
          } : function(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function getIDB() {
            try {
              if (typeof indexedDB !== "undefined") {
                return indexedDB;
              }
              if (typeof webkitIndexedDB !== "undefined") {
                return webkitIndexedDB;
              }
              if (typeof mozIndexedDB !== "undefined") {
                return mozIndexedDB;
              }
              if (typeof OIndexedDB !== "undefined") {
                return OIndexedDB;
              }
              if (typeof msIndexedDB !== "undefined") {
                return msIndexedDB;
              }
            } catch (e) {
              return;
            }
          }
          var idb = getIDB();
          function isIndexedDBValid() {
            try {
              if (!idb || !idb.open) {
                return false;
              }
              var isSafari = typeof openDatabase !== "undefined" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);
              var hasFetch = typeof fetch === "function" && fetch.toString().indexOf("[native code") !== -1;
              return (!isSafari || hasFetch) && typeof indexedDB !== "undefined" && typeof IDBKeyRange !== "undefined";
            } catch (e) {
              return false;
            }
          }
          function createBlob2(parts, properties) {
            parts = parts || [];
            properties = properties || {};
            try {
              return new Blob(parts, properties);
            } catch (e) {
              if (e.name !== "TypeError") {
                throw e;
              }
              var Builder = typeof BlobBuilder !== "undefined" ? BlobBuilder : typeof MSBlobBuilder !== "undefined" ? MSBlobBuilder : typeof MozBlobBuilder !== "undefined" ? MozBlobBuilder : WebKitBlobBuilder;
              var builder = new Builder();
              for (var i = 0; i < parts.length; i += 1) {
                builder.append(parts[i]);
              }
              return builder.getBlob(properties.type);
            }
          }
          if (typeof Promise === "undefined") {
            _dereq_(3);
          }
          var Promise$1 = Promise;
          function executeCallback(promise, callback) {
            if (callback) {
              promise.then(function(result) {
                callback(null, result);
              }, function(error) {
                callback(error);
              });
            }
          }
          function executeTwoCallbacks(promise, callback, errorCallback) {
            if (typeof callback === "function") {
              promise.then(callback);
            }
            if (typeof errorCallback === "function") {
              promise["catch"](errorCallback);
            }
          }
          function normalizeKey2(key2) {
            if (typeof key2 !== "string") {
              console.warn(key2 + " used as a key, but it is not a string.");
              key2 = String(key2);
            }
            return key2;
          }
          function getCallback() {
            if (arguments.length && typeof arguments[arguments.length - 1] === "function") {
              return arguments[arguments.length - 1];
            }
          }
          var DETECT_BLOB_SUPPORT_STORE = "local-forage-detect-blob-support";
          var supportsBlobs = void 0;
          var dbContexts = {};
          var toString = Object.prototype.toString;
          var READ_ONLY = "readonly";
          var READ_WRITE = "readwrite";
          function _binStringToArrayBuffer(bin) {
            var length2 = bin.length;
            var buf = new ArrayBuffer(length2);
            var arr = new Uint8Array(buf);
            for (var i = 0; i < length2; i++) {
              arr[i] = bin.charCodeAt(i);
            }
            return buf;
          }
          function _checkBlobSupportWithoutCaching(idb2) {
            return new Promise$1(function(resolve2) {
              var txn = idb2.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
              var blob = createBlob2([""]);
              txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, "key");
              txn.onabort = function(e) {
                e.preventDefault();
                e.stopPropagation();
                resolve2(false);
              };
              txn.oncomplete = function() {
                var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
                var matchedEdge = navigator.userAgent.match(/Edge\//);
                resolve2(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
              };
            })["catch"](function() {
              return false;
            });
          }
          function _checkBlobSupport(idb2) {
            if (typeof supportsBlobs === "boolean") {
              return Promise$1.resolve(supportsBlobs);
            }
            return _checkBlobSupportWithoutCaching(idb2).then(function(value) {
              supportsBlobs = value;
              return supportsBlobs;
            });
          }
          function _deferReadiness(dbInfo) {
            var dbContext = dbContexts[dbInfo.name];
            var deferredOperation = {};
            deferredOperation.promise = new Promise$1(function(resolve2, reject) {
              deferredOperation.resolve = resolve2;
              deferredOperation.reject = reject;
            });
            dbContext.deferredOperations.push(deferredOperation);
            if (!dbContext.dbReady) {
              dbContext.dbReady = deferredOperation.promise;
            } else {
              dbContext.dbReady = dbContext.dbReady.then(function() {
                return deferredOperation.promise;
              });
            }
          }
          function _advanceReadiness(dbInfo) {
            var dbContext = dbContexts[dbInfo.name];
            var deferredOperation = dbContext.deferredOperations.pop();
            if (deferredOperation) {
              deferredOperation.resolve();
              return deferredOperation.promise;
            }
          }
          function _rejectReadiness(dbInfo, err) {
            var dbContext = dbContexts[dbInfo.name];
            var deferredOperation = dbContext.deferredOperations.pop();
            if (deferredOperation) {
              deferredOperation.reject(err);
              return deferredOperation.promise;
            }
          }
          function _getConnection(dbInfo, upgradeNeeded) {
            return new Promise$1(function(resolve2, reject) {
              dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();
              if (dbInfo.db) {
                if (upgradeNeeded) {
                  _deferReadiness(dbInfo);
                  dbInfo.db.close();
                } else {
                  return resolve2(dbInfo.db);
                }
              }
              var dbArgs = [dbInfo.name];
              if (upgradeNeeded) {
                dbArgs.push(dbInfo.version);
              }
              var openreq = idb.open.apply(idb, dbArgs);
              if (upgradeNeeded) {
                openreq.onupgradeneeded = function(e) {
                  var db = openreq.result;
                  try {
                    db.createObjectStore(dbInfo.storeName);
                    if (e.oldVersion <= 1) {
                      db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                    }
                  } catch (ex) {
                    if (ex.name === "ConstraintError") {
                      console.warn('The database "' + dbInfo.name + '" has been upgraded from version ' + e.oldVersion + " to version " + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                    } else {
                      throw ex;
                    }
                  }
                };
              }
              openreq.onerror = function(e) {
                e.preventDefault();
                reject(openreq.error);
              };
              openreq.onsuccess = function() {
                var db = openreq.result;
                db.onversionchange = function(e) {
                  e.target.close();
                };
                resolve2(db);
                _advanceReadiness(dbInfo);
              };
            });
          }
          function _getOriginalConnection(dbInfo) {
            return _getConnection(dbInfo, false);
          }
          function _getUpgradedConnection(dbInfo) {
            return _getConnection(dbInfo, true);
          }
          function _isUpgradeNeeded(dbInfo, defaultVersion) {
            if (!dbInfo.db) {
              return true;
            }
            var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
            var isDowngrade = dbInfo.version < dbInfo.db.version;
            var isUpgrade = dbInfo.version > dbInfo.db.version;
            if (isDowngrade) {
              if (dbInfo.version !== defaultVersion) {
                console.warn('The database "' + dbInfo.name + `" can't be downgraded from version ` + dbInfo.db.version + " to version " + dbInfo.version + ".");
              }
              dbInfo.version = dbInfo.db.version;
            }
            if (isUpgrade || isNewStore) {
              if (isNewStore) {
                var incVersion = dbInfo.db.version + 1;
                if (incVersion > dbInfo.version) {
                  dbInfo.version = incVersion;
                }
              }
              return true;
            }
            return false;
          }
          function _encodeBlob(blob) {
            return new Promise$1(function(resolve2, reject) {
              var reader = new FileReader();
              reader.onerror = reject;
              reader.onloadend = function(e) {
                var base64 = btoa(e.target.result || "");
                resolve2({
                  __local_forage_encoded_blob: true,
                  data: base64,
                  type: blob.type
                });
              };
              reader.readAsBinaryString(blob);
            });
          }
          function _decodeBlob(encodedBlob) {
            var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
            return createBlob2([arrayBuff], { type: encodedBlob.type });
          }
          function _isEncodedBlob(value) {
            return value && value.__local_forage_encoded_blob;
          }
          function _fullyReady(callback) {
            var self2 = this;
            var promise = self2._initReady().then(function() {
              var dbContext = dbContexts[self2._dbInfo.name];
              if (dbContext && dbContext.dbReady) {
                return dbContext.dbReady;
              }
            });
            executeTwoCallbacks(promise, callback, callback);
            return promise;
          }
          function _tryReconnect(dbInfo) {
            _deferReadiness(dbInfo);
            var dbContext = dbContexts[dbInfo.name];
            var forages = dbContext.forages;
            for (var i = 0; i < forages.length; i++) {
              var forage = forages[i];
              if (forage._dbInfo.db) {
                forage._dbInfo.db.close();
                forage._dbInfo.db = null;
              }
            }
            dbInfo.db = null;
            return _getOriginalConnection(dbInfo).then(function(db) {
              dbInfo.db = db;
              if (_isUpgradeNeeded(dbInfo)) {
                return _getUpgradedConnection(dbInfo);
              }
              return db;
            }).then(function(db) {
              dbInfo.db = dbContext.db = db;
              for (var i2 = 0; i2 < forages.length; i2++) {
                forages[i2]._dbInfo.db = db;
              }
            })["catch"](function(err) {
              _rejectReadiness(dbInfo, err);
              throw err;
            });
          }
          function createTransaction(dbInfo, mode, callback, retries) {
            if (retries === void 0) {
              retries = 1;
            }
            try {
              var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
              callback(null, tx);
            } catch (err) {
              if (retries > 0 && (!dbInfo.db || err.name === "InvalidStateError" || err.name === "NotFoundError")) {
                return Promise$1.resolve().then(function() {
                  if (!dbInfo.db || err.name === "NotFoundError" && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                    if (dbInfo.db) {
                      dbInfo.version = dbInfo.db.version + 1;
                    }
                    return _getUpgradedConnection(dbInfo);
                  }
                }).then(function() {
                  return _tryReconnect(dbInfo).then(function() {
                    createTransaction(dbInfo, mode, callback, retries - 1);
                  });
                })["catch"](callback);
              }
              callback(err);
            }
          }
          function createDbContext() {
            return {
              forages: [],
              db: null,
              dbReady: null,
              deferredOperations: []
            };
          }
          function _initStorage(options) {
            var self2 = this;
            var dbInfo = {
              db: null
            };
            if (options) {
              for (var i in options) {
                dbInfo[i] = options[i];
              }
            }
            var dbContext = dbContexts[dbInfo.name];
            if (!dbContext) {
              dbContext = createDbContext();
              dbContexts[dbInfo.name] = dbContext;
            }
            dbContext.forages.push(self2);
            if (!self2._initReady) {
              self2._initReady = self2.ready;
              self2.ready = _fullyReady;
            }
            var initPromises = [];
            function ignoreErrors() {
              return Promise$1.resolve();
            }
            for (var j = 0; j < dbContext.forages.length; j++) {
              var forage = dbContext.forages[j];
              if (forage !== self2) {
                initPromises.push(forage._initReady()["catch"](ignoreErrors));
              }
            }
            var forages = dbContext.forages.slice(0);
            return Promise$1.all(initPromises).then(function() {
              dbInfo.db = dbContext.db;
              return _getOriginalConnection(dbInfo);
            }).then(function(db) {
              dbInfo.db = db;
              if (_isUpgradeNeeded(dbInfo, self2._defaultConfig.version)) {
                return _getUpgradedConnection(dbInfo);
              }
              return db;
            }).then(function(db) {
              dbInfo.db = dbContext.db = db;
              self2._dbInfo = dbInfo;
              for (var k = 0; k < forages.length; k++) {
                var forage2 = forages[k];
                if (forage2 !== self2) {
                  forage2._dbInfo.db = dbInfo.db;
                  forage2._dbInfo.version = dbInfo.version;
                }
              }
            });
          }
          function getItem(key2, callback) {
            var self2 = this;
            key2 = normalizeKey2(key2);
            var promise = new Promise$1(function(resolve2, reject) {
              self2.ready().then(function() {
                createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                  if (err) {
                    return reject(err);
                  }
                  try {
                    var store = transaction.objectStore(self2._dbInfo.storeName);
                    var req = store.get(key2);
                    req.onsuccess = function() {
                      var value = req.result;
                      if (value === void 0) {
                        value = null;
                      }
                      if (_isEncodedBlob(value)) {
                        value = _decodeBlob(value);
                      }
                      resolve2(value);
                    };
                    req.onerror = function() {
                      reject(req.error);
                    };
                  } catch (e) {
                    reject(e);
                  }
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function iterate(iterator, callback) {
            var self2 = this;
            var promise = new Promise$1(function(resolve2, reject) {
              self2.ready().then(function() {
                createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                  if (err) {
                    return reject(err);
                  }
                  try {
                    var store = transaction.objectStore(self2._dbInfo.storeName);
                    var req = store.openCursor();
                    var iterationNumber = 1;
                    req.onsuccess = function() {
                      var cursor = req.result;
                      if (cursor) {
                        var value = cursor.value;
                        if (_isEncodedBlob(value)) {
                          value = _decodeBlob(value);
                        }
                        var result = iterator(value, cursor.key, iterationNumber++);
                        if (result !== void 0) {
                          resolve2(result);
                        } else {
                          cursor["continue"]();
                        }
                      } else {
                        resolve2();
                      }
                    };
                    req.onerror = function() {
                      reject(req.error);
                    };
                  } catch (e) {
                    reject(e);
                  }
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function setItem(key2, value, callback) {
            var self2 = this;
            key2 = normalizeKey2(key2);
            var promise = new Promise$1(function(resolve2, reject) {
              var dbInfo;
              self2.ready().then(function() {
                dbInfo = self2._dbInfo;
                if (toString.call(value) === "[object Blob]") {
                  return _checkBlobSupport(dbInfo.db).then(function(blobSupport) {
                    if (blobSupport) {
                      return value;
                    }
                    return _encodeBlob(value);
                  });
                }
                return value;
              }).then(function(value2) {
                createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                  if (err) {
                    return reject(err);
                  }
                  try {
                    var store = transaction.objectStore(self2._dbInfo.storeName);
                    if (value2 === null) {
                      value2 = void 0;
                    }
                    var req = store.put(value2, key2);
                    transaction.oncomplete = function() {
                      if (value2 === void 0) {
                        value2 = null;
                      }
                      resolve2(value2);
                    };
                    transaction.onabort = transaction.onerror = function() {
                      var err2 = req.error ? req.error : req.transaction.error;
                      reject(err2);
                    };
                  } catch (e) {
                    reject(e);
                  }
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function removeItem(key2, callback) {
            var self2 = this;
            key2 = normalizeKey2(key2);
            var promise = new Promise$1(function(resolve2, reject) {
              self2.ready().then(function() {
                createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                  if (err) {
                    return reject(err);
                  }
                  try {
                    var store = transaction.objectStore(self2._dbInfo.storeName);
                    var req = store["delete"](key2);
                    transaction.oncomplete = function() {
                      resolve2();
                    };
                    transaction.onerror = function() {
                      reject(req.error);
                    };
                    transaction.onabort = function() {
                      var err2 = req.error ? req.error : req.transaction.error;
                      reject(err2);
                    };
                  } catch (e) {
                    reject(e);
                  }
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function clear2(callback) {
            var self2 = this;
            var promise = new Promise$1(function(resolve2, reject) {
              self2.ready().then(function() {
                createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                  if (err) {
                    return reject(err);
                  }
                  try {
                    var store = transaction.objectStore(self2._dbInfo.storeName);
                    var req = store.clear();
                    transaction.oncomplete = function() {
                      resolve2();
                    };
                    transaction.onabort = transaction.onerror = function() {
                      var err2 = req.error ? req.error : req.transaction.error;
                      reject(err2);
                    };
                  } catch (e) {
                    reject(e);
                  }
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function length(callback) {
            var self2 = this;
            var promise = new Promise$1(function(resolve2, reject) {
              self2.ready().then(function() {
                createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                  if (err) {
                    return reject(err);
                  }
                  try {
                    var store = transaction.objectStore(self2._dbInfo.storeName);
                    var req = store.count();
                    req.onsuccess = function() {
                      resolve2(req.result);
                    };
                    req.onerror = function() {
                      reject(req.error);
                    };
                  } catch (e) {
                    reject(e);
                  }
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function key(n, callback) {
            var self2 = this;
            var promise = new Promise$1(function(resolve2, reject) {
              if (n < 0) {
                resolve2(null);
                return;
              }
              self2.ready().then(function() {
                createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                  if (err) {
                    return reject(err);
                  }
                  try {
                    var store = transaction.objectStore(self2._dbInfo.storeName);
                    var advanced = false;
                    var req = store.openKeyCursor();
                    req.onsuccess = function() {
                      var cursor = req.result;
                      if (!cursor) {
                        resolve2(null);
                        return;
                      }
                      if (n === 0) {
                        resolve2(cursor.key);
                      } else {
                        if (!advanced) {
                          advanced = true;
                          cursor.advance(n);
                        } else {
                          resolve2(cursor.key);
                        }
                      }
                    };
                    req.onerror = function() {
                      reject(req.error);
                    };
                  } catch (e) {
                    reject(e);
                  }
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function keys2(callback) {
            var self2 = this;
            var promise = new Promise$1(function(resolve2, reject) {
              self2.ready().then(function() {
                createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                  if (err) {
                    return reject(err);
                  }
                  try {
                    var store = transaction.objectStore(self2._dbInfo.storeName);
                    var req = store.openKeyCursor();
                    var keys3 = [];
                    req.onsuccess = function() {
                      var cursor = req.result;
                      if (!cursor) {
                        resolve2(keys3);
                        return;
                      }
                      keys3.push(cursor.key);
                      cursor["continue"]();
                    };
                    req.onerror = function() {
                      reject(req.error);
                    };
                  } catch (e) {
                    reject(e);
                  }
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function dropInstance(options, callback) {
            callback = getCallback.apply(this, arguments);
            var currentConfig = this.config();
            options = typeof options !== "function" && options || {};
            if (!options.name) {
              options.name = options.name || currentConfig.name;
              options.storeName = options.storeName || currentConfig.storeName;
            }
            var self2 = this;
            var promise;
            if (!options.name) {
              promise = Promise$1.reject("Invalid arguments");
            } else {
              var isCurrentDb = options.name === currentConfig.name && self2._dbInfo.db;
              var dbPromise = isCurrentDb ? Promise$1.resolve(self2._dbInfo.db) : _getOriginalConnection(options).then(function(db) {
                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;
                dbContext.db = db;
                for (var i = 0; i < forages.length; i++) {
                  forages[i]._dbInfo.db = db;
                }
                return db;
              });
              if (!options.storeName) {
                promise = dbPromise.then(function(db) {
                  _deferReadiness(options);
                  var dbContext = dbContexts[options.name];
                  var forages = dbContext.forages;
                  db.close();
                  for (var i = 0; i < forages.length; i++) {
                    var forage = forages[i];
                    forage._dbInfo.db = null;
                  }
                  var dropDBPromise = new Promise$1(function(resolve2, reject) {
                    var req = idb.deleteDatabase(options.name);
                    req.onerror = function() {
                      var db2 = req.result;
                      if (db2) {
                        db2.close();
                      }
                      reject(req.error);
                    };
                    req.onblocked = function() {
                      console.warn('dropInstance blocked for database "' + options.name + '" until all open connections are closed');
                    };
                    req.onsuccess = function() {
                      var db2 = req.result;
                      if (db2) {
                        db2.close();
                      }
                      resolve2(db2);
                    };
                  });
                  return dropDBPromise.then(function(db2) {
                    dbContext.db = db2;
                    for (var i2 = 0; i2 < forages.length; i2++) {
                      var _forage = forages[i2];
                      _advanceReadiness(_forage._dbInfo);
                    }
                  })["catch"](function(err) {
                    (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                    });
                    throw err;
                  });
                });
              } else {
                promise = dbPromise.then(function(db) {
                  if (!db.objectStoreNames.contains(options.storeName)) {
                    return;
                  }
                  var newVersion = db.version + 1;
                  _deferReadiness(options);
                  var dbContext = dbContexts[options.name];
                  var forages = dbContext.forages;
                  db.close();
                  for (var i = 0; i < forages.length; i++) {
                    var forage = forages[i];
                    forage._dbInfo.db = null;
                    forage._dbInfo.version = newVersion;
                  }
                  var dropObjectPromise = new Promise$1(function(resolve2, reject) {
                    var req = idb.open(options.name, newVersion);
                    req.onerror = function(err) {
                      var db2 = req.result;
                      db2.close();
                      reject(err);
                    };
                    req.onupgradeneeded = function() {
                      var db2 = req.result;
                      db2.deleteObjectStore(options.storeName);
                    };
                    req.onsuccess = function() {
                      var db2 = req.result;
                      db2.close();
                      resolve2(db2);
                    };
                  });
                  return dropObjectPromise.then(function(db2) {
                    dbContext.db = db2;
                    for (var j = 0; j < forages.length; j++) {
                      var _forage2 = forages[j];
                      _forage2._dbInfo.db = db2;
                      _advanceReadiness(_forage2._dbInfo);
                    }
                  })["catch"](function(err) {
                    (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                    });
                    throw err;
                  });
                });
              }
            }
            executeCallback(promise, callback);
            return promise;
          }
          var asyncStorage = {
            _driver: "asyncStorage",
            _initStorage,
            _support: isIndexedDBValid(),
            iterate,
            getItem,
            setItem,
            removeItem,
            clear: clear2,
            length,
            key,
            keys: keys2,
            dropInstance
          };
          function isWebSQLValid() {
            return typeof openDatabase === "function";
          }
          var BASE_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          var BLOB_TYPE_PREFIX = "~~local_forage_type~";
          var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
          var SERIALIZED_MARKER = "__lfsc__:";
          var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
          var TYPE_ARRAYBUFFER = "arbf";
          var TYPE_BLOB = "blob";
          var TYPE_INT8ARRAY = "si08";
          var TYPE_UINT8ARRAY = "ui08";
          var TYPE_UINT8CLAMPEDARRAY = "uic8";
          var TYPE_INT16ARRAY = "si16";
          var TYPE_INT32ARRAY = "si32";
          var TYPE_UINT16ARRAY = "ur16";
          var TYPE_UINT32ARRAY = "ui32";
          var TYPE_FLOAT32ARRAY = "fl32";
          var TYPE_FLOAT64ARRAY = "fl64";
          var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
          var toString$1 = Object.prototype.toString;
          function stringToBuffer(serializedString) {
            var bufferLength = serializedString.length * 0.75;
            var len = serializedString.length;
            var i;
            var p2 = 0;
            var encoded1, encoded2, encoded3, encoded4;
            if (serializedString[serializedString.length - 1] === "=") {
              bufferLength--;
              if (serializedString[serializedString.length - 2] === "=") {
                bufferLength--;
              }
            }
            var buffer2 = new ArrayBuffer(bufferLength);
            var bytes = new Uint8Array(buffer2);
            for (i = 0; i < len; i += 4) {
              encoded1 = BASE_CHARS.indexOf(serializedString[i]);
              encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
              encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
              encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);
              bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
              bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
              bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
            }
            return buffer2;
          }
          function bufferToString(buffer2) {
            var bytes = new Uint8Array(buffer2);
            var base64String = "";
            var i;
            for (i = 0; i < bytes.length; i += 3) {
              base64String += BASE_CHARS[bytes[i] >> 2];
              base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
              base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
              base64String += BASE_CHARS[bytes[i + 2] & 63];
            }
            if (bytes.length % 3 === 2) {
              base64String = base64String.substring(0, base64String.length - 1) + "=";
            } else if (bytes.length % 3 === 1) {
              base64String = base64String.substring(0, base64String.length - 2) + "==";
            }
            return base64String;
          }
          function serialize(value, callback) {
            var valueType = "";
            if (value) {
              valueType = toString$1.call(value);
            }
            if (value && (valueType === "[object ArrayBuffer]" || value.buffer && toString$1.call(value.buffer) === "[object ArrayBuffer]")) {
              var buffer2;
              var marker = SERIALIZED_MARKER;
              if (value instanceof ArrayBuffer) {
                buffer2 = value;
                marker += TYPE_ARRAYBUFFER;
              } else {
                buffer2 = value.buffer;
                if (valueType === "[object Int8Array]") {
                  marker += TYPE_INT8ARRAY;
                } else if (valueType === "[object Uint8Array]") {
                  marker += TYPE_UINT8ARRAY;
                } else if (valueType === "[object Uint8ClampedArray]") {
                  marker += TYPE_UINT8CLAMPEDARRAY;
                } else if (valueType === "[object Int16Array]") {
                  marker += TYPE_INT16ARRAY;
                } else if (valueType === "[object Uint16Array]") {
                  marker += TYPE_UINT16ARRAY;
                } else if (valueType === "[object Int32Array]") {
                  marker += TYPE_INT32ARRAY;
                } else if (valueType === "[object Uint32Array]") {
                  marker += TYPE_UINT32ARRAY;
                } else if (valueType === "[object Float32Array]") {
                  marker += TYPE_FLOAT32ARRAY;
                } else if (valueType === "[object Float64Array]") {
                  marker += TYPE_FLOAT64ARRAY;
                } else {
                  callback(new Error("Failed to get type for BinaryArray"));
                }
              }
              callback(marker + bufferToString(buffer2));
            } else if (valueType === "[object Blob]") {
              var fileReader = new FileReader();
              fileReader.onload = function() {
                var str = BLOB_TYPE_PREFIX + value.type + "~" + bufferToString(this.result);
                callback(SERIALIZED_MARKER + TYPE_BLOB + str);
              };
              fileReader.readAsArrayBuffer(value);
            } else {
              try {
                callback(JSON.stringify(value));
              } catch (e) {
                console.error("Couldn't convert value into a JSON string: ", value);
                callback(null, e);
              }
            }
          }
          function deserialize(value) {
            if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
              return JSON.parse(value);
            }
            var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
            var type2 = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
            var blobType;
            if (type2 === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
              var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
              blobType = matcher[1];
              serializedString = serializedString.substring(matcher[0].length);
            }
            var buffer2 = stringToBuffer(serializedString);
            switch (type2) {
              case TYPE_ARRAYBUFFER:
                return buffer2;
              case TYPE_BLOB:
                return createBlob2([buffer2], { type: blobType });
              case TYPE_INT8ARRAY:
                return new Int8Array(buffer2);
              case TYPE_UINT8ARRAY:
                return new Uint8Array(buffer2);
              case TYPE_UINT8CLAMPEDARRAY:
                return new Uint8ClampedArray(buffer2);
              case TYPE_INT16ARRAY:
                return new Int16Array(buffer2);
              case TYPE_UINT16ARRAY:
                return new Uint16Array(buffer2);
              case TYPE_INT32ARRAY:
                return new Int32Array(buffer2);
              case TYPE_UINT32ARRAY:
                return new Uint32Array(buffer2);
              case TYPE_FLOAT32ARRAY:
                return new Float32Array(buffer2);
              case TYPE_FLOAT64ARRAY:
                return new Float64Array(buffer2);
              default:
                throw new Error("Unkown type: " + type2);
            }
          }
          var localforageSerializer = {
            serialize,
            deserialize,
            stringToBuffer,
            bufferToString
          };
          function createDbTable(t, dbInfo, callback, errorCallback) {
            t.executeSql("CREATE TABLE IF NOT EXISTS " + dbInfo.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], callback, errorCallback);
          }
          function _initStorage$1(options) {
            var self2 = this;
            var dbInfo = {
              db: null
            };
            if (options) {
              for (var i in options) {
                dbInfo[i] = typeof options[i] !== "string" ? options[i].toString() : options[i];
              }
            }
            var dbInfoPromise = new Promise$1(function(resolve2, reject) {
              try {
                dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
              } catch (e) {
                return reject(e);
              }
              dbInfo.db.transaction(function(t) {
                createDbTable(t, dbInfo, function() {
                  self2._dbInfo = dbInfo;
                  resolve2();
                }, function(t2, error) {
                  reject(error);
                });
              }, reject);
            });
            dbInfo.serializer = localforageSerializer;
            return dbInfoPromise;
          }
          function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {
            t.executeSql(sqlStatement, args, callback, function(t2, error) {
              if (error.code === error.SYNTAX_ERR) {
                t2.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [dbInfo.storeName], function(t3, results) {
                  if (!results.rows.length) {
                    createDbTable(t3, dbInfo, function() {
                      t3.executeSql(sqlStatement, args, callback, errorCallback);
                    }, errorCallback);
                  } else {
                    errorCallback(t3, error);
                  }
                }, errorCallback);
              } else {
                errorCallback(t2, error);
              }
            }, errorCallback);
          }
          function getItem$1(key2, callback) {
            var self2 = this;
            key2 = normalizeKey2(key2);
            var promise = new Promise$1(function(resolve2, reject) {
              self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                dbInfo.db.transaction(function(t) {
                  tryExecuteSql(t, dbInfo, "SELECT * FROM " + dbInfo.storeName + " WHERE key = ? LIMIT 1", [key2], function(t2, results) {
                    var result = results.rows.length ? results.rows.item(0).value : null;
                    if (result) {
                      result = dbInfo.serializer.deserialize(result);
                    }
                    resolve2(result);
                  }, function(t2, error) {
                    reject(error);
                  });
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function iterate$1(iterator, callback) {
            var self2 = this;
            var promise = new Promise$1(function(resolve2, reject) {
              self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                dbInfo.db.transaction(function(t) {
                  tryExecuteSql(t, dbInfo, "SELECT * FROM " + dbInfo.storeName, [], function(t2, results) {
                    var rows = results.rows;
                    var length2 = rows.length;
                    for (var i = 0; i < length2; i++) {
                      var item = rows.item(i);
                      var result = item.value;
                      if (result) {
                        result = dbInfo.serializer.deserialize(result);
                      }
                      result = iterator(result, item.key, i + 1);
                      if (result !== void 0) {
                        resolve2(result);
                        return;
                      }
                    }
                    resolve2();
                  }, function(t2, error) {
                    reject(error);
                  });
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function _setItem(key2, value, callback, retriesLeft) {
            var self2 = this;
            key2 = normalizeKey2(key2);
            var promise = new Promise$1(function(resolve2, reject) {
              self2.ready().then(function() {
                if (value === void 0) {
                  value = null;
                }
                var originalValue = value;
                var dbInfo = self2._dbInfo;
                dbInfo.serializer.serialize(value, function(value2, error) {
                  if (error) {
                    reject(error);
                  } else {
                    dbInfo.db.transaction(function(t) {
                      tryExecuteSql(t, dbInfo, "INSERT OR REPLACE INTO " + dbInfo.storeName + " (key, value) VALUES (?, ?)", [key2, value2], function() {
                        resolve2(originalValue);
                      }, function(t2, error2) {
                        reject(error2);
                      });
                    }, function(sqlError) {
                      if (sqlError.code === sqlError.QUOTA_ERR) {
                        if (retriesLeft > 0) {
                          resolve2(_setItem.apply(self2, [key2, originalValue, callback, retriesLeft - 1]));
                          return;
                        }
                        reject(sqlError);
                      }
                    });
                  }
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function setItem$1(key2, value, callback) {
            return _setItem.apply(this, [key2, value, callback, 1]);
          }
          function removeItem$1(key2, callback) {
            var self2 = this;
            key2 = normalizeKey2(key2);
            var promise = new Promise$1(function(resolve2, reject) {
              self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                dbInfo.db.transaction(function(t) {
                  tryExecuteSql(t, dbInfo, "DELETE FROM " + dbInfo.storeName + " WHERE key = ?", [key2], function() {
                    resolve2();
                  }, function(t2, error) {
                    reject(error);
                  });
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function clear$1(callback) {
            var self2 = this;
            var promise = new Promise$1(function(resolve2, reject) {
              self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                dbInfo.db.transaction(function(t) {
                  tryExecuteSql(t, dbInfo, "DELETE FROM " + dbInfo.storeName, [], function() {
                    resolve2();
                  }, function(t2, error) {
                    reject(error);
                  });
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function length$1(callback) {
            var self2 = this;
            var promise = new Promise$1(function(resolve2, reject) {
              self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                dbInfo.db.transaction(function(t) {
                  tryExecuteSql(t, dbInfo, "SELECT COUNT(key) as c FROM " + dbInfo.storeName, [], function(t2, results) {
                    var result = results.rows.item(0).c;
                    resolve2(result);
                  }, function(t2, error) {
                    reject(error);
                  });
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function key$1(n, callback) {
            var self2 = this;
            var promise = new Promise$1(function(resolve2, reject) {
              self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                dbInfo.db.transaction(function(t) {
                  tryExecuteSql(t, dbInfo, "SELECT key FROM " + dbInfo.storeName + " WHERE id = ? LIMIT 1", [n + 1], function(t2, results) {
                    var result = results.rows.length ? results.rows.item(0).key : null;
                    resolve2(result);
                  }, function(t2, error) {
                    reject(error);
                  });
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function keys$1(callback) {
            var self2 = this;
            var promise = new Promise$1(function(resolve2, reject) {
              self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                dbInfo.db.transaction(function(t) {
                  tryExecuteSql(t, dbInfo, "SELECT key FROM " + dbInfo.storeName, [], function(t2, results) {
                    var keys3 = [];
                    for (var i = 0; i < results.rows.length; i++) {
                      keys3.push(results.rows.item(i).key);
                    }
                    resolve2(keys3);
                  }, function(t2, error) {
                    reject(error);
                  });
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function getAllStoreNames(db) {
            return new Promise$1(function(resolve2, reject) {
              db.transaction(function(t) {
                t.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(t2, results) {
                  var storeNames = [];
                  for (var i = 0; i < results.rows.length; i++) {
                    storeNames.push(results.rows.item(i).name);
                  }
                  resolve2({
                    db,
                    storeNames
                  });
                }, function(t2, error) {
                  reject(error);
                });
              }, function(sqlError) {
                reject(sqlError);
              });
            });
          }
          function dropInstance$1(options, callback) {
            callback = getCallback.apply(this, arguments);
            var currentConfig = this.config();
            options = typeof options !== "function" && options || {};
            if (!options.name) {
              options.name = options.name || currentConfig.name;
              options.storeName = options.storeName || currentConfig.storeName;
            }
            var self2 = this;
            var promise;
            if (!options.name) {
              promise = Promise$1.reject("Invalid arguments");
            } else {
              promise = new Promise$1(function(resolve2) {
                var db;
                if (options.name === currentConfig.name) {
                  db = self2._dbInfo.db;
                } else {
                  db = openDatabase(options.name, "", "", 0);
                }
                if (!options.storeName) {
                  resolve2(getAllStoreNames(db));
                } else {
                  resolve2({
                    db,
                    storeNames: [options.storeName]
                  });
                }
              }).then(function(operationInfo) {
                return new Promise$1(function(resolve2, reject) {
                  operationInfo.db.transaction(function(t) {
                    function dropTable(storeName) {
                      return new Promise$1(function(resolve3, reject2) {
                        t.executeSql("DROP TABLE IF EXISTS " + storeName, [], function() {
                          resolve3();
                        }, function(t2, error) {
                          reject2(error);
                        });
                      });
                    }
                    var operations = [];
                    for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {
                      operations.push(dropTable(operationInfo.storeNames[i]));
                    }
                    Promise$1.all(operations).then(function() {
                      resolve2();
                    })["catch"](function(e) {
                      reject(e);
                    });
                  }, function(sqlError) {
                    reject(sqlError);
                  });
                });
              });
            }
            executeCallback(promise, callback);
            return promise;
          }
          var webSQLStorage = {
            _driver: "webSQLStorage",
            _initStorage: _initStorage$1,
            _support: isWebSQLValid(),
            iterate: iterate$1,
            getItem: getItem$1,
            setItem: setItem$1,
            removeItem: removeItem$1,
            clear: clear$1,
            length: length$1,
            key: key$1,
            keys: keys$1,
            dropInstance: dropInstance$1
          };
          function isLocalStorageValid() {
            try {
              return typeof localStorage !== "undefined" && "setItem" in localStorage && !!localStorage.setItem;
            } catch (e) {
              return false;
            }
          }
          function _getKeyPrefix(options, defaultConfig) {
            var keyPrefix = options.name + "/";
            if (options.storeName !== defaultConfig.storeName) {
              keyPrefix += options.storeName + "/";
            }
            return keyPrefix;
          }
          function checkIfLocalStorageThrows() {
            var localStorageTestKey = "_localforage_support_test";
            try {
              localStorage.setItem(localStorageTestKey, true);
              localStorage.removeItem(localStorageTestKey);
              return false;
            } catch (e) {
              return true;
            }
          }
          function _isLocalStorageUsable() {
            return !checkIfLocalStorageThrows() || localStorage.length > 0;
          }
          function _initStorage$2(options) {
            var self2 = this;
            var dbInfo = {};
            if (options) {
              for (var i in options) {
                dbInfo[i] = options[i];
              }
            }
            dbInfo.keyPrefix = _getKeyPrefix(options, self2._defaultConfig);
            if (!_isLocalStorageUsable()) {
              return Promise$1.reject();
            }
            self2._dbInfo = dbInfo;
            dbInfo.serializer = localforageSerializer;
            return Promise$1.resolve();
          }
          function clear$2(callback) {
            var self2 = this;
            var promise = self2.ready().then(function() {
              var keyPrefix = self2._dbInfo.keyPrefix;
              for (var i = localStorage.length - 1; i >= 0; i--) {
                var key2 = localStorage.key(i);
                if (key2.indexOf(keyPrefix) === 0) {
                  localStorage.removeItem(key2);
                }
              }
            });
            executeCallback(promise, callback);
            return promise;
          }
          function getItem$2(key2, callback) {
            var self2 = this;
            key2 = normalizeKey2(key2);
            var promise = self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              var result = localStorage.getItem(dbInfo.keyPrefix + key2);
              if (result) {
                result = dbInfo.serializer.deserialize(result);
              }
              return result;
            });
            executeCallback(promise, callback);
            return promise;
          }
          function iterate$2(iterator, callback) {
            var self2 = this;
            var promise = self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              var keyPrefix = dbInfo.keyPrefix;
              var keyPrefixLength = keyPrefix.length;
              var length2 = localStorage.length;
              var iterationNumber = 1;
              for (var i = 0; i < length2; i++) {
                var key2 = localStorage.key(i);
                if (key2.indexOf(keyPrefix) !== 0) {
                  continue;
                }
                var value = localStorage.getItem(key2);
                if (value) {
                  value = dbInfo.serializer.deserialize(value);
                }
                value = iterator(value, key2.substring(keyPrefixLength), iterationNumber++);
                if (value !== void 0) {
                  return value;
                }
              }
            });
            executeCallback(promise, callback);
            return promise;
          }
          function key$2(n, callback) {
            var self2 = this;
            var promise = self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              var result;
              try {
                result = localStorage.key(n);
              } catch (error) {
                result = null;
              }
              if (result) {
                result = result.substring(dbInfo.keyPrefix.length);
              }
              return result;
            });
            executeCallback(promise, callback);
            return promise;
          }
          function keys$2(callback) {
            var self2 = this;
            var promise = self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              var length2 = localStorage.length;
              var keys3 = [];
              for (var i = 0; i < length2; i++) {
                var itemKey = localStorage.key(i);
                if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
                  keys3.push(itemKey.substring(dbInfo.keyPrefix.length));
                }
              }
              return keys3;
            });
            executeCallback(promise, callback);
            return promise;
          }
          function length$2(callback) {
            var self2 = this;
            var promise = self2.keys().then(function(keys3) {
              return keys3.length;
            });
            executeCallback(promise, callback);
            return promise;
          }
          function removeItem$2(key2, callback) {
            var self2 = this;
            key2 = normalizeKey2(key2);
            var promise = self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              localStorage.removeItem(dbInfo.keyPrefix + key2);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function setItem$2(key2, value, callback) {
            var self2 = this;
            key2 = normalizeKey2(key2);
            var promise = self2.ready().then(function() {
              if (value === void 0) {
                value = null;
              }
              var originalValue = value;
              return new Promise$1(function(resolve2, reject) {
                var dbInfo = self2._dbInfo;
                dbInfo.serializer.serialize(value, function(value2, error) {
                  if (error) {
                    reject(error);
                  } else {
                    try {
                      localStorage.setItem(dbInfo.keyPrefix + key2, value2);
                      resolve2(originalValue);
                    } catch (e) {
                      if (e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED") {
                        reject(e);
                      }
                      reject(e);
                    }
                  }
                });
              });
            });
            executeCallback(promise, callback);
            return promise;
          }
          function dropInstance$2(options, callback) {
            callback = getCallback.apply(this, arguments);
            options = typeof options !== "function" && options || {};
            if (!options.name) {
              var currentConfig = this.config();
              options.name = options.name || currentConfig.name;
              options.storeName = options.storeName || currentConfig.storeName;
            }
            var self2 = this;
            var promise;
            if (!options.name) {
              promise = Promise$1.reject("Invalid arguments");
            } else {
              promise = new Promise$1(function(resolve2) {
                if (!options.storeName) {
                  resolve2(options.name + "/");
                } else {
                  resolve2(_getKeyPrefix(options, self2._defaultConfig));
                }
              }).then(function(keyPrefix) {
                for (var i = localStorage.length - 1; i >= 0; i--) {
                  var key2 = localStorage.key(i);
                  if (key2.indexOf(keyPrefix) === 0) {
                    localStorage.removeItem(key2);
                  }
                }
              });
            }
            executeCallback(promise, callback);
            return promise;
          }
          var localStorageWrapper = {
            _driver: "localStorageWrapper",
            _initStorage: _initStorage$2,
            _support: isLocalStorageValid(),
            iterate: iterate$2,
            getItem: getItem$2,
            setItem: setItem$2,
            removeItem: removeItem$2,
            clear: clear$2,
            length: length$2,
            key: key$2,
            keys: keys$2,
            dropInstance: dropInstance$2
          };
          var sameValue = function sameValue2(x, y) {
            return x === y || typeof x === "number" && typeof y === "number" && isNaN(x) && isNaN(y);
          };
          var includes2 = function includes3(array, searchElement) {
            var len = array.length;
            var i = 0;
            while (i < len) {
              if (sameValue(array[i], searchElement)) {
                return true;
              }
              i++;
            }
            return false;
          };
          var isArray2 = Array.isArray || function(arg) {
            return Object.prototype.toString.call(arg) === "[object Array]";
          };
          var DefinedDrivers = {};
          var DriverSupport = {};
          var DefaultDrivers = {
            INDEXEDDB: asyncStorage,
            WEBSQL: webSQLStorage,
            LOCALSTORAGE: localStorageWrapper
          };
          var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];
          var OptionalDriverMethods = ["dropInstance"];
          var LibraryMethods = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(OptionalDriverMethods);
          var DefaultConfig = {
            description: "",
            driver: DefaultDriverOrder.slice(),
            name: "localforage",
            size: 4980736,
            storeName: "keyvaluepairs",
            version: 1
          };
          function callWhenReady(localForageInstance, libraryMethod) {
            localForageInstance[libraryMethod] = function() {
              var _args = arguments;
              return localForageInstance.ready().then(function() {
                return localForageInstance[libraryMethod].apply(localForageInstance, _args);
              });
            };
          }
          function extend3() {
            for (var i = 1; i < arguments.length; i++) {
              var arg = arguments[i];
              if (arg) {
                for (var _key in arg) {
                  if (arg.hasOwnProperty(_key)) {
                    if (isArray2(arg[_key])) {
                      arguments[0][_key] = arg[_key].slice();
                    } else {
                      arguments[0][_key] = arg[_key];
                    }
                  }
                }
              }
            }
            return arguments[0];
          }
          var LocalForage = function() {
            function LocalForage2(options) {
              _classCallCheck(this, LocalForage2);
              for (var driverTypeKey in DefaultDrivers) {
                if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
                  var driver = DefaultDrivers[driverTypeKey];
                  var driverName = driver._driver;
                  this[driverTypeKey] = driverName;
                  if (!DefinedDrivers[driverName]) {
                    this.defineDriver(driver);
                  }
                }
              }
              this._defaultConfig = extend3({}, DefaultConfig);
              this._config = extend3({}, this._defaultConfig, options);
              this._driverSet = null;
              this._initDriver = null;
              this._ready = false;
              this._dbInfo = null;
              this._wrapLibraryMethodsWithReady();
              this.setDriver(this._config.driver)["catch"](function() {
              });
            }
            LocalForage2.prototype.config = function config(options) {
              if ((typeof options === "undefined" ? "undefined" : _typeof(options)) === "object") {
                if (this._ready) {
                  return new Error("Can't call config() after localforage has been used.");
                }
                for (var i in options) {
                  if (i === "storeName") {
                    options[i] = options[i].replace(/\W/g, "_");
                  }
                  if (i === "version" && typeof options[i] !== "number") {
                    return new Error("Database version must be a number.");
                  }
                  this._config[i] = options[i];
                }
                if ("driver" in options && options.driver) {
                  return this.setDriver(this._config.driver);
                }
                return true;
              } else if (typeof options === "string") {
                return this._config[options];
              } else {
                return this._config;
              }
            };
            LocalForage2.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
              var promise = new Promise$1(function(resolve2, reject) {
                try {
                  var driverName = driverObject._driver;
                  var complianceError = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
                  if (!driverObject._driver) {
                    reject(complianceError);
                    return;
                  }
                  var driverMethods = LibraryMethods.concat("_initStorage");
                  for (var i = 0, len = driverMethods.length; i < len; i++) {
                    var driverMethodName = driverMethods[i];
                    var isRequired = !includes2(OptionalDriverMethods, driverMethodName);
                    if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== "function") {
                      reject(complianceError);
                      return;
                    }
                  }
                  var configureMissingMethods = function configureMissingMethods2() {
                    var methodNotImplementedFactory = function methodNotImplementedFactory2(methodName) {
                      return function() {
                        var error = new Error("Method " + methodName + " is not implemented by the current driver");
                        var promise2 = Promise$1.reject(error);
                        executeCallback(promise2, arguments[arguments.length - 1]);
                        return promise2;
                      };
                    };
                    for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                      var optionalDriverMethod = OptionalDriverMethods[_i];
                      if (!driverObject[optionalDriverMethod]) {
                        driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                      }
                    }
                  };
                  configureMissingMethods();
                  var setDriverSupport = function setDriverSupport2(support) {
                    if (DefinedDrivers[driverName]) {
                      console.info("Redefining LocalForage driver: " + driverName);
                    }
                    DefinedDrivers[driverName] = driverObject;
                    DriverSupport[driverName] = support;
                    resolve2();
                  };
                  if ("_support" in driverObject) {
                    if (driverObject._support && typeof driverObject._support === "function") {
                      driverObject._support().then(setDriverSupport, reject);
                    } else {
                      setDriverSupport(!!driverObject._support);
                    }
                  } else {
                    setDriverSupport(true);
                  }
                } catch (e) {
                  reject(e);
                }
              });
              executeTwoCallbacks(promise, callback, errorCallback);
              return promise;
            };
            LocalForage2.prototype.driver = function driver() {
              return this._driver || null;
            };
            LocalForage2.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
              var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error("Driver not found."));
              executeTwoCallbacks(getDriverPromise, callback, errorCallback);
              return getDriverPromise;
            };
            LocalForage2.prototype.getSerializer = function getSerializer(callback) {
              var serializerPromise = Promise$1.resolve(localforageSerializer);
              executeTwoCallbacks(serializerPromise, callback);
              return serializerPromise;
            };
            LocalForage2.prototype.ready = function ready(callback) {
              var self2 = this;
              var promise = self2._driverSet.then(function() {
                if (self2._ready === null) {
                  self2._ready = self2._initDriver();
                }
                return self2._ready;
              });
              executeTwoCallbacks(promise, callback, callback);
              return promise;
            };
            LocalForage2.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
              var self2 = this;
              if (!isArray2(drivers)) {
                drivers = [drivers];
              }
              var supportedDrivers = this._getSupportedDrivers(drivers);
              function setDriverToConfig() {
                self2._config.driver = self2.driver();
              }
              function extendSelfWithDriver(driver) {
                self2._extend(driver);
                setDriverToConfig();
                self2._ready = self2._initStorage(self2._config);
                return self2._ready;
              }
              function initDriver(supportedDrivers2) {
                return function() {
                  var currentDriverIndex = 0;
                  function driverPromiseLoop() {
                    while (currentDriverIndex < supportedDrivers2.length) {
                      var driverName = supportedDrivers2[currentDriverIndex];
                      currentDriverIndex++;
                      self2._dbInfo = null;
                      self2._ready = null;
                      return self2.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                    }
                    setDriverToConfig();
                    var error = new Error("No available storage method found.");
                    self2._driverSet = Promise$1.reject(error);
                    return self2._driverSet;
                  }
                  return driverPromiseLoop();
                };
              }
              var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function() {
                return Promise$1.resolve();
              }) : Promise$1.resolve();
              this._driverSet = oldDriverSetDone.then(function() {
                var driverName = supportedDrivers[0];
                self2._dbInfo = null;
                self2._ready = null;
                return self2.getDriver(driverName).then(function(driver) {
                  self2._driver = driver._driver;
                  setDriverToConfig();
                  self2._wrapLibraryMethodsWithReady();
                  self2._initDriver = initDriver(supportedDrivers);
                });
              })["catch"](function() {
                setDriverToConfig();
                var error = new Error("No available storage method found.");
                self2._driverSet = Promise$1.reject(error);
                return self2._driverSet;
              });
              executeTwoCallbacks(this._driverSet, callback, errorCallback);
              return this._driverSet;
            };
            LocalForage2.prototype.supports = function supports(driverName) {
              return !!DriverSupport[driverName];
            };
            LocalForage2.prototype._extend = function _extend(libraryMethodsAndProperties) {
              extend3(this, libraryMethodsAndProperties);
            };
            LocalForage2.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
              var supportedDrivers = [];
              for (var i = 0, len = drivers.length; i < len; i++) {
                var driverName = drivers[i];
                if (this.supports(driverName)) {
                  supportedDrivers.push(driverName);
                }
              }
              return supportedDrivers;
            };
            LocalForage2.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
              for (var i = 0, len = LibraryMethods.length; i < len; i++) {
                callWhenReady(this, LibraryMethods[i]);
              }
            };
            LocalForage2.prototype.createInstance = function createInstance2(options) {
              return new LocalForage2(options);
            };
            return LocalForage2;
          }();
          var localforage_js = new LocalForage();
          module3.exports = localforage_js;
        }, { "3": 3 }] }, {}, [4])(4);
      });
    }
  });

  // ../library_management/node_modules/@vue/shared/dist/shared.esm-bundler.js
  function makeMap(str, expectsLowerCase) {
    const set3 = new Set(str.split(","));
    return expectsLowerCase ? (val) => set3.has(val.toLowerCase()) : (val) => set3.has(val);
  }
  var EMPTY_OBJ = true ? Object.freeze({}) : {};
  var EMPTY_ARR = true ? Object.freeze([]) : [];
  var NOOP = () => {
  };
  var NO = () => false;
  var isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
  var isModelListener = (key) => key.startsWith("onUpdate:");
  var extend = Object.assign;
  var remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
      arr.splice(i, 1);
    }
  };
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  var hasOwn = (val, key) => hasOwnProperty2.call(val, key);
  var isArray = Array.isArray;
  var isMap = (val) => toTypeString(val) === "[object Map]";
  var isSet = (val) => toTypeString(val) === "[object Set]";
  var isFunction = (val) => typeof val === "function";
  var isString = (val) => typeof val === "string";
  var isSymbol = (val) => typeof val === "symbol";
  var isObject = (val) => val !== null && typeof val === "object";
  var isPromise = (val) => {
    return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
  };
  var objectToString = Object.prototype.toString;
  var toTypeString = (value) => objectToString.call(value);
  var toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  var isPlainObject = (val) => toTypeString(val) === "[object Object]";
  var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  var isReservedProp = /* @__PURE__ */ makeMap(
    ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
  );
  var isBuiltInDirective = /* @__PURE__ */ makeMap(
    "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
  );
  var cacheStringFunction = (fn) => {
    const cache = /* @__PURE__ */ Object.create(null);
    return (str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  };
  var camelizeRE = /-(\w)/g;
  var camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
  });
  var hyphenateRE = /\B([A-Z])/g;
  var hyphenate = cacheStringFunction(
    (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
  );
  var capitalize = cacheStringFunction((str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
  });
  var toHandlerKey = cacheStringFunction((str) => {
    const s = str ? `on${capitalize(str)}` : ``;
    return s;
  });
  var hasChanged = (value, oldValue) => !Object.is(value, oldValue);
  var invokeArrayFns = (fns, arg) => {
    for (let i = 0; i < fns.length; i++) {
      fns[i](arg);
    }
  };
  var def = (obj, key, value) => {
    Object.defineProperty(obj, key, {
      configurable: true,
      enumerable: false,
      value
    });
  };
  var looseToNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
  };
  var toNumber = (val) => {
    const n = isString(val) ? Number(val) : NaN;
    return isNaN(n) ? val : n;
  };
  var _globalThis;
  var getGlobalThis = () => {
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };
  function normalizeStyle(value) {
    if (isArray(value)) {
      const res = {};
      for (let i = 0; i < value.length; i++) {
        const item = value[i];
        const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
        if (normalized) {
          for (const key in normalized) {
            res[key] = normalized[key];
          }
        }
      }
      return res;
    } else if (isString(value) || isObject(value)) {
      return value;
    }
  }
  var listDelimiterRE = /;(?![^(]*\))/g;
  var propertyDelimiterRE = /:([^]+)/;
  var styleCommentRE = /\/\*[^]*?\*\//g;
  function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
      if (item) {
        const tmp = item.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }
  function normalizeClass(value) {
    let res = "";
    if (isString(value)) {
      res = value;
    } else if (isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        const normalized = normalizeClass(value[i]);
        if (normalized) {
          res += normalized + " ";
        }
      }
    } else if (isObject(value)) {
      for (const name in value) {
        if (value[name]) {
          res += name + " ";
        }
      }
    }
    return res.trim();
  }
  var HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
  var SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
  var MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
  var isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
  var isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
  var isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
  var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  var isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
  var isBooleanAttr = /* @__PURE__ */ makeMap(
    specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`
  );
  function includeBooleanAttr(value) {
    return !!value || value === "";
  }
  var toDisplayString = (val) => {
    return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
  };
  var replacer = (_key, val) => {
    if (val && val.__v_isRef) {
      return replacer(_key, val.value);
    } else if (isMap(val)) {
      return {
        [`Map(${val.size})`]: [...val.entries()].reduce(
          (entries, [key, val2], i) => {
            entries[stringifySymbol(key, i) + " =>"] = val2;
            return entries;
          },
          {}
        )
      };
    } else if (isSet(val)) {
      return {
        [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
      };
    } else if (isSymbol(val)) {
      return stringifySymbol(val);
    } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
      return String(val);
    }
    return val;
  };
  var stringifySymbol = (v, i = "") => {
    var _a2;
    return isSymbol(v) ? `Symbol(${(_a2 = v.description) != null ? _a2 : i})` : v;
  };

  // ../library_management/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js
  function warn(msg, ...args) {
    console.warn(`[Vue warn] ${msg}`, ...args);
  }
  var activeEffectScope;
  var EffectScope = class {
    constructor(detached = false) {
      this.detached = detached;
      this._active = true;
      this.effects = [];
      this.cleanups = [];
      this.parent = activeEffectScope;
      if (!detached && activeEffectScope) {
        this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
          this
        ) - 1;
      }
    }
    get active() {
      return this._active;
    }
    run(fn) {
      if (this._active) {
        const currentEffectScope = activeEffectScope;
        try {
          activeEffectScope = this;
          return fn();
        } finally {
          activeEffectScope = currentEffectScope;
        }
      } else if (true) {
        warn(`cannot run an inactive effect scope.`);
      }
    }
    on() {
      activeEffectScope = this;
    }
    off() {
      activeEffectScope = this.parent;
    }
    stop(fromParent) {
      if (this._active) {
        let i, l;
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].stop();
        }
        for (i = 0, l = this.cleanups.length; i < l; i++) {
          this.cleanups[i]();
        }
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].stop(true);
          }
        }
        if (!this.detached && this.parent && !fromParent) {
          const last = this.parent.scopes.pop();
          if (last && last !== this) {
            this.parent.scopes[this.index] = last;
            last.index = this.index;
          }
        }
        this.parent = void 0;
        this._active = false;
      }
    }
  };
  function effectScope(detached) {
    return new EffectScope(detached);
  }
  function recordEffectScope(effect2, scope = activeEffectScope) {
    if (scope && scope.active) {
      scope.effects.push(effect2);
    }
  }
  function getCurrentScope() {
    return activeEffectScope;
  }
  function onScopeDispose(fn) {
    if (activeEffectScope) {
      activeEffectScope.cleanups.push(fn);
    } else if (true) {
      warn(
        `onScopeDispose() is called when there is no active effect scope to be associated with.`
      );
    }
  }
  var activeEffect;
  var ReactiveEffect = class {
    constructor(fn, trigger2, scheduler, scope) {
      this.fn = fn;
      this.trigger = trigger2;
      this.scheduler = scheduler;
      this.active = true;
      this.deps = [];
      this._dirtyLevel = 4;
      this._trackId = 0;
      this._runnings = 0;
      this._shouldSchedule = false;
      this._depsLength = 0;
      recordEffectScope(this, scope);
    }
    get dirty() {
      if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
        this._dirtyLevel = 1;
        pauseTracking();
        for (let i = 0; i < this._depsLength; i++) {
          const dep = this.deps[i];
          if (dep.computed) {
            triggerComputed(dep.computed);
            if (this._dirtyLevel >= 4) {
              break;
            }
          }
        }
        if (this._dirtyLevel === 1) {
          this._dirtyLevel = 0;
        }
        resetTracking();
      }
      return this._dirtyLevel >= 4;
    }
    set dirty(v) {
      this._dirtyLevel = v ? 4 : 0;
    }
    run() {
      this._dirtyLevel = 0;
      if (!this.active) {
        return this.fn();
      }
      let lastShouldTrack = shouldTrack;
      let lastEffect = activeEffect;
      try {
        shouldTrack = true;
        activeEffect = this;
        this._runnings++;
        preCleanupEffect(this);
        return this.fn();
      } finally {
        postCleanupEffect(this);
        this._runnings--;
        activeEffect = lastEffect;
        shouldTrack = lastShouldTrack;
      }
    }
    stop() {
      var _a2;
      if (this.active) {
        preCleanupEffect(this);
        postCleanupEffect(this);
        (_a2 = this.onStop) == null ? void 0 : _a2.call(this);
        this.active = false;
      }
    }
  };
  function triggerComputed(computed3) {
    return computed3.value;
  }
  function preCleanupEffect(effect2) {
    effect2._trackId++;
    effect2._depsLength = 0;
  }
  function postCleanupEffect(effect2) {
    if (effect2.deps.length > effect2._depsLength) {
      for (let i = effect2._depsLength; i < effect2.deps.length; i++) {
        cleanupDepEffect(effect2.deps[i], effect2);
      }
      effect2.deps.length = effect2._depsLength;
    }
  }
  function cleanupDepEffect(dep, effect2) {
    const trackId = dep.get(effect2);
    if (trackId !== void 0 && effect2._trackId !== trackId) {
      dep.delete(effect2);
      if (dep.size === 0) {
        dep.cleanup();
      }
    }
  }
  var shouldTrack = true;
  var pauseScheduleStack = 0;
  var trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
  }
  function pauseScheduling() {
    pauseScheduleStack++;
  }
  function resetScheduling() {
    pauseScheduleStack--;
    while (!pauseScheduleStack && queueEffectSchedulers.length) {
      queueEffectSchedulers.shift()();
    }
  }
  function trackEffect(effect2, dep, debuggerEventExtraInfo) {
    var _a2;
    if (dep.get(effect2) !== effect2._trackId) {
      dep.set(effect2, effect2._trackId);
      const oldDep = effect2.deps[effect2._depsLength];
      if (oldDep !== dep) {
        if (oldDep) {
          cleanupDepEffect(oldDep, effect2);
        }
        effect2.deps[effect2._depsLength++] = dep;
      } else {
        effect2._depsLength++;
      }
      if (true) {
        (_a2 = effect2.onTrack) == null ? void 0 : _a2.call(effect2, extend({ effect: effect2 }, debuggerEventExtraInfo));
      }
    }
  }
  var queueEffectSchedulers = [];
  function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
    var _a2;
    pauseScheduling();
    for (const effect2 of dep.keys()) {
      let tracking;
      if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
        effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);
        effect2._dirtyLevel = dirtyLevel;
      }
      if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
        if (true) {
          (_a2 = effect2.onTrigger) == null ? void 0 : _a2.call(effect2, extend({ effect: effect2 }, debuggerEventExtraInfo));
        }
        effect2.trigger();
        if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {
          effect2._shouldSchedule = false;
          if (effect2.scheduler) {
            queueEffectSchedulers.push(effect2.scheduler);
          }
        }
      }
    }
    resetScheduling();
  }
  var createDep = (cleanup, computed3) => {
    const dep = /* @__PURE__ */ new Map();
    dep.cleanup = cleanup;
    dep.computed = computed3;
    return dep;
  };
  var targetMap = /* @__PURE__ */ new WeakMap();
  var ITERATE_KEY = Symbol(true ? "iterate" : "");
  var MAP_KEY_ITERATE_KEY = Symbol(true ? "Map key iterate" : "");
  function track(target, type2, key) {
    if (shouldTrack && activeEffect) {
      let depsMap = targetMap.get(target);
      if (!depsMap) {
        targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
      }
      let dep = depsMap.get(key);
      if (!dep) {
        depsMap.set(key, dep = createDep(() => depsMap.delete(key)));
      }
      trackEffect(
        activeEffect,
        dep,
        true ? {
          target,
          type: type2,
          key
        } : void 0
      );
    }
  }
  function trigger(target, type2, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      return;
    }
    let deps = [];
    if (type2 === "clear") {
      deps = [...depsMap.values()];
    } else if (key === "length" && isArray(target)) {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || !isSymbol(key2) && key2 >= newLength) {
          deps.push(dep);
        }
      });
    } else {
      if (key !== void 0) {
        deps.push(depsMap.get(key));
      }
      switch (type2) {
        case "add":
          if (!isArray(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isIntegerKey(key)) {
            deps.push(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!isArray(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
    pauseScheduling();
    for (const dep of deps) {
      if (dep) {
        triggerEffects(
          dep,
          4,
          true ? {
            target,
            type: type2,
            key,
            newValue,
            oldValue,
            oldTarget
          } : void 0
        );
      }
    }
    resetScheduling();
  }
  function getDepFromReactive(object, key) {
    var _a2;
    return (_a2 = targetMap.get(object)) == null ? void 0 : _a2.get(key);
  }
  var isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
  var builtInSymbols = new Set(
    /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
  );
  var arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
  function createArrayInstrumentations() {
    const instrumentations = {};
    ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
      instrumentations[key] = function(...args) {
        const arr = toRaw(this);
        for (let i = 0, l = this.length; i < l; i++) {
          track(arr, "get", i + "");
        }
        const res = arr[key](...args);
        if (res === -1 || res === false) {
          return arr[key](...args.map(toRaw));
        } else {
          return res;
        }
      };
    });
    ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
      instrumentations[key] = function(...args) {
        pauseTracking();
        pauseScheduling();
        const res = toRaw(this)[key].apply(this, args);
        resetScheduling();
        resetTracking();
        return res;
      };
    });
    return instrumentations;
  }
  function hasOwnProperty3(key) {
    const obj = toRaw(this);
    track(obj, "has", key);
    return obj.hasOwnProperty(key);
  }
  var BaseReactiveHandler = class {
    constructor(_isReadonly = false, _isShallow = false) {
      this._isReadonly = _isReadonly;
      this._isShallow = _isShallow;
    }
    get(target, key, receiver) {
      const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_isShallow") {
        return isShallow2;
      } else if (key === "__v_raw") {
        if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
          return target;
        }
        return;
      }
      const targetIsArray = isArray(target);
      if (!isReadonly2) {
        if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
          return Reflect.get(arrayInstrumentations, key, receiver);
        }
        if (key === "hasOwnProperty") {
          return hasOwnProperty3;
        }
      }
      const res = Reflect.get(target, key, receiver);
      if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly2) {
        track(target, "get", key);
      }
      if (isShallow2) {
        return res;
      }
      if (isRef(res)) {
        return targetIsArray && isIntegerKey(key) ? res : res.value;
      }
      if (isObject(res)) {
        return isReadonly2 ? readonly(res) : reactive(res);
      }
      return res;
    }
  };
  var MutableReactiveHandler = class extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(false, isShallow2);
    }
    set(target, key, value, receiver) {
      let oldValue = target[key];
      if (!this._isShallow) {
        const isOldValueReadonly = isReadonly(oldValue);
        if (!isShallow(value) && !isReadonly(value)) {
          oldValue = toRaw(oldValue);
          value = toRaw(value);
        }
        if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
          if (isOldValueReadonly) {
            return false;
          } else {
            oldValue.value = value;
            return true;
          }
        }
      }
      const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
      const result = Reflect.set(target, key, value, receiver);
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
      }
      return result;
    }
    deleteProperty(target, key) {
      const hadKey = hasOwn(target, key);
      const oldValue = target[key];
      const result = Reflect.deleteProperty(target, key);
      if (result && hadKey) {
        trigger(target, "delete", key, void 0, oldValue);
      }
      return result;
    }
    has(target, key) {
      const result = Reflect.has(target, key);
      if (!isSymbol(key) || !builtInSymbols.has(key)) {
        track(target, "has", key);
      }
      return result;
    }
    ownKeys(target) {
      track(
        target,
        "iterate",
        isArray(target) ? "length" : ITERATE_KEY
      );
      return Reflect.ownKeys(target);
    }
  };
  var ReadonlyReactiveHandler = class extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(true, isShallow2);
    }
    set(target, key) {
      if (true) {
        warn(
          `Set operation on key "${String(key)}" failed: target is readonly.`,
          target
        );
      }
      return true;
    }
    deleteProperty(target, key) {
      if (true) {
        warn(
          `Delete operation on key "${String(key)}" failed: target is readonly.`,
          target
        );
      }
      return true;
    }
  };
  var mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
  var readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
  var shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
    true
  );
  var shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
  var toShallow = (value) => value;
  var getProto = (v) => Reflect.getPrototypeOf(v);
  function get(target, key, isReadonly2 = false, isShallow2 = false) {
    target = target["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly2) {
      if (hasChanged(key, rawKey)) {
        track(rawTarget, "get", key);
      }
      track(rawTarget, "get", rawKey);
    }
    const { has: has22 } = getProto(rawTarget);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    if (has22.call(rawTarget, key)) {
      return wrap(target.get(key));
    } else if (has22.call(rawTarget, rawKey)) {
      return wrap(target.get(rawKey));
    } else if (target !== rawTarget) {
      target.get(key);
    }
  }
  function has(key, isReadonly2 = false) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly2) {
      if (hasChanged(key, rawKey)) {
        track(rawTarget, "has", key);
      }
      track(rawTarget, "has", rawKey);
    }
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
  }
  function size(target, isReadonly2 = false) {
    target = target["__v_raw"];
    !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
  }
  function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
      target.add(value);
      trigger(target, "add", value, value);
    }
    return this;
  }
  function set(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has: has22, get: get2 } = getProto(target);
    let hadKey = has22.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has22.call(target, key);
    } else if (true) {
      checkIdentityKeys(target, has22, key);
    }
    const oldValue = get2.call(target, key);
    target.set(key, value);
    if (!hadKey) {
      trigger(target, "add", key, value);
    } else if (hasChanged(value, oldValue)) {
      trigger(target, "set", key, value, oldValue);
    }
    return this;
  }
  function deleteEntry(key) {
    const target = toRaw(this);
    const { has: has22, get: get2 } = getProto(target);
    let hadKey = has22.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has22.call(target, key);
    } else if (true) {
      checkIdentityKeys(target, has22, key);
    }
    const oldValue = get2 ? get2.call(target, key) : void 0;
    const result = target.delete(key);
    if (hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = true ? isMap(target) ? new Map(target) : new Set(target) : void 0;
    const result = target.clear();
    if (hadItems) {
      trigger(target, "clear", void 0, void 0, oldTarget);
    }
    return result;
  }
  function createForEach(isReadonly2, isShallow2) {
    return function forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    };
  }
  function createIterableMethod(method, isReadonly2, isShallow2) {
    return function(...args) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(
        rawTarget,
        "iterate",
        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
      );
      return {
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type2) {
    return function(...args) {
      if (true) {
        const key = args[0] ? `on key "${args[0]}" ` : ``;
        warn(
          `${capitalize(type2)} operation ${key}failed: target is readonly.`,
          toRaw(this)
        );
      }
      return type2 === "delete" ? false : type2 === "clear" ? void 0 : this;
    };
  }
  function createInstrumentations() {
    const mutableInstrumentations2 = {
      get(key) {
        return get(this, key);
      },
      get size() {
        return size(this);
      },
      has,
      add,
      set,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, false)
    };
    const shallowInstrumentations2 = {
      get(key) {
        return get(this, key, false, true);
      },
      get size() {
        return size(this);
      },
      has,
      add,
      set,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, true)
    };
    const readonlyInstrumentations2 = {
      get(key) {
        return get(this, key, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has.call(this, key, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations2 = {
      get(key) {
        return get(this, key, true, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has.call(this, key, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, true)
    };
    const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
    iteratorMethods.forEach((method) => {
      mutableInstrumentations2[method] = createIterableMethod(
        method,
        false,
        false
      );
      readonlyInstrumentations2[method] = createIterableMethod(
        method,
        true,
        false
      );
      shallowInstrumentations2[method] = createIterableMethod(
        method,
        false,
        true
      );
      shallowReadonlyInstrumentations2[method] = createIterableMethod(
        method,
        true,
        true
      );
    });
    return [
      mutableInstrumentations2,
      readonlyInstrumentations2,
      shallowInstrumentations2,
      shallowReadonlyInstrumentations2
    ];
  }
  var [
    mutableInstrumentations,
    readonlyInstrumentations,
    shallowInstrumentations,
    shallowReadonlyInstrumentations
  ] = /* @__PURE__ */ createInstrumentations();
  function createInstrumentationGetter(isReadonly2, shallow) {
    const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(
        hasOwn(instrumentations, key) && key in target ? instrumentations : target,
        key,
        receiver
      );
    };
  }
  var mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
  };
  var shallowCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, true)
  };
  var readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
  };
  var shallowReadonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, true)
  };
  function checkIdentityKeys(target, has22, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has22.call(target, rawKey)) {
      const type2 = toRawType(target);
      warn(
        `Reactive ${type2} contains both the raw and reactive versions of the same object${type2 === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
      );
    }
  }
  var reactiveMap = /* @__PURE__ */ new WeakMap();
  var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
  var readonlyMap = /* @__PURE__ */ new WeakMap();
  var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive(target) {
    if (isReadonly(target)) {
      return target;
    }
    return createReactiveObject(
      target,
      false,
      mutableHandlers,
      mutableCollectionHandlers,
      reactiveMap
    );
  }
  function shallowReactive(target) {
    return createReactiveObject(
      target,
      false,
      shallowReactiveHandlers,
      shallowCollectionHandlers,
      shallowReactiveMap
    );
  }
  function readonly(target) {
    return createReactiveObject(
      target,
      true,
      readonlyHandlers,
      readonlyCollectionHandlers,
      readonlyMap
    );
  }
  function shallowReadonly(target) {
    return createReactiveObject(
      target,
      true,
      shallowReadonlyHandlers,
      shallowReadonlyCollectionHandlers,
      shallowReadonlyMap
    );
  }
  function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject(target)) {
      if (true) {
        warn(`value cannot be made reactive: ${String(target)}`);
      }
      return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const proxy = new Proxy(
      target,
      targetType === 2 ? collectionHandlers : baseHandlers
    );
    proxyMap.set(target, proxy);
    return proxy;
  }
  function isReactive(value) {
    if (isReadonly(value)) {
      return isReactive(value["__v_raw"]);
    }
    return !!(value && value["__v_isReactive"]);
  }
  function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
  }
  function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
  }
  function isProxy(value) {
    return isReactive(value) || isReadonly(value);
  }
  function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
  }
  function markRaw(value) {
    if (Object.isExtensible(value)) {
      def(value, "__v_skip", true);
    }
    return value;
  }
  var toReactive = (value) => isObject(value) ? reactive(value) : value;
  var toReadonly = (value) => isObject(value) ? readonly(value) : value;
  var COMPUTED_SIDE_EFFECT_WARN = `Computed is still dirty after getter evaluation, likely because a computed is mutating its own dependency in its getter. State mutations in computed getters should be avoided.  Check the docs for more details: https://vuejs.org/guide/essentials/computed.html#getters-should-be-side-effect-free`;
  var ComputedRefImpl = class {
    constructor(getter, _setter, isReadonly2, isSSR) {
      this.getter = getter;
      this._setter = _setter;
      this.dep = void 0;
      this.__v_isRef = true;
      this["__v_isReadonly"] = false;
      this.effect = new ReactiveEffect(
        () => getter(this._value),
        () => triggerRefValue(
          this,
          this.effect._dirtyLevel === 2 ? 2 : 3
        )
      );
      this.effect.computed = this;
      this.effect.active = this._cacheable = !isSSR;
      this["__v_isReadonly"] = isReadonly2;
    }
    get value() {
      const self2 = toRaw(this);
      if ((!self2._cacheable || self2.effect.dirty) && hasChanged(self2._value, self2._value = self2.effect.run())) {
        triggerRefValue(self2, 4);
      }
      trackRefValue(self2);
      if (self2.effect._dirtyLevel >= 2) {
        if (this._warnRecursive) {
          warn(COMPUTED_SIDE_EFFECT_WARN, `

getter: `, this.getter);
        }
        triggerRefValue(self2, 2);
      }
      return self2._value;
    }
    set value(newValue) {
      this._setter(newValue);
    }
    get _dirty() {
      return this.effect.dirty;
    }
    set _dirty(v) {
      this.effect.dirty = v;
    }
  };
  function computed(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    const onlyGetter = isFunction(getterOrOptions);
    if (onlyGetter) {
      getter = getterOrOptions;
      setter = true ? () => {
        warn("Write operation failed: computed value is readonly");
      } : NOOP;
    } else {
      getter = getterOrOptions.get;
      setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
    if (debugOptions && !isSSR) {
      cRef.effect.onTrack = debugOptions.onTrack;
      cRef.effect.onTrigger = debugOptions.onTrigger;
    }
    return cRef;
  }
  function trackRefValue(ref2) {
    var _a2;
    if (shouldTrack && activeEffect) {
      ref2 = toRaw(ref2);
      trackEffect(
        activeEffect,
        (_a2 = ref2.dep) != null ? _a2 : ref2.dep = createDep(
          () => ref2.dep = void 0,
          ref2 instanceof ComputedRefImpl ? ref2 : void 0
        ),
        true ? {
          target: ref2,
          type: "get",
          key: "value"
        } : void 0
      );
    }
  }
  function triggerRefValue(ref2, dirtyLevel = 4, newVal) {
    ref2 = toRaw(ref2);
    const dep = ref2.dep;
    if (dep) {
      triggerEffects(
        dep,
        dirtyLevel,
        true ? {
          target: ref2,
          type: "set",
          key: "value",
          newValue: newVal
        } : void 0
      );
    }
  }
  function isRef(r) {
    return !!(r && r.__v_isRef === true);
  }
  function ref(value) {
    return createRef(value, false);
  }
  function shallowRef(value) {
    return createRef(value, true);
  }
  function createRef(rawValue, shallow) {
    if (isRef(rawValue)) {
      return rawValue;
    }
    return new RefImpl(rawValue, shallow);
  }
  var RefImpl = class {
    constructor(value, __v_isShallow) {
      this.__v_isShallow = __v_isShallow;
      this.dep = void 0;
      this.__v_isRef = true;
      this._rawValue = __v_isShallow ? value : toRaw(value);
      this._value = __v_isShallow ? value : toReactive(value);
    }
    get value() {
      trackRefValue(this);
      return this._value;
    }
    set value(newVal) {
      const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
      newVal = useDirectValue ? newVal : toRaw(newVal);
      if (hasChanged(newVal, this._rawValue)) {
        this._rawValue = newVal;
        this._value = useDirectValue ? newVal : toReactive(newVal);
        triggerRefValue(this, 4, newVal);
      }
    }
  };
  function unref(ref2) {
    return isRef(ref2) ? ref2.value : ref2;
  }
  var shallowUnwrapHandlers = {
    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver) => {
      const oldValue = target[key];
      if (isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      } else {
        return Reflect.set(target, key, value, receiver);
      }
    }
  };
  function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
  }
  function toRefs(object) {
    if (!isProxy(object)) {
      warn(`toRefs() expects a reactive object but received a plain one.`);
    }
    const ret = isArray(object) ? new Array(object.length) : {};
    for (const key in object) {
      ret[key] = propertyToRef(object, key);
    }
    return ret;
  }
  var ObjectRefImpl = class {
    constructor(_object, _key, _defaultValue) {
      this._object = _object;
      this._key = _key;
      this._defaultValue = _defaultValue;
      this.__v_isRef = true;
    }
    get value() {
      const val = this._object[this._key];
      return val === void 0 ? this._defaultValue : val;
    }
    set value(newVal) {
      this._object[this._key] = newVal;
    }
    get dep() {
      return getDepFromReactive(toRaw(this._object), this._key);
    }
  };
  var GetterRefImpl = class {
    constructor(_getter) {
      this._getter = _getter;
      this.__v_isRef = true;
      this.__v_isReadonly = true;
    }
    get value() {
      return this._getter();
    }
  };
  function toRef(source, key, defaultValue2) {
    if (isRef(source)) {
      return source;
    } else if (isFunction(source)) {
      return new GetterRefImpl(source);
    } else if (isObject(source) && arguments.length > 1) {
      return propertyToRef(source, key, defaultValue2);
    } else {
      return ref(source);
    }
  }
  function propertyToRef(source, key, defaultValue2) {
    const val = source[key];
    return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue2);
  }

  // ../library_management/node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js
  var stack = [];
  function pushWarningContext(vnode) {
    stack.push(vnode);
  }
  function popWarningContext() {
    stack.pop();
  }
  function warn$1(msg, ...args) {
    pauseTracking();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
      callWithErrorHandling(
        appWarnHandler,
        instance,
        11,
        [
          msg + args.map((a) => {
            var _a2, _b;
            return (_b = (_a2 = a.toString) == null ? void 0 : _a2.call(a)) != null ? _b : JSON.stringify(a);
          }).join(""),
          instance && instance.proxy,
          trace.map(
            ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
          ).join("\n"),
          trace
        ]
      );
    } else {
      const warnArgs = [`[Vue warn]: ${msg}`, ...args];
      if (trace.length && true) {
        warnArgs.push(`
`, ...formatTrace(trace));
      }
      console.warn(...warnArgs);
    }
    resetTracking();
  }
  function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
      return [];
    }
    const normalizedStack = [];
    while (currentVNode) {
      const last = normalizedStack[0];
      if (last && last.vnode === currentVNode) {
        last.recurseCount++;
      } else {
        normalizedStack.push({
          vnode: currentVNode,
          recurseCount: 0
        });
      }
      const parentInstance = currentVNode.component && currentVNode.component.parent;
      currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
  }
  function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i) => {
      logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
    });
    return logs;
  }
  function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open2 = ` at <${formatComponentName(
      vnode.component,
      vnode.type,
      isRoot
    )}`;
    const close = `>` + postfix;
    return vnode.props ? [open2, ...formatProps(vnode.props), close] : [open2 + close];
  }
  function formatProps(props) {
    const res = [];
    const keys2 = Object.keys(props);
    keys2.slice(0, 3).forEach((key) => {
      res.push(...formatProp(key, props[key]));
    });
    if (keys2.length > 3) {
      res.push(` ...`);
    }
    return res;
  }
  function formatProp(key, value, raw) {
    if (isString(value)) {
      value = JSON.stringify(value);
      return raw ? value : [`${key}=${value}`];
    } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
      return raw ? value : [`${key}=${value}`];
    } else if (isRef(value)) {
      value = formatProp(key, toRaw(value.value), true);
      return raw ? value : [`${key}=Ref<`, value, `>`];
    } else if (isFunction(value)) {
      return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    } else {
      value = toRaw(value);
      return raw ? value : [`${key}=`, value];
    }
  }
  function assertNumber(val, type2) {
    if (false)
      return;
    if (val === void 0) {
      return;
    } else if (typeof val !== "number") {
      warn$1(`${type2} is not a valid number - got ${JSON.stringify(val)}.`);
    } else if (isNaN(val)) {
      warn$1(`${type2} is NaN - the duration expression might be incorrect.`);
    }
  }
  var ErrorTypeStrings$1 = {
    ["sp"]: "serverPrefetch hook",
    ["bc"]: "beforeCreate hook",
    ["c"]: "created hook",
    ["bm"]: "beforeMount hook",
    ["m"]: "mounted hook",
    ["bu"]: "beforeUpdate hook",
    ["u"]: "updated",
    ["bum"]: "beforeUnmount hook",
    ["um"]: "unmounted hook",
    ["a"]: "activated hook",
    ["da"]: "deactivated hook",
    ["ec"]: "errorCaptured hook",
    ["rtc"]: "renderTracked hook",
    ["rtg"]: "renderTriggered hook",
    [0]: "setup function",
    [1]: "render function",
    [2]: "watcher getter",
    [3]: "watcher callback",
    [4]: "watcher cleanup function",
    [5]: "native event handler",
    [6]: "component event handler",
    [7]: "vnode hook",
    [8]: "directive hook",
    [9]: "transition hook",
    [10]: "app errorHandler",
    [11]: "app warnHandler",
    [12]: "ref function",
    [13]: "async component loader",
    [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://github.com/vuejs/core ."
  };
  function callWithErrorHandling(fn, instance, type2, args) {
    try {
      return args ? fn(...args) : fn();
    } catch (err) {
      handleError(err, instance, type2);
    }
  }
  function callWithAsyncErrorHandling(fn, instance, type2, args) {
    if (isFunction(fn)) {
      const res = callWithErrorHandling(fn, instance, type2, args);
      if (res && isPromise(res)) {
        res.catch((err) => {
          handleError(err, instance, type2);
        });
      }
      return res;
    }
    const values = [];
    for (let i = 0; i < fn.length; i++) {
      values.push(callWithAsyncErrorHandling(fn[i], instance, type2, args));
    }
    return values;
  }
  function handleError(err, instance, type2, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    if (instance) {
      let cur = instance.parent;
      const exposedInstance = instance.proxy;
      const errorInfo = true ? ErrorTypeStrings$1[type2] : `https://vuejs.org/error-reference/#runtime-${type2}`;
      while (cur) {
        const errorCapturedHooks = cur.ec;
        if (errorCapturedHooks) {
          for (let i = 0; i < errorCapturedHooks.length; i++) {
            if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
              return;
            }
          }
        }
        cur = cur.parent;
      }
      const appErrorHandler = instance.appContext.config.errorHandler;
      if (appErrorHandler) {
        callWithErrorHandling(
          appErrorHandler,
          null,
          10,
          [err, exposedInstance, errorInfo]
        );
        return;
      }
    }
    logError(err, type2, contextVNode, throwInDev);
  }
  function logError(err, type2, contextVNode, throwInDev = true) {
    if (true) {
      const info = ErrorTypeStrings$1[type2];
      if (contextVNode) {
        pushWarningContext(contextVNode);
      }
      warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
      if (contextVNode) {
        popWarningContext();
      }
      if (throwInDev) {
        throw err;
      } else {
        console.error(err);
      }
    } else {
      console.error(err);
    }
  }
  var isFlushing = false;
  var isFlushPending = false;
  var queue = [];
  var flushIndex = 0;
  var pendingPostFlushCbs = [];
  var activePostFlushCbs = null;
  var postFlushIndex = 0;
  var resolvedPromise = /* @__PURE__ */ Promise.resolve();
  var currentFlushPromise = null;
  var RECURSION_LIMIT = 100;
  function nextTick(fn) {
    const p2 = currentFlushPromise || resolvedPromise;
    return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
  }
  function findInsertionIndex(id) {
    let start = flushIndex + 1;
    let end = queue.length;
    while (start < end) {
      const middle = start + end >>> 1;
      const middleJob = queue[middle];
      const middleJobId = getId(middleJob);
      if (middleJobId < id || middleJobId === id && middleJob.pre) {
        start = middle + 1;
      } else {
        end = middle;
      }
    }
    return start;
  }
  function queueJob(job) {
    if (!queue.length || !queue.includes(
      job,
      isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
    )) {
      if (job.id == null) {
        queue.push(job);
      } else {
        queue.splice(findInsertionIndex(job.id), 0, job);
      }
      queueFlush();
    }
  }
  function queueFlush() {
    if (!isFlushing && !isFlushPending) {
      isFlushPending = true;
      currentFlushPromise = resolvedPromise.then(flushJobs);
    }
  }
  function invalidateJob(job) {
    const i = queue.indexOf(job);
    if (i > flushIndex) {
      queue.splice(i, 1);
    }
  }
  function queuePostFlushCb(cb) {
    if (!isArray(cb)) {
      if (!activePostFlushCbs || !activePostFlushCbs.includes(
        cb,
        cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
      )) {
        pendingPostFlushCbs.push(cb);
      }
    } else {
      pendingPostFlushCbs.push(...cb);
    }
    queueFlush();
  }
  function flushPreFlushCbs(instance, seen, i = isFlushing ? flushIndex + 1 : 0) {
    if (true) {
      seen = seen || /* @__PURE__ */ new Map();
    }
    for (; i < queue.length; i++) {
      const cb = queue[i];
      if (cb && cb.pre) {
        if (instance && cb.id !== instance.uid) {
          continue;
        }
        if (checkRecursiveUpdates(seen, cb)) {
          continue;
        }
        queue.splice(i, 1);
        i--;
        cb();
      }
    }
  }
  function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
      const deduped = [...new Set(pendingPostFlushCbs)].sort(
        (a, b) => getId(a) - getId(b)
      );
      pendingPostFlushCbs.length = 0;
      if (activePostFlushCbs) {
        activePostFlushCbs.push(...deduped);
        return;
      }
      activePostFlushCbs = deduped;
      if (true) {
        seen = seen || /* @__PURE__ */ new Map();
      }
      for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
        if (checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
          continue;
        }
        activePostFlushCbs[postFlushIndex]();
      }
      activePostFlushCbs = null;
      postFlushIndex = 0;
    }
  }
  var getId = (job) => job.id == null ? Infinity : job.id;
  var comparator = (a, b) => {
    const diff = getId(a) - getId(b);
    if (diff === 0) {
      if (a.pre && !b.pre)
        return -1;
      if (b.pre && !a.pre)
        return 1;
    }
    return diff;
  };
  function flushJobs(seen) {
    isFlushPending = false;
    isFlushing = true;
    if (true) {
      seen = seen || /* @__PURE__ */ new Map();
    }
    queue.sort(comparator);
    const check = true ? (job) => checkRecursiveUpdates(seen, job) : NOOP;
    try {
      for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job && job.active !== false) {
          if (check(job)) {
            continue;
          }
          callWithErrorHandling(job, null, 14);
        }
      }
    } finally {
      flushIndex = 0;
      queue.length = 0;
      flushPostFlushCbs(seen);
      isFlushing = false;
      currentFlushPromise = null;
      if (queue.length || pendingPostFlushCbs.length) {
        flushJobs(seen);
      }
    }
  }
  function checkRecursiveUpdates(seen, fn) {
    if (!seen.has(fn)) {
      seen.set(fn, 1);
    } else {
      const count = seen.get(fn);
      if (count > RECURSION_LIMIT) {
        const instance = fn.ownerInstance;
        const componentName = instance && getComponentName(instance.type);
        handleError(
          `Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
          null,
          10
        );
        return true;
      } else {
        seen.set(fn, count + 1);
      }
    }
  }
  var isHmrUpdating = false;
  var hmrDirtyComponents = /* @__PURE__ */ new Set();
  if (true) {
    getGlobalThis().__VUE_HMR_RUNTIME__ = {
      createRecord: tryWrap(createRecord),
      rerender: tryWrap(rerender),
      reload: tryWrap(reload)
    };
  }
  var map = /* @__PURE__ */ new Map();
  function registerHMR(instance) {
    const id = instance.type.__hmrId;
    let record = map.get(id);
    if (!record) {
      createRecord(id, instance.type);
      record = map.get(id);
    }
    record.instances.add(instance);
  }
  function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).instances.delete(instance);
  }
  function createRecord(id, initialDef) {
    if (map.has(id)) {
      return false;
    }
    map.set(id, {
      initialDef: normalizeClassComponent(initialDef),
      instances: /* @__PURE__ */ new Set()
    });
    return true;
  }
  function normalizeClassComponent(component) {
    return isClassComponent(component) ? component.__vccOpts : component;
  }
  function rerender(id, newRender) {
    const record = map.get(id);
    if (!record) {
      return;
    }
    record.initialDef.render = newRender;
    [...record.instances].forEach((instance) => {
      if (newRender) {
        instance.render = newRender;
        normalizeClassComponent(instance.type).render = newRender;
      }
      instance.renderCache = [];
      isHmrUpdating = true;
      instance.effect.dirty = true;
      instance.update();
      isHmrUpdating = false;
    });
  }
  function reload(id, newComp) {
    const record = map.get(id);
    if (!record)
      return;
    newComp = normalizeClassComponent(newComp);
    updateComponentDef(record.initialDef, newComp);
    const instances = [...record.instances];
    for (const instance of instances) {
      const oldComp = normalizeClassComponent(instance.type);
      if (!hmrDirtyComponents.has(oldComp)) {
        if (oldComp !== record.initialDef) {
          updateComponentDef(oldComp, newComp);
        }
        hmrDirtyComponents.add(oldComp);
      }
      instance.appContext.propsCache.delete(instance.type);
      instance.appContext.emitsCache.delete(instance.type);
      instance.appContext.optionsCache.delete(instance.type);
      if (instance.ceReload) {
        hmrDirtyComponents.add(oldComp);
        instance.ceReload(newComp.styles);
        hmrDirtyComponents.delete(oldComp);
      } else if (instance.parent) {
        instance.parent.effect.dirty = true;
        queueJob(instance.parent.update);
      } else if (instance.appContext.reload) {
        instance.appContext.reload();
      } else if (typeof window !== "undefined") {
        window.location.reload();
      } else {
        console.warn(
          "[HMR] Root or manually mounted instance modified. Full reload required."
        );
      }
    }
    queuePostFlushCb(() => {
      for (const instance of instances) {
        hmrDirtyComponents.delete(
          normalizeClassComponent(instance.type)
        );
      }
    });
  }
  function updateComponentDef(oldComp, newComp) {
    extend(oldComp, newComp);
    for (const key in oldComp) {
      if (key !== "__file" && !(key in newComp)) {
        delete oldComp[key];
      }
    }
  }
  function tryWrap(fn) {
    return (id, arg) => {
      try {
        return fn(id, arg);
      } catch (e) {
        console.error(e);
        console.warn(
          `[HMR] Something went wrong during Vue component hot-reload. Full reload required.`
        );
      }
    };
  }
  var devtools$1;
  var buffer = [];
  var devtoolsNotInstalled = false;
  function emit$1(event, ...args) {
    if (devtools$1) {
      devtools$1.emit(event, ...args);
    } else if (!devtoolsNotInstalled) {
      buffer.push({ event, args });
    }
  }
  function setDevtoolsHook$1(hook, target) {
    var _a2, _b;
    devtools$1 = hook;
    if (devtools$1) {
      devtools$1.enabled = true;
      buffer.forEach(({ event, args }) => devtools$1.emit(event, ...args));
      buffer = [];
    } else if (typeof window !== "undefined" && window.HTMLElement && !((_b = (_a2 = window.navigator) == null ? void 0 : _a2.userAgent) == null ? void 0 : _b.includes("jsdom"))) {
      const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
      replay.push((newHook) => {
        setDevtoolsHook$1(newHook, target);
      });
      setTimeout(() => {
        if (!devtools$1) {
          target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
          devtoolsNotInstalled = true;
          buffer = [];
        }
      }, 3e3);
    } else {
      devtoolsNotInstalled = true;
      buffer = [];
    }
  }
  function devtoolsInitApp(app, version3) {
    emit$1("app:init", app, version3, {
      Fragment,
      Text,
      Comment,
      Static
    });
  }
  function devtoolsUnmountApp(app) {
    emit$1("app:unmount", app);
  }
  var devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook(
    "component:added"
  );
  var devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook("component:updated");
  var _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook(
    "component:removed"
  );
  var devtoolsComponentRemoved = (component) => {
    if (devtools$1 && typeof devtools$1.cleanupBuffer === "function" && !devtools$1.cleanupBuffer(component)) {
      _devtoolsComponentRemoved(component);
    }
  };
  function createDevtoolsComponentHook(hook) {
    return (component) => {
      emit$1(
        hook,
        component.appContext.app,
        component.uid,
        component.parent ? component.parent.uid : void 0,
        component
      );
    };
  }
  var devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook(
    "perf:start"
  );
  var devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook(
    "perf:end"
  );
  function createDevtoolsPerformanceHook(hook) {
    return (component, type2, time) => {
      emit$1(hook, component.appContext.app, component.uid, component, type2, time);
    };
  }
  function devtoolsComponentEmit(component, event, params) {
    emit$1(
      "component:emit",
      component.appContext.app,
      component,
      event,
      params
    );
  }
  function emit(instance, event, ...rawArgs) {
    if (instance.isUnmounted)
      return;
    const props = instance.vnode.props || EMPTY_OBJ;
    if (true) {
      const {
        emitsOptions,
        propsOptions: [propsOptions]
      } = instance;
      if (emitsOptions) {
        if (!(event in emitsOptions) && true) {
          if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {
            warn$1(
              `Component emitted event "${event}" but it is neither declared in the emits option nor as an "${toHandlerKey(event)}" prop.`
            );
          }
        } else {
          const validator = emitsOptions[event];
          if (isFunction(validator)) {
            const isValid2 = validator(...rawArgs);
            if (!isValid2) {
              warn$1(
                `Invalid event arguments: event validation failed for event "${event}".`
              );
            }
          }
        }
      }
    }
    let args = rawArgs;
    const isModelListener2 = event.startsWith("update:");
    const modelArg = isModelListener2 && event.slice(7);
    if (modelArg && modelArg in props) {
      const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
      const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
      if (trim) {
        args = rawArgs.map((a) => isString(a) ? a.trim() : a);
      }
      if (number) {
        args = rawArgs.map(looseToNumber);
      }
    }
    if (true) {
      devtoolsComponentEmit(instance, event, args);
    }
    if (true) {
      const lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {
        warn$1(
          `Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(
            instance,
            instance.type
          )} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(
            event
          )}" instead of "${event}".`
        );
      }
    }
    let handlerName;
    let handler = props[handlerName = toHandlerKey(event)] || props[handlerName = toHandlerKey(camelize(event))];
    if (!handler && isModelListener2) {
      handler = props[handlerName = toHandlerKey(hyphenate(event))];
    }
    if (handler) {
      callWithAsyncErrorHandling(
        handler,
        instance,
        6,
        args
      );
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
      if (!instance.emitted) {
        instance.emitted = {};
      } else if (instance.emitted[handlerName]) {
        return;
      }
      instance.emitted[handlerName] = true;
      callWithAsyncErrorHandling(
        onceHandler,
        instance,
        6,
        args
      );
    }
  }
  function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.emitsCache;
    const cached = cache.get(comp);
    if (cached !== void 0) {
      return cached;
    }
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (!isFunction(comp)) {
      const extendEmits = (raw2) => {
        const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
        if (normalizedFromExtend) {
          hasExtends = true;
          extend(normalized, normalizedFromExtend);
        }
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendEmits);
      }
      if (comp.extends) {
        extendEmits(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendEmits);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject(comp)) {
        cache.set(comp, null);
      }
      return null;
    }
    if (isArray(raw)) {
      raw.forEach((key) => normalized[key] = null);
    } else {
      extend(normalized, raw);
    }
    if (isObject(comp)) {
      cache.set(comp, normalized);
    }
    return normalized;
  }
  function isEmitListener(options, key) {
    if (!options || !isOn(key)) {
      return false;
    }
    key = key.slice(2).replace(/Once$/, "");
    return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
  }
  var currentRenderingInstance = null;
  var currentScopeId = null;
  function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
  }
  function pushScopeId(id) {
    currentScopeId = id;
  }
  function popScopeId() {
    currentScopeId = null;
  }
  function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx)
      return fn;
    if (fn._n) {
      return fn;
    }
    const renderFnWithContext = (...args) => {
      if (renderFnWithContext._d) {
        setBlockTracking(-1);
      }
      const prevInstance = setCurrentRenderingInstance(ctx);
      let res;
      try {
        res = fn(...args);
      } finally {
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
          setBlockTracking(1);
        }
      }
      if (true) {
        devtoolsComponentUpdated(ctx);
      }
      return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
  }
  var accessedAttrs = false;
  function markAttrsAccessed() {
    accessedAttrs = true;
  }
  function renderComponentRoot(instance) {
    const {
      type: Component,
      vnode,
      proxy,
      withProxy,
      props,
      propsOptions: [propsOptions],
      slots,
      attrs,
      emit: emit2,
      render: render7,
      renderCache,
      data,
      setupState,
      ctx,
      inheritAttrs
    } = instance;
    let result;
    let fallthroughAttrs;
    const prev = setCurrentRenderingInstance(instance);
    if (true) {
      accessedAttrs = false;
    }
    try {
      if (vnode.shapeFlag & 4) {
        const proxyToUse = withProxy || proxy;
        const thisProxy = setupState.__isScriptSetup ? new Proxy(proxyToUse, {
          get(target, key, receiver) {
            warn$1(
              `Property '${String(
                key
              )}' was accessed via 'this'. Avoid using 'this' in templates.`
            );
            return Reflect.get(target, key, receiver);
          }
        }) : proxyToUse;
        result = normalizeVNode(
          render7.call(
            thisProxy,
            proxyToUse,
            renderCache,
            props,
            setupState,
            data,
            ctx
          )
        );
        fallthroughAttrs = attrs;
      } else {
        const render22 = Component;
        if (attrs === props) {
          markAttrsAccessed();
        }
        result = normalizeVNode(
          render22.length > 1 ? render22(
            props,
            true ? {
              get attrs() {
                markAttrsAccessed();
                return attrs;
              },
              slots,
              emit: emit2
            } : { attrs, slots, emit: emit2 }
          ) : render22(
            props,
            null
          )
        );
        fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
      }
    } catch (err) {
      blockStack.length = 0;
      handleError(err, instance, 1);
      result = createVNode(Comment);
    }
    let root = result;
    let setRoot = void 0;
    if (result.patchFlag > 0 && result.patchFlag & 2048) {
      [root, setRoot] = getChildRoot(result);
    }
    if (fallthroughAttrs && inheritAttrs !== false) {
      const keys2 = Object.keys(fallthroughAttrs);
      const { shapeFlag } = root;
      if (keys2.length) {
        if (shapeFlag & (1 | 6)) {
          if (propsOptions && keys2.some(isModelListener)) {
            fallthroughAttrs = filterModelListeners(
              fallthroughAttrs,
              propsOptions
            );
          }
          root = cloneVNode(root, fallthroughAttrs);
        } else if (!accessedAttrs && root.type !== Comment) {
          const allAttrs = Object.keys(attrs);
          const eventAttrs = [];
          const extraAttrs = [];
          for (let i = 0, l = allAttrs.length; i < l; i++) {
            const key = allAttrs[i];
            if (isOn(key)) {
              if (!isModelListener(key)) {
                eventAttrs.push(key[2].toLowerCase() + key.slice(3));
              }
            } else {
              extraAttrs.push(key);
            }
          }
          if (extraAttrs.length) {
            warn$1(
              `Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`
            );
          }
          if (eventAttrs.length) {
            warn$1(
              `Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
            );
          }
        }
      }
    }
    if (vnode.dirs) {
      if (!isElementRoot(root)) {
        warn$1(
          `Runtime directive used on component with non-element root node. The directives will not function as intended.`
        );
      }
      root = cloneVNode(root);
      root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
      if (!isElementRoot(root)) {
        warn$1(
          `Component inside <Transition> renders non-element root node that cannot be animated.`
        );
      }
      root.transition = vnode.transition;
    }
    if (setRoot) {
      setRoot(root);
    } else {
      result = root;
    }
    setCurrentRenderingInstance(prev);
    return result;
  }
  var getChildRoot = (vnode) => {
    const rawChildren = vnode.children;
    const dynamicChildren = vnode.dynamicChildren;
    const childRoot = filterSingleRoot(rawChildren, false);
    if (!childRoot) {
      return [vnode, void 0];
    } else if (childRoot.patchFlag > 0 && childRoot.patchFlag & 2048) {
      return getChildRoot(childRoot);
    }
    const index = rawChildren.indexOf(childRoot);
    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
    const setRoot = (updatedRoot) => {
      rawChildren[index] = updatedRoot;
      if (dynamicChildren) {
        if (dynamicIndex > -1) {
          dynamicChildren[dynamicIndex] = updatedRoot;
        } else if (updatedRoot.patchFlag > 0) {
          vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
        }
      }
    };
    return [normalizeVNode(childRoot), setRoot];
  };
  function filterSingleRoot(children, recurse = true) {
    let singleRoot;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (isVNode(child)) {
        if (child.type !== Comment || child.children === "v-if") {
          if (singleRoot) {
            return;
          } else {
            singleRoot = child;
            if (recurse && singleRoot.patchFlag > 0 && singleRoot.patchFlag & 2048) {
              return filterSingleRoot(singleRoot.children);
            }
          }
        }
      } else {
        return;
      }
    }
    return singleRoot;
  }
  var getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key in attrs) {
      if (key === "class" || key === "style" || isOn(key)) {
        (res || (res = {}))[key] = attrs[key];
      }
    }
    return res;
  };
  var filterModelListeners = (attrs, props) => {
    const res = {};
    for (const key in attrs) {
      if (!isModelListener(key) || !(key.slice(9) in props)) {
        res[key] = attrs[key];
      }
    }
    return res;
  };
  var isElementRoot = (vnode) => {
    return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
  };
  function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    if ((prevChildren || nextChildren) && isHmrUpdating) {
      return true;
    }
    if (nextVNode.dirs || nextVNode.transition) {
      return true;
    }
    if (optimized && patchFlag >= 0) {
      if (patchFlag & 1024) {
        return true;
      }
      if (patchFlag & 16) {
        if (!prevProps) {
          return !!nextProps;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      } else if (patchFlag & 8) {
        const dynamicProps = nextVNode.dynamicProps;
        for (let i = 0; i < dynamicProps.length; i++) {
          const key = dynamicProps[i];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
            return true;
          }
        }
      }
    } else {
      if (prevChildren || nextChildren) {
        if (!nextChildren || !nextChildren.$stable) {
          return true;
        }
      }
      if (prevProps === nextProps) {
        return false;
      }
      if (!prevProps) {
        return !!nextProps;
      }
      if (!nextProps) {
        return true;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
  }
  function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
      return true;
    }
    for (let i = 0; i < nextKeys.length; i++) {
      const key = nextKeys[i];
      if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
        return true;
      }
    }
    return false;
  }
  function updateHOCHostEl({ vnode, parent: parent2 }, el) {
    while (parent2) {
      const root = parent2.subTree;
      if (root.suspense && root.suspense.activeBranch === vnode) {
        root.el = vnode.el;
      }
      if (root === vnode) {
        (vnode = parent2.vnode).el = el;
        parent2 = parent2.parent;
      } else {
        break;
      }
    }
  }
  var COMPONENTS = "components";
  var DIRECTIVES = "directives";
  function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
  }
  var NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
  function resolveDynamicComponent(component) {
    if (isString(component)) {
      return resolveAsset(COMPONENTS, component, false) || component;
    } else {
      return component || NULL_DYNAMIC_COMPONENT;
    }
  }
  function resolveDirective(name) {
    return resolveAsset(DIRECTIVES, name);
  }
  function resolveAsset(type2, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
      const Component = instance.type;
      if (type2 === COMPONENTS) {
        const selfName = getComponentName(
          Component,
          false
        );
        if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
          return Component;
        }
      }
      const res = resolve(instance[type2] || Component[type2], name) || resolve(instance.appContext[type2], name);
      if (!res && maybeSelfReference) {
        return Component;
      }
      if (warnMissing && !res) {
        const extra = type2 === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
        warn$1(`Failed to resolve ${type2.slice(0, -1)}: ${name}${extra}`);
      }
      return res;
    } else if (true) {
      warn$1(
        `resolve${capitalize(type2.slice(0, -1))} can only be used in render() or setup().`
      );
    }
  }
  function resolve(registry, name) {
    return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
  }
  var isSuspense = (type2) => type2.__isSuspense;
  function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
      if (isArray(fn)) {
        suspense.effects.push(...fn);
      } else {
        suspense.effects.push(fn);
      }
    } else {
      queuePostFlushCb(fn);
    }
  }
  var ssrContextKey = Symbol.for("v-scx");
  var useSSRContext = () => {
    {
      const ctx = inject(ssrContextKey);
      if (!ctx) {
        warn$1(
          `Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`
        );
      }
      return ctx;
    }
  };
  function watchEffect(effect2, options) {
    return doWatch(effect2, null, options);
  }
  var INITIAL_WATCHER_VALUE = {};
  function watch(source, cb, options) {
    if (!isFunction(cb)) {
      warn$1(
        `\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`
      );
    }
    return doWatch(source, cb, options);
  }
  function doWatch(source, cb, {
    immediate,
    deep,
    flush,
    once,
    onTrack,
    onTrigger
  } = EMPTY_OBJ) {
    if (cb && once) {
      const _cb = cb;
      cb = (...args) => {
        _cb(...args);
        unwatch();
      };
    }
    if (deep !== void 0 && typeof deep === "number") {
      warn$1(
        `watch() "deep" option with number value will be used as watch depth in future versions. Please use a boolean instead to avoid potential breakage.`
      );
    }
    if (!cb) {
      if (immediate !== void 0) {
        warn$1(
          `watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`
        );
      }
      if (deep !== void 0) {
        warn$1(
          `watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`
        );
      }
      if (once !== void 0) {
        warn$1(
          `watch() "once" option is only respected when using the watch(source, callback, options?) signature.`
        );
      }
    }
    const warnInvalidSource = (s) => {
      warn$1(
        `Invalid watch source: `,
        s,
        `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`
      );
    };
    const instance = currentInstance;
    const reactiveGetter = (source2) => deep === true ? source2 : traverse(source2, deep === false ? 1 : void 0);
    let getter;
    let forceTrigger = false;
    let isMultiSource = false;
    if (isRef(source)) {
      getter = () => source.value;
      forceTrigger = isShallow(source);
    } else if (isReactive(source)) {
      getter = () => reactiveGetter(source);
      forceTrigger = true;
    } else if (isArray(source)) {
      isMultiSource = true;
      forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
      getter = () => source.map((s) => {
        if (isRef(s)) {
          return s.value;
        } else if (isReactive(s)) {
          return reactiveGetter(s);
        } else if (isFunction(s)) {
          return callWithErrorHandling(s, instance, 2);
        } else {
          warnInvalidSource(s);
        }
      });
    } else if (isFunction(source)) {
      if (cb) {
        getter = () => callWithErrorHandling(source, instance, 2);
      } else {
        getter = () => {
          if (cleanup) {
            cleanup();
          }
          return callWithAsyncErrorHandling(
            source,
            instance,
            3,
            [onCleanup]
          );
        };
      }
    } else {
      getter = NOOP;
      warnInvalidSource(source);
    }
    if (cb && deep) {
      const baseGetter = getter;
      getter = () => traverse(baseGetter());
    }
    let cleanup;
    let onCleanup = (fn) => {
      cleanup = effect2.onStop = () => {
        callWithErrorHandling(fn, instance, 4);
        cleanup = effect2.onStop = void 0;
      };
    };
    let ssrCleanup;
    if (isInSSRComponentSetup) {
      onCleanup = NOOP;
      if (!cb) {
        getter();
      } else if (immediate) {
        callWithAsyncErrorHandling(cb, instance, 3, [
          getter(),
          isMultiSource ? [] : void 0,
          onCleanup
        ]);
      }
      if (flush === "sync") {
        const ctx = useSSRContext();
        ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
      } else {
        return NOOP;
      }
    }
    let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    const job = () => {
      if (!effect2.active || !effect2.dirty) {
        return;
      }
      if (cb) {
        const newValue = effect2.run();
        if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
          if (cleanup) {
            cleanup();
          }
          callWithAsyncErrorHandling(cb, instance, 3, [
            newValue,
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            onCleanup
          ]);
          oldValue = newValue;
        }
      } else {
        effect2.run();
      }
    };
    job.allowRecurse = !!cb;
    let scheduler;
    if (flush === "sync") {
      scheduler = job;
    } else if (flush === "post") {
      scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
    } else {
      job.pre = true;
      if (instance)
        job.id = instance.uid;
      scheduler = () => queueJob(job);
    }
    const effect2 = new ReactiveEffect(getter, NOOP, scheduler);
    const scope = getCurrentScope();
    const unwatch = () => {
      effect2.stop();
      if (scope) {
        remove(scope.effects, effect2);
      }
    };
    if (true) {
      effect2.onTrack = onTrack;
      effect2.onTrigger = onTrigger;
    }
    if (cb) {
      if (immediate) {
        job();
      } else {
        oldValue = effect2.run();
      }
    } else if (flush === "post") {
      queuePostRenderEffect(
        effect2.run.bind(effect2),
        instance && instance.suspense
      );
    } else {
      effect2.run();
    }
    if (ssrCleanup)
      ssrCleanup.push(unwatch);
    return unwatch;
  }
  function instanceWatch(source, value, options) {
    const publicThis = this.proxy;
    const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
    let cb;
    if (isFunction(value)) {
      cb = value;
    } else {
      cb = value.handler;
      options = value;
    }
    const reset = setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    reset();
    return res;
  }
  function createPathGetter(ctx, path5) {
    const segments = path5.split(".");
    return () => {
      let cur = ctx;
      for (let i = 0; i < segments.length && cur; i++) {
        cur = cur[segments[i]];
      }
      return cur;
    };
  }
  function traverse(value, depth, currentDepth = 0, seen) {
    if (!isObject(value) || value["__v_skip"]) {
      return value;
    }
    if (depth && depth > 0) {
      if (currentDepth >= depth) {
        return value;
      }
      currentDepth++;
    }
    seen = seen || /* @__PURE__ */ new Set();
    if (seen.has(value)) {
      return value;
    }
    seen.add(value);
    if (isRef(value)) {
      traverse(value.value, depth, currentDepth, seen);
    } else if (isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        traverse(value[i], depth, currentDepth, seen);
      }
    } else if (isSet(value) || isMap(value)) {
      value.forEach((v) => {
        traverse(v, depth, currentDepth, seen);
      });
    } else if (isPlainObject(value)) {
      for (const key in value) {
        traverse(value[key], depth, currentDepth, seen);
      }
    }
    return value;
  }
  function validateDirectiveName(name) {
    if (isBuiltInDirective(name)) {
      warn$1("Do not use built-in directive ids as custom directive id: " + name);
    }
  }
  function withDirectives(vnode, directives) {
    if (currentRenderingInstance === null) {
      warn$1(`withDirectives can only be used inside render functions.`);
      return vnode;
    }
    const instance = getExposeProxy(currentRenderingInstance) || currentRenderingInstance.proxy;
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i = 0; i < directives.length; i++) {
      let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
      if (dir) {
        if (isFunction(dir)) {
          dir = {
            mounted: dir,
            updated: dir
          };
        }
        if (dir.deep) {
          traverse(value);
        }
        bindings.push({
          dir,
          instance,
          value,
          oldValue: void 0,
          arg,
          modifiers
        });
      }
    }
    return vnode;
  }
  function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i = 0; i < bindings.length; i++) {
      const binding = bindings[i];
      if (oldBindings) {
        binding.oldValue = oldBindings[i].value;
      }
      let hook = binding.dir[name];
      if (hook) {
        pauseTracking();
        callWithAsyncErrorHandling(hook, instance, 8, [
          vnode.el,
          binding,
          vnode,
          prevVNode
        ]);
        resetTracking();
      }
    }
  }
  var leaveCbKey = Symbol("_leaveCb");
  var enterCbKey = Symbol("_enterCb");
  function useTransitionState() {
    const state = {
      isMounted: false,
      isLeaving: false,
      isUnmounting: false,
      leavingVNodes: /* @__PURE__ */ new Map()
    };
    onMounted(() => {
      state.isMounted = true;
    });
    onBeforeUnmount(() => {
      state.isUnmounting = true;
    });
    return state;
  }
  var TransitionHookValidator = [Function, Array];
  var BaseTransitionPropsValidators = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  };
  var BaseTransitionImpl = {
    name: `BaseTransition`,
    props: BaseTransitionPropsValidators,
    setup(props, { slots }) {
      const instance = getCurrentInstance();
      const state = useTransitionState();
      return () => {
        const children = slots.default && getTransitionRawChildren(slots.default(), true);
        if (!children || !children.length) {
          return;
        }
        let child = children[0];
        if (children.length > 1) {
          let hasFound = false;
          for (const c of children) {
            if (c.type !== Comment) {
              if (hasFound) {
                warn$1(
                  "<transition> can only be used on a single element or component. Use <transition-group> for lists."
                );
                break;
              }
              child = c;
              hasFound = true;
              if (false)
                break;
            }
          }
        }
        const rawProps = toRaw(props);
        const { mode } = rawProps;
        if (mode && mode !== "in-out" && mode !== "out-in" && mode !== "default") {
          warn$1(`invalid <transition> mode: ${mode}`);
        }
        if (state.isLeaving) {
          return emptyPlaceholder(child);
        }
        const innerChild = getKeepAliveChild(child);
        if (!innerChild) {
          return emptyPlaceholder(child);
        }
        const enterHooks = resolveTransitionHooks(
          innerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(innerChild, enterHooks);
        const oldChild = instance.subTree;
        const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
        if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild)) {
          const leavingHooks = resolveTransitionHooks(
            oldInnerChild,
            rawProps,
            state,
            instance
          );
          setTransitionHooks(oldInnerChild, leavingHooks);
          if (mode === "out-in") {
            state.isLeaving = true;
            leavingHooks.afterLeave = () => {
              state.isLeaving = false;
              if (instance.update.active !== false) {
                instance.effect.dirty = true;
                instance.update();
              }
            };
            return emptyPlaceholder(child);
          } else if (mode === "in-out" && innerChild.type !== Comment) {
            leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
              const leavingVNodesCache = getLeavingNodesForType(
                state,
                oldInnerChild
              );
              leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
              el[leaveCbKey] = () => {
                earlyRemove();
                el[leaveCbKey] = void 0;
                delete enterHooks.delayedLeave;
              };
              enterHooks.delayedLeave = delayedLeave;
            };
          }
        }
        return child;
      };
    }
  };
  var BaseTransition = BaseTransitionImpl;
  function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
      leavingVNodesCache = /* @__PURE__ */ Object.create(null);
      leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
  }
  function resolveTransitionHooks(vnode, props, state, instance) {
    const {
      appear,
      mode,
      persisted = false,
      onBeforeEnter,
      onEnter,
      onAfterEnter,
      onEnterCancelled,
      onBeforeLeave,
      onLeave,
      onAfterLeave,
      onLeaveCancelled,
      onBeforeAppear,
      onAppear,
      onAfterAppear,
      onAppearCancelled
    } = props;
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook3 = (hook, args) => {
      hook && callWithAsyncErrorHandling(
        hook,
        instance,
        9,
        args
      );
    };
    const callAsyncHook = (hook, args) => {
      const done = args[1];
      callHook3(hook, args);
      if (isArray(hook)) {
        if (hook.every((hook2) => hook2.length <= 1))
          done();
      } else if (hook.length <= 1) {
        done();
      }
    };
    const hooks = {
      mode,
      persisted,
      beforeEnter(el) {
        let hook = onBeforeEnter;
        if (!state.isMounted) {
          if (appear) {
            hook = onBeforeAppear || onBeforeEnter;
          } else {
            return;
          }
        }
        if (el[leaveCbKey]) {
          el[leaveCbKey](
            true
          );
        }
        const leavingVNode = leavingVNodesCache[key];
        if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
          leavingVNode.el[leaveCbKey]();
        }
        callHook3(hook, [el]);
      },
      enter(el) {
        let hook = onEnter;
        let afterHook = onAfterEnter;
        let cancelHook = onEnterCancelled;
        if (!state.isMounted) {
          if (appear) {
            hook = onAppear || onEnter;
            afterHook = onAfterAppear || onAfterEnter;
            cancelHook = onAppearCancelled || onEnterCancelled;
          } else {
            return;
          }
        }
        let called = false;
        const done = el[enterCbKey] = (cancelled) => {
          if (called)
            return;
          called = true;
          if (cancelled) {
            callHook3(cancelHook, [el]);
          } else {
            callHook3(afterHook, [el]);
          }
          if (hooks.delayedLeave) {
            hooks.delayedLeave();
          }
          el[enterCbKey] = void 0;
        };
        if (hook) {
          callAsyncHook(hook, [el, done]);
        } else {
          done();
        }
      },
      leave(el, remove2) {
        const key2 = String(vnode.key);
        if (el[enterCbKey]) {
          el[enterCbKey](
            true
          );
        }
        if (state.isUnmounting) {
          return remove2();
        }
        callHook3(onBeforeLeave, [el]);
        let called = false;
        const done = el[leaveCbKey] = (cancelled) => {
          if (called)
            return;
          called = true;
          remove2();
          if (cancelled) {
            callHook3(onLeaveCancelled, [el]);
          } else {
            callHook3(onAfterLeave, [el]);
          }
          el[leaveCbKey] = void 0;
          if (leavingVNodesCache[key2] === vnode) {
            delete leavingVNodesCache[key2];
          }
        };
        leavingVNodesCache[key2] = vnode;
        if (onLeave) {
          callAsyncHook(onLeave, [el, done]);
        } else {
          done();
        }
      },
      clone(vnode2) {
        return resolveTransitionHooks(vnode2, props, state, instance);
      }
    };
    return hooks;
  }
  function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
      vnode = cloneVNode(vnode);
      vnode.children = null;
      return vnode;
    }
  }
  function getKeepAliveChild(vnode) {
    return isKeepAlive(vnode) ? vnode.component ? vnode.component.subTree : vnode.children ? vnode.children[0] : void 0 : vnode;
  }
  function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) {
      setTransitionHooks(vnode.component.subTree, hooks);
    } else if (vnode.shapeFlag & 128) {
      vnode.ssContent.transition = hooks.clone(vnode.ssContent);
      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
      vnode.transition = hooks;
    }
  }
  function getTransitionRawChildren(children, keepComment = false, parentKey) {
    let ret = [];
    let keyedFragmentCount = 0;
    for (let i = 0; i < children.length; i++) {
      let child = children[i];
      const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
      if (child.type === Fragment) {
        if (child.patchFlag & 128)
          keyedFragmentCount++;
        ret = ret.concat(
          getTransitionRawChildren(child.children, keepComment, key)
        );
      } else if (keepComment || child.type !== Comment) {
        ret.push(key != null ? cloneVNode(child, { key }) : child);
      }
    }
    if (keyedFragmentCount > 1) {
      for (let i = 0; i < ret.length; i++) {
        ret[i].patchFlag = -2;
      }
    }
    return ret;
  }
  function defineComponent(options, extraOptions) {
    return isFunction(options) ? /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))() : options;
  }
  var isAsyncWrapper = (i) => !!i.type.__asyncLoader;
  var isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
  function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
  }
  function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
  }
  function registerKeepAliveHook(hook, type2, target = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = () => {
      let current = target;
      while (current) {
        if (current.isDeactivated) {
          return;
        }
        current = current.parent;
      }
      return hook();
    });
    injectHook(type2, wrappedHook, target);
    if (target) {
      let current = target.parent;
      while (current && current.parent) {
        if (isKeepAlive(current.parent.vnode)) {
          injectToKeepAliveRoot(wrappedHook, type2, target, current);
        }
        current = current.parent;
      }
    }
  }
  function injectToKeepAliveRoot(hook, type2, target, keepAliveRoot) {
    const injected = injectHook(
      type2,
      hook,
      keepAliveRoot,
      true
    );
    onUnmounted(() => {
      remove(keepAliveRoot[type2], injected);
    }, target);
  }
  function injectHook(type2, hook, target = currentInstance, prepend = false) {
    if (target) {
      const hooks = target[type2] || (target[type2] = []);
      const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
        if (target.isUnmounted) {
          return;
        }
        pauseTracking();
        const reset = setCurrentInstance(target);
        const res = callWithAsyncErrorHandling(hook, target, type2, args);
        reset();
        resetTracking();
        return res;
      });
      if (prepend) {
        hooks.unshift(wrappedHook);
      } else {
        hooks.push(wrappedHook);
      }
      return wrappedHook;
    } else if (true) {
      const apiName = toHandlerKey(ErrorTypeStrings$1[type2].replace(/ hook$/, ""));
      warn$1(
        `${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
      );
    }
  }
  var createHook = (lifecycle) => (hook, target = currentInstance) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target);
  var onBeforeMount = createHook("bm");
  var onMounted = createHook("m");
  var onBeforeUpdate = createHook("bu");
  var onUpdated = createHook("u");
  var onBeforeUnmount = createHook("bum");
  var onUnmounted = createHook("um");
  var onServerPrefetch = createHook("sp");
  var onRenderTriggered = createHook(
    "rtg"
  );
  var onRenderTracked = createHook(
    "rtc"
  );
  function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec", hook, target);
  }
  function renderList(source, renderItem, cache, index) {
    let ret;
    const cached = cache && cache[index];
    if (isArray(source) || isString(source)) {
      ret = new Array(source.length);
      for (let i = 0, l = source.length; i < l; i++) {
        ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
      }
    } else if (typeof source === "number") {
      if (!Number.isInteger(source)) {
        warn$1(`The v-for range expect an integer value but got ${source}.`);
      }
      ret = new Array(source);
      for (let i = 0; i < source; i++) {
        ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
      }
    } else if (isObject(source)) {
      if (source[Symbol.iterator]) {
        ret = Array.from(
          source,
          (item, i) => renderItem(item, i, void 0, cached && cached[i])
        );
      } else {
        const keys2 = Object.keys(source);
        ret = new Array(keys2.length);
        for (let i = 0, l = keys2.length; i < l; i++) {
          const key = keys2[i];
          ret[i] = renderItem(source[key], key, i, cached && cached[i]);
        }
      }
    } else {
      ret = [];
    }
    if (cache) {
      cache[index] = ret;
    }
    return ret;
  }
  var getPublicInstance = (i) => {
    if (!i)
      return null;
    if (isStatefulComponent(i))
      return getExposeProxy(i) || i.proxy;
    return getPublicInstance(i.parent);
  };
  var publicPropertiesMap = /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => true ? shallowReadonly(i.props) : i.props,
    $attrs: (i) => true ? shallowReadonly(i.attrs) : i.attrs,
    $slots: (i) => true ? shallowReadonly(i.slots) : i.slots,
    $refs: (i) => true ? shallowReadonly(i.refs) : i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $emit: (i) => i.emit,
    $options: (i) => true ? resolveMergedOptions(i) : i.type,
    $forceUpdate: (i) => i.f || (i.f = () => {
      i.effect.dirty = true;
      queueJob(i.update);
    }),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => true ? instanceWatch.bind(i) : NOOP
  });
  var isReservedPrefix = (key) => key === "_" || key === "$";
  var hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
  var PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
      const { ctx, setupState, data, props, accessCache, type: type2, appContext } = instance;
      if (key === "__isVue") {
        return true;
      }
      let normalizedProps;
      if (key[0] !== "$") {
        const n = accessCache[key];
        if (n !== void 0) {
          switch (n) {
            case 1:
              return setupState[key];
            case 2:
              return data[key];
            case 4:
              return ctx[key];
            case 3:
              return props[key];
          }
        } else if (hasSetupBinding(setupState, key)) {
          accessCache[key] = 1;
          return setupState[key];
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          accessCache[key] = 2;
          return data[key];
        } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)) {
          accessCache[key] = 3;
          return props[key];
        } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (shouldCacheAccess) {
          accessCache[key] = 0;
        }
      }
      const publicGetter = publicPropertiesMap[key];
      let cssModule, globalProperties;
      if (publicGetter) {
        if (key === "$attrs") {
          track(instance, "get", key);
          markAttrsAccessed();
        } else if (key === "$slots") {
          track(instance, "get", key);
        }
        return publicGetter(instance);
      } else if ((cssModule = type2.__cssModules) && (cssModule = cssModule[key])) {
        return cssModule;
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)) {
        {
          return globalProperties[key];
        }
      } else if (currentRenderingInstance && (!isString(key) || key.indexOf("__v") !== 0)) {
        if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn(data, key)) {
          warn$1(
            `Property ${JSON.stringify(
              key
            )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
          );
        } else if (instance === currentRenderingInstance) {
          warn$1(
            `Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`
          );
        }
      }
    },
    set({ _: instance }, key, value) {
      const { data, setupState, ctx } = instance;
      if (hasSetupBinding(setupState, key)) {
        setupState[key] = value;
        return true;
      } else if (setupState.__isScriptSetup && hasOwn(setupState, key)) {
        warn$1(`Cannot mutate <script setup> binding "${key}" from Options API.`);
        return false;
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        data[key] = value;
        return true;
      } else if (hasOwn(instance.props, key)) {
        warn$1(`Attempting to mutate prop "${key}". Props are readonly.`);
        return false;
      }
      if (key[0] === "$" && key.slice(1) in instance) {
        warn$1(
          `Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`
        );
        return false;
      } else {
        if (key in instance.appContext.config.globalProperties) {
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            value
          });
        } else {
          ctx[key] = value;
        }
      }
      return true;
    },
    has({
      _: { data, setupState, accessCache, ctx, appContext, propsOptions }
    }, key) {
      let normalizedProps;
      return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
    },
    defineProperty(target, key, descriptor) {
      if (descriptor.get != null) {
        target._.accessCache[key] = 0;
      } else if (hasOwn(descriptor, "value")) {
        this.set(target, key, descriptor.value, null);
      }
      return Reflect.defineProperty(target, key, descriptor);
    }
  };
  if (true) {
    PublicInstanceProxyHandlers.ownKeys = (target) => {
      warn$1(
        `Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`
      );
      return Reflect.ownKeys(target);
    };
  }
  function createDevRenderContext(instance) {
    const target = {};
    Object.defineProperty(target, `_`, {
      configurable: true,
      enumerable: false,
      get: () => instance
    });
    Object.keys(publicPropertiesMap).forEach((key) => {
      Object.defineProperty(target, key, {
        configurable: true,
        enumerable: false,
        get: () => publicPropertiesMap[key](instance),
        set: NOOP
      });
    });
    return target;
  }
  function exposePropsOnRenderContext(instance) {
    const {
      ctx,
      propsOptions: [propsOptions]
    } = instance;
    if (propsOptions) {
      Object.keys(propsOptions).forEach((key) => {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => instance.props[key],
          set: NOOP
        });
      });
    }
  }
  function exposeSetupStateOnRenderContext(instance) {
    const { ctx, setupState } = instance;
    Object.keys(toRaw(setupState)).forEach((key) => {
      if (!setupState.__isScriptSetup) {
        if (isReservedPrefix(key[0])) {
          warn$1(
            `setup() return property ${JSON.stringify(
              key
            )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
          );
          return;
        }
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => setupState[key],
          set: NOOP
        });
      }
    });
  }
  function normalizePropsOrEmits(props) {
    return isArray(props) ? props.reduce(
      (normalized, p2) => (normalized[p2] = null, normalized),
      {}
    ) : props;
  }
  function createDuplicateChecker() {
    const cache = /* @__PURE__ */ Object.create(null);
    return (type2, key) => {
      if (cache[key]) {
        warn$1(`${type2} property "${key}" is already defined in ${cache[key]}.`);
      } else {
        cache[key] = type2;
      }
    };
  }
  var shouldCacheAccess = true;
  function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    shouldCacheAccess = false;
    if (options.beforeCreate) {
      callHook(options.beforeCreate, instance, "bc");
    }
    const {
      data: dataOptions,
      computed: computedOptions,
      methods,
      watch: watchOptions,
      provide: provideOptions,
      inject: injectOptions,
      created,
      beforeMount,
      mounted: mounted7,
      beforeUpdate,
      updated: updated3,
      activated,
      deactivated,
      beforeDestroy,
      beforeUnmount,
      destroyed,
      unmounted: unmounted7,
      render: render7,
      renderTracked,
      renderTriggered,
      errorCaptured,
      serverPrefetch,
      expose,
      inheritAttrs,
      components,
      directives,
      filters
    } = options;
    const checkDuplicateProperties = true ? createDuplicateChecker() : null;
    if (true) {
      const [propsOptions] = instance.propsOptions;
      if (propsOptions) {
        for (const key in propsOptions) {
          checkDuplicateProperties("Props", key);
        }
      }
    }
    if (injectOptions) {
      resolveInjections(injectOptions, ctx, checkDuplicateProperties);
    }
    if (methods) {
      for (const key in methods) {
        const methodHandler = methods[key];
        if (isFunction(methodHandler)) {
          if (true) {
            Object.defineProperty(ctx, key, {
              value: methodHandler.bind(publicThis),
              configurable: true,
              enumerable: true,
              writable: true
            });
          } else {
            ctx[key] = methodHandler.bind(publicThis);
          }
          if (true) {
            checkDuplicateProperties("Methods", key);
          }
        } else if (true) {
          warn$1(
            `Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`
          );
        }
      }
    }
    if (dataOptions) {
      if (!isFunction(dataOptions)) {
        warn$1(
          `The data option must be a function. Plain object usage is no longer supported.`
        );
      }
      const data = dataOptions.call(publicThis, publicThis);
      if (isPromise(data)) {
        warn$1(
          `data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`
        );
      }
      if (!isObject(data)) {
        warn$1(`data() should return an object.`);
      } else {
        instance.data = reactive(data);
        if (true) {
          for (const key in data) {
            checkDuplicateProperties("Data", key);
            if (!isReservedPrefix(key[0])) {
              Object.defineProperty(ctx, key, {
                configurable: true,
                enumerable: true,
                get: () => data[key],
                set: NOOP
              });
            }
          }
        }
      }
    }
    shouldCacheAccess = true;
    if (computedOptions) {
      for (const key in computedOptions) {
        const opt = computedOptions[key];
        const get2 = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
        if (get2 === NOOP) {
          warn$1(`Computed property "${key}" has no getter.`);
        }
        const set3 = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : true ? () => {
          warn$1(
            `Write operation failed: computed property "${key}" is readonly.`
          );
        } : NOOP;
        const c = computed2({
          get: get2,
          set: set3
        });
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => c.value,
          set: (v) => c.value = v
        });
        if (true) {
          checkDuplicateProperties("Computed", key);
        }
      }
    }
    if (watchOptions) {
      for (const key in watchOptions) {
        createWatcher(watchOptions[key], ctx, publicThis, key);
      }
    }
    if (provideOptions) {
      const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
      Reflect.ownKeys(provides).forEach((key) => {
        provide(key, provides[key]);
      });
    }
    if (created) {
      callHook(created, instance, "c");
    }
    function registerLifecycleHook(register, hook) {
      if (isArray(hook)) {
        hook.forEach((_hook) => register(_hook.bind(publicThis)));
      } else if (hook) {
        register(hook.bind(publicThis));
      }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted7);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated3);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted7);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if (isArray(expose)) {
      if (expose.length) {
        const exposed = instance.exposed || (instance.exposed = {});
        expose.forEach((key) => {
          Object.defineProperty(exposed, key, {
            get: () => publicThis[key],
            set: (val) => publicThis[key] = val
          });
        });
      } else if (!instance.exposed) {
        instance.exposed = {};
      }
    }
    if (render7 && instance.render === NOOP) {
      instance.render = render7;
    }
    if (inheritAttrs != null) {
      instance.inheritAttrs = inheritAttrs;
    }
    if (components)
      instance.components = components;
    if (directives)
      instance.directives = directives;
  }
  function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
    if (isArray(injectOptions)) {
      injectOptions = normalizeInject(injectOptions);
    }
    for (const key in injectOptions) {
      const opt = injectOptions[key];
      let injected;
      if (isObject(opt)) {
        if ("default" in opt) {
          injected = inject(
            opt.from || key,
            opt.default,
            true
          );
        } else {
          injected = inject(opt.from || key);
        }
      } else {
        injected = inject(opt);
      }
      if (isRef(injected)) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => injected.value = v
        });
      } else {
        ctx[key] = injected;
      }
      if (true) {
        checkDuplicateProperties("Inject", key);
      }
    }
  }
  function callHook(hook, instance, type2) {
    callWithAsyncErrorHandling(
      isArray(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
      instance,
      type2
    );
  }
  function createWatcher(raw, ctx, publicThis, key) {
    const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
    if (isString(raw)) {
      const handler = ctx[raw];
      if (isFunction(handler)) {
        watch(getter, handler);
      } else if (true) {
        warn$1(`Invalid watch handler specified by key "${raw}"`, handler);
      }
    } else if (isFunction(raw)) {
      watch(getter, raw.bind(publicThis));
    } else if (isObject(raw)) {
      if (isArray(raw)) {
        raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
      } else {
        const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
        if (isFunction(handler)) {
          watch(getter, handler, raw);
        } else if (true) {
          warn$1(`Invalid watch handler specified by key "${raw.handler}"`, handler);
        }
      }
    } else if (true) {
      warn$1(`Invalid watch option: "${key}"`, raw);
    }
  }
  function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const {
      mixins: globalMixins,
      optionsCache: cache,
      config: { optionMergeStrategies }
    } = instance.appContext;
    const cached = cache.get(base);
    let resolved;
    if (cached) {
      resolved = cached;
    } else if (!globalMixins.length && !mixins && !extendsOptions) {
      {
        resolved = base;
      }
    } else {
      resolved = {};
      if (globalMixins.length) {
        globalMixins.forEach(
          (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
        );
      }
      mergeOptions(resolved, base, optionMergeStrategies);
    }
    if (isObject(base)) {
      cache.set(base, resolved);
    }
    return resolved;
  }
  function mergeOptions(to, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
      mergeOptions(to, extendsOptions, strats, true);
    }
    if (mixins) {
      mixins.forEach(
        (m) => mergeOptions(to, m, strats, true)
      );
    }
    for (const key in from) {
      if (asMixin && key === "expose") {
        warn$1(
          `"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`
        );
      } else {
        const strat = internalOptionMergeStrats[key] || strats && strats[key];
        to[key] = strat ? strat(to[key], from[key]) : from[key];
      }
    }
    return to;
  }
  var internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    watch: mergeWatchOptions,
    provide: mergeDataFn,
    inject: mergeInject
  };
  function mergeDataFn(to, from) {
    if (!from) {
      return to;
    }
    if (!to) {
      return from;
    }
    return function mergedDataFn() {
      return extend(
        isFunction(to) ? to.call(this, this) : to,
        isFunction(from) ? from.call(this, this) : from
      );
    };
  }
  function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
  }
  function normalizeInject(raw) {
    if (isArray(raw)) {
      const res = {};
      for (let i = 0; i < raw.length; i++) {
        res[raw[i]] = raw[i];
      }
      return res;
    }
    return raw;
  }
  function mergeAsArray(to, from) {
    return to ? [...new Set([].concat(to, from))] : from;
  }
  function mergeObjectOptions(to, from) {
    return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
  }
  function mergeEmitsOrPropsOptions(to, from) {
    if (to) {
      if (isArray(to) && isArray(from)) {
        return [.../* @__PURE__ */ new Set([...to, ...from])];
      }
      return extend(
        /* @__PURE__ */ Object.create(null),
        normalizePropsOrEmits(to),
        normalizePropsOrEmits(from != null ? from : {})
      );
    } else {
      return from;
    }
  }
  function mergeWatchOptions(to, from) {
    if (!to)
      return from;
    if (!from)
      return to;
    const merged = extend(/* @__PURE__ */ Object.create(null), to);
    for (const key in from) {
      merged[key] = mergeAsArray(to[key], from[key]);
    }
    return merged;
  }
  function createAppContext() {
    return {
      app: null,
      config: {
        isNativeTag: NO,
        performance: false,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: /* @__PURE__ */ Object.create(null),
      optionsCache: /* @__PURE__ */ new WeakMap(),
      propsCache: /* @__PURE__ */ new WeakMap(),
      emitsCache: /* @__PURE__ */ new WeakMap()
    };
  }
  var uid$1 = 0;
  function createAppAPI(render7, hydrate) {
    return function createApp2(rootComponent, rootProps = null) {
      if (!isFunction(rootComponent)) {
        rootComponent = extend({}, rootComponent);
      }
      if (rootProps != null && !isObject(rootProps)) {
        warn$1(`root props passed to app.mount() must be an object.`);
        rootProps = null;
      }
      const context = createAppContext();
      const installedPlugins = /* @__PURE__ */ new WeakSet();
      let isMounted = false;
      const app = context.app = {
        _uid: uid$1++,
        _component: rootComponent,
        _props: rootProps,
        _container: null,
        _context: context,
        _instance: null,
        version,
        get config() {
          return context.config;
        },
        set config(v) {
          if (true) {
            warn$1(
              `app.config cannot be replaced. Modify individual options instead.`
            );
          }
        },
        use(plugin, ...options) {
          if (installedPlugins.has(plugin)) {
            warn$1(`Plugin has already been applied to target app.`);
          } else if (plugin && isFunction(plugin.install)) {
            installedPlugins.add(plugin);
            plugin.install(app, ...options);
          } else if (isFunction(plugin)) {
            installedPlugins.add(plugin);
            plugin(app, ...options);
          } else if (true) {
            warn$1(
              `A plugin must either be a function or an object with an "install" function.`
            );
          }
          return app;
        },
        mixin(mixin) {
          if (true) {
            if (!context.mixins.includes(mixin)) {
              context.mixins.push(mixin);
            } else if (true) {
              warn$1(
                "Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : "")
              );
            }
          } else if (true) {
            warn$1("Mixins are only available in builds supporting Options API");
          }
          return app;
        },
        component(name, component) {
          if (true) {
            validateComponentName(name, context.config);
          }
          if (!component) {
            return context.components[name];
          }
          if (context.components[name]) {
            warn$1(`Component "${name}" has already been registered in target app.`);
          }
          context.components[name] = component;
          return app;
        },
        directive(name, directive2) {
          if (true) {
            validateDirectiveName(name);
          }
          if (!directive2) {
            return context.directives[name];
          }
          if (context.directives[name]) {
            warn$1(`Directive "${name}" has already been registered in target app.`);
          }
          context.directives[name] = directive2;
          return app;
        },
        mount(rootContainer, isHydrate, namespace) {
          if (!isMounted) {
            if (rootContainer.__vue_app__) {
              warn$1(
                `There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`
              );
            }
            const vnode = createVNode(rootComponent, rootProps);
            vnode.appContext = context;
            if (namespace === true) {
              namespace = "svg";
            } else if (namespace === false) {
              namespace = void 0;
            }
            if (true) {
              context.reload = () => {
                render7(
                  cloneVNode(vnode),
                  rootContainer,
                  namespace
                );
              };
            }
            if (isHydrate && hydrate) {
              hydrate(vnode, rootContainer);
            } else {
              render7(vnode, rootContainer, namespace);
            }
            isMounted = true;
            app._container = rootContainer;
            rootContainer.__vue_app__ = app;
            if (true) {
              app._instance = vnode.component;
              devtoolsInitApp(app, version);
            }
            return getExposeProxy(vnode.component) || vnode.component.proxy;
          } else if (true) {
            warn$1(
              `App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``
            );
          }
        },
        unmount() {
          if (isMounted) {
            render7(null, app._container);
            if (true) {
              app._instance = null;
              devtoolsUnmountApp(app);
            }
            delete app._container.__vue_app__;
          } else if (true) {
            warn$1(`Cannot unmount an app that is not mounted.`);
          }
        },
        provide(key, value) {
          if (key in context.provides) {
            warn$1(
              `App already provides property with key "${String(key)}". It will be overwritten with the new value.`
            );
          }
          context.provides[key] = value;
          return app;
        },
        runWithContext(fn) {
          const lastApp = currentApp;
          currentApp = app;
          try {
            return fn();
          } finally {
            currentApp = lastApp;
          }
        }
      };
      return app;
    };
  }
  var currentApp = null;
  function provide(key, value) {
    if (!currentInstance) {
      if (true) {
        warn$1(`provide() can only be used inside setup().`);
      }
    } else {
      let provides = currentInstance.provides;
      const parentProvides = currentInstance.parent && currentInstance.parent.provides;
      if (parentProvides === provides) {
        provides = currentInstance.provides = Object.create(parentProvides);
      }
      provides[key] = value;
    }
  }
  function inject(key, defaultValue2, treatDefaultAsFactory = false) {
    const instance = currentInstance || currentRenderingInstance;
    if (instance || currentApp) {
      const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
      if (provides && key in provides) {
        return provides[key];
      } else if (arguments.length > 1) {
        return treatDefaultAsFactory && isFunction(defaultValue2) ? defaultValue2.call(instance && instance.proxy) : defaultValue2;
      } else if (true) {
        warn$1(`injection "${String(key)}" not found.`);
      }
    } else if (true) {
      warn$1(`inject() can only be used inside setup() or functional components.`);
    }
  }
  function hasInjectionContext() {
    return !!(currentInstance || currentRenderingInstance || currentApp);
  }
  function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props = {};
    const attrs = {};
    def(attrs, InternalObjectKey, 1);
    instance.propsDefaults = /* @__PURE__ */ Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    for (const key in instance.propsOptions[0]) {
      if (!(key in props)) {
        props[key] = void 0;
      }
    }
    if (true) {
      validateProps(rawProps || {}, props, instance);
    }
    if (isStateful) {
      instance.props = isSSR ? props : shallowReactive(props);
    } else {
      if (!instance.type.props) {
        instance.props = attrs;
      } else {
        instance.props = props;
      }
    }
    instance.attrs = attrs;
  }
  function isInHmrContext(instance) {
    while (instance) {
      if (instance.type.__hmrId)
        return true;
      instance = instance.parent;
    }
  }
  function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const {
      props,
      attrs,
      vnode: { patchFlag }
    } = instance;
    const rawCurrentProps = toRaw(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (!isInHmrContext(instance) && (optimized || patchFlag > 0) && !(patchFlag & 16)) {
      if (patchFlag & 8) {
        const propsToUpdate = instance.vnode.dynamicProps;
        for (let i = 0; i < propsToUpdate.length; i++) {
          let key = propsToUpdate[i];
          if (isEmitListener(instance.emitsOptions, key)) {
            continue;
          }
          const value = rawProps[key];
          if (options) {
            if (hasOwn(attrs, key)) {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            } else {
              const camelizedKey = camelize(key);
              props[camelizedKey] = resolvePropValue(
                options,
                rawCurrentProps,
                camelizedKey,
                value,
                instance,
                false
              );
            }
          } else {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
    } else {
      if (setFullProps(instance, rawProps, props, attrs)) {
        hasAttrsChanged = true;
      }
      let kebabKey;
      for (const key in rawCurrentProps) {
        if (!rawProps || !hasOwn(rawProps, key) && ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
          if (options) {
            if (rawPrevProps && (rawPrevProps[key] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
              props[key] = resolvePropValue(
                options,
                rawCurrentProps,
                key,
                void 0,
                instance,
                true
              );
            }
          } else {
            delete props[key];
          }
        }
      }
      if (attrs !== rawCurrentProps) {
        for (const key in attrs) {
          if (!rawProps || !hasOwn(rawProps, key) && true) {
            delete attrs[key];
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (hasAttrsChanged) {
      trigger(instance, "set", "$attrs");
    }
    if (true) {
      validateProps(rawProps || {}, props, instance);
    }
  }
  function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
      for (let key in rawProps) {
        if (isReservedProp(key)) {
          continue;
        }
        const value = rawProps[key];
        let camelKey;
        if (options && hasOwn(options, camelKey = camelize(key))) {
          if (!needCastKeys || !needCastKeys.includes(camelKey)) {
            props[camelKey] = value;
          } else {
            (rawCastValues || (rawCastValues = {}))[camelKey] = value;
          }
        } else if (!isEmitListener(instance.emitsOptions, key)) {
          if (!(key in attrs) || value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (needCastKeys) {
      const rawCurrentProps = toRaw(props);
      const castValues = rawCastValues || EMPTY_OBJ;
      for (let i = 0; i < needCastKeys.length; i++) {
        const key = needCastKeys[i];
        props[key] = resolvePropValue(
          options,
          rawCurrentProps,
          key,
          castValues[key],
          instance,
          !hasOwn(castValues, key)
        );
      }
    }
    return hasAttrsChanged;
  }
  function resolvePropValue(options, props, key, value, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
      const hasDefault = hasOwn(opt, "default");
      if (hasDefault && value === void 0) {
        const defaultValue2 = opt.default;
        if (opt.type !== Function && !opt.skipFactory && isFunction(defaultValue2)) {
          const { propsDefaults } = instance;
          if (key in propsDefaults) {
            value = propsDefaults[key];
          } else {
            const reset = setCurrentInstance(instance);
            value = propsDefaults[key] = defaultValue2.call(
              null,
              props
            );
            reset();
          }
        } else {
          value = defaultValue2;
        }
      }
      if (opt[0]) {
        if (isAbsent && !hasDefault) {
          value = false;
        } else if (opt[1] && (value === "" || value === hyphenate(key))) {
          value = true;
        }
      }
    }
    return value;
  }
  function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.propsCache;
    const cached = cache.get(comp);
    if (cached) {
      return cached;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (!isFunction(comp)) {
      const extendProps = (raw2) => {
        hasExtends = true;
        const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
        extend(normalized, props);
        if (keys2)
          needCastKeys.push(...keys2);
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendProps);
      }
      if (comp.extends) {
        extendProps(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendProps);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject(comp)) {
        cache.set(comp, EMPTY_ARR);
      }
      return EMPTY_ARR;
    }
    if (isArray(raw)) {
      for (let i = 0; i < raw.length; i++) {
        if (!isString(raw[i])) {
          warn$1(`props must be strings when using array syntax.`, raw[i]);
        }
        const normalizedKey = camelize(raw[i]);
        if (validatePropName(normalizedKey)) {
          normalized[normalizedKey] = EMPTY_OBJ;
        }
      }
    } else if (raw) {
      if (!isObject(raw)) {
        warn$1(`invalid props options`, raw);
      }
      for (const key in raw) {
        const normalizedKey = camelize(key);
        if (validatePropName(normalizedKey)) {
          const opt = raw[key];
          const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : extend({}, opt);
          if (prop) {
            const booleanIndex = getTypeIndex(Boolean, prop.type);
            const stringIndex = getTypeIndex(String, prop.type);
            prop[0] = booleanIndex > -1;
            prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
            if (booleanIndex > -1 || hasOwn(prop, "default")) {
              needCastKeys.push(normalizedKey);
            }
          }
        }
      }
    }
    const res = [normalized, needCastKeys];
    if (isObject(comp)) {
      cache.set(comp, res);
    }
    return res;
  }
  function validatePropName(key) {
    if (key[0] !== "$" && !isReservedProp(key)) {
      return true;
    } else if (true) {
      warn$1(`Invalid prop name: "${key}" is a reserved property.`);
    }
    return false;
  }
  function getType(ctor) {
    if (ctor === null) {
      return "null";
    }
    if (typeof ctor === "function") {
      return ctor.name || "";
    } else if (typeof ctor === "object") {
      const name = ctor.constructor && ctor.constructor.name;
      return name || "";
    }
    return "";
  }
  function isSameType(a, b) {
    return getType(a) === getType(b);
  }
  function getTypeIndex(type2, expectedTypes) {
    if (isArray(expectedTypes)) {
      return expectedTypes.findIndex((t) => isSameType(t, type2));
    } else if (isFunction(expectedTypes)) {
      return isSameType(expectedTypes, type2) ? 0 : -1;
    }
    return -1;
  }
  function validateProps(rawProps, props, instance) {
    const resolvedValues = toRaw(props);
    const options = instance.propsOptions[0];
    for (const key in options) {
      let opt = options[key];
      if (opt == null)
        continue;
      validateProp(
        key,
        resolvedValues[key],
        opt,
        true ? shallowReadonly(resolvedValues) : resolvedValues,
        !hasOwn(rawProps, key) && !hasOwn(rawProps, hyphenate(key))
      );
    }
  }
  function validateProp(name, value, prop, props, isAbsent) {
    const { type: type2, required, validator, skipCheck } = prop;
    if (required && isAbsent) {
      warn$1('Missing required prop: "' + name + '"');
      return;
    }
    if (value == null && !required) {
      return;
    }
    if (type2 != null && type2 !== true && !skipCheck) {
      let isValid2 = false;
      const types = isArray(type2) ? type2 : [type2];
      const expectedTypes = [];
      for (let i = 0; i < types.length && !isValid2; i++) {
        const { valid, expectedType } = assertType(value, types[i]);
        expectedTypes.push(expectedType || "");
        isValid2 = valid;
      }
      if (!isValid2) {
        warn$1(getInvalidTypeMessage(name, value, expectedTypes));
        return;
      }
    }
    if (validator && !validator(value, props)) {
      warn$1('Invalid prop: custom validator check failed for prop "' + name + '".');
    }
  }
  var isSimpleType = /* @__PURE__ */ makeMap(
    "String,Number,Boolean,Function,Symbol,BigInt"
  );
  function assertType(value, type2) {
    let valid;
    const expectedType = getType(type2);
    if (isSimpleType(expectedType)) {
      const t = typeof value;
      valid = t === expectedType.toLowerCase();
      if (!valid && t === "object") {
        valid = value instanceof type2;
      }
    } else if (expectedType === "Object") {
      valid = isObject(value);
    } else if (expectedType === "Array") {
      valid = isArray(value);
    } else if (expectedType === "null") {
      valid = value === null;
    } else {
      valid = value instanceof type2;
    }
    return {
      valid,
      expectedType
    };
  }
  function getInvalidTypeMessage(name, value, expectedTypes) {
    if (expectedTypes.length === 0) {
      return `Prop type [] for prop "${name}" won't match anything. Did you mean to use type Array instead?`;
    }
    let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize).join(" | ")}`;
    const expectedType = expectedTypes[0];
    const receivedType = toRawType(value);
    const expectedValue = styleValue(value, expectedType);
    const receivedValue = styleValue(value, receivedType);
    if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
      message += ` with value ${expectedValue}`;
    }
    message += `, got ${receivedType} `;
    if (isExplicable(receivedType)) {
      message += `with value ${receivedValue}.`;
    }
    return message;
  }
  function styleValue(value, type2) {
    if (type2 === "String") {
      return `"${value}"`;
    } else if (type2 === "Number") {
      return `${Number(value)}`;
    } else {
      return `${value}`;
    }
  }
  function isExplicable(type2) {
    const explicitTypes = ["string", "number", "boolean"];
    return explicitTypes.some((elem) => type2.toLowerCase() === elem);
  }
  function isBoolean(...args) {
    return args.some((elem) => elem.toLowerCase() === "boolean");
  }
  var isInternalKey = (key) => key[0] === "_" || key === "$stable";
  var normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
  var normalizeSlot = (key, rawSlot, ctx) => {
    if (rawSlot._n) {
      return rawSlot;
    }
    const normalized = withCtx((...args) => {
      if (currentInstance && (!ctx || ctx.root === currentInstance.root)) {
        warn$1(
          `Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
        );
      }
      return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
  };
  var normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx = rawSlots._ctx;
    for (const key in rawSlots) {
      if (isInternalKey(key))
        continue;
      const value = rawSlots[key];
      if (isFunction(value)) {
        slots[key] = normalizeSlot(key, value, ctx);
      } else if (value != null) {
        if (true) {
          warn$1(
            `Non-function value encountered for slot "${key}". Prefer function slots for better performance.`
          );
        }
        const normalized = normalizeSlotValue(value);
        slots[key] = () => normalized;
      }
    }
  };
  var normalizeVNodeSlots = (instance, children) => {
    if (!isKeepAlive(instance.vnode) && true) {
      warn$1(
        `Non-function value encountered for default slot. Prefer function slots for better performance.`
      );
    }
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
  };
  var initSlots = (instance, children) => {
    if (instance.vnode.shapeFlag & 32) {
      const type2 = children._;
      if (type2) {
        instance.slots = toRaw(children);
        def(children, "_", type2);
      } else {
        normalizeObjectSlots(
          children,
          instance.slots = {}
        );
      }
    } else {
      instance.slots = {};
      if (children) {
        normalizeVNodeSlots(instance, children);
      }
    }
    def(instance.slots, InternalObjectKey, 1);
  };
  var updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = EMPTY_OBJ;
    if (vnode.shapeFlag & 32) {
      const type2 = children._;
      if (type2) {
        if (isHmrUpdating) {
          extend(slots, children);
          trigger(instance, "set", "$slots");
        } else if (optimized && type2 === 1) {
          needDeletionCheck = false;
        } else {
          extend(slots, children);
          if (!optimized && type2 === 1) {
            delete slots._;
          }
        }
      } else {
        needDeletionCheck = !children.$stable;
        normalizeObjectSlots(children, slots);
      }
      deletionComparisonTarget = children;
    } else if (children) {
      normalizeVNodeSlots(instance, children);
      deletionComparisonTarget = { default: 1 };
    }
    if (needDeletionCheck) {
      for (const key in slots) {
        if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
          delete slots[key];
        }
      }
    }
  };
  function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if (isArray(rawRef)) {
      rawRef.forEach(
        (r, i) => setRef(
          r,
          oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),
          parentSuspense,
          vnode,
          isUnmount
        )
      );
      return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
      return;
    }
    const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref2 } = rawRef;
    if (!owner) {
      warn$1(
        `Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`
      );
      return;
    }
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    if (oldRef != null && oldRef !== ref2) {
      if (isString(oldRef)) {
        refs[oldRef] = null;
        if (hasOwn(setupState, oldRef)) {
          setupState[oldRef] = null;
        }
      } else if (isRef(oldRef)) {
        oldRef.value = null;
      }
    }
    if (isFunction(ref2)) {
      callWithErrorHandling(ref2, owner, 12, [value, refs]);
    } else {
      const _isString = isString(ref2);
      const _isRef = isRef(ref2);
      if (_isString || _isRef) {
        const doSet = () => {
          if (rawRef.f) {
            const existing = _isString ? hasOwn(setupState, ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
            if (isUnmount) {
              isArray(existing) && remove(existing, refValue);
            } else {
              if (!isArray(existing)) {
                if (_isString) {
                  refs[ref2] = [refValue];
                  if (hasOwn(setupState, ref2)) {
                    setupState[ref2] = refs[ref2];
                  }
                } else {
                  ref2.value = [refValue];
                  if (rawRef.k)
                    refs[rawRef.k] = ref2.value;
                }
              } else if (!existing.includes(refValue)) {
                existing.push(refValue);
              }
            }
          } else if (_isString) {
            refs[ref2] = value;
            if (hasOwn(setupState, ref2)) {
              setupState[ref2] = value;
            }
          } else if (_isRef) {
            ref2.value = value;
            if (rawRef.k)
              refs[rawRef.k] = value;
          } else if (true) {
            warn$1("Invalid template ref type:", ref2, `(${typeof ref2})`);
          }
        };
        if (value) {
          doSet.id = -1;
          queuePostRenderEffect(doSet, parentSuspense);
        } else {
          doSet();
        }
      } else if (true) {
        warn$1("Invalid template ref type:", ref2, `(${typeof ref2})`);
      }
    }
  }
  var supported;
  var perf;
  function startMeasure(instance, type2) {
    if (instance.appContext.config.performance && isSupported()) {
      perf.mark(`vue-${type2}-${instance.uid}`);
    }
    if (true) {
      devtoolsPerfStart(instance, type2, isSupported() ? perf.now() : Date.now());
    }
  }
  function endMeasure(instance, type2) {
    if (instance.appContext.config.performance && isSupported()) {
      const startTag = `vue-${type2}-${instance.uid}`;
      const endTag = startTag + `:end`;
      perf.mark(endTag);
      perf.measure(
        `<${formatComponentName(instance, instance.type)}> ${type2}`,
        startTag,
        endTag
      );
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
    }
    if (true) {
      devtoolsPerfEnd(instance, type2, isSupported() ? perf.now() : Date.now());
    }
  }
  function isSupported() {
    if (supported !== void 0) {
      return supported;
    }
    if (typeof window !== "undefined" && window.performance) {
      supported = true;
      perf = window.performance;
    } else {
      supported = false;
    }
    return supported;
  }
  function initFeatureFlags() {
    const needWarn = [];
    if (false) {
      needWarn.push(`__VUE_OPTIONS_API__`);
      getGlobalThis().__VUE_OPTIONS_API__ = true;
    }
    if (false) {
      needWarn.push(`__VUE_PROD_DEVTOOLS__`);
      getGlobalThis().__VUE_PROD_DEVTOOLS__ = false;
    }
    if (typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ !== "boolean") {
      needWarn.push(`__VUE_PROD_HYDRATION_MISMATCH_DETAILS__`);
      getGlobalThis().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = false;
    }
    if (needWarn.length) {
      const multi = needWarn.length > 1;
      console.warn(
        `Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
      );
    }
  }
  var queuePostRenderEffect = queueEffectWithSuspense;
  function createRenderer(options) {
    return baseCreateRenderer(options);
  }
  function baseCreateRenderer(options, createHydrationFns) {
    {
      initFeatureFlags();
    }
    const target = getGlobalThis();
    target.__VUE__ = true;
    if (true) {
      setDevtoolsHook$1(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
    }
    const {
      insert: hostInsert,
      remove: hostRemove,
      patchProp: hostPatchProp,
      createElement: hostCreateElement,
      createText: hostCreateText,
      createComment: hostCreateComment,
      setText: hostSetText,
      setElementText: hostSetElementText,
      parentNode: hostParentNode,
      nextSibling: hostNextSibling,
      setScopeId: hostSetScopeId = NOOP,
      insertStaticContent: hostInsertStaticContent
    } = options;
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren) => {
      if (n1 === n2) {
        return;
      }
      if (n1 && !isSameVNodeType(n1, n2)) {
        anchor = getNextHostNode(n1);
        unmount(n1, parentComponent, parentSuspense, true);
        n1 = null;
      }
      if (n2.patchFlag === -2) {
        optimized = false;
        n2.dynamicChildren = null;
      }
      const { type: type2, ref: ref2, shapeFlag } = n2;
      switch (type2) {
        case Text:
          processText(n1, n2, container, anchor);
          break;
        case Comment:
          processCommentNode(n1, n2, container, anchor);
          break;
        case Static:
          if (n1 == null) {
            mountStaticNode(n2, container, anchor, namespace);
          } else if (true) {
            patchStaticNode(n1, n2, container, namespace);
          }
          break;
        case Fragment:
          processFragment(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          break;
        default:
          if (shapeFlag & 1) {
            processElement(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 6) {
            processComponent(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 64) {
            type2.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else if (shapeFlag & 128) {
            type2.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else if (true) {
            warn$1("Invalid VNode type:", type2, `(${typeof type2})`);
          }
      }
      if (ref2 != null && parentComponent) {
        setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
      }
    };
    const processText = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateText(n2.children),
          container,
          anchor
        );
      } else {
        const el = n2.el = n1.el;
        if (n2.children !== n1.children) {
          hostSetText(el, n2.children);
        }
      }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateComment(n2.children || ""),
          container,
          anchor
        );
      } else {
        n2.el = n1.el;
      }
    };
    const mountStaticNode = (n2, container, anchor, namespace) => {
      [n2.el, n2.anchor] = hostInsertStaticContent(
        n2.children,
        container,
        anchor,
        namespace,
        n2.el,
        n2.anchor
      );
    };
    const patchStaticNode = (n1, n2, container, namespace) => {
      if (n2.children !== n1.children) {
        const anchor = hostNextSibling(n1.anchor);
        removeStaticNode(n1);
        [n2.el, n2.anchor] = hostInsertStaticContent(
          n2.children,
          container,
          anchor,
          namespace
        );
      } else {
        n2.el = n1.el;
        n2.anchor = n1.anchor;
      }
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostInsert(el, container, nextSibling);
        el = next;
      }
      hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostRemove(el);
        el = next;
      }
      hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      if (n2.type === "svg") {
        namespace = "svg";
      } else if (n2.type === "math") {
        namespace = "mathml";
      }
      if (n1 == null) {
        mountElement(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        patchElement(
          n1,
          n2,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let el;
      let vnodeHook;
      const { props, shapeFlag, transition, dirs } = vnode;
      el = vnode.el = hostCreateElement(
        vnode.type,
        namespace,
        props && props.is,
        props
      );
      if (shapeFlag & 8) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(
          vnode.children,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(vnode, namespace),
          slotScopeIds,
          optimized
        );
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
      if (props) {
        for (const key in props) {
          if (key !== "value" && !isReservedProp(key)) {
            hostPatchProp(
              el,
              key,
              null,
              props[key],
              namespace,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
        if ("value" in props) {
          hostPatchProp(el, "value", null, props.value, namespace);
        }
        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      if (true) {
        Object.defineProperty(el, "__vnode", {
          value: vnode,
          enumerable: false
        });
        Object.defineProperty(el, "__vueParentComponent", {
          value: parentComponent,
          enumerable: false
        });
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      const needCallTransitionHooks = needTransition(parentSuspense, transition);
      if (needCallTransitionHooks) {
        transition.beforeEnter(el);
      }
      hostInsert(el, container, anchor);
      if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
      if (scopeId) {
        hostSetScopeId(el, scopeId);
      }
      if (slotScopeIds) {
        for (let i = 0; i < slotScopeIds.length; i++) {
          hostSetScopeId(el, slotScopeIds[i]);
        }
      }
      if (parentComponent) {
        let subTree = parentComponent.subTree;
        if (subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
          subTree = filterSingleRoot(subTree.children) || subTree;
        }
        if (vnode === subTree) {
          const parentVNode = parentComponent.vnode;
          setScopeId(
            el,
            parentVNode,
            parentVNode.scopeId,
            parentVNode.slotScopeIds,
            parentComponent.parent
          );
        }
      }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
      for (let i = start; i < children.length; i++) {
        const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
        patch(
          null,
          child,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const el = n2.el = n1.el;
      let { patchFlag, dynamicChildren, dirs } = n2;
      patchFlag |= n1.patchFlag & 16;
      const oldProps = n1.props || EMPTY_OBJ;
      const newProps = n2.props || EMPTY_OBJ;
      let vnodeHook;
      parentComponent && toggleRecurse(parentComponent, false);
      if (vnodeHook = newProps.onVnodeBeforeUpdate) {
        invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
      }
      if (dirs) {
        invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
      }
      parentComponent && toggleRecurse(parentComponent, true);
      if (isHmrUpdating) {
        patchFlag = 0;
        optimized = false;
        dynamicChildren = null;
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          el,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds
        );
        if (true) {
          traverseStaticChildren(n1, n2);
        }
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds,
          false
        );
      }
      if (patchFlag > 0) {
        if (patchFlag & 16) {
          patchProps(
            el,
            n2,
            oldProps,
            newProps,
            parentComponent,
            parentSuspense,
            namespace
          );
        } else {
          if (patchFlag & 2) {
            if (oldProps.class !== newProps.class) {
              hostPatchProp(el, "class", null, newProps.class, namespace);
            }
          }
          if (patchFlag & 4) {
            hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
          }
          if (patchFlag & 8) {
            const propsToUpdate = n2.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
              const key = propsToUpdate[i];
              const prev = oldProps[key];
              const next = newProps[key];
              if (next !== prev || key === "value") {
                hostPatchProp(
                  el,
                  key,
                  prev,
                  next,
                  namespace,
                  n1.children,
                  parentComponent,
                  parentSuspense,
                  unmountChildren
                );
              }
            }
          }
        }
        if (patchFlag & 1) {
          if (n1.children !== n2.children) {
            hostSetElementText(el, n2.children);
          }
        }
      } else if (!optimized && dynamicChildren == null) {
        patchProps(
          el,
          n2,
          oldProps,
          newProps,
          parentComponent,
          parentSuspense,
          namespace
        );
      }
      if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
        }, parentSuspense);
      }
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
      for (let i = 0; i < newChildren.length; i++) {
        const oldVNode = oldChildren[i];
        const newVNode = newChildren[i];
        const container = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
        patch(
          oldVNode,
          newVNode,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          true
        );
      }
    };
    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, namespace) => {
      if (oldProps !== newProps) {
        if (oldProps !== EMPTY_OBJ) {
          for (const key in oldProps) {
            if (!isReservedProp(key) && !(key in newProps)) {
              hostPatchProp(
                el,
                key,
                oldProps[key],
                null,
                namespace,
                vnode.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
        }
        for (const key in newProps) {
          if (isReservedProp(key))
            continue;
          const next = newProps[key];
          const prev = oldProps[key];
          if (next !== prev && key !== "value") {
            hostPatchProp(
              el,
              key,
              prev,
              next,
              namespace,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
        if ("value" in newProps) {
          hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
        }
      }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
      const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
      let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
      if (isHmrUpdating || patchFlag & 2048) {
        patchFlag = 0;
        optimized = false;
        dynamicChildren = null;
      }
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      if (n1 == null) {
        hostInsert(fragmentStartAnchor, container, anchor);
        hostInsert(fragmentEndAnchor, container, anchor);
        mountChildren(
          n2.children || [],
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            container,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds
          );
          if (true) {
            traverseStaticChildren(n1, n2);
          } else if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
            traverseStaticChildren(
              n1,
              n2,
              true
            );
          }
        } else {
          patchChildren(
            n1,
            n2,
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      n2.slotScopeIds = slotScopeIds;
      if (n1 == null) {
        if (n2.shapeFlag & 512) {
          parentComponent.ctx.activate(
            n2,
            container,
            anchor,
            namespace,
            optimized
          );
        } else {
          mountComponent(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            optimized
          );
        }
      } else {
        updateComponent(n1, n2, optimized);
      }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
      const instance = initialVNode.component = createComponentInstance(
        initialVNode,
        parentComponent,
        parentSuspense
      );
      if (instance.type.__hmrId) {
        registerHMR(instance);
      }
      if (true) {
        pushWarningContext(initialVNode);
        startMeasure(instance, `mount`);
      }
      if (isKeepAlive(initialVNode)) {
        instance.ctx.renderer = internals;
      }
      {
        if (true) {
          startMeasure(instance, `init`);
        }
        setupComponent(instance);
        if (true) {
          endMeasure(instance, `init`);
        }
      }
      if (instance.asyncDep) {
        parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
        if (!initialVNode.el) {
          const placeholder = instance.subTree = createVNode(Comment);
          processCommentNode(null, placeholder, container, anchor);
        }
      } else {
        setupRenderEffect(
          instance,
          initialVNode,
          container,
          anchor,
          parentSuspense,
          namespace,
          optimized
        );
      }
      if (true) {
        popWarningContext();
        endMeasure(instance, `mount`);
      }
    };
    const updateComponent = (n1, n2, optimized) => {
      const instance = n2.component = n1.component;
      if (shouldUpdateComponent(n1, n2, optimized)) {
        if (instance.asyncDep && !instance.asyncResolved) {
          if (true) {
            pushWarningContext(n2);
          }
          updateComponentPreRender(instance, n2, optimized);
          if (true) {
            popWarningContext();
          }
          return;
        } else {
          instance.next = n2;
          invalidateJob(instance.update);
          instance.effect.dirty = true;
          instance.update();
        }
      } else {
        n2.el = n1.el;
        instance.vnode = n2;
      }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
      const componentUpdateFn = () => {
        if (!instance.isMounted) {
          let vnodeHook;
          const { el, props } = initialVNode;
          const { bm, m, parent: parent2 } = instance;
          const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
          toggleRecurse(instance, false);
          if (bm) {
            invokeArrayFns(bm);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
            invokeVNodeHook(vnodeHook, parent2, initialVNode);
          }
          toggleRecurse(instance, true);
          if (el && hydrateNode) {
            const hydrateSubTree = () => {
              if (true) {
                startMeasure(instance, `render`);
              }
              instance.subTree = renderComponentRoot(instance);
              if (true) {
                endMeasure(instance, `render`);
              }
              if (true) {
                startMeasure(instance, `hydrate`);
              }
              hydrateNode(
                el,
                instance.subTree,
                instance,
                parentSuspense,
                null
              );
              if (true) {
                endMeasure(instance, `hydrate`);
              }
            };
            if (isAsyncWrapperVNode) {
              initialVNode.type.__asyncLoader().then(
                () => !instance.isUnmounted && hydrateSubTree()
              );
            } else {
              hydrateSubTree();
            }
          } else {
            if (true) {
              startMeasure(instance, `render`);
            }
            const subTree = instance.subTree = renderComponentRoot(instance);
            if (true) {
              endMeasure(instance, `render`);
            }
            if (true) {
              startMeasure(instance, `patch`);
            }
            patch(
              null,
              subTree,
              container,
              anchor,
              instance,
              parentSuspense,
              namespace
            );
            if (true) {
              endMeasure(instance, `patch`);
            }
            initialVNode.el = subTree.el;
          }
          if (m) {
            queuePostRenderEffect(m, parentSuspense);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
            const scopedInitialVNode = initialVNode;
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent2, scopedInitialVNode),
              parentSuspense
            );
          }
          if (initialVNode.shapeFlag & 256 || parent2 && isAsyncWrapper(parent2.vnode) && parent2.vnode.shapeFlag & 256) {
            instance.a && queuePostRenderEffect(instance.a, parentSuspense);
          }
          instance.isMounted = true;
          if (true) {
            devtoolsComponentAdded(instance);
          }
          initialVNode = container = anchor = null;
        } else {
          let { next, bu, u, parent: parent2, vnode } = instance;
          {
            const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
            if (nonHydratedAsyncRoot) {
              if (next) {
                next.el = vnode.el;
                updateComponentPreRender(instance, next, optimized);
              }
              nonHydratedAsyncRoot.asyncDep.then(() => {
                if (!instance.isUnmounted) {
                  componentUpdateFn();
                }
              });
              return;
            }
          }
          let originNext = next;
          let vnodeHook;
          if (true) {
            pushWarningContext(next || instance.vnode);
          }
          toggleRecurse(instance, false);
          if (next) {
            next.el = vnode.el;
            updateComponentPreRender(instance, next, optimized);
          } else {
            next = vnode;
          }
          if (bu) {
            invokeArrayFns(bu);
          }
          if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parent2, next, vnode);
          }
          toggleRecurse(instance, true);
          if (true) {
            startMeasure(instance, `render`);
          }
          const nextTree = renderComponentRoot(instance);
          if (true) {
            endMeasure(instance, `render`);
          }
          const prevTree = instance.subTree;
          instance.subTree = nextTree;
          if (true) {
            startMeasure(instance, `patch`);
          }
          patch(
            prevTree,
            nextTree,
            hostParentNode(prevTree.el),
            getNextHostNode(prevTree),
            instance,
            parentSuspense,
            namespace
          );
          if (true) {
            endMeasure(instance, `patch`);
          }
          next.el = nextTree.el;
          if (originNext === null) {
            updateHOCHostEl(instance, nextTree.el);
          }
          if (u) {
            queuePostRenderEffect(u, parentSuspense);
          }
          if (vnodeHook = next.props && next.props.onVnodeUpdated) {
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent2, next, vnode),
              parentSuspense
            );
          }
          if (true) {
            devtoolsComponentUpdated(instance);
          }
          if (true) {
            popWarningContext();
          }
        }
      };
      const effect2 = instance.effect = new ReactiveEffect(
        componentUpdateFn,
        NOOP,
        () => queueJob(update),
        instance.scope
      );
      const update = instance.update = () => {
        if (effect2.dirty) {
          effect2.run();
        }
      };
      update.id = instance.uid;
      toggleRecurse(instance, true);
      if (true) {
        effect2.onTrack = instance.rtc ? (e) => invokeArrayFns(instance.rtc, e) : void 0;
        effect2.onTrigger = instance.rtg ? (e) => invokeArrayFns(instance.rtg, e) : void 0;
        update.ownerInstance = instance;
      }
      update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
      nextVNode.component = instance;
      const prevProps = instance.vnode.props;
      instance.vnode = nextVNode;
      instance.next = null;
      updateProps(instance, nextVNode.props, prevProps, optimized);
      updateSlots(instance, nextVNode.children, optimized);
      pauseTracking();
      flushPreFlushCbs(instance);
      resetTracking();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
      const c1 = n1 && n1.children;
      const prevShapeFlag = n1 ? n1.shapeFlag : 0;
      const c2 = n2.children;
      const { patchFlag, shapeFlag } = n2;
      if (patchFlag > 0) {
        if (patchFlag & 128) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        } else if (patchFlag & 256) {
          patchUnkeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        }
      }
      if (shapeFlag & 8) {
        if (prevShapeFlag & 16) {
          unmountChildren(c1, parentComponent, parentSuspense);
        }
        if (c2 !== c1) {
          hostSetElementText(container, c2);
        }
      } else {
        if (prevShapeFlag & 16) {
          if (shapeFlag & 16) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            unmountChildren(c1, parentComponent, parentSuspense, true);
          }
        } else {
          if (prevShapeFlag & 8) {
            hostSetElementText(container, "");
          }
          if (shapeFlag & 16) {
            mountChildren(
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        }
      }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      c1 = c1 || EMPTY_ARR;
      c2 = c2 || EMPTY_ARR;
      const oldLength = c1.length;
      const newLength = c2.length;
      const commonLength = Math.min(oldLength, newLength);
      let i;
      for (i = 0; i < commonLength; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        patch(
          c1[i],
          nextChild,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
      if (oldLength > newLength) {
        unmountChildren(
          c1,
          parentComponent,
          parentSuspense,
          true,
          false,
          commonLength
        );
      } else {
        mountChildren(
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized,
          commonLength
        );
      }
    };
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let i = 0;
      const l2 = c2.length;
      let e1 = c1.length - 1;
      let e2 = l2 - 1;
      while (i <= e1 && i <= e2) {
        const n1 = c1[i];
        const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        i++;
      }
      while (i <= e1 && i <= e2) {
        const n1 = c1[e1];
        const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        e1--;
        e2--;
      }
      if (i > e1) {
        if (i <= e2) {
          const nextPos = e2 + 1;
          const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
          while (i <= e2) {
            patch(
              null,
              c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            i++;
          }
        }
      } else if (i > e2) {
        while (i <= e1) {
          unmount(c1[i], parentComponent, parentSuspense, true);
          i++;
        }
      } else {
        const s1 = i;
        const s2 = i;
        const keyToNewIndexMap = /* @__PURE__ */ new Map();
        for (i = s2; i <= e2; i++) {
          const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (nextChild.key != null) {
            if (keyToNewIndexMap.has(nextChild.key)) {
              warn$1(
                `Duplicate keys found during update:`,
                JSON.stringify(nextChild.key),
                `Make sure keys are unique.`
              );
            }
            keyToNewIndexMap.set(nextChild.key, i);
          }
        }
        let j;
        let patched = 0;
        const toBePatched = e2 - s2 + 1;
        let moved = false;
        let maxNewIndexSoFar = 0;
        const newIndexToOldIndexMap = new Array(toBePatched);
        for (i = 0; i < toBePatched; i++)
          newIndexToOldIndexMap[i] = 0;
        for (i = s1; i <= e1; i++) {
          const prevChild = c1[i];
          if (patched >= toBePatched) {
            unmount(prevChild, parentComponent, parentSuspense, true);
            continue;
          }
          let newIndex;
          if (prevChild.key != null) {
            newIndex = keyToNewIndexMap.get(prevChild.key);
          } else {
            for (j = s2; j <= e2; j++) {
              if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                newIndex = j;
                break;
              }
            }
          }
          if (newIndex === void 0) {
            unmount(prevChild, parentComponent, parentSuspense, true);
          } else {
            newIndexToOldIndexMap[newIndex - s2] = i + 1;
            if (newIndex >= maxNewIndexSoFar) {
              maxNewIndexSoFar = newIndex;
            } else {
              moved = true;
            }
            patch(
              prevChild,
              c2[newIndex],
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            patched++;
          }
        }
        const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
        j = increasingNewIndexSequence.length - 1;
        for (i = toBePatched - 1; i >= 0; i--) {
          const nextIndex = s2 + i;
          const nextChild = c2[nextIndex];
          const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
          if (newIndexToOldIndexMap[i] === 0) {
            patch(
              null,
              nextChild,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (moved) {
            if (j < 0 || i !== increasingNewIndexSequence[j]) {
              move(nextChild, container, anchor, 2);
            } else {
              j--;
            }
          }
        }
      }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
      const { el, type: type2, transition, children, shapeFlag } = vnode;
      if (shapeFlag & 6) {
        move(vnode.component.subTree, container, anchor, moveType);
        return;
      }
      if (shapeFlag & 128) {
        vnode.suspense.move(container, anchor, moveType);
        return;
      }
      if (shapeFlag & 64) {
        type2.move(vnode, container, anchor, internals);
        return;
      }
      if (type2 === Fragment) {
        hostInsert(el, container, anchor);
        for (let i = 0; i < children.length; i++) {
          move(children[i], container, anchor, moveType);
        }
        hostInsert(vnode.anchor, container, anchor);
        return;
      }
      if (type2 === Static) {
        moveStaticNode(vnode, container, anchor);
        return;
      }
      const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
      if (needTransition2) {
        if (moveType === 0) {
          transition.beforeEnter(el);
          hostInsert(el, container, anchor);
          queuePostRenderEffect(() => transition.enter(el), parentSuspense);
        } else {
          const { leave, delayLeave, afterLeave } = transition;
          const remove22 = () => hostInsert(el, container, anchor);
          const performLeave = () => {
            leave(el, () => {
              remove22();
              afterLeave && afterLeave();
            });
          };
          if (delayLeave) {
            delayLeave(el, remove22, performLeave);
          } else {
            performLeave();
          }
        }
      } else {
        hostInsert(el, container, anchor);
      }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
      const {
        type: type2,
        props,
        ref: ref2,
        children,
        dynamicChildren,
        shapeFlag,
        patchFlag,
        dirs
      } = vnode;
      if (ref2 != null) {
        setRef(ref2, null, parentSuspense, vnode, true);
      }
      if (shapeFlag & 256) {
        parentComponent.ctx.deactivate(vnode);
        return;
      }
      const shouldInvokeDirs = shapeFlag & 1 && dirs;
      const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
      let vnodeHook;
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
      if (shapeFlag & 6) {
        unmountComponent(vnode.component, parentSuspense, doRemove);
      } else {
        if (shapeFlag & 128) {
          vnode.suspense.unmount(parentSuspense, doRemove);
          return;
        }
        if (shouldInvokeDirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
        }
        if (shapeFlag & 64) {
          vnode.type.remove(
            vnode,
            parentComponent,
            parentSuspense,
            optimized,
            internals,
            doRemove
          );
        } else if (dynamicChildren && (type2 !== Fragment || patchFlag > 0 && patchFlag & 64)) {
          unmountChildren(
            dynamicChildren,
            parentComponent,
            parentSuspense,
            false,
            true
          );
        } else if (type2 === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
          unmountChildren(children, parentComponent, parentSuspense);
        }
        if (doRemove) {
          remove2(vnode);
        }
      }
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
      }
    };
    const remove2 = (vnode) => {
      const { type: type2, el, anchor, transition } = vnode;
      if (type2 === Fragment) {
        if (vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {
          vnode.children.forEach((child) => {
            if (child.type === Comment) {
              hostRemove(child.el);
            } else {
              remove2(child);
            }
          });
        } else {
          removeFragment(el, anchor);
        }
        return;
      }
      if (type2 === Static) {
        removeStaticNode(vnode);
        return;
      }
      const performRemove = () => {
        hostRemove(el);
        if (transition && !transition.persisted && transition.afterLeave) {
          transition.afterLeave();
        }
      };
      if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
        const { leave, delayLeave } = transition;
        const performLeave = () => leave(el, performRemove);
        if (delayLeave) {
          delayLeave(vnode.el, performRemove, performLeave);
        } else {
          performLeave();
        }
      } else {
        performRemove();
      }
    };
    const removeFragment = (cur, end) => {
      let next;
      while (cur !== end) {
        next = hostNextSibling(cur);
        hostRemove(cur);
        cur = next;
      }
      hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
      if (instance.type.__hmrId) {
        unregisterHMR(instance);
      }
      const { bum, scope, update, subTree, um } = instance;
      if (bum) {
        invokeArrayFns(bum);
      }
      scope.stop();
      if (update) {
        update.active = false;
        unmount(subTree, instance, parentSuspense, doRemove);
      }
      if (um) {
        queuePostRenderEffect(um, parentSuspense);
      }
      queuePostRenderEffect(() => {
        instance.isUnmounted = true;
      }, parentSuspense);
      if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
        parentSuspense.deps--;
        if (parentSuspense.deps === 0) {
          parentSuspense.resolve();
        }
      }
      if (true) {
        devtoolsComponentRemoved(instance);
      }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
      for (let i = start; i < children.length; i++) {
        unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
      }
    };
    const getNextHostNode = (vnode) => {
      if (vnode.shapeFlag & 6) {
        return getNextHostNode(vnode.component.subTree);
      }
      if (vnode.shapeFlag & 128) {
        return vnode.suspense.next();
      }
      return hostNextSibling(vnode.anchor || vnode.el);
    };
    let isFlushing2 = false;
    const render7 = (vnode, container, namespace) => {
      if (vnode == null) {
        if (container._vnode) {
          unmount(container._vnode, null, null, true);
        }
      } else {
        patch(
          container._vnode || null,
          vnode,
          container,
          null,
          null,
          null,
          namespace
        );
      }
      if (!isFlushing2) {
        isFlushing2 = true;
        flushPreFlushCbs();
        flushPostFlushCbs();
        isFlushing2 = false;
      }
      container._vnode = vnode;
    };
    const internals = {
      p: patch,
      um: unmount,
      m: move,
      r: remove2,
      mt: mountComponent,
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      n: getNextHostNode,
      o: options
    };
    let hydrate;
    let hydrateNode;
    if (createHydrationFns) {
      [hydrate, hydrateNode] = createHydrationFns(
        internals
      );
    }
    return {
      render: render7,
      hydrate,
      createApp: createAppAPI(render7, hydrate)
    };
  }
  function resolveChildrenNamespace({ type: type2, props }, currentNamespace) {
    return currentNamespace === "svg" && type2 === "foreignObject" || currentNamespace === "mathml" && type2 === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
  }
  function toggleRecurse({ effect: effect2, update }, allowed) {
    effect2.allowRecurse = update.allowRecurse = allowed;
  }
  function needTransition(parentSuspense, transition) {
    return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
  }
  function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if (isArray(ch1) && isArray(ch2)) {
      for (let i = 0; i < ch1.length; i++) {
        const c1 = ch1[i];
        let c2 = ch2[i];
        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
          if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
            c2 = ch2[i] = cloneIfMounted(ch2[i]);
            c2.el = c1.el;
          }
          if (!shallow)
            traverseStaticChildren(c1, c2);
        }
        if (c2.type === Text) {
          c2.el = c1.el;
        }
        if (c2.type === Comment && !c2.el) {
          c2.el = c1.el;
        }
      }
    }
  }
  function getSequence(arr) {
    const p2 = arr.slice();
    const result = [0];
    let i, j, u, v, c;
    const len = arr.length;
    for (i = 0; i < len; i++) {
      const arrI = arr[i];
      if (arrI !== 0) {
        j = result[result.length - 1];
        if (arr[j] < arrI) {
          p2[i] = j;
          result.push(i);
          continue;
        }
        u = 0;
        v = result.length - 1;
        while (u < v) {
          c = u + v >> 1;
          if (arr[result[c]] < arrI) {
            u = c + 1;
          } else {
            v = c;
          }
        }
        if (arrI < arr[result[u]]) {
          if (u > 0) {
            p2[i] = result[u - 1];
          }
          result[u] = i;
        }
      }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
      result[u] = v;
      v = p2[v];
    }
    return result;
  }
  function locateNonHydratedAsyncRoot(instance) {
    const subComponent = instance.subTree.component;
    if (subComponent) {
      if (subComponent.asyncDep && !subComponent.asyncResolved) {
        return subComponent;
      } else {
        return locateNonHydratedAsyncRoot(subComponent);
      }
    }
  }
  var isTeleport = (type2) => type2.__isTeleport;
  var isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
  var isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
  var isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
  var resolveTarget = (props, select) => {
    const targetSelector = props && props.to;
    if (isString(targetSelector)) {
      if (!select) {
        warn$1(
          `Current renderer does not support string target for Teleports. (missing querySelector renderer option)`
        );
        return null;
      } else {
        const target = select(targetSelector);
        if (!target) {
          warn$1(
            `Failed to locate Teleport target with selector "${targetSelector}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
          );
        }
        return target;
      }
    } else {
      if (!targetSelector && !isTeleportDisabled(props)) {
        warn$1(`Invalid Teleport target: ${targetSelector}`);
      }
      return targetSelector;
    }
  };
  var TeleportImpl = {
    name: "Teleport",
    __isTeleport: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
      const {
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        o: { insert: insert2, querySelector, createText, createComment }
      } = internals;
      const disabled = isTeleportDisabled(n2.props);
      let { shapeFlag, children, dynamicChildren } = n2;
      if (isHmrUpdating) {
        optimized = false;
        dynamicChildren = null;
      }
      if (n1 == null) {
        const placeholder = n2.el = true ? createComment("teleport start") : createText("");
        const mainAnchor = n2.anchor = true ? createComment("teleport end") : createText("");
        insert2(placeholder, container, anchor);
        insert2(mainAnchor, container, anchor);
        const target = n2.target = resolveTarget(n2.props, querySelector);
        const targetAnchor = n2.targetAnchor = createText("");
        if (target) {
          insert2(targetAnchor, target);
          if (namespace === "svg" || isTargetSVG(target)) {
            namespace = "svg";
          } else if (namespace === "mathml" || isTargetMathML(target)) {
            namespace = "mathml";
          }
        } else if (!disabled) {
          warn$1("Invalid Teleport target on mount:", target, `(${typeof target})`);
        }
        const mount = (container2, anchor2) => {
          if (shapeFlag & 16) {
            mountChildren(
              children,
              container2,
              anchor2,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        };
        if (disabled) {
          mount(container, mainAnchor);
        } else if (target) {
          mount(target, targetAnchor);
        }
      } else {
        n2.el = n1.el;
        const mainAnchor = n2.anchor = n1.anchor;
        const target = n2.target = n1.target;
        const targetAnchor = n2.targetAnchor = n1.targetAnchor;
        const wasDisabled = isTeleportDisabled(n1.props);
        const currentContainer = wasDisabled ? container : target;
        const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
        if (namespace === "svg" || isTargetSVG(target)) {
          namespace = "svg";
        } else if (namespace === "mathml" || isTargetMathML(target)) {
          namespace = "mathml";
        }
        if (dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            currentContainer,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds
          );
          traverseStaticChildren(n1, n2, true);
        } else if (!optimized) {
          patchChildren(
            n1,
            n2,
            currentContainer,
            currentAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            false
          );
        }
        if (disabled) {
          if (!wasDisabled) {
            moveTeleport(
              n2,
              container,
              mainAnchor,
              internals,
              1
            );
          } else {
            if (n2.props && n1.props && n2.props.to !== n1.props.to) {
              n2.props.to = n1.props.to;
            }
          }
        } else {
          if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
            const nextTarget = n2.target = resolveTarget(
              n2.props,
              querySelector
            );
            if (nextTarget) {
              moveTeleport(
                n2,
                nextTarget,
                null,
                internals,
                0
              );
            } else if (true) {
              warn$1(
                "Invalid Teleport target on update:",
                target,
                `(${typeof target})`
              );
            }
          } else if (wasDisabled) {
            moveTeleport(
              n2,
              target,
              targetAnchor,
              internals,
              1
            );
          }
        }
      }
      updateCssVars(n2);
    },
    remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
      const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
      if (target) {
        hostRemove(targetAnchor);
      }
      doRemove && hostRemove(anchor);
      if (shapeFlag & 16) {
        const shouldRemove = doRemove || !isTeleportDisabled(props);
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          unmount(
            child,
            parentComponent,
            parentSuspense,
            shouldRemove,
            !!child.dynamicChildren
          );
        }
      }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
  };
  function moveTeleport(vnode, container, parentAnchor, { o: { insert: insert2 }, m: move }, moveType = 2) {
    if (moveType === 0) {
      insert2(vnode.targetAnchor, container, parentAnchor);
    }
    const { el, anchor, shapeFlag, children, props } = vnode;
    const isReorder = moveType === 2;
    if (isReorder) {
      insert2(el, container, parentAnchor);
    }
    if (!isReorder || isTeleportDisabled(props)) {
      if (shapeFlag & 16) {
        for (let i = 0; i < children.length; i++) {
          move(
            children[i],
            container,
            parentAnchor,
            2
          );
        }
      }
    }
    if (isReorder) {
      insert2(anchor, container, parentAnchor);
    }
  }
  function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
    o: { nextSibling, parentNode, querySelector }
  }, hydrateChildren) {
    const target = vnode.target = resolveTarget(
      vnode.props,
      querySelector
    );
    if (target) {
      const targetNode = target._lpa || target.firstChild;
      if (vnode.shapeFlag & 16) {
        if (isTeleportDisabled(vnode.props)) {
          vnode.anchor = hydrateChildren(
            nextSibling(node),
            vnode,
            parentNode(node),
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
          vnode.targetAnchor = targetNode;
        } else {
          vnode.anchor = nextSibling(node);
          let targetAnchor = targetNode;
          while (targetAnchor) {
            targetAnchor = nextSibling(targetAnchor);
            if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
              vnode.targetAnchor = targetAnchor;
              target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
              break;
            }
          }
          hydrateChildren(
            targetNode,
            vnode,
            target,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        }
      }
      updateCssVars(vnode);
    }
    return vnode.anchor && nextSibling(vnode.anchor);
  }
  var Teleport = TeleportImpl;
  function updateCssVars(vnode) {
    const ctx = vnode.ctx;
    if (ctx && ctx.ut) {
      let node = vnode.children[0].el;
      while (node && node !== vnode.targetAnchor) {
        if (node.nodeType === 1)
          node.setAttribute("data-v-owner", ctx.uid);
        node = node.nextSibling;
      }
      ctx.ut();
    }
  }
  var Fragment = Symbol.for("v-fgt");
  var Text = Symbol.for("v-txt");
  var Comment = Symbol.for("v-cmt");
  var Static = Symbol.for("v-stc");
  var blockStack = [];
  var currentBlock = null;
  function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
  }
  function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
  }
  var isBlockTreeEnabled = 1;
  function setBlockTracking(value) {
    isBlockTreeEnabled += value;
  }
  function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  function createElementBlock(type2, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(
      createBaseVNode(
        type2,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        true
      )
    );
  }
  function createBlock(type2, props, children, patchFlag, dynamicProps) {
    return setupBlock(
      createVNode(
        type2,
        props,
        children,
        patchFlag,
        dynamicProps,
        true
      )
    );
  }
  function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
  }
  function isSameVNodeType(n1, n2) {
    if (n2.shapeFlag & 6 && hmrDirtyComponents.has(n2.type)) {
      n1.shapeFlag &= ~256;
      n2.shapeFlag &= ~512;
      return false;
    }
    return n1.type === n2.type && n1.key === n2.key;
  }
  var vnodeArgsTransformer;
  var createVNodeWithArgsTransform = (...args) => {
    return _createVNode(
      ...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args
    );
  };
  var InternalObjectKey = `__vInternal`;
  var normalizeKey = ({ key }) => key != null ? key : null;
  var normalizeRef = ({
    ref: ref2,
    ref_key,
    ref_for
  }) => {
    if (typeof ref2 === "number") {
      ref2 = "" + ref2;
    }
    return ref2 != null ? isString(ref2) || isRef(ref2) || isFunction(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
  };
  function createBaseVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type2 === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
      __v_isVNode: true,
      __v_skip: true,
      type: type2,
      props,
      key: props && normalizeKey(props),
      ref: props && normalizeRef(props),
      scopeId: currentScopeId,
      slotScopeIds: null,
      children,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag,
      patchFlag,
      dynamicProps,
      dynamicChildren: null,
      appContext: null,
      ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
      normalizeChildren(vnode, children);
      if (shapeFlag & 128) {
        type2.normalize(vnode);
      }
    } else if (children) {
      vnode.shapeFlag |= isString(children) ? 8 : 16;
    }
    if (vnode.key !== vnode.key) {
      warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  var createVNode = true ? createVNodeWithArgsTransform : _createVNode;
  function _createVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type2 || type2 === NULL_DYNAMIC_COMPONENT) {
      if (!type2) {
        warn$1(`Invalid vnode type when creating vnode: ${type2}.`);
      }
      type2 = Comment;
    }
    if (isVNode(type2)) {
      const cloned = cloneVNode(
        type2,
        props,
        true
      );
      if (children) {
        normalizeChildren(cloned, children);
      }
      if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
        if (cloned.shapeFlag & 6) {
          currentBlock[currentBlock.indexOf(type2)] = cloned;
        } else {
          currentBlock.push(cloned);
        }
      }
      cloned.patchFlag |= -2;
      return cloned;
    }
    if (isClassComponent(type2)) {
      type2 = type2.__vccOpts;
    }
    if (props) {
      props = guardReactiveProps(props);
      let { class: klass, style } = props;
      if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
      }
      if (isObject(style)) {
        if (isProxy(style) && !isArray(style)) {
          style = extend({}, style);
        }
        props.style = normalizeStyle(style);
      }
    }
    const shapeFlag = isString(type2) ? 1 : isSuspense(type2) ? 128 : isTeleport(type2) ? 64 : isObject(type2) ? 4 : isFunction(type2) ? 2 : 0;
    if (shapeFlag & 4 && isProxy(type2)) {
      type2 = toRaw(type2);
      warn$1(
        `Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`,
        `
Component that was made reactive: `,
        type2
      );
    }
    return createBaseVNode(
      type2,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      isBlockNode,
      true
    );
  }
  function guardReactiveProps(props) {
    if (!props)
      return null;
    return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
  }
  function cloneVNode(vnode, extraProps, mergeRef = false) {
    const { props, ref: ref2, patchFlag, children } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
      __v_isVNode: true,
      __v_skip: true,
      type: vnode.type,
      props: mergedProps,
      key: mergedProps && normalizeKey(mergedProps),
      ref: extraProps && extraProps.ref ? mergeRef && ref2 ? isArray(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref2,
      scopeId: vnode.scopeId,
      slotScopeIds: vnode.slotScopeIds,
      children: patchFlag === -1 && isArray(children) ? children.map(deepCloneVNode) : children,
      target: vnode.target,
      targetAnchor: vnode.targetAnchor,
      staticCount: vnode.staticCount,
      shapeFlag: vnode.shapeFlag,
      patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
      dynamicProps: vnode.dynamicProps,
      dynamicChildren: vnode.dynamicChildren,
      appContext: vnode.appContext,
      dirs: vnode.dirs,
      transition: vnode.transition,
      component: vnode.component,
      suspense: vnode.suspense,
      ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
      ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
      el: vnode.el,
      anchor: vnode.anchor,
      ctx: vnode.ctx,
      ce: vnode.ce
    };
    return cloned;
  }
  function deepCloneVNode(vnode) {
    const cloned = cloneVNode(vnode);
    if (isArray(vnode.children)) {
      cloned.children = vnode.children.map(deepCloneVNode);
    }
    return cloned;
  }
  function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
  }
  function createCommentVNode(text = "", asBlock = false) {
    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
  }
  function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") {
      return createVNode(Comment);
    } else if (isArray(child)) {
      return createVNode(
        Fragment,
        null,
        child.slice()
      );
    } else if (typeof child === "object") {
      return cloneIfMounted(child);
    } else {
      return createVNode(Text, null, String(child));
    }
  }
  function cloneIfMounted(child) {
    return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
  }
  function normalizeChildren(vnode, children) {
    let type2 = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
      children = null;
    } else if (isArray(children)) {
      type2 = 16;
    } else if (typeof children === "object") {
      if (shapeFlag & (1 | 64)) {
        const slot = children.default;
        if (slot) {
          slot._c && (slot._d = false);
          normalizeChildren(vnode, slot());
          slot._c && (slot._d = true);
        }
        return;
      } else {
        type2 = 32;
        const slotFlag = children._;
        if (!slotFlag && !(InternalObjectKey in children)) {
          children._ctx = currentRenderingInstance;
        } else if (slotFlag === 3 && currentRenderingInstance) {
          if (currentRenderingInstance.slots._ === 1) {
            children._ = 1;
          } else {
            children._ = 2;
            vnode.patchFlag |= 1024;
          }
        }
      }
    } else if (isFunction(children)) {
      children = { default: children, _ctx: currentRenderingInstance };
      type2 = 32;
    } else {
      children = String(children);
      if (shapeFlag & 64) {
        type2 = 16;
        children = [createTextVNode(children)];
      } else {
        type2 = 8;
      }
    }
    vnode.children = children;
    vnode.shapeFlag |= type2;
  }
  function mergeProps(...args) {
    const ret = {};
    for (let i = 0; i < args.length; i++) {
      const toMerge = args[i];
      for (const key in toMerge) {
        if (key === "class") {
          if (ret.class !== toMerge.class) {
            ret.class = normalizeClass([ret.class, toMerge.class]);
          }
        } else if (key === "style") {
          ret.style = normalizeStyle([ret.style, toMerge.style]);
        } else if (isOn(key)) {
          const existing = ret[key];
          const incoming = toMerge[key];
          if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
            ret[key] = existing ? [].concat(existing, incoming) : incoming;
          }
        } else if (key !== "") {
          ret[key] = toMerge[key];
        }
      }
    }
    return ret;
  }
  function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
      vnode,
      prevVNode
    ]);
  }
  var emptyAppContext = createAppContext();
  var uid = 0;
  function createComponentInstance(vnode, parent2, suspense) {
    const type2 = vnode.type;
    const appContext = (parent2 ? parent2.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
      uid: uid++,
      vnode,
      type: type2,
      parent: parent2,
      appContext,
      root: null,
      next: null,
      subTree: null,
      effect: null,
      update: null,
      scope: new EffectScope(
        true
      ),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: parent2 ? parent2.provides : Object.create(appContext.provides),
      accessCache: null,
      renderCache: [],
      components: null,
      directives: null,
      propsOptions: normalizePropsOptions(type2, appContext),
      emitsOptions: normalizeEmitsOptions(type2, appContext),
      emit: null,
      emitted: null,
      propsDefaults: EMPTY_OBJ,
      inheritAttrs: type2.inheritAttrs,
      ctx: EMPTY_OBJ,
      data: EMPTY_OBJ,
      props: EMPTY_OBJ,
      attrs: EMPTY_OBJ,
      slots: EMPTY_OBJ,
      refs: EMPTY_OBJ,
      setupState: EMPTY_OBJ,
      setupContext: null,
      attrsProxy: null,
      slotsProxy: null,
      suspense,
      suspenseId: suspense ? suspense.pendingId : 0,
      asyncDep: null,
      asyncResolved: false,
      isMounted: false,
      isUnmounted: false,
      isDeactivated: false,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
    if (true) {
      instance.ctx = createDevRenderContext(instance);
    } else {
      instance.ctx = { _: instance };
    }
    instance.root = parent2 ? parent2.root : instance;
    instance.emit = emit.bind(null, instance);
    if (vnode.ce) {
      vnode.ce(instance);
    }
    return instance;
  }
  var currentInstance = null;
  var getCurrentInstance = () => currentInstance || currentRenderingInstance;
  var internalSetCurrentInstance;
  var setInSSRSetupState;
  {
    const g = getGlobalThis();
    const registerGlobalSetter = (key, setter) => {
      let setters;
      if (!(setters = g[key]))
        setters = g[key] = [];
      setters.push(setter);
      return (v) => {
        if (setters.length > 1)
          setters.forEach((set3) => set3(v));
        else
          setters[0](v);
      };
    };
    internalSetCurrentInstance = registerGlobalSetter(
      `__VUE_INSTANCE_SETTERS__`,
      (v) => currentInstance = v
    );
    setInSSRSetupState = registerGlobalSetter(
      `__VUE_SSR_SETTERS__`,
      (v) => isInSSRComponentSetup = v
    );
  }
  var setCurrentInstance = (instance) => {
    const prev = currentInstance;
    internalSetCurrentInstance(instance);
    instance.scope.on();
    return () => {
      instance.scope.off();
      internalSetCurrentInstance(prev);
    };
  };
  var unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off();
    internalSetCurrentInstance(null);
  };
  var isBuiltInTag = /* @__PURE__ */ makeMap("slot,component");
  function validateComponentName(name, { isNativeTag }) {
    if (isBuiltInTag(name) || isNativeTag(name)) {
      warn$1(
        "Do not use built-in or reserved HTML elements as component id: " + name
      );
    }
  }
  function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
  }
  var isInSSRComponentSetup = false;
  function setupComponent(instance, isSSR = false) {
    isSSR && setInSSRSetupState(isSSR);
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isSSR && setInSSRSetupState(false);
    return setupResult;
  }
  function setupStatefulComponent(instance, isSSR) {
    var _a2;
    const Component = instance.type;
    if (true) {
      if (Component.name) {
        validateComponentName(Component.name, instance.appContext.config);
      }
      if (Component.components) {
        const names = Object.keys(Component.components);
        for (let i = 0; i < names.length; i++) {
          validateComponentName(names[i], instance.appContext.config);
        }
      }
      if (Component.directives) {
        const names = Object.keys(Component.directives);
        for (let i = 0; i < names.length; i++) {
          validateDirectiveName(names[i]);
        }
      }
      if (Component.compilerOptions && isRuntimeOnly()) {
        warn$1(
          `"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`
        );
      }
    }
    instance.accessCache = /* @__PURE__ */ Object.create(null);
    instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
    if (true) {
      exposePropsOnRenderContext(instance);
    }
    const { setup } = Component;
    if (setup) {
      const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
      const reset = setCurrentInstance(instance);
      pauseTracking();
      const setupResult = callWithErrorHandling(
        setup,
        instance,
        0,
        [
          true ? shallowReadonly(instance.props) : instance.props,
          setupContext
        ]
      );
      resetTracking();
      reset();
      if (isPromise(setupResult)) {
        setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
        if (isSSR) {
          return setupResult.then((resolvedResult) => {
            handleSetupResult(instance, resolvedResult, isSSR);
          }).catch((e) => {
            handleError(e, instance, 0);
          });
        } else {
          instance.asyncDep = setupResult;
          if (!instance.suspense) {
            const name = (_a2 = Component.name) != null ? _a2 : "Anonymous";
            warn$1(
              `Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
            );
          }
        }
      } else {
        handleSetupResult(instance, setupResult, isSSR);
      }
    } else {
      finishComponentSetup(instance, isSSR);
    }
  }
  function handleSetupResult(instance, setupResult, isSSR) {
    if (isFunction(setupResult)) {
      if (instance.type.__ssrInlineRender) {
        instance.ssrRender = setupResult;
      } else {
        instance.render = setupResult;
      }
    } else if (isObject(setupResult)) {
      if (isVNode(setupResult)) {
        warn$1(
          `setup() should not return VNodes directly - return a render function instead.`
        );
      }
      if (true) {
        instance.devtoolsRawSetupState = setupResult;
      }
      instance.setupState = proxyRefs(setupResult);
      if (true) {
        exposeSetupStateOnRenderContext(instance);
      }
    } else if (setupResult !== void 0) {
      warn$1(
        `setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`
      );
    }
    finishComponentSetup(instance, isSSR);
  }
  var compile;
  var installWithProxy;
  var isRuntimeOnly = () => !compile;
  function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    if (!instance.render) {
      if (!isSSR && compile && !Component.render) {
        const template = Component.template || resolveMergedOptions(instance).template;
        if (template) {
          if (true) {
            startMeasure(instance, `compile`);
          }
          const { isCustomElement, compilerOptions } = instance.appContext.config;
          const { delimiters, compilerOptions: componentCompilerOptions } = Component;
          const finalCompilerOptions = extend(
            extend(
              {
                isCustomElement,
                delimiters
              },
              compilerOptions
            ),
            componentCompilerOptions
          );
          Component.render = compile(template, finalCompilerOptions);
          if (true) {
            endMeasure(instance, `compile`);
          }
        }
      }
      instance.render = Component.render || NOOP;
      if (installWithProxy) {
        installWithProxy(instance);
      }
    }
    if (true) {
      const reset = setCurrentInstance(instance);
      pauseTracking();
      try {
        applyOptions(instance);
      } finally {
        resetTracking();
        reset();
      }
    }
    if (!Component.render && instance.render === NOOP && !isSSR) {
      if (!compile && Component.template) {
        warn$1(
          `Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
        );
      } else {
        warn$1(`Component is missing template or render function.`);
      }
    }
  }
  function getAttrsProxy(instance) {
    return instance.attrsProxy || (instance.attrsProxy = new Proxy(
      instance.attrs,
      true ? {
        get(target, key) {
          markAttrsAccessed();
          track(instance, "get", "$attrs");
          return target[key];
        },
        set() {
          warn$1(`setupContext.attrs is readonly.`);
          return false;
        },
        deleteProperty() {
          warn$1(`setupContext.attrs is readonly.`);
          return false;
        }
      } : {
        get(target, key) {
          track(instance, "get", "$attrs");
          return target[key];
        }
      }
    ));
  }
  function getSlotsProxy(instance) {
    return instance.slotsProxy || (instance.slotsProxy = new Proxy(instance.slots, {
      get(target, key) {
        track(instance, "get", "$slots");
        return target[key];
      }
    }));
  }
  function createSetupContext(instance) {
    const expose = (exposed) => {
      if (true) {
        if (instance.exposed) {
          warn$1(`expose() should be called only once per setup().`);
        }
        if (exposed != null) {
          let exposedType = typeof exposed;
          if (exposedType === "object") {
            if (isArray(exposed)) {
              exposedType = "array";
            } else if (isRef(exposed)) {
              exposedType = "ref";
            }
          }
          if (exposedType !== "object") {
            warn$1(
              `expose() should be passed a plain object, received ${exposedType}.`
            );
          }
        }
      }
      instance.exposed = exposed || {};
    };
    if (true) {
      return Object.freeze({
        get attrs() {
          return getAttrsProxy(instance);
        },
        get slots() {
          return getSlotsProxy(instance);
        },
        get emit() {
          return (event, ...args) => instance.emit(event, ...args);
        },
        expose
      });
    } else {
      return {
        get attrs() {
          return getAttrsProxy(instance);
        },
        slots: instance.slots,
        emit: instance.emit,
        expose
      };
    }
  }
  function getExposeProxy(instance) {
    if (instance.exposed) {
      return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
        get(target, key) {
          if (key in target) {
            return target[key];
          } else if (key in publicPropertiesMap) {
            return publicPropertiesMap[key](instance);
          }
        },
        has(target, key) {
          return key in target || key in publicPropertiesMap;
        }
      }));
    }
  }
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
  function getComponentName(Component, includeInferred = true) {
    return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
  }
  function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
      const match = Component.__file.match(/([^/\\]+)\.\w+$/);
      if (match) {
        name = match[1];
      }
    }
    if (!name && instance && instance.parent) {
      const inferFromRegistry = (registry) => {
        for (const key in registry) {
          if (registry[key] === Component) {
            return key;
          }
        }
      };
      name = inferFromRegistry(
        instance.components || instance.parent.type.components
      ) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
  }
  function isClassComponent(value) {
    return isFunction(value) && "__vccOpts" in value;
  }
  var computed2 = (getterOrOptions, debugOptions) => {
    const c = computed(getterOrOptions, debugOptions, isInSSRComponentSetup);
    if (true) {
      const i = getCurrentInstance();
      if (i && i.appContext.config.warnRecursiveComputed) {
        c._warnRecursive = true;
      }
    }
    return c;
  };
  function h(type2, propsOrChildren, children) {
    const l = arguments.length;
    if (l === 2) {
      if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {
        if (isVNode(propsOrChildren)) {
          return createVNode(type2, null, [propsOrChildren]);
        }
        return createVNode(type2, propsOrChildren);
      } else {
        return createVNode(type2, null, propsOrChildren);
      }
    } else {
      if (l > 3) {
        children = Array.prototype.slice.call(arguments, 2);
      } else if (l === 3 && isVNode(children)) {
        children = [children];
      }
      return createVNode(type2, propsOrChildren, children);
    }
  }
  function initCustomFormatter() {
    if (typeof window === "undefined") {
      return;
    }
    const vueStyle = { style: "color:#3ba776" };
    const numberStyle = { style: "color:#1677ff" };
    const stringStyle = { style: "color:#f5222d" };
    const keywordStyle = { style: "color:#eb2f96" };
    const formatter = {
      header(obj) {
        if (!isObject(obj)) {
          return null;
        }
        if (obj.__isVue) {
          return ["div", vueStyle, `VueInstance`];
        } else if (isRef(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, genRefFlag(obj)],
            "<",
            formatValue(obj.value),
            `>`
          ];
        } else if (isReactive(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, isShallow(obj) ? "ShallowReactive" : "Reactive"],
            "<",
            formatValue(obj),
            `>${isReadonly(obj) ? ` (readonly)` : ``}`
          ];
        } else if (isReadonly(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, isShallow(obj) ? "ShallowReadonly" : "Readonly"],
            "<",
            formatValue(obj),
            ">"
          ];
        }
        return null;
      },
      hasBody(obj) {
        return obj && obj.__isVue;
      },
      body(obj) {
        if (obj && obj.__isVue) {
          return [
            "div",
            {},
            ...formatInstance(obj.$)
          ];
        }
      }
    };
    function formatInstance(instance) {
      const blocks = [];
      if (instance.type.props && instance.props) {
        blocks.push(createInstanceBlock("props", toRaw(instance.props)));
      }
      if (instance.setupState !== EMPTY_OBJ) {
        blocks.push(createInstanceBlock("setup", instance.setupState));
      }
      if (instance.data !== EMPTY_OBJ) {
        blocks.push(createInstanceBlock("data", toRaw(instance.data)));
      }
      const computed3 = extractKeys2(instance, "computed");
      if (computed3) {
        blocks.push(createInstanceBlock("computed", computed3));
      }
      const injected = extractKeys2(instance, "inject");
      if (injected) {
        blocks.push(createInstanceBlock("injected", injected));
      }
      blocks.push([
        "div",
        {},
        [
          "span",
          {
            style: keywordStyle.style + ";opacity:0.66"
          },
          "$ (internal): "
        ],
        ["object", { object: instance }]
      ]);
      return blocks;
    }
    function createInstanceBlock(type2, target) {
      target = extend({}, target);
      if (!Object.keys(target).length) {
        return ["span", {}];
      }
      return [
        "div",
        { style: "line-height:1.25em;margin-bottom:0.6em" },
        [
          "div",
          {
            style: "color:#476582"
          },
          type2
        ],
        [
          "div",
          {
            style: "padding-left:1.25em"
          },
          ...Object.keys(target).map((key) => {
            return [
              "div",
              {},
              ["span", keywordStyle, key + ": "],
              formatValue(target[key], false)
            ];
          })
        ]
      ];
    }
    function formatValue(v, asRaw = true) {
      if (typeof v === "number") {
        return ["span", numberStyle, v];
      } else if (typeof v === "string") {
        return ["span", stringStyle, JSON.stringify(v)];
      } else if (typeof v === "boolean") {
        return ["span", keywordStyle, v];
      } else if (isObject(v)) {
        return ["object", { object: asRaw ? toRaw(v) : v }];
      } else {
        return ["span", stringStyle, String(v)];
      }
    }
    function extractKeys2(instance, type2) {
      const Comp = instance.type;
      if (isFunction(Comp)) {
        return;
      }
      const extracted = {};
      for (const key in instance.ctx) {
        if (isKeyOfType(Comp, key, type2)) {
          extracted[key] = instance.ctx[key];
        }
      }
      return extracted;
    }
    function isKeyOfType(Comp, key, type2) {
      const opts = Comp[type2];
      if (isArray(opts) && opts.includes(key) || isObject(opts) && key in opts) {
        return true;
      }
      if (Comp.extends && isKeyOfType(Comp.extends, key, type2)) {
        return true;
      }
      if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type2))) {
        return true;
      }
    }
    function genRefFlag(v) {
      if (isShallow(v)) {
        return `ShallowRef`;
      }
      if (v.effect) {
        return `ComputedRef`;
      }
      return `Ref`;
    }
    if (window.devtoolsFormatters) {
      window.devtoolsFormatters.push(formatter);
    } else {
      window.devtoolsFormatters = [formatter];
    }
  }
  var version = "3.4.21";
  var warn2 = true ? warn$1 : NOOP;

  // ../library_management/node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js
  var svgNS = "http://www.w3.org/2000/svg";
  var mathmlNS = "http://www.w3.org/1998/Math/MathML";
  var doc = typeof document !== "undefined" ? document : null;
  var templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
  var nodeOps = {
    insert: (child, parent2, anchor) => {
      parent2.insertBefore(child, anchor || null);
    },
    remove: (child) => {
      const parent2 = child.parentNode;
      if (parent2) {
        parent2.removeChild(child);
      }
    },
    createElement: (tag, namespace, is, props) => {
      const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : doc.createElement(tag, is ? { is } : void 0);
      if (tag === "select" && props && props.multiple != null) {
        el.setAttribute("multiple", props.multiple);
      }
      return el;
    },
    createText: (text) => doc.createTextNode(text),
    createComment: (text) => doc.createComment(text),
    setText: (node, text) => {
      node.nodeValue = text;
    },
    setElementText: (el, text) => {
      el.textContent = text;
    },
    parentNode: (node) => node.parentNode,
    nextSibling: (node) => node.nextSibling,
    querySelector: (selector) => doc.querySelector(selector),
    setScopeId(el, id) {
      el.setAttribute(id, "");
    },
    insertStaticContent(content, parent2, anchor, namespace, start, end) {
      const before = anchor ? anchor.previousSibling : parent2.lastChild;
      if (start && (start === end || start.nextSibling)) {
        while (true) {
          parent2.insertBefore(start.cloneNode(true), anchor);
          if (start === end || !(start = start.nextSibling))
            break;
        }
      } else {
        templateContainer.innerHTML = namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content;
        const template = templateContainer.content;
        if (namespace === "svg" || namespace === "mathml") {
          const wrapper = template.firstChild;
          while (wrapper.firstChild) {
            template.appendChild(wrapper.firstChild);
          }
          template.removeChild(wrapper);
        }
        parent2.insertBefore(template, anchor);
      }
      return [
        before ? before.nextSibling : parent2.firstChild,
        anchor ? anchor.previousSibling : parent2.lastChild
      ];
    }
  };
  var TRANSITION = "transition";
  var ANIMATION = "animation";
  var vtcKey = Symbol("_vtc");
  var Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
  Transition.displayName = "Transition";
  var DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
      type: Boolean,
      default: true
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
  };
  var TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend(
    {},
    BaseTransitionPropsValidators,
    DOMTransitionPropsValidators
  );
  var callHook2 = (hook, args = []) => {
    if (isArray(hook)) {
      hook.forEach((h2) => h2(...args));
    } else if (hook) {
      hook(...args);
    }
  };
  var hasExplicitCallback = (hook) => {
    return hook ? isArray(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
  };
  function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for (const key in rawProps) {
      if (!(key in DOMTransitionPropsValidators)) {
        baseProps[key] = rawProps[key];
      }
    }
    if (rawProps.css === false) {
      return baseProps;
    }
    const {
      name = "v",
      type: type2,
      duration,
      enterFromClass = `${name}-enter-from`,
      enterActiveClass = `${name}-enter-active`,
      enterToClass = `${name}-enter-to`,
      appearFromClass = enterFromClass,
      appearActiveClass = enterActiveClass,
      appearToClass = enterToClass,
      leaveFromClass = `${name}-leave-from`,
      leaveActiveClass = `${name}-leave-active`,
      leaveToClass = `${name}-leave-to`
    } = rawProps;
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const {
      onBeforeEnter,
      onEnter,
      onEnterCancelled,
      onLeave,
      onLeaveCancelled,
      onBeforeAppear = onBeforeEnter,
      onAppear = onEnter,
      onAppearCancelled = onEnterCancelled
    } = baseProps;
    const finishEnter = (el, isAppear, done) => {
      removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
      removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
      done && done();
    };
    const finishLeave = (el, done) => {
      el._isLeaving = false;
      removeTransitionClass(el, leaveFromClass);
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
      done && done();
    };
    const makeEnterHook = (isAppear) => {
      return (el, done) => {
        const hook = isAppear ? onAppear : onEnter;
        const resolve2 = () => finishEnter(el, isAppear, done);
        callHook2(hook, [el, resolve2]);
        nextFrame(() => {
          removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
          addTransitionClass(el, isAppear ? appearToClass : enterToClass);
          if (!hasExplicitCallback(hook)) {
            whenTransitionEnds(el, type2, enterDuration, resolve2);
          }
        });
      };
    };
    return extend(baseProps, {
      onBeforeEnter(el) {
        callHook2(onBeforeEnter, [el]);
        addTransitionClass(el, enterFromClass);
        addTransitionClass(el, enterActiveClass);
      },
      onBeforeAppear(el) {
        callHook2(onBeforeAppear, [el]);
        addTransitionClass(el, appearFromClass);
        addTransitionClass(el, appearActiveClass);
      },
      onEnter: makeEnterHook(false),
      onAppear: makeEnterHook(true),
      onLeave(el, done) {
        el._isLeaving = true;
        const resolve2 = () => finishLeave(el, done);
        addTransitionClass(el, leaveFromClass);
        forceReflow();
        addTransitionClass(el, leaveActiveClass);
        nextFrame(() => {
          if (!el._isLeaving) {
            return;
          }
          removeTransitionClass(el, leaveFromClass);
          addTransitionClass(el, leaveToClass);
          if (!hasExplicitCallback(onLeave)) {
            whenTransitionEnds(el, type2, leaveDuration, resolve2);
          }
        });
        callHook2(onLeave, [el, resolve2]);
      },
      onEnterCancelled(el) {
        finishEnter(el, false);
        callHook2(onEnterCancelled, [el]);
      },
      onAppearCancelled(el) {
        finishEnter(el, true);
        callHook2(onAppearCancelled, [el]);
      },
      onLeaveCancelled(el) {
        finishLeave(el);
        callHook2(onLeaveCancelled, [el]);
      }
    });
  }
  function normalizeDuration(duration) {
    if (duration == null) {
      return null;
    } else if (isObject(duration)) {
      return [NumberOf(duration.enter), NumberOf(duration.leave)];
    } else {
      const n = NumberOf(duration);
      return [n, n];
    }
  }
  function NumberOf(val) {
    const res = toNumber(val);
    if (true) {
      assertNumber(res, "<transition> explicit duration");
    }
    return res;
  }
  function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
    (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
  }
  function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
    const _vtc = el[vtcKey];
    if (_vtc) {
      _vtc.delete(cls);
      if (!_vtc.size) {
        el[vtcKey] = void 0;
      }
    }
  }
  function nextFrame(cb) {
    requestAnimationFrame(() => {
      requestAnimationFrame(cb);
    });
  }
  var endId = 0;
  function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
    const id = el._endId = ++endId;
    const resolveIfNotStale = () => {
      if (id === el._endId) {
        resolve2();
      }
    };
    if (explicitTimeout) {
      return setTimeout(resolveIfNotStale, explicitTimeout);
    }
    const { type: type2, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type2) {
      return resolve2();
    }
    const endEvent = type2 + "end";
    let ended = 0;
    const end = () => {
      el.removeEventListener(endEvent, onEnd);
      resolveIfNotStale();
    };
    const onEnd = (e) => {
      if (e.target === el && ++ended >= propCount) {
        end();
      }
    };
    setTimeout(() => {
      if (ended < propCount) {
        end();
      }
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
  }
  function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    const getStyleProperties = (key) => (styles[key] || "").split(", ");
    const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
    const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
    const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type2 = null;
    let timeout = 0;
    let propCount = 0;
    if (expectedType === TRANSITION) {
      if (transitionTimeout > 0) {
        type2 = TRANSITION;
        timeout = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type2 = ANIMATION;
        timeout = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout = Math.max(transitionTimeout, animationTimeout);
      type2 = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
      propCount = type2 ? type2 === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    const hasTransform = type2 === TRANSITION && /\b(transform|all)(,|$)/.test(
      getStyleProperties(`${TRANSITION}Property`).toString()
    );
    return {
      type: type2,
      timeout,
      propCount,
      hasTransform
    };
  }
  function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }
    return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
  }
  function toMs(s) {
    if (s === "auto")
      return 0;
    return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
  }
  function forceReflow() {
    return document.body.offsetHeight;
  }
  function patchClass(el, value, isSVG) {
    const transitionClasses = el[vtcKey];
    if (transitionClasses) {
      value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
    }
    if (value == null) {
      el.removeAttribute("class");
    } else if (isSVG) {
      el.setAttribute("class", value);
    } else {
      el.className = value;
    }
  }
  var vShowOriginalDisplay = Symbol("_vod");
  var vShowHidden = Symbol("_vsh");
  var vShow = {
    beforeMount(el, { value }, { transition }) {
      el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
      if (transition && value) {
        transition.beforeEnter(el);
      } else {
        setDisplay(el, value);
      }
    },
    mounted(el, { value }, { transition }) {
      if (transition && value) {
        transition.enter(el);
      }
    },
    updated(el, { value, oldValue }, { transition }) {
      if (!value === !oldValue)
        return;
      if (transition) {
        if (value) {
          transition.beforeEnter(el);
          setDisplay(el, true);
          transition.enter(el);
        } else {
          transition.leave(el, () => {
            setDisplay(el, false);
          });
        }
      } else {
        setDisplay(el, value);
      }
    },
    beforeUnmount(el, { value }) {
      setDisplay(el, value);
    }
  };
  if (true) {
    vShow.name = "show";
  }
  function setDisplay(el, value) {
    el.style.display = value ? el[vShowOriginalDisplay] : "none";
    el[vShowHidden] = !value;
  }
  var CSS_VAR_TEXT = Symbol(true ? "CSS_VAR_TEXT" : "");
  var displayRE = /(^|;)\s*display\s*:/;
  function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = isString(next);
    let hasControlledDisplay = false;
    if (next && !isCssString) {
      if (prev) {
        if (!isString(prev)) {
          for (const key in prev) {
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        } else {
          for (const prevStyle of prev.split(";")) {
            const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        }
      }
      for (const key in next) {
        if (key === "display") {
          hasControlledDisplay = true;
        }
        setStyle(style, key, next[key]);
      }
    } else {
      if (isCssString) {
        if (prev !== next) {
          const cssVarText = style[CSS_VAR_TEXT];
          if (cssVarText) {
            next += ";" + cssVarText;
          }
          style.cssText = next;
          hasControlledDisplay = displayRE.test(next);
        }
      } else if (prev) {
        el.removeAttribute("style");
      }
    }
    if (vShowOriginalDisplay in el) {
      el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
      if (el[vShowHidden]) {
        style.display = "none";
      }
    }
  }
  var semicolonRE = /[^\\];\s*$/;
  var importantRE = /\s*!important$/;
  function setStyle(style, name, val) {
    if (isArray(val)) {
      val.forEach((v) => setStyle(style, name, v));
    } else {
      if (val == null)
        val = "";
      if (true) {
        if (semicolonRE.test(val)) {
          warn2(
            `Unexpected semicolon at the end of '${name}' style value: '${val}'`
          );
        }
      }
      if (name.startsWith("--")) {
        style.setProperty(name, val);
      } else {
        const prefixed2 = autoPrefix(style, name);
        if (importantRE.test(val)) {
          style.setProperty(
            hyphenate(prefixed2),
            val.replace(importantRE, ""),
            "important"
          );
        } else {
          style[prefixed2] = val;
        }
      }
    }
  }
  var prefixes = ["Webkit", "Moz", "ms"];
  var prefixCache = {};
  function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
      return cached;
    }
    let name = camelize(rawName);
    if (name !== "filter" && name in style) {
      return prefixCache[rawName] = name;
    }
    name = capitalize(name);
    for (let i = 0; i < prefixes.length; i++) {
      const prefixed2 = prefixes[i] + name;
      if (prefixed2 in style) {
        return prefixCache[rawName] = prefixed2;
      }
    }
    return rawName;
  }
  var xlinkNS = "http://www.w3.org/1999/xlink";
  function patchAttr(el, key, value, isSVG, instance) {
    if (isSVG && key.startsWith("xlink:")) {
      if (value == null) {
        el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      const isBoolean2 = isSpecialBooleanAttr(key);
      if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
        el.removeAttribute(key);
      } else {
        el.setAttribute(key, isBoolean2 ? "" : value);
      }
    }
  }
  function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
    if (key === "innerHTML" || key === "textContent") {
      if (prevChildren) {
        unmountChildren(prevChildren, parentComponent, parentSuspense);
      }
      el[key] = value == null ? "" : value;
      return;
    }
    const tag = el.tagName;
    if (key === "value" && tag !== "PROGRESS" && !tag.includes("-")) {
      const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
      const newValue = value == null ? "" : value;
      if (oldValue !== newValue || !("_value" in el)) {
        el.value = newValue;
      }
      if (value == null) {
        el.removeAttribute(key);
      }
      el._value = value;
      return;
    }
    let needRemove = false;
    if (value === "" || value == null) {
      const type2 = typeof el[key];
      if (type2 === "boolean") {
        value = includeBooleanAttr(value);
      } else if (value == null && type2 === "string") {
        value = "";
        needRemove = true;
      } else if (type2 === "number") {
        value = 0;
        needRemove = true;
      }
    }
    try {
      el[key] = value;
    } catch (e) {
      if (!needRemove) {
        warn2(
          `Failed setting prop "${key}" on <${tag.toLowerCase()}>: value ${value} is invalid.`,
          e
        );
      }
    }
    needRemove && el.removeAttribute(key);
  }
  function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
  }
  function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
  }
  var veiKey = Symbol("_vei");
  function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const invokers = el[veiKey] || (el[veiKey] = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
      existingInvoker.value = nextValue;
    } else {
      const [name, options] = parseName(rawName);
      if (nextValue) {
        const invoker = invokers[rawName] = createInvoker(nextValue, instance);
        addEventListener(el, name, invoker, options);
      } else if (existingInvoker) {
        removeEventListener(el, name, existingInvoker, options);
        invokers[rawName] = void 0;
      }
    }
  }
  var optionsModifierRE = /(?:Once|Passive|Capture)$/;
  function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
      options = {};
      let m;
      while (m = name.match(optionsModifierRE)) {
        name = name.slice(0, name.length - m[0].length);
        options[m[0].toLowerCase()] = true;
      }
    }
    const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
    return [event, options];
  }
  var cachedNow = 0;
  var p = /* @__PURE__ */ Promise.resolve();
  var getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
  function createInvoker(initialValue, instance) {
    const invoker = (e) => {
      if (!e._vts) {
        e._vts = Date.now();
      } else if (e._vts <= invoker.attached) {
        return;
      }
      callWithAsyncErrorHandling(
        patchStopImmediatePropagation(e, invoker.value),
        instance,
        5,
        [e]
      );
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
  }
  function patchStopImmediatePropagation(e, value) {
    if (isArray(value)) {
      const originalStop = e.stopImmediatePropagation;
      e.stopImmediatePropagation = () => {
        originalStop.call(e);
        e._stopped = true;
      };
      return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
    } else {
      return value;
    }
  }
  var isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
  var patchProp = (el, key, prevValue, nextValue, namespace, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
    const isSVG = namespace === "svg";
    if (key === "class") {
      patchClass(el, nextValue, isSVG);
    } else if (key === "style") {
      patchStyle(el, prevValue, nextValue);
    } else if (isOn(key)) {
      if (!isModelListener(key)) {
        patchEvent(el, key, prevValue, nextValue, parentComponent);
      }
    } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
      patchDOMProp(
        el,
        key,
        nextValue,
        prevChildren,
        parentComponent,
        parentSuspense,
        unmountChildren
      );
    } else {
      if (key === "true-value") {
        el._trueValue = nextValue;
      } else if (key === "false-value") {
        el._falseValue = nextValue;
      }
      patchAttr(el, key, nextValue, isSVG);
    }
  };
  function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
      if (key === "innerHTML" || key === "textContent") {
        return true;
      }
      if (key in el && isNativeOn(key) && isFunction(value)) {
        return true;
      }
      return false;
    }
    if (key === "spellcheck" || key === "draggable" || key === "translate") {
      return false;
    }
    if (key === "form") {
      return false;
    }
    if (key === "list" && el.tagName === "INPUT") {
      return false;
    }
    if (key === "type" && el.tagName === "TEXTAREA") {
      return false;
    }
    if (key === "width" || key === "height") {
      const tag = el.tagName;
      if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
        return false;
      }
    }
    if (isNativeOn(key) && isString(value)) {
      return false;
    }
    return key in el;
  }
  var positionMap = /* @__PURE__ */ new WeakMap();
  var newPositionMap = /* @__PURE__ */ new WeakMap();
  var moveCbKey = Symbol("_moveCb");
  var enterCbKey2 = Symbol("_enterCb");
  var TransitionGroupImpl = {
    name: "TransitionGroup",
    props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
      tag: String,
      moveClass: String
    }),
    setup(props, { slots }) {
      const instance = getCurrentInstance();
      const state = useTransitionState();
      let prevChildren;
      let children;
      onUpdated(() => {
        if (!prevChildren.length) {
          return;
        }
        const moveClass = props.moveClass || `${props.name || "v"}-move`;
        if (!hasCSSTransform(
          prevChildren[0].el,
          instance.vnode.el,
          moveClass
        )) {
          return;
        }
        prevChildren.forEach(callPendingCbs);
        prevChildren.forEach(recordPosition);
        const movedChildren = prevChildren.filter(applyTranslation);
        forceReflow();
        movedChildren.forEach((c) => {
          const el = c.el;
          const style = el.style;
          addTransitionClass(el, moveClass);
          style.transform = style.webkitTransform = style.transitionDuration = "";
          const cb = el[moveCbKey] = (e) => {
            if (e && e.target !== el) {
              return;
            }
            if (!e || /transform$/.test(e.propertyName)) {
              el.removeEventListener("transitionend", cb);
              el[moveCbKey] = null;
              removeTransitionClass(el, moveClass);
            }
          };
          el.addEventListener("transitionend", cb);
        });
      });
      return () => {
        const rawProps = toRaw(props);
        const cssTransitionProps = resolveTransitionProps(rawProps);
        let tag = rawProps.tag || Fragment;
        prevChildren = children;
        children = slots.default ? getTransitionRawChildren(slots.default()) : [];
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child.key != null) {
            setTransitionHooks(
              child,
              resolveTransitionHooks(child, cssTransitionProps, state, instance)
            );
          } else if (true) {
            warn2(`<TransitionGroup> children must be keyed.`);
          }
        }
        if (prevChildren) {
          for (let i = 0; i < prevChildren.length; i++) {
            const child = prevChildren[i];
            setTransitionHooks(
              child,
              resolveTransitionHooks(child, cssTransitionProps, state, instance)
            );
            positionMap.set(child, child.el.getBoundingClientRect());
          }
        }
        return createVNode(tag, null, children);
      };
    }
  };
  var removeMode = (props) => delete props.mode;
  /* @__PURE__ */ removeMode(TransitionGroupImpl.props);
  var TransitionGroup = TransitionGroupImpl;
  function callPendingCbs(c) {
    const el = c.el;
    if (el[moveCbKey]) {
      el[moveCbKey]();
    }
    if (el[enterCbKey2]) {
      el[enterCbKey2]();
    }
  }
  function recordPosition(c) {
    newPositionMap.set(c, c.el.getBoundingClientRect());
  }
  function applyTranslation(c) {
    const oldPos = positionMap.get(c);
    const newPos = newPositionMap.get(c);
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
      const s = c.el.style;
      s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
      s.transitionDuration = "0s";
      return c;
    }
  }
  function hasCSSTransform(el, root, moveClass) {
    const clone = el.cloneNode();
    const _vtc = el[vtcKey];
    if (_vtc) {
      _vtc.forEach((cls) => {
        cls.split(/\s+/).forEach((c) => c && clone.classList.remove(c));
      });
    }
    moveClass.split(/\s+/).forEach((c) => c && clone.classList.add(c));
    clone.style.display = "none";
    const container = root.nodeType === 1 ? root : root.parentNode;
    container.appendChild(clone);
    const { hasTransform } = getTransitionInfo(clone);
    container.removeChild(clone);
    return hasTransform;
  }
  var getModelAssigner = (vnode) => {
    const fn = vnode.props["onUpdate:modelValue"] || false;
    return isArray(fn) ? (value) => invokeArrayFns(fn, value) : fn;
  };
  function onCompositionStart(e) {
    e.target.composing = true;
  }
  function onCompositionEnd(e) {
    const target = e.target;
    if (target.composing) {
      target.composing = false;
      target.dispatchEvent(new Event("input"));
    }
  }
  var assignKey = Symbol("_assign");
  var vModelText = {
    created(el, { modifiers: { lazy, trim, number } }, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      const castToNumber = number || vnode.props && vnode.props.type === "number";
      addEventListener(el, lazy ? "change" : "input", (e) => {
        if (e.target.composing)
          return;
        let domValue = el.value;
        if (trim) {
          domValue = domValue.trim();
        }
        if (castToNumber) {
          domValue = looseToNumber(domValue);
        }
        el[assignKey](domValue);
      });
      if (trim) {
        addEventListener(el, "change", () => {
          el.value = el.value.trim();
        });
      }
      if (!lazy) {
        addEventListener(el, "compositionstart", onCompositionStart);
        addEventListener(el, "compositionend", onCompositionEnd);
        addEventListener(el, "change", onCompositionEnd);
      }
    },
    mounted(el, { value }) {
      el.value = value == null ? "" : value;
    },
    beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      if (el.composing)
        return;
      const elValue = number || el.type === "number" ? looseToNumber(el.value) : el.value;
      const newValue = value == null ? "" : value;
      if (elValue === newValue) {
        return;
      }
      if (document.activeElement === el && el.type !== "range") {
        if (lazy) {
          return;
        }
        if (trim && el.value.trim() === newValue) {
          return;
        }
      }
      el.value = newValue;
    }
  };
  var systemModifiers = ["ctrl", "shift", "alt", "meta"];
  var modifierGuards = {
    stop: (e) => e.stopPropagation(),
    prevent: (e) => e.preventDefault(),
    self: (e) => e.target !== e.currentTarget,
    ctrl: (e) => !e.ctrlKey,
    shift: (e) => !e.shiftKey,
    alt: (e) => !e.altKey,
    meta: (e) => !e.metaKey,
    left: (e) => "button" in e && e.button !== 0,
    middle: (e) => "button" in e && e.button !== 1,
    right: (e) => "button" in e && e.button !== 2,
    exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
  };
  var withModifiers = (fn, modifiers) => {
    const cache = fn._withMods || (fn._withMods = {});
    const cacheKey = modifiers.join(".");
    return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
      for (let i = 0; i < modifiers.length; i++) {
        const guard = modifierGuards[modifiers[i]];
        if (guard && guard(event, modifiers))
          return;
      }
      return fn(event, ...args);
    });
  };
  var keyNames = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
  };
  var withKeys = (fn, modifiers) => {
    const cache = fn._withKeys || (fn._withKeys = {});
    const cacheKey = modifiers.join(".");
    return cache[cacheKey] || (cache[cacheKey] = (event) => {
      if (!("key" in event)) {
        return;
      }
      const eventKey = hyphenate(event.key);
      if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
        return fn(event);
      }
    });
  };
  var rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
  var renderer;
  function ensureRenderer() {
    return renderer || (renderer = createRenderer(rendererOptions));
  }
  var createApp = (...args) => {
    const app = ensureRenderer().createApp(...args);
    if (true) {
      injectNativeTagCheck(app);
      injectCompilerOptionsCheck(app);
    }
    const { mount } = app;
    app.mount = (containerOrSelector) => {
      const container = normalizeContainer(containerOrSelector);
      if (!container)
        return;
      const component = app._component;
      if (!isFunction(component) && !component.render && !component.template) {
        component.template = container.innerHTML;
      }
      container.innerHTML = "";
      const proxy = mount(container, false, resolveRootNamespace(container));
      if (container instanceof Element) {
        container.removeAttribute("v-cloak");
        container.setAttribute("data-v-app", "");
      }
      return proxy;
    };
    return app;
  };
  function resolveRootNamespace(container) {
    if (container instanceof SVGElement) {
      return "svg";
    }
    if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
      return "mathml";
    }
  }
  function injectNativeTagCheck(app) {
    Object.defineProperty(app.config, "isNativeTag", {
      value: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
      writable: false
    });
  }
  function injectCompilerOptionsCheck(app) {
    if (isRuntimeOnly()) {
      const isCustomElement = app.config.isCustomElement;
      Object.defineProperty(app.config, "isCustomElement", {
        get() {
          return isCustomElement;
        },
        set() {
          warn2(
            `The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`
          );
        }
      });
      const compilerOptions = app.config.compilerOptions;
      const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
      Object.defineProperty(app.config, "compilerOptions", {
        get() {
          warn2(msg);
          return compilerOptions;
        },
        set() {
          warn2(msg);
        }
      });
    }
  }
  function normalizeContainer(container) {
    if (isString(container)) {
      const res = document.querySelector(container);
      if (!res) {
        warn2(
          `Failed to mount app: mount target selector "${container}" returned null.`
        );
      }
      return res;
    }
    if (window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
      warn2(
        `mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`
      );
    }
    return container;
  }

  // ../library_management/node_modules/vue/dist/vue.runtime.esm-bundler.js
  function initDev() {
    {
      initCustomFormatter();
    }
  }
  if (true) {
    initDev();
  }

  // ../library_management/node_modules/vue-demi/lib/index.mjs
  var isVue2 = false;
  function set2(target, key, val) {
    if (Array.isArray(target)) {
      target.length = Math.max(target.length, key);
      target.splice(key, 1, val);
      return val;
    }
    target[key] = val;
    return val;
  }
  function del(target, key) {
    if (Array.isArray(target)) {
      target.splice(key, 1);
      return;
    }
    delete target[key];
  }

  // ../library_management/node_modules/@vue/devtools-api/lib/esm/env.js
  function getDevtoolsGlobalHook() {
    return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
  }
  function getTarget() {
    return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : {};
  }
  var isProxyAvailable = typeof Proxy === "function";

  // ../library_management/node_modules/@vue/devtools-api/lib/esm/const.js
  var HOOK_SETUP = "devtools-plugin:setup";
  var HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";

  // ../library_management/node_modules/@vue/devtools-api/lib/esm/time.js
  var supported2;
  var perf2;
  function isPerformanceSupported() {
    var _a2;
    if (supported2 !== void 0) {
      return supported2;
    }
    if (typeof window !== "undefined" && window.performance) {
      supported2 = true;
      perf2 = window.performance;
    } else if (typeof globalThis !== "undefined" && ((_a2 = globalThis.perf_hooks) === null || _a2 === void 0 ? void 0 : _a2.performance)) {
      supported2 = true;
      perf2 = globalThis.perf_hooks.performance;
    } else {
      supported2 = false;
    }
    return supported2;
  }
  function now() {
    return isPerformanceSupported() ? perf2.now() : Date.now();
  }

  // ../library_management/node_modules/@vue/devtools-api/lib/esm/proxy.js
  var ApiProxy = class {
    constructor(plugin, hook) {
      this.target = null;
      this.targetQueue = [];
      this.onQueue = [];
      this.plugin = plugin;
      this.hook = hook;
      const defaultSettings = {};
      if (plugin.settings) {
        for (const id in plugin.settings) {
          const item = plugin.settings[id];
          defaultSettings[id] = item.defaultValue;
        }
      }
      const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
      let currentSettings = Object.assign({}, defaultSettings);
      try {
        const raw = localStorage.getItem(localSettingsSaveId);
        const data = JSON.parse(raw);
        Object.assign(currentSettings, data);
      } catch (e) {
      }
      this.fallbacks = {
        getSettings() {
          return currentSettings;
        },
        setSettings(value) {
          try {
            localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
          } catch (e) {
          }
          currentSettings = value;
        },
        now() {
          return now();
        }
      };
      if (hook) {
        hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
          if (pluginId === this.plugin.id) {
            this.fallbacks.setSettings(value);
          }
        });
      }
      this.proxiedOn = new Proxy({}, {
        get: (_target, prop) => {
          if (this.target) {
            return this.target.on[prop];
          } else {
            return (...args) => {
              this.onQueue.push({
                method: prop,
                args
              });
            };
          }
        }
      });
      this.proxiedTarget = new Proxy({}, {
        get: (_target, prop) => {
          if (this.target) {
            return this.target[prop];
          } else if (prop === "on") {
            return this.proxiedOn;
          } else if (Object.keys(this.fallbacks).includes(prop)) {
            return (...args) => {
              this.targetQueue.push({
                method: prop,
                args,
                resolve: () => {
                }
              });
              return this.fallbacks[prop](...args);
            };
          } else {
            return (...args) => {
              return new Promise((resolve2) => {
                this.targetQueue.push({
                  method: prop,
                  args,
                  resolve: resolve2
                });
              });
            };
          }
        }
      });
    }
    async setRealTarget(target) {
      this.target = target;
      for (const item of this.onQueue) {
        this.target.on[item.method](...item.args);
      }
      for (const item of this.targetQueue) {
        item.resolve(await this.target[item.method](...item.args));
      }
    }
  };

  // ../library_management/node_modules/@vue/devtools-api/lib/esm/index.js
  function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
    const descriptor = pluginDescriptor;
    const target = getTarget();
    const hook = getDevtoolsGlobalHook();
    const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
    if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
      hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
    } else {
      const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
      const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
      list.push({
        pluginDescriptor: descriptor,
        setupFn,
        proxy
      });
      if (proxy) {
        setupFn(proxy.proxiedTarget);
      }
    }
  }

  // ../library_management/node_modules/pinia/dist/pinia.mjs
  var activePinia;
  var setActivePinia = (pinia) => activePinia = pinia;
  var piniaSymbol = true ? Symbol("pinia") : Symbol();
  function isPlainObject2(o) {
    return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
  }
  var MutationType;
  (function(MutationType2) {
    MutationType2["direct"] = "direct";
    MutationType2["patchObject"] = "patch object";
    MutationType2["patchFunction"] = "patch function";
  })(MutationType || (MutationType = {}));
  var IS_CLIENT = typeof window !== "undefined";
  var USE_DEVTOOLS = IS_CLIENT;
  var _global = /* @__PURE__ */ (() => typeof window === "object" && window.window === window ? window : typeof self === "object" && self.self === self ? self : typeof global === "object" && global.global === global ? global : typeof globalThis === "object" ? globalThis : { HTMLElement: null })();
  function bom(blob, { autoBom = false } = {}) {
    if (autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
      return new Blob([String.fromCharCode(65279), blob], { type: blob.type });
    }
    return blob;
  }
  function download(url, name, opts) {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.responseType = "blob";
    xhr.onload = function() {
      saveAs(xhr.response, name, opts);
    };
    xhr.onerror = function() {
      console.error("could not download file");
    };
    xhr.send();
  }
  function corsEnabled(url) {
    const xhr = new XMLHttpRequest();
    xhr.open("HEAD", url, false);
    try {
      xhr.send();
    } catch (e) {
    }
    return xhr.status >= 200 && xhr.status <= 299;
  }
  function click(node) {
    try {
      node.dispatchEvent(new MouseEvent("click"));
    } catch (e) {
      const evt = document.createEvent("MouseEvents");
      evt.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);
      node.dispatchEvent(evt);
    }
  }
  var _navigator = typeof navigator === "object" ? navigator : { userAgent: "" };
  var isMacOSWebView = /* @__PURE__ */ (() => /Macintosh/.test(_navigator.userAgent) && /AppleWebKit/.test(_navigator.userAgent) && !/Safari/.test(_navigator.userAgent))();
  var saveAs = !IS_CLIENT ? () => {
  } : typeof HTMLAnchorElement !== "undefined" && "download" in HTMLAnchorElement.prototype && !isMacOSWebView ? downloadSaveAs : "msSaveOrOpenBlob" in _navigator ? msSaveAs : fileSaverSaveAs;
  function downloadSaveAs(blob, name = "download", opts) {
    const a = document.createElement("a");
    a.download = name;
    a.rel = "noopener";
    if (typeof blob === "string") {
      a.href = blob;
      if (a.origin !== location.origin) {
        if (corsEnabled(a.href)) {
          download(blob, name, opts);
        } else {
          a.target = "_blank";
          click(a);
        }
      } else {
        click(a);
      }
    } else {
      a.href = URL.createObjectURL(blob);
      setTimeout(function() {
        URL.revokeObjectURL(a.href);
      }, 4e4);
      setTimeout(function() {
        click(a);
      }, 0);
    }
  }
  function msSaveAs(blob, name = "download", opts) {
    if (typeof blob === "string") {
      if (corsEnabled(blob)) {
        download(blob, name, opts);
      } else {
        const a = document.createElement("a");
        a.href = blob;
        a.target = "_blank";
        setTimeout(function() {
          click(a);
        });
      }
    } else {
      navigator.msSaveOrOpenBlob(bom(blob, opts), name);
    }
  }
  function fileSaverSaveAs(blob, name, opts, popup) {
    popup = popup || open("", "_blank");
    if (popup) {
      popup.document.title = popup.document.body.innerText = "downloading...";
    }
    if (typeof blob === "string")
      return download(blob, name, opts);
    const force = blob.type === "application/octet-stream";
    const isSafari = /constructor/i.test(String(_global.HTMLElement)) || "safari" in _global;
    const isChromeIOS = /CriOS\/[\d]+/.test(navigator.userAgent);
    if ((isChromeIOS || force && isSafari || isMacOSWebView) && typeof FileReader !== "undefined") {
      const reader = new FileReader();
      reader.onloadend = function() {
        let url = reader.result;
        if (typeof url !== "string") {
          popup = null;
          throw new Error("Wrong reader.result type");
        }
        url = isChromeIOS ? url : url.replace(/^data:[^;]*;/, "data:attachment/file;");
        if (popup) {
          popup.location.href = url;
        } else {
          location.assign(url);
        }
        popup = null;
      };
      reader.readAsDataURL(blob);
    } else {
      const url = URL.createObjectURL(blob);
      if (popup)
        popup.location.assign(url);
      else
        location.href = url;
      popup = null;
      setTimeout(function() {
        URL.revokeObjectURL(url);
      }, 4e4);
    }
  }
  function toastMessage(message, type2) {
    const piniaMessage = "\u{1F34D} " + message;
    if (typeof __VUE_DEVTOOLS_TOAST__ === "function") {
      __VUE_DEVTOOLS_TOAST__(piniaMessage, type2);
    } else if (type2 === "error") {
      console.error(piniaMessage);
    } else if (type2 === "warn") {
      console.warn(piniaMessage);
    } else {
      console.log(piniaMessage);
    }
  }
  function isPinia(o) {
    return "_a" in o && "install" in o;
  }
  function checkClipboardAccess() {
    if (!("clipboard" in navigator)) {
      toastMessage(`Your browser doesn't support the Clipboard API`, "error");
      return true;
    }
  }
  function checkNotFocusedError(error) {
    if (error instanceof Error && error.message.toLowerCase().includes("document is not focused")) {
      toastMessage('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn");
      return true;
    }
    return false;
  }
  async function actionGlobalCopyState(pinia) {
    if (checkClipboardAccess())
      return;
    try {
      await navigator.clipboard.writeText(JSON.stringify(pinia.state.value));
      toastMessage("Global state copied to clipboard.");
    } catch (error) {
      if (checkNotFocusedError(error))
        return;
      toastMessage(`Failed to serialize the state. Check the console for more details.`, "error");
      console.error(error);
    }
  }
  async function actionGlobalPasteState(pinia) {
    if (checkClipboardAccess())
      return;
    try {
      loadStoresState(pinia, JSON.parse(await navigator.clipboard.readText()));
      toastMessage("Global state pasted from clipboard.");
    } catch (error) {
      if (checkNotFocusedError(error))
        return;
      toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, "error");
      console.error(error);
    }
  }
  async function actionGlobalSaveState(pinia) {
    try {
      saveAs(new Blob([JSON.stringify(pinia.state.value)], {
        type: "text/plain;charset=utf-8"
      }), "pinia-state.json");
    } catch (error) {
      toastMessage(`Failed to export the state as JSON. Check the console for more details.`, "error");
      console.error(error);
    }
  }
  var fileInput;
  function getFileOpener() {
    if (!fileInput) {
      fileInput = document.createElement("input");
      fileInput.type = "file";
      fileInput.accept = ".json";
    }
    function openFile() {
      return new Promise((resolve2, reject) => {
        fileInput.onchange = async () => {
          const files = fileInput.files;
          if (!files)
            return resolve2(null);
          const file = files.item(0);
          if (!file)
            return resolve2(null);
          return resolve2({ text: await file.text(), file });
        };
        fileInput.oncancel = () => resolve2(null);
        fileInput.onerror = reject;
        fileInput.click();
      });
    }
    return openFile;
  }
  async function actionGlobalOpenStateFile(pinia) {
    try {
      const open2 = getFileOpener();
      const result = await open2();
      if (!result)
        return;
      const { text, file } = result;
      loadStoresState(pinia, JSON.parse(text));
      toastMessage(`Global state imported from "${file.name}".`);
    } catch (error) {
      toastMessage(`Failed to import the state from JSON. Check the console for more details.`, "error");
      console.error(error);
    }
  }
  function loadStoresState(pinia, state) {
    for (const key in state) {
      const storeState = pinia.state.value[key];
      if (storeState) {
        Object.assign(storeState, state[key]);
      } else {
        pinia.state.value[key] = state[key];
      }
    }
  }
  function formatDisplay(display) {
    return {
      _custom: {
        display
      }
    };
  }
  var PINIA_ROOT_LABEL = "\u{1F34D} Pinia (root)";
  var PINIA_ROOT_ID = "_root";
  function formatStoreForInspectorTree(store) {
    return isPinia(store) ? {
      id: PINIA_ROOT_ID,
      label: PINIA_ROOT_LABEL
    } : {
      id: store.$id,
      label: store.$id
    };
  }
  function formatStoreForInspectorState(store) {
    if (isPinia(store)) {
      const storeNames = Array.from(store._s.keys());
      const storeMap = store._s;
      const state2 = {
        state: storeNames.map((storeId) => ({
          editable: true,
          key: storeId,
          value: store.state.value[storeId]
        })),
        getters: storeNames.filter((id) => storeMap.get(id)._getters).map((id) => {
          const store2 = storeMap.get(id);
          return {
            editable: false,
            key: id,
            value: store2._getters.reduce((getters, key) => {
              getters[key] = store2[key];
              return getters;
            }, {})
          };
        })
      };
      return state2;
    }
    const state = {
      state: Object.keys(store.$state).map((key) => ({
        editable: true,
        key,
        value: store.$state[key]
      }))
    };
    if (store._getters && store._getters.length) {
      state.getters = store._getters.map((getterName) => ({
        editable: false,
        key: getterName,
        value: store[getterName]
      }));
    }
    if (store._customProperties.size) {
      state.customProperties = Array.from(store._customProperties).map((key) => ({
        editable: true,
        key,
        value: store[key]
      }));
    }
    return state;
  }
  function formatEventData(events) {
    if (!events)
      return {};
    if (Array.isArray(events)) {
      return events.reduce((data, event) => {
        data.keys.push(event.key);
        data.operations.push(event.type);
        data.oldValue[event.key] = event.oldValue;
        data.newValue[event.key] = event.newValue;
        return data;
      }, {
        oldValue: {},
        keys: [],
        operations: [],
        newValue: {}
      });
    } else {
      return {
        operation: formatDisplay(events.type),
        key: formatDisplay(events.key),
        oldValue: events.oldValue,
        newValue: events.newValue
      };
    }
  }
  function formatMutationType(type2) {
    switch (type2) {
      case MutationType.direct:
        return "mutation";
      case MutationType.patchFunction:
        return "$patch";
      case MutationType.patchObject:
        return "$patch";
      default:
        return "unknown";
    }
  }
  var isTimelineActive = true;
  var componentStateTypes = [];
  var MUTATIONS_LAYER_ID = "pinia:mutations";
  var INSPECTOR_ID = "pinia";
  var { assign: assign$1 } = Object;
  var getStoreType = (id) => "\u{1F34D} " + id;
  function registerPiniaDevtools(app, pinia) {
    setupDevtoolsPlugin({
      id: "dev.esm.pinia",
      label: "Pinia \u{1F34D}",
      logo: "https://pinia.vuejs.org/logo.svg",
      packageName: "pinia",
      homepage: "https://pinia.vuejs.org",
      componentStateTypes,
      app
    }, (api) => {
      if (typeof api.now !== "function") {
        toastMessage("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.");
      }
      api.addTimelineLayer({
        id: MUTATIONS_LAYER_ID,
        label: `Pinia \u{1F34D}`,
        color: 15064968
      });
      api.addInspector({
        id: INSPECTOR_ID,
        label: "Pinia \u{1F34D}",
        icon: "storage",
        treeFilterPlaceholder: "Search stores",
        actions: [
          {
            icon: "content_copy",
            action: () => {
              actionGlobalCopyState(pinia);
            },
            tooltip: "Serialize and copy the state"
          },
          {
            icon: "content_paste",
            action: async () => {
              await actionGlobalPasteState(pinia);
              api.sendInspectorTree(INSPECTOR_ID);
              api.sendInspectorState(INSPECTOR_ID);
            },
            tooltip: "Replace the state with the content of your clipboard"
          },
          {
            icon: "save",
            action: () => {
              actionGlobalSaveState(pinia);
            },
            tooltip: "Save the state as a JSON file"
          },
          {
            icon: "folder_open",
            action: async () => {
              await actionGlobalOpenStateFile(pinia);
              api.sendInspectorTree(INSPECTOR_ID);
              api.sendInspectorState(INSPECTOR_ID);
            },
            tooltip: "Import the state from a JSON file"
          }
        ],
        nodeActions: [
          {
            icon: "restore",
            tooltip: 'Reset the state (with "$reset")',
            action: (nodeId) => {
              const store = pinia._s.get(nodeId);
              if (!store) {
                toastMessage(`Cannot reset "${nodeId}" store because it wasn't found.`, "warn");
              } else if (typeof store.$reset !== "function") {
                toastMessage(`Cannot reset "${nodeId}" store because it doesn't have a "$reset" method implemented.`, "warn");
              } else {
                store.$reset();
                toastMessage(`Store "${nodeId}" reset.`);
              }
            }
          }
        ]
      });
      api.on.inspectComponent((payload, ctx) => {
        const proxy = payload.componentInstance && payload.componentInstance.proxy;
        if (proxy && proxy._pStores) {
          const piniaStores = payload.componentInstance.proxy._pStores;
          Object.values(piniaStores).forEach((store) => {
            payload.instanceData.state.push({
              type: getStoreType(store.$id),
              key: "state",
              editable: true,
              value: store._isOptionsAPI ? {
                _custom: {
                  value: toRaw(store.$state),
                  actions: [
                    {
                      icon: "restore",
                      tooltip: "Reset the state of this store",
                      action: () => store.$reset()
                    }
                  ]
                }
              } : Object.keys(store.$state).reduce((state, key) => {
                state[key] = store.$state[key];
                return state;
              }, {})
            });
            if (store._getters && store._getters.length) {
              payload.instanceData.state.push({
                type: getStoreType(store.$id),
                key: "getters",
                editable: false,
                value: store._getters.reduce((getters, key) => {
                  try {
                    getters[key] = store[key];
                  } catch (error) {
                    getters[key] = error;
                  }
                  return getters;
                }, {})
              });
            }
          });
        }
      });
      api.on.getInspectorTree((payload) => {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          let stores = [pinia];
          stores = stores.concat(Array.from(pinia._s.values()));
          payload.rootNodes = (payload.filter ? stores.filter((store) => "$id" in store ? store.$id.toLowerCase().includes(payload.filter.toLowerCase()) : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase())) : stores).map(formatStoreForInspectorTree);
        }
      });
      api.on.getInspectorState((payload) => {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia : pinia._s.get(payload.nodeId);
          if (!inspectedStore) {
            return;
          }
          if (inspectedStore) {
            payload.state = formatStoreForInspectorState(inspectedStore);
          }
        }
      });
      api.on.editInspectorState((payload, ctx) => {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia : pinia._s.get(payload.nodeId);
          if (!inspectedStore) {
            return toastMessage(`store "${payload.nodeId}" not found`, "error");
          }
          const { path: path5 } = payload;
          if (!isPinia(inspectedStore)) {
            if (path5.length !== 1 || !inspectedStore._customProperties.has(path5[0]) || path5[0] in inspectedStore.$state) {
              path5.unshift("$state");
            }
          } else {
            path5.unshift("state");
          }
          isTimelineActive = false;
          payload.set(inspectedStore, path5, payload.state.value);
          isTimelineActive = true;
        }
      });
      api.on.editComponentState((payload) => {
        if (payload.type.startsWith("\u{1F34D}")) {
          const storeId = payload.type.replace(/^🍍\s*/, "");
          const store = pinia._s.get(storeId);
          if (!store) {
            return toastMessage(`store "${storeId}" not found`, "error");
          }
          const { path: path5 } = payload;
          if (path5[0] !== "state") {
            return toastMessage(`Invalid path for store "${storeId}":
${path5}
Only state can be modified.`);
          }
          path5[0] = "$state";
          isTimelineActive = false;
          payload.set(store, path5, payload.state.value);
          isTimelineActive = true;
        }
      });
    });
  }
  function addStoreToDevtools(app, store) {
    if (!componentStateTypes.includes(getStoreType(store.$id))) {
      componentStateTypes.push(getStoreType(store.$id));
    }
    setupDevtoolsPlugin({
      id: "dev.esm.pinia",
      label: "Pinia \u{1F34D}",
      logo: "https://pinia.vuejs.org/logo.svg",
      packageName: "pinia",
      homepage: "https://pinia.vuejs.org",
      componentStateTypes,
      app,
      settings: {
        logStoreChanges: {
          label: "Notify about new/deleted stores",
          type: "boolean",
          defaultValue: true
        }
      }
    }, (api) => {
      const now2 = typeof api.now === "function" ? api.now.bind(api) : Date.now;
      store.$onAction(({ after, onError, name, args }) => {
        const groupId = runningActionId++;
        api.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: now2(),
            title: "\u{1F6EB} " + name,
            subtitle: "start",
            data: {
              store: formatDisplay(store.$id),
              action: formatDisplay(name),
              args
            },
            groupId
          }
        });
        after((result) => {
          activeAction = void 0;
          api.addTimelineEvent({
            layerId: MUTATIONS_LAYER_ID,
            event: {
              time: now2(),
              title: "\u{1F6EC} " + name,
              subtitle: "end",
              data: {
                store: formatDisplay(store.$id),
                action: formatDisplay(name),
                args,
                result
              },
              groupId
            }
          });
        });
        onError((error) => {
          activeAction = void 0;
          api.addTimelineEvent({
            layerId: MUTATIONS_LAYER_ID,
            event: {
              time: now2(),
              logType: "error",
              title: "\u{1F4A5} " + name,
              subtitle: "end",
              data: {
                store: formatDisplay(store.$id),
                action: formatDisplay(name),
                args,
                error
              },
              groupId
            }
          });
        });
      }, true);
      store._customProperties.forEach((name) => {
        watch(() => unref(store[name]), (newValue, oldValue) => {
          api.notifyComponentUpdate();
          api.sendInspectorState(INSPECTOR_ID);
          if (isTimelineActive) {
            api.addTimelineEvent({
              layerId: MUTATIONS_LAYER_ID,
              event: {
                time: now2(),
                title: "Change",
                subtitle: name,
                data: {
                  newValue,
                  oldValue
                },
                groupId: activeAction
              }
            });
          }
        }, { deep: true });
      });
      store.$subscribe(({ events, type: type2 }, state) => {
        api.notifyComponentUpdate();
        api.sendInspectorState(INSPECTOR_ID);
        if (!isTimelineActive)
          return;
        const eventData = {
          time: now2(),
          title: formatMutationType(type2),
          data: assign$1({ store: formatDisplay(store.$id) }, formatEventData(events)),
          groupId: activeAction
        };
        if (type2 === MutationType.patchFunction) {
          eventData.subtitle = "\u2935\uFE0F";
        } else if (type2 === MutationType.patchObject) {
          eventData.subtitle = "\u{1F9E9}";
        } else if (events && !Array.isArray(events)) {
          eventData.subtitle = events.type;
        }
        if (events) {
          eventData.data["rawEvent(s)"] = {
            _custom: {
              display: "DebuggerEvent",
              type: "object",
              tooltip: "raw DebuggerEvent[]",
              value: events
            }
          };
        }
        api.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: eventData
        });
      }, { detached: true, flush: "sync" });
      const hotUpdate = store._hotUpdate;
      store._hotUpdate = markRaw((newStore) => {
        hotUpdate(newStore);
        api.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: now2(),
            title: "\u{1F525} " + store.$id,
            subtitle: "HMR update",
            data: {
              store: formatDisplay(store.$id),
              info: formatDisplay(`HMR update`)
            }
          }
        });
        api.notifyComponentUpdate();
        api.sendInspectorTree(INSPECTOR_ID);
        api.sendInspectorState(INSPECTOR_ID);
      });
      const { $dispose } = store;
      store.$dispose = () => {
        $dispose();
        api.notifyComponentUpdate();
        api.sendInspectorTree(INSPECTOR_ID);
        api.sendInspectorState(INSPECTOR_ID);
        api.getSettings().logStoreChanges && toastMessage(`Disposed "${store.$id}" store \u{1F5D1}`);
      };
      api.notifyComponentUpdate();
      api.sendInspectorTree(INSPECTOR_ID);
      api.sendInspectorState(INSPECTOR_ID);
      api.getSettings().logStoreChanges && toastMessage(`"${store.$id}" store installed \u{1F195}`);
    });
  }
  var runningActionId = 0;
  var activeAction;
  function patchActionForGrouping(store, actionNames, wrapWithProxy) {
    const actions = actionNames.reduce((storeActions, actionName) => {
      storeActions[actionName] = toRaw(store)[actionName];
      return storeActions;
    }, {});
    for (const actionName in actions) {
      store[actionName] = function() {
        const _actionId = runningActionId;
        const trackedStore = wrapWithProxy ? new Proxy(store, {
          get(...args) {
            activeAction = _actionId;
            return Reflect.get(...args);
          },
          set(...args) {
            activeAction = _actionId;
            return Reflect.set(...args);
          }
        }) : store;
        activeAction = _actionId;
        const retValue = actions[actionName].apply(trackedStore, arguments);
        activeAction = void 0;
        return retValue;
      };
    }
  }
  function devtoolsPlugin({ app, store, options }) {
    if (store.$id.startsWith("__hot:")) {
      return;
    }
    store._isOptionsAPI = !!options.state;
    patchActionForGrouping(store, Object.keys(options.actions), store._isOptionsAPI);
    const originalHotUpdate = store._hotUpdate;
    toRaw(store)._hotUpdate = function(newStore) {
      originalHotUpdate.apply(this, arguments);
      patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions), !!store._isOptionsAPI);
    };
    addStoreToDevtools(
      app,
      store
    );
  }
  function createPinia() {
    const scope = effectScope(true);
    const state = scope.run(() => ref({}));
    let _p = [];
    let toBeInstalled = [];
    const pinia = markRaw({
      install(app) {
        setActivePinia(pinia);
        if (!isVue2) {
          pinia._a = app;
          app.provide(piniaSymbol, pinia);
          app.config.globalProperties.$pinia = pinia;
          if (USE_DEVTOOLS) {
            registerPiniaDevtools(app, pinia);
          }
          toBeInstalled.forEach((plugin) => _p.push(plugin));
          toBeInstalled = [];
        }
      },
      use(plugin) {
        if (!this._a && !isVue2) {
          toBeInstalled.push(plugin);
        } else {
          _p.push(plugin);
        }
        return this;
      },
      _p,
      _a: null,
      _e: scope,
      _s: /* @__PURE__ */ new Map(),
      state
    });
    if (USE_DEVTOOLS && typeof Proxy !== "undefined") {
      pinia.use(devtoolsPlugin);
    }
    return pinia;
  }
  function patchObject(newState, oldState) {
    for (const key in oldState) {
      const subPatch = oldState[key];
      if (!(key in newState)) {
        continue;
      }
      const targetValue = newState[key];
      if (isPlainObject2(targetValue) && isPlainObject2(subPatch) && !isRef(subPatch) && !isReactive(subPatch)) {
        newState[key] = patchObject(targetValue, subPatch);
      } else {
        if (isVue2) {
          set2(newState, key, subPatch);
        } else {
          newState[key] = subPatch;
        }
      }
    }
    return newState;
  }
  var noop = () => {
  };
  function addSubscription(subscriptions, callback, detached, onCleanup = noop) {
    subscriptions.push(callback);
    const removeSubscription = () => {
      const idx = subscriptions.indexOf(callback);
      if (idx > -1) {
        subscriptions.splice(idx, 1);
        onCleanup();
      }
    };
    if (!detached && getCurrentScope()) {
      onScopeDispose(removeSubscription);
    }
    return removeSubscription;
  }
  function triggerSubscriptions(subscriptions, ...args) {
    subscriptions.slice().forEach((callback) => {
      callback(...args);
    });
  }
  var fallbackRunWithContext = (fn) => fn();
  function mergeReactiveObjects(target, patchToApply) {
    if (target instanceof Map && patchToApply instanceof Map) {
      patchToApply.forEach((value, key) => target.set(key, value));
    }
    if (target instanceof Set && patchToApply instanceof Set) {
      patchToApply.forEach(target.add, target);
    }
    for (const key in patchToApply) {
      if (!patchToApply.hasOwnProperty(key))
        continue;
      const subPatch = patchToApply[key];
      const targetValue = target[key];
      if (isPlainObject2(targetValue) && isPlainObject2(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
        target[key] = mergeReactiveObjects(targetValue, subPatch);
      } else {
        target[key] = subPatch;
      }
    }
    return target;
  }
  var skipHydrateSymbol = true ? Symbol("pinia:skipHydration") : Symbol();
  var skipHydrateMap = /* @__PURE__ */ new WeakMap();
  function shouldHydrate(obj) {
    return isVue2 ? !skipHydrateMap.has(obj) : !isPlainObject2(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
  }
  var { assign } = Object;
  function isComputed(o) {
    return !!(isRef(o) && o.effect);
  }
  function createOptionsStore(id, options, pinia, hot) {
    const { state, actions, getters } = options;
    const initialState = pinia.state.value[id];
    let store;
    function setup() {
      if (!initialState && !hot) {
        if (isVue2) {
          set2(pinia.state.value, id, state ? state() : {});
        } else {
          pinia.state.value[id] = state ? state() : {};
        }
      }
      const localState = hot ? toRefs(ref(state ? state() : {}).value) : toRefs(pinia.state.value[id]);
      return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
        if (name in localState) {
          console.warn(`[\u{1F34D}]: A getter cannot have the same name as another state property. Rename one of them. Found with "${name}" in store "${id}".`);
        }
        computedGetters[name] = markRaw(computed2(() => {
          setActivePinia(pinia);
          const store2 = pinia._s.get(id);
          if (isVue2 && !store2._r)
            return;
          return getters[name].call(store2, store2);
        }));
        return computedGetters;
      }, {}));
    }
    store = createSetupStore(id, setup, options, pinia, hot, true);
    return store;
  }
  function createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {
    let scope;
    const optionsForPlugin = assign({ actions: {} }, options);
    if (!pinia._e.active) {
      throw new Error("Pinia destroyed");
    }
    const $subscribeOptions = {
      deep: true
    };
    if (!isVue2) {
      $subscribeOptions.onTrigger = (event) => {
        if (isListening) {
          debuggerEvents = event;
        } else if (isListening == false && !store._hotUpdating) {
          if (Array.isArray(debuggerEvents)) {
            debuggerEvents.push(event);
          } else {
            console.error("\u{1F34D} debuggerEvents should be an array. This is most likely an internal Pinia bug.");
          }
        }
      };
    }
    let isListening;
    let isSyncListening;
    let subscriptions = [];
    let actionSubscriptions = [];
    let debuggerEvents;
    const initialState = pinia.state.value[$id];
    if (!isOptionsStore && !initialState && !hot) {
      if (isVue2) {
        set2(pinia.state.value, $id, {});
      } else {
        pinia.state.value[$id] = {};
      }
    }
    const hotState = ref({});
    let activeListener;
    function $patch(partialStateOrMutator) {
      let subscriptionMutation;
      isListening = isSyncListening = false;
      if (true) {
        debuggerEvents = [];
      }
      if (typeof partialStateOrMutator === "function") {
        partialStateOrMutator(pinia.state.value[$id]);
        subscriptionMutation = {
          type: MutationType.patchFunction,
          storeId: $id,
          events: debuggerEvents
        };
      } else {
        mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
        subscriptionMutation = {
          type: MutationType.patchObject,
          payload: partialStateOrMutator,
          storeId: $id,
          events: debuggerEvents
        };
      }
      const myListenerId = activeListener = Symbol();
      nextTick().then(() => {
        if (activeListener === myListenerId) {
          isListening = true;
        }
      });
      isSyncListening = true;
      triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
    }
    const $reset = isOptionsStore ? function $reset2() {
      const { state } = options;
      const newState = state ? state() : {};
      this.$patch(($state) => {
        assign($state, newState);
      });
    } : true ? () => {
      throw new Error(`\u{1F34D}: Store "${$id}" is built using the setup syntax and does not implement $reset().`);
    } : noop;
    function $dispose() {
      scope.stop();
      subscriptions = [];
      actionSubscriptions = [];
      pinia._s.delete($id);
    }
    function wrapAction(name, action) {
      return function() {
        setActivePinia(pinia);
        const args = Array.from(arguments);
        const afterCallbackList = [];
        const onErrorCallbackList = [];
        function after(callback) {
          afterCallbackList.push(callback);
        }
        function onError(callback) {
          onErrorCallbackList.push(callback);
        }
        triggerSubscriptions(actionSubscriptions, {
          args,
          name,
          store,
          after,
          onError
        });
        let ret;
        try {
          ret = action.apply(this && this.$id === $id ? this : store, args);
        } catch (error) {
          triggerSubscriptions(onErrorCallbackList, error);
          throw error;
        }
        if (ret instanceof Promise) {
          return ret.then((value) => {
            triggerSubscriptions(afterCallbackList, value);
            return value;
          }).catch((error) => {
            triggerSubscriptions(onErrorCallbackList, error);
            return Promise.reject(error);
          });
        }
        triggerSubscriptions(afterCallbackList, ret);
        return ret;
      };
    }
    const _hmrPayload = /* @__PURE__ */ markRaw({
      actions: {},
      getters: {},
      state: [],
      hotState
    });
    const partialStore = {
      _p: pinia,
      $id,
      $onAction: addSubscription.bind(null, actionSubscriptions),
      $patch,
      $reset,
      $subscribe(callback, options2 = {}) {
        const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
        const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state) => {
          if (options2.flush === "sync" ? isSyncListening : isListening) {
            callback({
              storeId: $id,
              type: MutationType.direct,
              events: debuggerEvents
            }, state);
          }
        }, assign({}, $subscribeOptions, options2)));
        return removeSubscription;
      },
      $dispose
    };
    if (isVue2) {
      partialStore._r = false;
    }
    const store = reactive(true ? assign(
      {
        _hmrPayload,
        _customProperties: markRaw(/* @__PURE__ */ new Set())
      },
      partialStore
    ) : partialStore);
    pinia._s.set($id, store);
    const runWithContext = pinia._a && pinia._a.runWithContext || fallbackRunWithContext;
    const setupStore = runWithContext(() => pinia._e.run(() => (scope = effectScope()).run(setup)));
    for (const key in setupStore) {
      const prop = setupStore[key];
      if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
        if (hot) {
          set2(hotState.value, key, toRef(setupStore, key));
        } else if (!isOptionsStore) {
          if (initialState && shouldHydrate(prop)) {
            if (isRef(prop)) {
              prop.value = initialState[key];
            } else {
              mergeReactiveObjects(prop, initialState[key]);
            }
          }
          if (isVue2) {
            set2(pinia.state.value[$id], key, prop);
          } else {
            pinia.state.value[$id][key] = prop;
          }
        }
        if (true) {
          _hmrPayload.state.push(key);
        }
      } else if (typeof prop === "function") {
        const actionValue = hot ? prop : wrapAction(key, prop);
        if (isVue2) {
          set2(setupStore, key, actionValue);
        } else {
          setupStore[key] = actionValue;
        }
        if (true) {
          _hmrPayload.actions[key] = prop;
        }
        optionsForPlugin.actions[key] = prop;
      } else if (true) {
        if (isComputed(prop)) {
          _hmrPayload.getters[key] = isOptionsStore ? options.getters[key] : prop;
          if (IS_CLIENT) {
            const getters = setupStore._getters || (setupStore._getters = markRaw([]));
            getters.push(key);
          }
        }
      }
    }
    if (isVue2) {
      Object.keys(setupStore).forEach((key) => {
        set2(store, key, setupStore[key]);
      });
    } else {
      assign(store, setupStore);
      assign(toRaw(store), setupStore);
    }
    Object.defineProperty(store, "$state", {
      get: () => hot ? hotState.value : pinia.state.value[$id],
      set: (state) => {
        if (hot) {
          throw new Error("cannot set hotState");
        }
        $patch(($state) => {
          assign($state, state);
        });
      }
    });
    if (true) {
      store._hotUpdate = markRaw((newStore) => {
        store._hotUpdating = true;
        newStore._hmrPayload.state.forEach((stateKey) => {
          if (stateKey in store.$state) {
            const newStateTarget = newStore.$state[stateKey];
            const oldStateSource = store.$state[stateKey];
            if (typeof newStateTarget === "object" && isPlainObject2(newStateTarget) && isPlainObject2(oldStateSource)) {
              patchObject(newStateTarget, oldStateSource);
            } else {
              newStore.$state[stateKey] = oldStateSource;
            }
          }
          set2(store, stateKey, toRef(newStore.$state, stateKey));
        });
        Object.keys(store.$state).forEach((stateKey) => {
          if (!(stateKey in newStore.$state)) {
            del(store, stateKey);
          }
        });
        isListening = false;
        isSyncListening = false;
        pinia.state.value[$id] = toRef(newStore._hmrPayload, "hotState");
        isSyncListening = true;
        nextTick().then(() => {
          isListening = true;
        });
        for (const actionName in newStore._hmrPayload.actions) {
          const action = newStore[actionName];
          set2(store, actionName, wrapAction(actionName, action));
        }
        for (const getterName in newStore._hmrPayload.getters) {
          const getter = newStore._hmrPayload.getters[getterName];
          const getterValue = isOptionsStore ? computed2(() => {
            setActivePinia(pinia);
            return getter.call(store, store);
          }) : getter;
          set2(store, getterName, getterValue);
        }
        Object.keys(store._hmrPayload.getters).forEach((key) => {
          if (!(key in newStore._hmrPayload.getters)) {
            del(store, key);
          }
        });
        Object.keys(store._hmrPayload.actions).forEach((key) => {
          if (!(key in newStore._hmrPayload.actions)) {
            del(store, key);
          }
        });
        store._hmrPayload = newStore._hmrPayload;
        store._getters = newStore._getters;
        store._hotUpdating = false;
      });
    }
    if (USE_DEVTOOLS) {
      const nonEnumerable = {
        writable: true,
        configurable: true,
        enumerable: false
      };
      ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach((p2) => {
        Object.defineProperty(store, p2, assign({ value: store[p2] }, nonEnumerable));
      });
    }
    if (isVue2) {
      store._r = true;
    }
    pinia._p.forEach((extender) => {
      if (USE_DEVTOOLS) {
        const extensions = scope.run(() => extender({
          store,
          app: pinia._a,
          pinia,
          options: optionsForPlugin
        }));
        Object.keys(extensions || {}).forEach((key) => store._customProperties.add(key));
        assign(store, extensions);
      } else {
        assign(store, scope.run(() => extender({
          store,
          app: pinia._a,
          pinia,
          options: optionsForPlugin
        })));
      }
    });
    if (store.$state && typeof store.$state === "object" && typeof store.$state.constructor === "function" && !store.$state.constructor.toString().includes("[native code]")) {
      console.warn(`[\u{1F34D}]: The "state" must be a plain object. It cannot be
	state: () => new MyClass()
Found in store "${store.$id}".`);
    }
    if (initialState && isOptionsStore && options.hydrate) {
      options.hydrate(store.$state, initialState);
    }
    isListening = true;
    isSyncListening = true;
    return store;
  }
  function defineStore(idOrOptions, setup, setupOptions) {
    let id;
    let options;
    const isSetupStore = typeof setup === "function";
    if (typeof idOrOptions === "string") {
      id = idOrOptions;
      options = isSetupStore ? setupOptions : setup;
    } else {
      options = idOrOptions;
      id = idOrOptions.id;
      if (typeof id !== "string") {
        throw new Error(`[\u{1F34D}]: "defineStore()" must be passed a store id as its first argument.`);
      }
    }
    function useStore(pinia, hot) {
      const hasContext = hasInjectionContext();
      pinia = (false ? null : pinia) || (hasContext ? inject(piniaSymbol, null) : null);
      if (pinia)
        setActivePinia(pinia);
      if (!activePinia) {
        throw new Error(`[\u{1F34D}]: "getActivePinia()" was called but there was no active Pinia. Are you trying to use a store before calling "app.use(pinia)"?
See https://pinia.vuejs.org/core-concepts/outside-component-usage.html for help.
This will fail in production.`);
      }
      pinia = activePinia;
      if (!pinia._s.has(id)) {
        if (isSetupStore) {
          createSetupStore(id, setup, options, pinia);
        } else {
          createOptionsStore(id, options, pinia);
        }
        if (true) {
          useStore._pinia = pinia;
        }
      }
      const store = pinia._s.get(id);
      if (hot) {
        const hotId = "__hot:" + id;
        const newStore = isSetupStore ? createSetupStore(hotId, setup, options, pinia, true) : createOptionsStore(hotId, assign({}, options), pinia, true);
        hot._hotUpdate(newStore);
        delete pinia.state.value[hotId];
        pinia._s.delete(hotId);
      }
      if (IS_CLIENT) {
        const currentInstance2 = getCurrentInstance();
        if (currentInstance2 && currentInstance2.proxy && !hot) {
          const vm = currentInstance2.proxy;
          const cache = "_pStores" in vm ? vm._pStores : vm._pStores = {};
          cache[id] = store;
        }
      }
      return store;
    }
    useStore.$id = id;
    return useStore;
  }

  // ../library_management/library_management/public/js/books/store.js
  var useBooksStore = defineStore("books", {
    state: () => {
      return {
        books: ref([]),
        search_book: ref(""),
        book_category: ref(""),
        book_categories: ref([]),
        book_author: ref(""),
        book_subject: ref(""),
        book_tag: ref(""),
        book_edition: ref(""),
        year_of_publication: ref("")
      };
    },
    getters: {},
    actions: {
      get_books() {
        frappe.call({
          method: "library_management.api.api.get_books",
          args: {},
          callback: (r) => {
            if (r.message.length > 0) {
              this.books = r.message;
            } else {
              this.books = [];
            }
          }
        });
      },
      get_book_categories() {
        frappe.call({
          method: "library_management.api.api.get_book_categories",
          args: {},
          callback: (r) => {
            if (r.message.length > 0) {
              this.book_categories = r.message;
            } else {
              this.book_categories = [];
            }
          }
        });
      },
      search_books() {
        frappe.call({
          method: "library_management.api.api.search_books",
          args: {
            book_title: this.search_book
          },
          callback: (r) => {
            if (r.message.length > 0) {
              this.books = r.message;
            } else {
              this.books = [];
            }
          }
        });
      },
      get_books_by_category() {
        frappe.call({
          method: "library_management.api.api.get_books_by_category",
          args: {
            book_category: this.book_category
          },
          callback: (r) => {
            if (r.message.length > 0) {
              this.books = r.message;
            } else {
              this.books = [];
            }
          }
        });
      },
      get_books_by_author() {
        frappe.call({
          method: "library_management.api.api.get_books_by_author",
          args: {
            author: this.book_author
          },
          callback: (r) => {
            if (r.message.length > 0) {
              this.books = r.message;
            } else {
              this.books = [];
            }
          }
        });
      },
      get_books_by_subject() {
        frappe.call({
          method: "library_management.api.api.get_books_by_subject",
          args: {
            subject: this.book_subject
          },
          callback: (r) => {
            if (r.message.length > 0) {
              this.books = r.message;
            } else {
              this.books = [];
            }
          }
        });
      },
      get_books_by_tag() {
        frappe.call({
          method: "library_management.api.api.get_books_by_book_tag",
          args: {
            book_tag: this.book_tag
          },
          callback: (r) => {
            if (r.message.length > 0) {
              this.books = r.message;
            } else {
              this.books = [];
            }
          }
        });
      },
      get_books_by_edition() {
        frappe.call({
          method: "library_management.api.api.get_books_by_book_edition",
          args: {
            edition: this.book_edition
          },
          callback: (r) => {
            if (r.message.length > 0) {
              this.books = r.message;
            } else {
              this.books = [];
            }
          }
        });
      },
      get_books_by_year_of_publication() {
        frappe.call({
          method: "library_management.api.api.get_books_by_publication_year",
          args: {
            year_of_publication: this.year_of_publication
          },
          callback: (r) => {
            if (r.message.length > 0) {
              this.books = r.message;
            } else {
              this.books = [];
            }
          }
        });
      }
    }
  });

  // sfc-script:/home/dev2/projects/v15/apps/library_management/library_management/public/js/ebook_reader/components/Sidebar.vue?type=script
  var Sidebar_default = {
    name: "Sidebar",
    props: ["drawer", "bookstore"],
    emits: ["toggle-drawer", "item-selected"],
    data() {
      return {
        exploreBook: false,
        openFilters: false
      };
    },
    methods: {
      toggleSidebar() {
        this.$emit("toggle-drawer");
      },
      toggleGroup(group) {
        this[group] = !this[group];
      },
      get_books_by_category(category) {
        this.bookstore.book_category = category;
        this.bookstore.get_books_by_category();
      },
      get_books_by_author(author) {
        this.bookstore.book_author = author;
        this.bookstore.get_books_by_author();
      },
      get_books_by_subject(subject) {
        this.bookstore.book_subject = subject;
        this.bookstore.get_books_by_subject();
      },
      get_books_by_book_tag(tag) {
        this.bookstore.book_tag = tag;
        this.bookstore.get_books_by_tag();
      },
      get_books_by_book_edition(edition) {
        this.bookstore.book_edition = edition;
        this.bookstore.get_books_by_edition();
      },
      get_books_by_year_of_publication(year_of_publication) {
        this.bookstore.year_of_publication = year_of_publication;
        this.bookstore.get_books_by_year_of_publication();
      }
    }
  };

  // sfc-template:/home/dev2/projects/v15/apps/library_management/library_management/public/js/ebook_reader/components/Sidebar.vue?type=template
  function render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_app_bar_nav_icon = resolveComponent("v-app-bar-nav-icon");
    const _component_v_tooltip = resolveComponent("v-tooltip");
    const _component_v_spacer = resolveComponent("v-spacer");
    const _component_v_toolbar_title = resolveComponent("v-toolbar-title");
    const _component_v_text_field = resolveComponent("v-text-field");
    const _component_v_toolbar = resolveComponent("v-toolbar");
    const _component_v_card = resolveComponent("v-card");
    const _component_v_list_item = resolveComponent("v-list-item");
    const _component_v_list_group = resolveComponent("v-list-group");
    const _component_v_list_item_title = resolveComponent("v-list-item-title");
    const _component_v_list = resolveComponent("v-list");
    const _component_v_navigation_drawer = resolveComponent("v-navigation-drawer");
    return openBlock(), createElementBlock(Fragment, null, [
      createVNode(_component_v_toolbar, { color: "primary" }, {
        prepend: withCtx(() => [
          createVNode(_component_v_app_bar_nav_icon, { onClick: $options.toggleSidebar }, null, 8, ["onClick"]),
          createVNode(_component_v_tooltip, {
            activator: "parent",
            location: "bottom"
          }, {
            default: withCtx(() => [
              createTextVNode("Toggle Sidebar")
            ]),
            _: 1
          })
        ]),
        default: withCtx(() => [
          createVNode(_component_v_spacer),
          createVNode(_component_v_toolbar_title, null, {
            default: withCtx(() => [
              createTextVNode("Book List")
            ]),
            _: 1
          }),
          createVNode(_component_v_spacer),
          createVNode(_component_v_text_field, {
            "bg-color": "white",
            rounded: "pill",
            dense: "",
            modelValue: $props.bookstore.search_book,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $props.bookstore.search_book = $event),
            "prepend-icon": "mdi-magnify",
            label: "Search Books",
            onInput: _cache[1] || (_cache[1] = ($event) => $props.bookstore.search_books()),
            "single-line": "",
            "hide-details": ""
          }, null, 8, ["modelValue"]),
          createVNode(_component_v_spacer)
        ]),
        _: 1
      }),
      $props.drawer ? (openBlock(), createBlock(_component_v_navigation_drawer, {
        key: 0,
        app: "",
        class: "nav-drawer"
      }, {
        default: withCtx(() => [
          createVNode(_component_v_card, {
            height: "64",
            color: "primary"
          }),
          createVNode(_component_v_card, { class: "mx-auto" }, {
            default: withCtx(() => [
              createVNode(_component_v_list, null, {
                default: withCtx(() => [
                  createVNode(_component_v_list_group, {
                    modelValue: $data.openFilters,
                    "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => $data.openFilters = $event),
                    onClick: _cache[15] || (_cache[15] = ($event) => $options.toggleGroup("openFilters")),
                    value: "FILTERS:"
                  }, {
                    activator: withCtx(({ props }) => [
                      createVNode(_component_v_list_item, mergeProps(props, {
                        "prepend-icon": "mdi-air-filter",
                        title: "FILTERS:",
                        align: "left"
                      }), null, 16)
                    ]),
                    default: withCtx(() => [
                      createVNode(_component_v_list_item, {
                        color: "primary",
                        rounded: "shaped"
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_v_text_field, {
                            modelValue: $props.bookstore.search_book,
                            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $props.bookstore.search_book = $event),
                            label: "Title",
                            required: "",
                            align: "left",
                            onInput: _cache[3] || (_cache[3] = ($event) => $props.bookstore.search_books()),
                            "single-line": "",
                            "hide-details": ""
                          }, null, 8, ["modelValue"])
                        ]),
                        _: 1
                      }),
                      createVNode(_component_v_list_item, {
                        color: "primary",
                        rounded: "shaped"
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_v_text_field, {
                            modelValue: $props.bookstore.book_author,
                            "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $props.bookstore.book_author = $event),
                            label: "Author",
                            required: "",
                            align: "left",
                            onInput: _cache[5] || (_cache[5] = ($event) => $options.get_books_by_author($props.bookstore.book_author)),
                            "single-line": "",
                            "hide-details": ""
                          }, null, 8, ["modelValue"])
                        ]),
                        _: 1
                      }),
                      createVNode(_component_v_list_item, {
                        color: "primary",
                        rounded: "shaped"
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_v_text_field, {
                            modelValue: $props.bookstore.book_subject,
                            "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => $props.bookstore.book_subject = $event),
                            label: "Subject",
                            required: "",
                            align: "left",
                            onInput: _cache[7] || (_cache[7] = ($event) => $options.get_books_by_subject($props.bookstore.book_subject)),
                            "single-line": "",
                            "hide-details": ""
                          }, null, 8, ["modelValue"])
                        ]),
                        _: 1
                      }),
                      createVNode(_component_v_list_item, {
                        color: "primary",
                        rounded: "shaped"
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_v_text_field, {
                            modelValue: $props.bookstore.book_tag,
                            "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => $props.bookstore.book_tag = $event),
                            label: "Book Tag",
                            required: "",
                            align: "left",
                            onInput: _cache[9] || (_cache[9] = ($event) => $options.get_books_by_book_tag($props.bookstore.book_tag)),
                            "single-line": "",
                            "hide-details": ""
                          }, null, 8, ["modelValue"])
                        ]),
                        _: 1
                      }),
                      createVNode(_component_v_list_item, {
                        color: "primary",
                        rounded: "shaped"
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_v_text_field, {
                            modelValue: $props.bookstore.book_edition,
                            "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => $props.bookstore.book_edition = $event),
                            label: "Edition",
                            required: "",
                            align: "left",
                            onInput: _cache[11] || (_cache[11] = ($event) => $options.get_books_by_book_edition($props.bookstore.book_edition)),
                            "single-line": "",
                            "hide-details": ""
                          }, null, 8, ["modelValue"])
                        ]),
                        _: 1
                      }),
                      createVNode(_component_v_list_item, {
                        color: "primary",
                        rounded: "shaped"
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_v_text_field, {
                            modelValue: $props.bookstore.year_of_publication,
                            "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => $props.bookstore.year_of_publication = $event),
                            label: "Year of Publication",
                            onInput: _cache[13] || (_cache[13] = ($event) => $options.get_books_by_year_of_publication($props.bookstore.year_of_publication)),
                            required: "",
                            align: "left",
                            "single-line": "",
                            "hide-details": ""
                          }, null, 8, ["modelValue"])
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["modelValue"]),
                  createVNode(_component_v_list_group, {
                    modelValue: $data.exploreBook,
                    "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => $data.exploreBook = $event),
                    onClick: _cache[17] || (_cache[17] = ($event) => $options.toggleGroup("exploreBook")),
                    value: "CATEGORIES:"
                  }, {
                    activator: withCtx(({ props }) => [
                      createVNode(_component_v_list_item, mergeProps(props, {
                        "prepend-icon": "mdi-book-multiple",
                        title: "CATEGORIES:",
                        align: "left"
                      }), null, 16)
                    ]),
                    default: withCtx(() => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList($props.bookstore.book_categories, (item) => {
                        return openBlock(), createBlock(_component_v_list_item, {
                          color: "primary",
                          rounded: "shaped",
                          key: item.category,
                          onClick: ($event) => $options.get_books_by_category(item.category),
                          modelValue: item.category,
                          "onUpdate:modelValue": ($event) => item.category = $event
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_list_item_title, {
                              align: "left",
                              textContent: toDisplayString(item.category)
                            }, null, 8, ["textContent"])
                          ]),
                          _: 2
                        }, 1032, ["onClick", "modelValue", "onUpdate:modelValue"]);
                      }), 128))
                    ]),
                    _: 1
                  }, 8, ["modelValue"])
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      })) : createCommentVNode("v-if", true)
    ], 64);
  }

  // ../library_management/library_management/public/js/ebook_reader/components/Sidebar.vue
  Sidebar_default.render = render;
  Sidebar_default.__file = "../library_management/library_management/public/js/ebook_reader/components/Sidebar.vue";
  Sidebar_default.__scopeId = "data-v-899d8ded";
  var Sidebar_default2 = Sidebar_default;

  // ../library_management/node_modules/epubjs/src/book.js
  var import_event_emitter10 = __toESM(require_event_emitter());

  // ../library_management/node_modules/epubjs/src/utils/core.js
  var core_exports = {};
  __export(core_exports, {
    RangeObject: () => RangeObject,
    blob2base64: () => blob2base64,
    borders: () => borders,
    bounds: () => bounds,
    createBase64Url: () => createBase64Url,
    createBlob: () => createBlob,
    createBlobUrl: () => createBlobUrl,
    defaults: () => defaults,
    defer: () => defer,
    documentHeight: () => documentHeight,
    extend: () => extend2,
    filterChildren: () => filterChildren,
    findChildren: () => findChildren,
    getParentByTagName: () => getParentByTagName,
    indexOfElementNode: () => indexOfElementNode,
    indexOfNode: () => indexOfNode,
    indexOfSorted: () => indexOfSorted,
    indexOfTextNode: () => indexOfTextNode,
    insert: () => insert,
    isElement: () => isElement,
    isFloat: () => isFloat,
    isNumber: () => isNumber,
    isXml: () => isXml,
    locationOf: () => locationOf,
    nodeBounds: () => nodeBounds,
    parents: () => parents,
    parse: () => parse,
    prefixed: () => prefixed,
    qs: () => qs,
    qsa: () => qsa,
    qsp: () => qsp,
    querySelectorByType: () => querySelectorByType,
    requestAnimationFrame: () => requestAnimationFrame2,
    revokeBlobUrl: () => revokeBlobUrl,
    sprint: () => sprint,
    treeWalker: () => treeWalker,
    type: () => type,
    uuid: () => uuid,
    walk: () => walk,
    windowBounds: () => windowBounds
  });
  var import_xmldom = __toESM(require_lib());
  var requestAnimationFrame2 = typeof window != "undefined" ? window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame : false;
  var ELEMENT_NODE = 1;
  var TEXT_NODE = 3;
  var _URL = typeof URL != "undefined" ? URL : typeof window != "undefined" ? window.URL || window.webkitURL || window.mozURL : void 0;
  function uuid() {
    var d = new Date().getTime();
    var uuid2 = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      var r = (d + Math.random() * 16) % 16 | 0;
      d = Math.floor(d / 16);
      return (c == "x" ? r : r & 7 | 8).toString(16);
    });
    return uuid2;
  }
  function documentHeight() {
    return Math.max(
      document.documentElement.clientHeight,
      document.body.scrollHeight,
      document.documentElement.scrollHeight,
      document.body.offsetHeight,
      document.documentElement.offsetHeight
    );
  }
  function isElement(obj) {
    return !!(obj && obj.nodeType == 1);
  }
  function isNumber(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  }
  function isFloat(n) {
    let f = parseFloat(n);
    if (isNumber(n) === false) {
      return false;
    }
    if (typeof n === "string" && n.indexOf(".") > -1) {
      return true;
    }
    return Math.floor(f) !== f;
  }
  function prefixed(unprefixed) {
    var vendors = ["Webkit", "webkit", "Moz", "O", "ms"];
    var prefixes2 = ["-webkit-", "-webkit-", "-moz-", "-o-", "-ms-"];
    var lower = unprefixed.toLowerCase();
    var length = vendors.length;
    if (typeof document === "undefined" || typeof document.body.style[lower] != "undefined") {
      return unprefixed;
    }
    for (var i = 0; i < length; i++) {
      if (typeof document.body.style[prefixes2[i] + lower] != "undefined") {
        return prefixes2[i] + lower;
      }
    }
    return unprefixed;
  }
  function defaults(obj) {
    for (var i = 1, length = arguments.length; i < length; i++) {
      var source = arguments[i];
      for (var prop in source) {
        if (obj[prop] === void 0)
          obj[prop] = source[prop];
      }
    }
    return obj;
  }
  function extend2(target) {
    var sources = [].slice.call(arguments, 1);
    sources.forEach(function(source) {
      if (!source)
        return;
      Object.getOwnPropertyNames(source).forEach(function(propName) {
        Object.defineProperty(target, propName, Object.getOwnPropertyDescriptor(source, propName));
      });
    });
    return target;
  }
  function insert(item, array, compareFunction) {
    var location2 = locationOf(item, array, compareFunction);
    array.splice(location2, 0, item);
    return location2;
  }
  function locationOf(item, array, compareFunction, _start, _end) {
    var start = _start || 0;
    var end = _end || array.length;
    var pivot = parseInt(start + (end - start) / 2);
    var compared;
    if (!compareFunction) {
      compareFunction = function(a, b) {
        if (a > b)
          return 1;
        if (a < b)
          return -1;
        if (a == b)
          return 0;
      };
    }
    if (end - start <= 0) {
      return pivot;
    }
    compared = compareFunction(array[pivot], item);
    if (end - start === 1) {
      return compared >= 0 ? pivot : pivot + 1;
    }
    if (compared === 0) {
      return pivot;
    }
    if (compared === -1) {
      return locationOf(item, array, compareFunction, pivot, end);
    } else {
      return locationOf(item, array, compareFunction, start, pivot);
    }
  }
  function indexOfSorted(item, array, compareFunction, _start, _end) {
    var start = _start || 0;
    var end = _end || array.length;
    var pivot = parseInt(start + (end - start) / 2);
    var compared;
    if (!compareFunction) {
      compareFunction = function(a, b) {
        if (a > b)
          return 1;
        if (a < b)
          return -1;
        if (a == b)
          return 0;
      };
    }
    if (end - start <= 0) {
      return -1;
    }
    compared = compareFunction(array[pivot], item);
    if (end - start === 1) {
      return compared === 0 ? pivot : -1;
    }
    if (compared === 0) {
      return pivot;
    }
    if (compared === -1) {
      return indexOfSorted(item, array, compareFunction, pivot, end);
    } else {
      return indexOfSorted(item, array, compareFunction, start, pivot);
    }
  }
  function bounds(el) {
    var style = window.getComputedStyle(el);
    var widthProps = ["width", "paddingRight", "paddingLeft", "marginRight", "marginLeft", "borderRightWidth", "borderLeftWidth"];
    var heightProps = ["height", "paddingTop", "paddingBottom", "marginTop", "marginBottom", "borderTopWidth", "borderBottomWidth"];
    var width = 0;
    var height = 0;
    widthProps.forEach(function(prop) {
      width += parseFloat(style[prop]) || 0;
    });
    heightProps.forEach(function(prop) {
      height += parseFloat(style[prop]) || 0;
    });
    return {
      height,
      width
    };
  }
  function borders(el) {
    var style = window.getComputedStyle(el);
    var widthProps = ["paddingRight", "paddingLeft", "marginRight", "marginLeft", "borderRightWidth", "borderLeftWidth"];
    var heightProps = ["paddingTop", "paddingBottom", "marginTop", "marginBottom", "borderTopWidth", "borderBottomWidth"];
    var width = 0;
    var height = 0;
    widthProps.forEach(function(prop) {
      width += parseFloat(style[prop]) || 0;
    });
    heightProps.forEach(function(prop) {
      height += parseFloat(style[prop]) || 0;
    });
    return {
      height,
      width
    };
  }
  function nodeBounds(node) {
    let elPos;
    let doc2 = node.ownerDocument;
    if (node.nodeType == Node.TEXT_NODE) {
      let elRange = doc2.createRange();
      elRange.selectNodeContents(node);
      elPos = elRange.getBoundingClientRect();
    } else {
      elPos = node.getBoundingClientRect();
    }
    return elPos;
  }
  function windowBounds() {
    var width = window.innerWidth;
    var height = window.innerHeight;
    return {
      top: 0,
      left: 0,
      right: width,
      bottom: height,
      width,
      height
    };
  }
  function indexOfNode(node, typeId) {
    var parent2 = node.parentNode;
    var children = parent2.childNodes;
    var sib;
    var index = -1;
    for (var i = 0; i < children.length; i++) {
      sib = children[i];
      if (sib.nodeType === typeId) {
        index++;
      }
      if (sib == node)
        break;
    }
    return index;
  }
  function indexOfTextNode(textNode) {
    return indexOfNode(textNode, TEXT_NODE);
  }
  function indexOfElementNode(elementNode) {
    return indexOfNode(elementNode, ELEMENT_NODE);
  }
  function isXml(ext) {
    return ["xml", "opf", "ncx"].indexOf(ext) > -1;
  }
  function createBlob(content, mime) {
    return new Blob([content], { type: mime });
  }
  function createBlobUrl(content, mime) {
    var tempUrl;
    var blob = createBlob(content, mime);
    tempUrl = _URL.createObjectURL(blob);
    return tempUrl;
  }
  function revokeBlobUrl(url) {
    return _URL.revokeObjectURL(url);
  }
  function createBase64Url(content, mime) {
    var data;
    var datauri;
    if (typeof content !== "string") {
      return;
    }
    data = btoa(content);
    datauri = "data:" + mime + ";base64," + data;
    return datauri;
  }
  function type(obj) {
    return Object.prototype.toString.call(obj).slice(8, -1);
  }
  function parse(markup, mime, forceXMLDom) {
    var doc2;
    var Parser;
    if (typeof DOMParser === "undefined" || forceXMLDom) {
      Parser = import_xmldom.DOMParser;
    } else {
      Parser = DOMParser;
    }
    if (markup.charCodeAt(0) === 65279) {
      markup = markup.slice(1);
    }
    doc2 = new Parser().parseFromString(markup, mime);
    return doc2;
  }
  function qs(el, sel) {
    var elements;
    if (!el) {
      throw new Error("No Element Provided");
    }
    if (typeof el.querySelector != "undefined") {
      return el.querySelector(sel);
    } else {
      elements = el.getElementsByTagName(sel);
      if (elements.length) {
        return elements[0];
      }
    }
  }
  function qsa(el, sel) {
    if (typeof el.querySelector != "undefined") {
      return el.querySelectorAll(sel);
    } else {
      return el.getElementsByTagName(sel);
    }
  }
  function qsp(el, sel, props) {
    var q, filtered;
    if (typeof el.querySelector != "undefined") {
      sel += "[";
      for (var prop in props) {
        sel += prop + "~='" + props[prop] + "'";
      }
      sel += "]";
      return el.querySelector(sel);
    } else {
      q = el.getElementsByTagName(sel);
      filtered = Array.prototype.slice.call(q, 0).filter(function(el2) {
        for (var prop2 in props) {
          if (el2.getAttribute(prop2) === props[prop2]) {
            return true;
          }
        }
        return false;
      });
      if (filtered) {
        return filtered[0];
      }
    }
  }
  function sprint(root, func) {
    var doc2 = root.ownerDocument || root;
    if (typeof doc2.createTreeWalker !== "undefined") {
      treeWalker(root, func, NodeFilter.SHOW_TEXT);
    } else {
      walk(root, function(node) {
        if (node && node.nodeType === 3) {
          func(node);
        }
      }, true);
    }
  }
  function treeWalker(root, func, filter) {
    var treeWalker2 = document.createTreeWalker(root, filter, null, false);
    let node;
    while (node = treeWalker2.nextNode()) {
      func(node);
    }
  }
  function walk(node, callback) {
    if (callback(node)) {
      return true;
    }
    node = node.firstChild;
    if (node) {
      do {
        let walked = walk(node, callback);
        if (walked) {
          return true;
        }
        node = node.nextSibling;
      } while (node);
    }
  }
  function blob2base64(blob) {
    return new Promise(function(resolve2, reject) {
      var reader = new FileReader();
      reader.readAsDataURL(blob);
      reader.onloadend = function() {
        resolve2(reader.result);
      };
    });
  }
  function defer() {
    this.resolve = null;
    this.reject = null;
    this.id = uuid();
    this.promise = new Promise((resolve2, reject) => {
      this.resolve = resolve2;
      this.reject = reject;
    });
    Object.freeze(this);
  }
  function querySelectorByType(html, element, type2) {
    var query;
    if (typeof html.querySelector != "undefined") {
      query = html.querySelector(`${element}[*|type="${type2}"]`);
    }
    if (!query || query.length === 0) {
      query = qsa(html, element);
      for (var i = 0; i < query.length; i++) {
        if (query[i].getAttributeNS("http://www.idpf.org/2007/ops", "type") === type2 || query[i].getAttribute("epub:type") === type2) {
          return query[i];
        }
      }
    } else {
      return query;
    }
  }
  function findChildren(el) {
    var result = [];
    var childNodes = el.childNodes;
    for (var i = 0; i < childNodes.length; i++) {
      let node = childNodes[i];
      if (node.nodeType === 1) {
        result.push(node);
      }
    }
    return result;
  }
  function parents(node) {
    var nodes = [node];
    for (; node; node = node.parentNode) {
      nodes.unshift(node);
    }
    return nodes;
  }
  function filterChildren(el, nodeName, single) {
    var result = [];
    var childNodes = el.childNodes;
    for (var i = 0; i < childNodes.length; i++) {
      let node = childNodes[i];
      if (node.nodeType === 1 && node.nodeName.toLowerCase() === nodeName) {
        if (single) {
          return node;
        } else {
          result.push(node);
        }
      }
    }
    if (!single) {
      return result;
    }
  }
  function getParentByTagName(node, tagname) {
    let parent2;
    if (node === null || tagname === "")
      return;
    parent2 = node.parentNode;
    while (parent2.nodeType === 1) {
      if (parent2.tagName.toLowerCase() === tagname) {
        return parent2;
      }
      parent2 = parent2.parentNode;
    }
  }
  var RangeObject = class {
    constructor() {
      this.collapsed = false;
      this.commonAncestorContainer = void 0;
      this.endContainer = void 0;
      this.endOffset = void 0;
      this.startContainer = void 0;
      this.startOffset = void 0;
    }
    setStart(startNode, startOffset) {
      this.startContainer = startNode;
      this.startOffset = startOffset;
      if (!this.endContainer) {
        this.collapse(true);
      } else {
        this.commonAncestorContainer = this._commonAncestorContainer();
      }
      this._checkCollapsed();
    }
    setEnd(endNode, endOffset) {
      this.endContainer = endNode;
      this.endOffset = endOffset;
      if (!this.startContainer) {
        this.collapse(false);
      } else {
        this.collapsed = false;
        this.commonAncestorContainer = this._commonAncestorContainer();
      }
      this._checkCollapsed();
    }
    collapse(toStart) {
      this.collapsed = true;
      if (toStart) {
        this.endContainer = this.startContainer;
        this.endOffset = this.startOffset;
        this.commonAncestorContainer = this.startContainer.parentNode;
      } else {
        this.startContainer = this.endContainer;
        this.startOffset = this.endOffset;
        this.commonAncestorContainer = this.endOffset.parentNode;
      }
    }
    selectNode(referenceNode) {
      let parent2 = referenceNode.parentNode;
      let index = Array.prototype.indexOf.call(parent2.childNodes, referenceNode);
      this.setStart(parent2, index);
      this.setEnd(parent2, index + 1);
    }
    selectNodeContents(referenceNode) {
      let end = referenceNode.childNodes[referenceNode.childNodes - 1];
      let endIndex = referenceNode.nodeType === 3 ? referenceNode.textContent.length : parent.childNodes.length;
      this.setStart(referenceNode, 0);
      this.setEnd(referenceNode, endIndex);
    }
    _commonAncestorContainer(startContainer, endContainer) {
      var startParents = parents(startContainer || this.startContainer);
      var endParents = parents(endContainer || this.endContainer);
      if (startParents[0] != endParents[0])
        return void 0;
      for (var i = 0; i < startParents.length; i++) {
        if (startParents[i] != endParents[i]) {
          return startParents[i - 1];
        }
      }
    }
    _checkCollapsed() {
      if (this.startContainer === this.endContainer && this.startOffset === this.endOffset) {
        this.collapsed = true;
      } else {
        this.collapsed = false;
      }
    }
    toString() {
    }
  };

  // ../library_management/node_modules/epubjs/src/utils/path.js
  var import_path_webpack = __toESM(require_path());
  var Path = class {
    constructor(pathString) {
      var protocol;
      var parsed;
      protocol = pathString.indexOf("://");
      if (protocol > -1) {
        pathString = new URL(pathString).pathname;
      }
      parsed = this.parse(pathString);
      this.path = pathString;
      if (this.isDirectory(pathString)) {
        this.directory = pathString;
      } else {
        this.directory = parsed.dir + "/";
      }
      this.filename = parsed.base;
      this.extension = parsed.ext.slice(1);
    }
    parse(what) {
      return import_path_webpack.default.parse(what);
    }
    isAbsolute(what) {
      return import_path_webpack.default.isAbsolute(what || this.path);
    }
    isDirectory(what) {
      return what.charAt(what.length - 1) === "/";
    }
    resolve(what) {
      return import_path_webpack.default.resolve(this.directory, what);
    }
    relative(what) {
      var isAbsolute = what && what.indexOf("://") > -1;
      if (isAbsolute) {
        return what;
      }
      return import_path_webpack.default.relative(this.directory, what);
    }
    splitPath(filename) {
      return this.splitPathRe.exec(filename).slice(1);
    }
    toString() {
      return this.path;
    }
  };
  var path_default = Path;

  // ../library_management/node_modules/epubjs/src/utils/url.js
  var import_path_webpack2 = __toESM(require_path());
  var Url = class {
    constructor(urlString, baseString) {
      var absolute = urlString.indexOf("://") > -1;
      var pathname = urlString;
      var basePath;
      this.Url = void 0;
      this.href = urlString;
      this.protocol = "";
      this.origin = "";
      this.hash = "";
      this.hash = "";
      this.search = "";
      this.base = baseString;
      if (!absolute && baseString !== false && typeof baseString !== "string" && window && window.location) {
        this.base = window.location.href;
      }
      if (absolute || this.base) {
        try {
          if (this.base) {
            this.Url = new URL(urlString, this.base);
          } else {
            this.Url = new URL(urlString);
          }
          this.href = this.Url.href;
          this.protocol = this.Url.protocol;
          this.origin = this.Url.origin;
          this.hash = this.Url.hash;
          this.search = this.Url.search;
          pathname = this.Url.pathname + (this.Url.search ? this.Url.search : "");
        } catch (e) {
          this.Url = void 0;
          if (this.base) {
            basePath = new path_default(this.base);
            pathname = basePath.resolve(pathname);
          }
        }
      }
      this.Path = new path_default(pathname);
      this.directory = this.Path.directory;
      this.filename = this.Path.filename;
      this.extension = this.Path.extension;
    }
    path() {
      return this.Path;
    }
    resolve(what) {
      var isAbsolute = what.indexOf("://") > -1;
      var fullpath;
      if (isAbsolute) {
        return what;
      }
      fullpath = import_path_webpack2.default.resolve(this.directory, what);
      return this.origin + fullpath;
    }
    relative(what) {
      return import_path_webpack2.default.relative(what, this.directory);
    }
    toString() {
      return this.href;
    }
  };
  var url_default = Url;

  // ../library_management/node_modules/epubjs/src/epubcfi.js
  var ELEMENT_NODE2 = 1;
  var TEXT_NODE2 = 3;
  var DOCUMENT_NODE = 9;
  var EpubCFI = class {
    constructor(cfiFrom, base, ignoreClass) {
      var type2;
      this.str = "";
      this.base = {};
      this.spinePos = 0;
      this.range = false;
      this.path = {};
      this.start = null;
      this.end = null;
      if (!(this instanceof EpubCFI)) {
        return new EpubCFI(cfiFrom, base, ignoreClass);
      }
      if (typeof base === "string") {
        this.base = this.parseComponent(base);
      } else if (typeof base === "object" && base.steps) {
        this.base = base;
      }
      type2 = this.checkType(cfiFrom);
      if (type2 === "string") {
        this.str = cfiFrom;
        return extend2(this, this.parse(cfiFrom));
      } else if (type2 === "range") {
        return extend2(this, this.fromRange(cfiFrom, this.base, ignoreClass));
      } else if (type2 === "node") {
        return extend2(this, this.fromNode(cfiFrom, this.base, ignoreClass));
      } else if (type2 === "EpubCFI" && cfiFrom.path) {
        return cfiFrom;
      } else if (!cfiFrom) {
        return this;
      } else {
        throw new TypeError("not a valid argument for EpubCFI");
      }
    }
    checkType(cfi) {
      if (this.isCfiString(cfi)) {
        return "string";
      } else if (cfi && typeof cfi === "object" && (type(cfi) === "Range" || typeof cfi.startContainer != "undefined")) {
        return "range";
      } else if (cfi && typeof cfi === "object" && typeof cfi.nodeType != "undefined") {
        return "node";
      } else if (cfi && typeof cfi === "object" && cfi instanceof EpubCFI) {
        return "EpubCFI";
      } else {
        return false;
      }
    }
    parse(cfiStr) {
      var cfi = {
        spinePos: -1,
        range: false,
        base: {},
        path: {},
        start: null,
        end: null
      };
      var baseComponent, pathComponent, range;
      if (typeof cfiStr !== "string") {
        return { spinePos: -1 };
      }
      if (cfiStr.indexOf("epubcfi(") === 0 && cfiStr[cfiStr.length - 1] === ")") {
        cfiStr = cfiStr.slice(8, cfiStr.length - 1);
      }
      baseComponent = this.getChapterComponent(cfiStr);
      if (!baseComponent) {
        return { spinePos: -1 };
      }
      cfi.base = this.parseComponent(baseComponent);
      pathComponent = this.getPathComponent(cfiStr);
      cfi.path = this.parseComponent(pathComponent);
      range = this.getRange(cfiStr);
      if (range) {
        cfi.range = true;
        cfi.start = this.parseComponent(range[0]);
        cfi.end = this.parseComponent(range[1]);
      }
      cfi.spinePos = cfi.base.steps[1].index;
      return cfi;
    }
    parseComponent(componentStr) {
      var component = {
        steps: [],
        terminal: {
          offset: null,
          assertion: null
        }
      };
      var parts = componentStr.split(":");
      var steps = parts[0].split("/");
      var terminal;
      if (parts.length > 1) {
        terminal = parts[1];
        component.terminal = this.parseTerminal(terminal);
      }
      if (steps[0] === "") {
        steps.shift();
      }
      component.steps = steps.map(function(step) {
        return this.parseStep(step);
      }.bind(this));
      return component;
    }
    parseStep(stepStr) {
      var type2, num, index, has_brackets, id;
      has_brackets = stepStr.match(/\[(.*)\]/);
      if (has_brackets && has_brackets[1]) {
        id = has_brackets[1];
      }
      num = parseInt(stepStr);
      if (isNaN(num)) {
        return;
      }
      if (num % 2 === 0) {
        type2 = "element";
        index = num / 2 - 1;
      } else {
        type2 = "text";
        index = (num - 1) / 2;
      }
      return {
        "type": type2,
        "index": index,
        "id": id || null
      };
    }
    parseTerminal(termialStr) {
      var characterOffset, textLocationAssertion;
      var assertion = termialStr.match(/\[(.*)\]/);
      if (assertion && assertion[1]) {
        characterOffset = parseInt(termialStr.split("[")[0]);
        textLocationAssertion = assertion[1];
      } else {
        characterOffset = parseInt(termialStr);
      }
      if (!isNumber(characterOffset)) {
        characterOffset = null;
      }
      return {
        "offset": characterOffset,
        "assertion": textLocationAssertion
      };
    }
    getChapterComponent(cfiStr) {
      var indirection = cfiStr.split("!");
      return indirection[0];
    }
    getPathComponent(cfiStr) {
      var indirection = cfiStr.split("!");
      if (indirection[1]) {
        let ranges = indirection[1].split(",");
        return ranges[0];
      }
    }
    getRange(cfiStr) {
      var ranges = cfiStr.split(",");
      if (ranges.length === 3) {
        return [
          ranges[1],
          ranges[2]
        ];
      }
      return false;
    }
    getCharecterOffsetComponent(cfiStr) {
      var splitStr = cfiStr.split(":");
      return splitStr[1] || "";
    }
    joinSteps(steps) {
      if (!steps) {
        return "";
      }
      return steps.map(function(part) {
        var segment = "";
        if (part.type === "element") {
          segment += (part.index + 1) * 2;
        }
        if (part.type === "text") {
          segment += 1 + 2 * part.index;
        }
        if (part.id) {
          segment += "[" + part.id + "]";
        }
        return segment;
      }).join("/");
    }
    segmentString(segment) {
      var segmentString = "/";
      segmentString += this.joinSteps(segment.steps);
      if (segment.terminal && segment.terminal.offset != null) {
        segmentString += ":" + segment.terminal.offset;
      }
      if (segment.terminal && segment.terminal.assertion != null) {
        segmentString += "[" + segment.terminal.assertion + "]";
      }
      return segmentString;
    }
    toString() {
      var cfiString = "epubcfi(";
      cfiString += this.segmentString(this.base);
      cfiString += "!";
      cfiString += this.segmentString(this.path);
      if (this.range && this.start) {
        cfiString += ",";
        cfiString += this.segmentString(this.start);
      }
      if (this.range && this.end) {
        cfiString += ",";
        cfiString += this.segmentString(this.end);
      }
      cfiString += ")";
      return cfiString;
    }
    compare(cfiOne, cfiTwo) {
      var stepsA, stepsB;
      var terminalA, terminalB;
      var rangeAStartSteps, rangeAEndSteps;
      var rangeBEndSteps, rangeBEndSteps;
      var rangeAStartTerminal, rangeAEndTerminal;
      var rangeBStartTerminal, rangeBEndTerminal;
      if (typeof cfiOne === "string") {
        cfiOne = new EpubCFI(cfiOne);
      }
      if (typeof cfiTwo === "string") {
        cfiTwo = new EpubCFI(cfiTwo);
      }
      if (cfiOne.spinePos > cfiTwo.spinePos) {
        return 1;
      }
      if (cfiOne.spinePos < cfiTwo.spinePos) {
        return -1;
      }
      if (cfiOne.range) {
        stepsA = cfiOne.path.steps.concat(cfiOne.start.steps);
        terminalA = cfiOne.start.terminal;
      } else {
        stepsA = cfiOne.path.steps;
        terminalA = cfiOne.path.terminal;
      }
      if (cfiTwo.range) {
        stepsB = cfiTwo.path.steps.concat(cfiTwo.start.steps);
        terminalB = cfiTwo.start.terminal;
      } else {
        stepsB = cfiTwo.path.steps;
        terminalB = cfiTwo.path.terminal;
      }
      for (var i = 0; i < stepsA.length; i++) {
        if (!stepsA[i]) {
          return -1;
        }
        if (!stepsB[i]) {
          return 1;
        }
        if (stepsA[i].index > stepsB[i].index) {
          return 1;
        }
        if (stepsA[i].index < stepsB[i].index) {
          return -1;
        }
      }
      if (stepsA.length < stepsB.length) {
        return -1;
      }
      if (terminalA.offset > terminalB.offset) {
        return 1;
      }
      if (terminalA.offset < terminalB.offset) {
        return -1;
      }
      return 0;
    }
    step(node) {
      var nodeType = node.nodeType === TEXT_NODE2 ? "text" : "element";
      return {
        "id": node.id,
        "tagName": node.tagName,
        "type": nodeType,
        "index": this.position(node)
      };
    }
    filteredStep(node, ignoreClass) {
      var filteredNode = this.filter(node, ignoreClass);
      var nodeType;
      if (!filteredNode) {
        return;
      }
      nodeType = filteredNode.nodeType === TEXT_NODE2 ? "text" : "element";
      return {
        "id": filteredNode.id,
        "tagName": filteredNode.tagName,
        "type": nodeType,
        "index": this.filteredPosition(filteredNode, ignoreClass)
      };
    }
    pathTo(node, offset, ignoreClass) {
      var segment = {
        steps: [],
        terminal: {
          offset: null,
          assertion: null
        }
      };
      var currentNode = node;
      var step;
      while (currentNode && currentNode.parentNode && currentNode.parentNode.nodeType != DOCUMENT_NODE) {
        if (ignoreClass) {
          step = this.filteredStep(currentNode, ignoreClass);
        } else {
          step = this.step(currentNode);
        }
        if (step) {
          segment.steps.unshift(step);
        }
        currentNode = currentNode.parentNode;
      }
      if (offset != null && offset >= 0) {
        segment.terminal.offset = offset;
        if (segment.steps[segment.steps.length - 1].type != "text") {
          segment.steps.push({
            "type": "text",
            "index": 0
          });
        }
      }
      return segment;
    }
    equalStep(stepA, stepB) {
      if (!stepA || !stepB) {
        return false;
      }
      if (stepA.index === stepB.index && stepA.id === stepB.id && stepA.type === stepB.type) {
        return true;
      }
      return false;
    }
    fromRange(range, base, ignoreClass) {
      var cfi = {
        range: false,
        base: {},
        path: {},
        start: null,
        end: null
      };
      var start = range.startContainer;
      var end = range.endContainer;
      var startOffset = range.startOffset;
      var endOffset = range.endOffset;
      var needsIgnoring = false;
      if (ignoreClass) {
        needsIgnoring = start.ownerDocument.querySelector("." + ignoreClass) != null;
      }
      if (typeof base === "string") {
        cfi.base = this.parseComponent(base);
        cfi.spinePos = cfi.base.steps[1].index;
      } else if (typeof base === "object") {
        cfi.base = base;
      }
      if (range.collapsed) {
        if (needsIgnoring) {
          startOffset = this.patchOffset(start, startOffset, ignoreClass);
        }
        cfi.path = this.pathTo(start, startOffset, ignoreClass);
      } else {
        cfi.range = true;
        if (needsIgnoring) {
          startOffset = this.patchOffset(start, startOffset, ignoreClass);
        }
        cfi.start = this.pathTo(start, startOffset, ignoreClass);
        if (needsIgnoring) {
          endOffset = this.patchOffset(end, endOffset, ignoreClass);
        }
        cfi.end = this.pathTo(end, endOffset, ignoreClass);
        cfi.path = {
          steps: [],
          terminal: null
        };
        var len = cfi.start.steps.length;
        var i;
        for (i = 0; i < len; i++) {
          if (this.equalStep(cfi.start.steps[i], cfi.end.steps[i])) {
            if (i === len - 1) {
              if (cfi.start.terminal === cfi.end.terminal) {
                cfi.path.steps.push(cfi.start.steps[i]);
                cfi.range = false;
              }
            } else {
              cfi.path.steps.push(cfi.start.steps[i]);
            }
          } else {
            break;
          }
        }
        cfi.start.steps = cfi.start.steps.slice(cfi.path.steps.length);
        cfi.end.steps = cfi.end.steps.slice(cfi.path.steps.length);
      }
      return cfi;
    }
    fromNode(anchor, base, ignoreClass) {
      var cfi = {
        range: false,
        base: {},
        path: {},
        start: null,
        end: null
      };
      if (typeof base === "string") {
        cfi.base = this.parseComponent(base);
        cfi.spinePos = cfi.base.steps[1].index;
      } else if (typeof base === "object") {
        cfi.base = base;
      }
      cfi.path = this.pathTo(anchor, null, ignoreClass);
      return cfi;
    }
    filter(anchor, ignoreClass) {
      var needsIgnoring;
      var sibling;
      var parent2, previousSibling, nextSibling;
      var isText = false;
      if (anchor.nodeType === TEXT_NODE2) {
        isText = true;
        parent2 = anchor.parentNode;
        needsIgnoring = anchor.parentNode.classList.contains(ignoreClass);
      } else {
        isText = false;
        needsIgnoring = anchor.classList.contains(ignoreClass);
      }
      if (needsIgnoring && isText) {
        previousSibling = parent2.previousSibling;
        nextSibling = parent2.nextSibling;
        if (previousSibling && previousSibling.nodeType === TEXT_NODE2) {
          sibling = previousSibling;
        } else if (nextSibling && nextSibling.nodeType === TEXT_NODE2) {
          sibling = nextSibling;
        }
        if (sibling) {
          return sibling;
        } else {
          return anchor;
        }
      } else if (needsIgnoring && !isText) {
        return false;
      } else {
        return anchor;
      }
    }
    patchOffset(anchor, offset, ignoreClass) {
      if (anchor.nodeType != TEXT_NODE2) {
        throw new Error("Anchor must be a text node");
      }
      var curr = anchor;
      var totalOffset = offset;
      if (anchor.parentNode.classList.contains(ignoreClass)) {
        curr = anchor.parentNode;
      }
      while (curr.previousSibling) {
        if (curr.previousSibling.nodeType === ELEMENT_NODE2) {
          if (curr.previousSibling.classList.contains(ignoreClass)) {
            totalOffset += curr.previousSibling.textContent.length;
          } else {
            break;
          }
        } else {
          totalOffset += curr.previousSibling.textContent.length;
        }
        curr = curr.previousSibling;
      }
      return totalOffset;
    }
    normalizedMap(children, nodeType, ignoreClass) {
      var output = {};
      var prevIndex = -1;
      var i, len = children.length;
      var currNodeType;
      var prevNodeType;
      for (i = 0; i < len; i++) {
        currNodeType = children[i].nodeType;
        if (currNodeType === ELEMENT_NODE2 && children[i].classList.contains(ignoreClass)) {
          currNodeType = TEXT_NODE2;
        }
        if (i > 0 && currNodeType === TEXT_NODE2 && prevNodeType === TEXT_NODE2) {
          output[i] = prevIndex;
        } else if (nodeType === currNodeType) {
          prevIndex = prevIndex + 1;
          output[i] = prevIndex;
        }
        prevNodeType = currNodeType;
      }
      return output;
    }
    position(anchor) {
      var children, index;
      if (anchor.nodeType === ELEMENT_NODE2) {
        children = anchor.parentNode.children;
        if (!children) {
          children = findChildren(anchor.parentNode);
        }
        index = Array.prototype.indexOf.call(children, anchor);
      } else {
        children = this.textNodes(anchor.parentNode);
        index = children.indexOf(anchor);
      }
      return index;
    }
    filteredPosition(anchor, ignoreClass) {
      var children, index, map2;
      if (anchor.nodeType === ELEMENT_NODE2) {
        children = anchor.parentNode.children;
        map2 = this.normalizedMap(children, ELEMENT_NODE2, ignoreClass);
      } else {
        children = anchor.parentNode.childNodes;
        if (anchor.parentNode.classList.contains(ignoreClass)) {
          anchor = anchor.parentNode;
          children = anchor.parentNode.childNodes;
        }
        map2 = this.normalizedMap(children, TEXT_NODE2, ignoreClass);
      }
      index = Array.prototype.indexOf.call(children, anchor);
      return map2[index];
    }
    stepsToXpath(steps) {
      var xpath = [".", "*"];
      steps.forEach(function(step) {
        var position = step.index + 1;
        if (step.id) {
          xpath.push("*[position()=" + position + " and @id='" + step.id + "']");
        } else if (step.type === "text") {
          xpath.push("text()[" + position + "]");
        } else {
          xpath.push("*[" + position + "]");
        }
      });
      return xpath.join("/");
    }
    stepsToQuerySelector(steps) {
      var query = ["html"];
      steps.forEach(function(step) {
        var position = step.index + 1;
        if (step.id) {
          query.push("#" + step.id);
        } else if (step.type === "text") {
        } else {
          query.push("*:nth-child(" + position + ")");
        }
      });
      return query.join(">");
    }
    textNodes(container, ignoreClass) {
      return Array.prototype.slice.call(container.childNodes).filter(function(node) {
        if (node.nodeType === TEXT_NODE2) {
          return true;
        } else if (ignoreClass && node.classList.contains(ignoreClass)) {
          return true;
        }
        return false;
      });
    }
    walkToNode(steps, _doc, ignoreClass) {
      var doc2 = _doc || document;
      var container = doc2.documentElement;
      var children;
      var step;
      var len = steps.length;
      var i;
      for (i = 0; i < len; i++) {
        step = steps[i];
        if (step.type === "element") {
          if (step.id) {
            container = doc2.getElementById(step.id);
          } else {
            children = container.children || findChildren(container);
            container = children[step.index];
          }
        } else if (step.type === "text") {
          container = this.textNodes(container, ignoreClass)[step.index];
        }
        if (!container) {
          break;
        }
      }
      return container;
    }
    findNode(steps, _doc, ignoreClass) {
      var doc2 = _doc || document;
      var container;
      var xpath;
      if (!ignoreClass && typeof doc2.evaluate != "undefined") {
        xpath = this.stepsToXpath(steps);
        container = doc2.evaluate(xpath, doc2, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
      } else if (ignoreClass) {
        container = this.walkToNode(steps, doc2, ignoreClass);
      } else {
        container = this.walkToNode(steps, doc2);
      }
      return container;
    }
    fixMiss(steps, offset, _doc, ignoreClass) {
      var container = this.findNode(steps.slice(0, -1), _doc, ignoreClass);
      var children = container.childNodes;
      var map2 = this.normalizedMap(children, TEXT_NODE2, ignoreClass);
      var child;
      var len;
      var lastStepIndex = steps[steps.length - 1].index;
      for (let childIndex in map2) {
        if (!map2.hasOwnProperty(childIndex))
          return;
        if (map2[childIndex] === lastStepIndex) {
          child = children[childIndex];
          len = child.textContent.length;
          if (offset > len) {
            offset = offset - len;
          } else {
            if (child.nodeType === ELEMENT_NODE2) {
              container = child.childNodes[0];
            } else {
              container = child;
            }
            break;
          }
        }
      }
      return {
        container,
        offset
      };
    }
    toRange(_doc, ignoreClass) {
      var doc2 = _doc || document;
      var range;
      var start, end, startContainer, endContainer;
      var cfi = this;
      var startSteps, endSteps;
      var needsIgnoring = ignoreClass ? doc2.querySelector("." + ignoreClass) != null : false;
      var missed;
      if (typeof doc2.createRange !== "undefined") {
        range = doc2.createRange();
      } else {
        range = new RangeObject();
      }
      if (cfi.range) {
        start = cfi.start;
        startSteps = cfi.path.steps.concat(start.steps);
        startContainer = this.findNode(startSteps, doc2, needsIgnoring ? ignoreClass : null);
        end = cfi.end;
        endSteps = cfi.path.steps.concat(end.steps);
        endContainer = this.findNode(endSteps, doc2, needsIgnoring ? ignoreClass : null);
      } else {
        start = cfi.path;
        startSteps = cfi.path.steps;
        startContainer = this.findNode(cfi.path.steps, doc2, needsIgnoring ? ignoreClass : null);
      }
      if (startContainer) {
        try {
          if (start.terminal.offset != null) {
            range.setStart(startContainer, start.terminal.offset);
          } else {
            range.setStart(startContainer, 0);
          }
        } catch (e) {
          missed = this.fixMiss(startSteps, start.terminal.offset, doc2, needsIgnoring ? ignoreClass : null);
          range.setStart(missed.container, missed.offset);
        }
      } else {
        console.log("No startContainer found for", this.toString());
        return null;
      }
      if (endContainer) {
        try {
          if (end.terminal.offset != null) {
            range.setEnd(endContainer, end.terminal.offset);
          } else {
            range.setEnd(endContainer, 0);
          }
        } catch (e) {
          missed = this.fixMiss(endSteps, cfi.end.terminal.offset, doc2, needsIgnoring ? ignoreClass : null);
          range.setEnd(missed.container, missed.offset);
        }
      }
      return range;
    }
    isCfiString(str) {
      if (typeof str === "string" && str.indexOf("epubcfi(") === 0 && str[str.length - 1] === ")") {
        return true;
      }
      return false;
    }
    generateChapterComponent(_spineNodeIndex, _pos, id) {
      var pos = parseInt(_pos), spineNodeIndex = (_spineNodeIndex + 1) * 2, cfi = "/" + spineNodeIndex + "/";
      cfi += (pos + 1) * 2;
      if (id) {
        cfi += "[" + id + "]";
      }
      return cfi;
    }
    collapse(toStart) {
      if (!this.range) {
        return;
      }
      this.range = false;
      if (toStart) {
        this.path.steps = this.path.steps.concat(this.start.steps);
        this.path.terminal = this.start.terminal;
      } else {
        this.path.steps = this.path.steps.concat(this.end.steps);
        this.path.terminal = this.end.terminal;
      }
    }
  };
  var epubcfi_default = EpubCFI;

  // ../library_management/node_modules/epubjs/src/utils/hook.js
  var Hook = class {
    constructor(context) {
      this.context = context || this;
      this.hooks = [];
    }
    register() {
      for (var i = 0; i < arguments.length; ++i) {
        if (typeof arguments[i] === "function") {
          this.hooks.push(arguments[i]);
        } else {
          for (var j = 0; j < arguments[i].length; ++j) {
            this.hooks.push(arguments[i][j]);
          }
        }
      }
    }
    deregister(func) {
      let hook;
      for (let i = 0; i < this.hooks.length; i++) {
        hook = this.hooks[i];
        if (hook === func) {
          this.hooks.splice(i, 1);
          break;
        }
      }
    }
    trigger() {
      var args = arguments;
      var context = this.context;
      var promises = [];
      this.hooks.forEach(function(task) {
        try {
          var executing = task.apply(context, args);
        } catch (err) {
          console.log(err);
        }
        if (executing && typeof executing["then"] === "function") {
          promises.push(executing);
        }
      });
      return Promise.all(promises);
    }
    list() {
      return this.hooks;
    }
    clear() {
      return this.hooks = [];
    }
  };
  var hook_default = Hook;

  // ../library_management/node_modules/epubjs/src/utils/replacements.js
  function replaceBase(doc2, section) {
    var base;
    var head;
    var url = section.url;
    var absolute = url.indexOf("://") > -1;
    if (!doc2) {
      return;
    }
    head = qs(doc2, "head");
    base = qs(head, "base");
    if (!base) {
      base = doc2.createElement("base");
      head.insertBefore(base, head.firstChild);
    }
    if (!absolute && window && window.location) {
      url = window.location.origin + url;
    }
    base.setAttribute("href", url);
  }
  function replaceCanonical(doc2, section) {
    var head;
    var link;
    var url = section.canonical;
    if (!doc2) {
      return;
    }
    head = qs(doc2, "head");
    link = qs(head, "link[rel='canonical']");
    if (link) {
      link.setAttribute("href", url);
    } else {
      link = doc2.createElement("link");
      link.setAttribute("rel", "canonical");
      link.setAttribute("href", url);
      head.appendChild(link);
    }
  }
  function replaceMeta(doc2, section) {
    var head;
    var meta;
    var id = section.idref;
    if (!doc2) {
      return;
    }
    head = qs(doc2, "head");
    meta = qs(head, "link[property='dc.identifier']");
    if (meta) {
      meta.setAttribute("content", id);
    } else {
      meta = doc2.createElement("meta");
      meta.setAttribute("name", "dc.identifier");
      meta.setAttribute("content", id);
      head.appendChild(meta);
    }
  }
  function replaceLinks(contents, fn) {
    var links = contents.querySelectorAll("a[href]");
    if (!links.length) {
      return;
    }
    var base = qs(contents.ownerDocument, "base");
    var location2 = base ? base.getAttribute("href") : void 0;
    var replaceLink = function(link) {
      var href = link.getAttribute("href");
      if (href.indexOf("mailto:") === 0) {
        return;
      }
      var absolute = href.indexOf("://") > -1;
      if (absolute) {
        link.setAttribute("target", "_blank");
      } else {
        var linkUrl;
        try {
          linkUrl = new url_default(href, location2);
        } catch (error) {
        }
        link.onclick = function() {
          if (linkUrl && linkUrl.hash) {
            fn(linkUrl.Path.path + linkUrl.hash);
          } else if (linkUrl) {
            fn(linkUrl.Path.path);
          } else {
            fn(href);
          }
          return false;
        };
      }
    }.bind(this);
    for (var i = 0; i < links.length; i++) {
      replaceLink(links[i]);
    }
  }
  function substitute(content, urls, replacements) {
    urls.forEach(function(url, i) {
      if (url && replacements[i]) {
        url = url.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
        content = content.replace(new RegExp(url, "g"), replacements[i]);
      }
    });
    return content;
  }

  // ../library_management/node_modules/epubjs/src/utils/request.js
  function request(url, type2, withCredentials, headers) {
    var supportsURL = typeof window != "undefined" ? window.URL : false;
    var BLOB_RESPONSE = supportsURL ? "blob" : "arraybuffer";
    var deferred = new defer();
    var xhr = new XMLHttpRequest();
    var xhrPrototype = XMLHttpRequest.prototype;
    var header;
    if (!("overrideMimeType" in xhrPrototype)) {
      Object.defineProperty(xhrPrototype, "overrideMimeType", {
        value: function xmlHttpRequestOverrideMimeType() {
        }
      });
    }
    if (withCredentials) {
      xhr.withCredentials = true;
    }
    xhr.onreadystatechange = handler;
    xhr.onerror = err;
    xhr.open("GET", url, true);
    for (header in headers) {
      xhr.setRequestHeader(header, headers[header]);
    }
    if (type2 == "json") {
      xhr.setRequestHeader("Accept", "application/json");
    }
    if (!type2) {
      type2 = new path_default(url).extension;
    }
    if (type2 == "blob") {
      xhr.responseType = BLOB_RESPONSE;
    }
    if (isXml(type2)) {
      xhr.overrideMimeType("text/xml");
    }
    if (type2 == "xhtml") {
    }
    if (type2 == "html" || type2 == "htm") {
    }
    if (type2 == "binary") {
      xhr.responseType = "arraybuffer";
    }
    xhr.send();
    function err(e) {
      deferred.reject(e);
    }
    function handler() {
      if (this.readyState === XMLHttpRequest.DONE) {
        var responseXML = false;
        if (this.responseType === "" || this.responseType === "document") {
          responseXML = this.responseXML;
        }
        if (this.status === 200 || this.status === 0 || responseXML) {
          var r;
          if (!this.response && !responseXML) {
            deferred.reject({
              status: this.status,
              message: "Empty Response",
              stack: new Error().stack
            });
            return deferred.promise;
          }
          if (this.status === 403) {
            deferred.reject({
              status: this.status,
              response: this.response,
              message: "Forbidden",
              stack: new Error().stack
            });
            return deferred.promise;
          }
          if (responseXML) {
            r = this.responseXML;
          } else if (isXml(type2)) {
            r = parse(this.response, "text/xml");
          } else if (type2 == "xhtml") {
            r = parse(this.response, "application/xhtml+xml");
          } else if (type2 == "html" || type2 == "htm") {
            r = parse(this.response, "text/html");
          } else if (type2 == "json") {
            r = JSON.parse(this.response);
          } else if (type2 == "blob") {
            if (supportsURL) {
              r = this.response;
            } else {
              r = new Blob([this.response]);
            }
          } else {
            r = this.response;
          }
          deferred.resolve(r);
        } else {
          deferred.reject({
            status: this.status,
            message: this.response,
            stack: new Error().stack
          });
        }
      }
    }
    return deferred.promise;
  }
  var request_default = request;

  // ../library_management/node_modules/epubjs/src/section.js
  var import_xmldom2 = __toESM(require_lib());
  var Section = class {
    constructor(item, hooks) {
      this.idref = item.idref;
      this.linear = item.linear === "yes";
      this.properties = item.properties;
      this.index = item.index;
      this.href = item.href;
      this.url = item.url;
      this.canonical = item.canonical;
      this.next = item.next;
      this.prev = item.prev;
      this.cfiBase = item.cfiBase;
      if (hooks) {
        this.hooks = hooks;
      } else {
        this.hooks = {};
        this.hooks.serialize = new hook_default(this);
        this.hooks.content = new hook_default(this);
      }
      this.document = void 0;
      this.contents = void 0;
      this.output = void 0;
    }
    load(_request) {
      var request2 = _request || this.request || request_default;
      var loading = new defer();
      var loaded = loading.promise;
      if (this.contents) {
        loading.resolve(this.contents);
      } else {
        request2(this.url).then(function(xml) {
          this.document = xml;
          this.contents = xml.documentElement;
          return this.hooks.content.trigger(this.document, this);
        }.bind(this)).then(function() {
          loading.resolve(this.contents);
        }.bind(this)).catch(function(error) {
          loading.reject(error);
        });
      }
      return loaded;
    }
    base() {
      return replaceBase(this.document, this);
    }
    render(_request) {
      var rendering = new defer();
      var rendered = rendering.promise;
      this.output;
      this.load(_request).then(function(contents) {
        var userAgent = typeof navigator !== "undefined" && navigator.userAgent || "";
        var isIE = userAgent.indexOf("Trident") >= 0;
        var Serializer;
        if (typeof XMLSerializer === "undefined" || isIE) {
          Serializer = import_xmldom2.DOMParser;
        } else {
          Serializer = XMLSerializer;
        }
        var serializer = new Serializer();
        this.output = serializer.serializeToString(contents);
        return this.output;
      }.bind(this)).then(function() {
        return this.hooks.serialize.trigger(this.output, this);
      }.bind(this)).then(function() {
        rendering.resolve(this.output);
      }.bind(this)).catch(function(error) {
        rendering.reject(error);
      });
      return rendered;
    }
    find(_query) {
      var section = this;
      var matches = [];
      var query = _query.toLowerCase();
      var find = function(node) {
        var text = node.textContent.toLowerCase();
        var range = section.document.createRange();
        var cfi;
        var pos;
        var last = -1;
        var excerpt;
        var limit = 150;
        while (pos != -1) {
          pos = text.indexOf(query, last + 1);
          if (pos != -1) {
            range = section.document.createRange();
            range.setStart(node, pos);
            range.setEnd(node, pos + query.length);
            cfi = section.cfiFromRange(range);
            if (node.textContent.length < limit) {
              excerpt = node.textContent;
            } else {
              excerpt = node.textContent.substring(pos - limit / 2, pos + limit / 2);
              excerpt = "..." + excerpt + "...";
            }
            matches.push({
              cfi,
              excerpt
            });
          }
          last = pos;
        }
      };
      sprint(section.document, function(node) {
        find(node);
      });
      return matches;
    }
    search(_query, maxSeqEle = 5) {
      if (typeof document.createTreeWalker == "undefined") {
        return this.find(_query);
      }
      let matches = [];
      const excerptLimit = 150;
      const section = this;
      const query = _query.toLowerCase();
      const search = function(nodeList2) {
        const textWithCase = nodeList2.reduce((acc, current) => {
          return acc + current.textContent;
        }, "");
        const text = textWithCase.toLowerCase();
        const pos = text.indexOf(query);
        if (pos != -1) {
          const startNodeIndex = 0, endPos = pos + query.length;
          let endNodeIndex = 0, l = 0;
          if (pos < nodeList2[startNodeIndex].length) {
            let cfi;
            while (endNodeIndex < nodeList2.length - 1) {
              l += nodeList2[endNodeIndex].length;
              if (endPos <= l) {
                break;
              }
              endNodeIndex += 1;
            }
            let startNode = nodeList2[startNodeIndex], endNode = nodeList2[endNodeIndex];
            let range = section.document.createRange();
            range.setStart(startNode, pos);
            let beforeEndLengthCount = nodeList2.slice(0, endNodeIndex).reduce((acc, current) => {
              return acc + current.textContent.length;
            }, 0);
            range.setEnd(endNode, beforeEndLengthCount > endPos ? endPos : endPos - beforeEndLengthCount);
            cfi = section.cfiFromRange(range);
            let excerpt = nodeList2.slice(0, endNodeIndex + 1).reduce((acc, current) => {
              return acc + current.textContent;
            }, "");
            if (excerpt.length > excerptLimit) {
              excerpt = excerpt.substring(pos - excerptLimit / 2, pos + excerptLimit / 2);
              excerpt = "..." + excerpt + "...";
            }
            matches.push({
              cfi,
              excerpt
            });
          }
        }
      };
      const treeWalker2 = document.createTreeWalker(section.document, NodeFilter.SHOW_TEXT, null, false);
      let node, nodeList = [];
      while (node = treeWalker2.nextNode()) {
        nodeList.push(node);
        if (nodeList.length == maxSeqEle) {
          search(nodeList.slice(0, maxSeqEle));
          nodeList = nodeList.slice(1, maxSeqEle);
        }
      }
      if (nodeList.length > 0) {
        search(nodeList);
      }
      return matches;
    }
    reconcileLayoutSettings(globalLayout) {
      var settings = {
        layout: globalLayout.layout,
        spread: globalLayout.spread,
        orientation: globalLayout.orientation
      };
      this.properties.forEach(function(prop) {
        var rendition = prop.replace("rendition:", "");
        var split = rendition.indexOf("-");
        var property, value;
        if (split != -1) {
          property = rendition.slice(0, split);
          value = rendition.slice(split + 1);
          settings[property] = value;
        }
      });
      return settings;
    }
    cfiFromRange(_range) {
      return new epubcfi_default(_range, this.cfiBase).toString();
    }
    cfiFromElement(el) {
      return new epubcfi_default(el, this.cfiBase).toString();
    }
    unload() {
      this.document = void 0;
      this.contents = void 0;
      this.output = void 0;
    }
    destroy() {
      this.unload();
      this.hooks.serialize.clear();
      this.hooks.content.clear();
      this.hooks = void 0;
      this.idref = void 0;
      this.linear = void 0;
      this.properties = void 0;
      this.index = void 0;
      this.href = void 0;
      this.url = void 0;
      this.next = void 0;
      this.prev = void 0;
      this.cfiBase = void 0;
    }
  };
  var section_default = Section;

  // ../library_management/node_modules/epubjs/src/spine.js
  var Spine = class {
    constructor() {
      this.spineItems = [];
      this.spineByHref = {};
      this.spineById = {};
      this.hooks = {};
      this.hooks.serialize = new hook_default();
      this.hooks.content = new hook_default();
      this.hooks.content.register(replaceBase);
      this.hooks.content.register(replaceCanonical);
      this.hooks.content.register(replaceMeta);
      this.epubcfi = new epubcfi_default();
      this.loaded = false;
      this.items = void 0;
      this.manifest = void 0;
      this.spineNodeIndex = void 0;
      this.baseUrl = void 0;
      this.length = void 0;
    }
    unpack(_package, resolver, canonical) {
      this.items = _package.spine;
      this.manifest = _package.manifest;
      this.spineNodeIndex = _package.spineNodeIndex;
      this.baseUrl = _package.baseUrl || _package.basePath || "";
      this.length = this.items.length;
      this.items.forEach((item, index) => {
        var manifestItem = this.manifest[item.idref];
        var spineItem;
        item.index = index;
        item.cfiBase = this.epubcfi.generateChapterComponent(this.spineNodeIndex, item.index, item.id);
        if (item.href) {
          item.url = resolver(item.href, true);
          item.canonical = canonical(item.href);
        }
        if (manifestItem) {
          item.href = manifestItem.href;
          item.url = resolver(item.href, true);
          item.canonical = canonical(item.href);
          if (manifestItem.properties.length) {
            item.properties.push.apply(item.properties, manifestItem.properties);
          }
        }
        if (item.linear === "yes") {
          item.prev = function() {
            let prevIndex = item.index;
            while (prevIndex > 0) {
              let prev = this.get(prevIndex - 1);
              if (prev && prev.linear) {
                return prev;
              }
              prevIndex -= 1;
            }
            return;
          }.bind(this);
          item.next = function() {
            let nextIndex = item.index;
            while (nextIndex < this.spineItems.length - 1) {
              let next = this.get(nextIndex + 1);
              if (next && next.linear) {
                return next;
              }
              nextIndex += 1;
            }
            return;
          }.bind(this);
        } else {
          item.prev = function() {
            return;
          };
          item.next = function() {
            return;
          };
        }
        spineItem = new section_default(item, this.hooks);
        this.append(spineItem);
      });
      this.loaded = true;
    }
    get(target) {
      var index = 0;
      if (typeof target === "undefined") {
        while (index < this.spineItems.length) {
          let next = this.spineItems[index];
          if (next && next.linear) {
            break;
          }
          index += 1;
        }
      } else if (this.epubcfi.isCfiString(target)) {
        let cfi = new epubcfi_default(target);
        index = cfi.spinePos;
      } else if (typeof target === "number" || isNaN(target) === false) {
        index = target;
      } else if (typeof target === "string" && target.indexOf("#") === 0) {
        index = this.spineById[target.substring(1)];
      } else if (typeof target === "string") {
        target = target.split("#")[0];
        index = this.spineByHref[target] || this.spineByHref[encodeURI(target)];
      }
      return this.spineItems[index] || null;
    }
    append(section) {
      var index = this.spineItems.length;
      section.index = index;
      this.spineItems.push(section);
      this.spineByHref[decodeURI(section.href)] = index;
      this.spineByHref[encodeURI(section.href)] = index;
      this.spineByHref[section.href] = index;
      this.spineById[section.idref] = index;
      return index;
    }
    prepend(section) {
      this.spineByHref[section.href] = 0;
      this.spineById[section.idref] = 0;
      this.spineItems.forEach(function(item, index) {
        item.index = index;
      });
      return 0;
    }
    remove(section) {
      var index = this.spineItems.indexOf(section);
      if (index > -1) {
        delete this.spineByHref[section.href];
        delete this.spineById[section.idref];
        return this.spineItems.splice(index, 1);
      }
    }
    each() {
      return this.spineItems.forEach.apply(this.spineItems, arguments);
    }
    first() {
      let index = 0;
      do {
        let next = this.get(index);
        if (next && next.linear) {
          return next;
        }
        index += 1;
      } while (index < this.spineItems.length);
    }
    last() {
      let index = this.spineItems.length - 1;
      do {
        let prev = this.get(index);
        if (prev && prev.linear) {
          return prev;
        }
        index -= 1;
      } while (index >= 0);
    }
    destroy() {
      this.each((section) => section.destroy());
      this.spineItems = void 0;
      this.spineByHref = void 0;
      this.spineById = void 0;
      this.hooks.serialize.clear();
      this.hooks.content.clear();
      this.hooks = void 0;
      this.epubcfi = void 0;
      this.loaded = false;
      this.items = void 0;
      this.manifest = void 0;
      this.spineNodeIndex = void 0;
      this.baseUrl = void 0;
      this.length = void 0;
    }
  };
  var spine_default = Spine;

  // ../library_management/node_modules/epubjs/src/utils/queue.js
  var Queue = class {
    constructor(context) {
      this._q = [];
      this.context = context;
      this.tick = requestAnimationFrame2;
      this.running = false;
      this.paused = false;
    }
    enqueue() {
      var deferred, promise;
      var queued;
      var task = [].shift.call(arguments);
      var args = arguments;
      if (!task) {
        throw new Error("No Task Provided");
      }
      if (typeof task === "function") {
        deferred = new defer();
        promise = deferred.promise;
        queued = {
          "task": task,
          "args": args,
          "deferred": deferred,
          "promise": promise
        };
      } else {
        queued = {
          "promise": task
        };
      }
      this._q.push(queued);
      if (this.paused == false && !this.running) {
        this.run();
      }
      return queued.promise;
    }
    dequeue() {
      var inwait, task, result;
      if (this._q.length && !this.paused) {
        inwait = this._q.shift();
        task = inwait.task;
        if (task) {
          result = task.apply(this.context, inwait.args);
          if (result && typeof result["then"] === "function") {
            return result.then(function() {
              inwait.deferred.resolve.apply(this.context, arguments);
            }.bind(this), function() {
              inwait.deferred.reject.apply(this.context, arguments);
            }.bind(this));
          } else {
            inwait.deferred.resolve.apply(this.context, result);
            return inwait.promise;
          }
        } else if (inwait.promise) {
          return inwait.promise;
        }
      } else {
        inwait = new defer();
        inwait.deferred.resolve();
        return inwait.promise;
      }
    }
    dump() {
      while (this._q.length) {
        this.dequeue();
      }
    }
    run() {
      if (!this.running) {
        this.running = true;
        this.defered = new defer();
      }
      this.tick.call(window, () => {
        if (this._q.length) {
          this.dequeue().then(function() {
            this.run();
          }.bind(this));
        } else {
          this.defered.resolve();
          this.running = void 0;
        }
      });
      if (this.paused == true) {
        this.paused = false;
      }
      return this.defered.promise;
    }
    flush() {
      if (this.running) {
        return this.running;
      }
      if (this._q.length) {
        this.running = this.dequeue().then(function() {
          this.running = void 0;
          return this.flush();
        }.bind(this));
        return this.running;
      }
    }
    clear() {
      this._q = [];
    }
    length() {
      return this._q.length;
    }
    pause() {
      this.paused = true;
    }
    stop() {
      this._q = [];
      this.running = false;
      this.paused = true;
    }
  };
  var queue_default = Queue;

  // ../library_management/node_modules/epubjs/src/utils/constants.js
  var EPUBJS_VERSION = "0.3";
  var DOM_EVENTS = ["keydown", "keyup", "keypressed", "mouseup", "mousedown", "mousemove", "click", "touchend", "touchstart", "touchmove"];
  var EVENTS = {
    BOOK: {
      OPEN_FAILED: "openFailed"
    },
    CONTENTS: {
      EXPAND: "expand",
      RESIZE: "resize",
      SELECTED: "selected",
      SELECTED_RANGE: "selectedRange",
      LINK_CLICKED: "linkClicked"
    },
    LOCATIONS: {
      CHANGED: "changed"
    },
    MANAGERS: {
      RESIZE: "resize",
      RESIZED: "resized",
      ORIENTATION_CHANGE: "orientationchange",
      ADDED: "added",
      SCROLL: "scroll",
      SCROLLED: "scrolled",
      REMOVED: "removed"
    },
    VIEWS: {
      AXIS: "axis",
      WRITING_MODE: "writingMode",
      LOAD_ERROR: "loaderror",
      RENDERED: "rendered",
      RESIZED: "resized",
      DISPLAYED: "displayed",
      SHOWN: "shown",
      HIDDEN: "hidden",
      MARK_CLICKED: "markClicked"
    },
    RENDITION: {
      STARTED: "started",
      ATTACHED: "attached",
      DISPLAYED: "displayed",
      DISPLAY_ERROR: "displayerror",
      RENDERED: "rendered",
      REMOVED: "removed",
      RESIZED: "resized",
      ORIENTATION_CHANGE: "orientationchange",
      LOCATION_CHANGED: "locationChanged",
      RELOCATED: "relocated",
      MARK_CLICKED: "markClicked",
      SELECTED: "selected",
      LAYOUT: "layout"
    },
    LAYOUT: {
      UPDATED: "updated"
    },
    ANNOTATION: {
      ATTACH: "attach",
      DETACH: "detach"
    }
  };

  // ../library_management/node_modules/epubjs/src/locations.js
  var import_event_emitter = __toESM(require_event_emitter());
  var Locations = class {
    constructor(spine, request2, pause) {
      this.spine = spine;
      this.request = request2;
      this.pause = pause || 100;
      this.q = new queue_default(this);
      this.epubcfi = new epubcfi_default();
      this._locations = [];
      this._locationsWords = [];
      this.total = 0;
      this.break = 150;
      this._current = 0;
      this._wordCounter = 0;
      this.currentLocation = "";
      this._currentCfi = "";
      this.processingTimeout = void 0;
    }
    generate(chars) {
      if (chars) {
        this.break = chars;
      }
      this.q.pause();
      this.spine.each(function(section) {
        if (section.linear) {
          this.q.enqueue(this.process.bind(this), section);
        }
      }.bind(this));
      return this.q.run().then(function() {
        this.total = this._locations.length - 1;
        if (this._currentCfi) {
          this.currentLocation = this._currentCfi;
        }
        return this._locations;
      }.bind(this));
    }
    createRange() {
      return {
        startContainer: void 0,
        startOffset: void 0,
        endContainer: void 0,
        endOffset: void 0
      };
    }
    process(section) {
      return section.load(this.request).then(function(contents) {
        var completed = new defer();
        var locations2 = this.parse(contents, section.cfiBase);
        this._locations = this._locations.concat(locations2);
        section.unload();
        this.processingTimeout = setTimeout(() => completed.resolve(locations2), this.pause);
        return completed.promise;
      }.bind(this));
    }
    parse(contents, cfiBase, chars) {
      var locations2 = [];
      var range;
      var doc2 = contents.ownerDocument;
      var body = qs(doc2, "body");
      var counter = 0;
      var prev;
      var _break = chars || this.break;
      var parser = function(node) {
        var len = node.length;
        var dist;
        var pos = 0;
        if (node.textContent.trim().length === 0) {
          return false;
        }
        if (counter == 0) {
          range = this.createRange();
          range.startContainer = node;
          range.startOffset = 0;
        }
        dist = _break - counter;
        if (dist > len) {
          counter += len;
          pos = len;
        }
        while (pos < len) {
          dist = _break - counter;
          if (counter === 0) {
            pos += 1;
            range = this.createRange();
            range.startContainer = node;
            range.startOffset = pos;
          }
          if (pos + dist >= len) {
            counter += len - pos;
            pos = len;
          } else {
            pos += dist;
            range.endContainer = node;
            range.endOffset = pos;
            let cfi = new epubcfi_default(range, cfiBase).toString();
            locations2.push(cfi);
            counter = 0;
          }
        }
        prev = node;
      };
      sprint(body, parser.bind(this));
      if (range && range.startContainer && prev) {
        range.endContainer = prev;
        range.endOffset = prev.length;
        let cfi = new epubcfi_default(range, cfiBase).toString();
        locations2.push(cfi);
        counter = 0;
      }
      return locations2;
    }
    generateFromWords(startCfi, wordCount, count) {
      var start = startCfi ? new epubcfi_default(startCfi) : void 0;
      this.q.pause();
      this._locationsWords = [];
      this._wordCounter = 0;
      this.spine.each(function(section) {
        if (section.linear) {
          if (start) {
            if (section.index >= start.spinePos) {
              this.q.enqueue(this.processWords.bind(this), section, wordCount, start, count);
            }
          } else {
            this.q.enqueue(this.processWords.bind(this), section, wordCount, start, count);
          }
        }
      }.bind(this));
      return this.q.run().then(function() {
        if (this._currentCfi) {
          this.currentLocation = this._currentCfi;
        }
        return this._locationsWords;
      }.bind(this));
    }
    processWords(section, wordCount, startCfi, count) {
      if (count && this._locationsWords.length >= count) {
        return Promise.resolve();
      }
      return section.load(this.request).then(function(contents) {
        var completed = new defer();
        var locations2 = this.parseWords(contents, section, wordCount, startCfi);
        var remainingCount = count - this._locationsWords.length;
        this._locationsWords = this._locationsWords.concat(locations2.length >= count ? locations2.slice(0, remainingCount) : locations2);
        section.unload();
        this.processingTimeout = setTimeout(() => completed.resolve(locations2), this.pause);
        return completed.promise;
      }.bind(this));
    }
    countWords(s) {
      s = s.replace(/(^\s*)|(\s*$)/gi, "");
      s = s.replace(/[ ]{2,}/gi, " ");
      s = s.replace(/\n /, "\n");
      return s.split(" ").length;
    }
    parseWords(contents, section, wordCount, startCfi) {
      var cfiBase = section.cfiBase;
      var locations2 = [];
      var doc2 = contents.ownerDocument;
      var body = qs(doc2, "body");
      var prev;
      var _break = wordCount;
      var foundStartNode = startCfi ? startCfi.spinePos !== section.index : true;
      var startNode;
      if (startCfi && section.index === startCfi.spinePos) {
        startNode = startCfi.findNode(startCfi.range ? startCfi.path.steps.concat(startCfi.start.steps) : startCfi.path.steps, contents.ownerDocument);
      }
      var parser = function(node) {
        if (!foundStartNode) {
          if (node === startNode) {
            foundStartNode = true;
          } else {
            return false;
          }
        }
        if (node.textContent.length < 10) {
          if (node.textContent.trim().length === 0) {
            return false;
          }
        }
        var len = this.countWords(node.textContent);
        var dist;
        var pos = 0;
        if (len === 0) {
          return false;
        }
        dist = _break - this._wordCounter;
        if (dist > len) {
          this._wordCounter += len;
          pos = len;
        }
        while (pos < len) {
          dist = _break - this._wordCounter;
          if (pos + dist >= len) {
            this._wordCounter += len - pos;
            pos = len;
          } else {
            pos += dist;
            let cfi = new epubcfi_default(node, cfiBase);
            locations2.push({ cfi: cfi.toString(), wordCount: this._wordCounter });
            this._wordCounter = 0;
          }
        }
        prev = node;
      };
      sprint(body, parser.bind(this));
      return locations2;
    }
    locationFromCfi(cfi) {
      let loc;
      if (epubcfi_default.prototype.isCfiString(cfi)) {
        cfi = new epubcfi_default(cfi);
      }
      if (this._locations.length === 0) {
        return -1;
      }
      loc = locationOf(cfi, this._locations, this.epubcfi.compare);
      if (loc > this.total) {
        return this.total;
      }
      return loc;
    }
    percentageFromCfi(cfi) {
      if (this._locations.length === 0) {
        return null;
      }
      var loc = this.locationFromCfi(cfi);
      return this.percentageFromLocation(loc);
    }
    percentageFromLocation(loc) {
      if (!loc || !this.total) {
        return 0;
      }
      return loc / this.total;
    }
    cfiFromLocation(loc) {
      var cfi = -1;
      if (typeof loc != "number") {
        loc = parseInt(loc);
      }
      if (loc >= 0 && loc < this._locations.length) {
        cfi = this._locations[loc];
      }
      return cfi;
    }
    cfiFromPercentage(percentage) {
      let loc;
      if (percentage > 1) {
        console.warn("Normalize cfiFromPercentage value to between 0 - 1");
      }
      if (percentage >= 1) {
        let cfi = new epubcfi_default(this._locations[this.total]);
        cfi.collapse();
        return cfi.toString();
      }
      loc = Math.ceil(this.total * percentage);
      return this.cfiFromLocation(loc);
    }
    load(locations2) {
      if (typeof locations2 === "string") {
        this._locations = JSON.parse(locations2);
      } else {
        this._locations = locations2;
      }
      this.total = this._locations.length - 1;
      return this._locations;
    }
    save() {
      return JSON.stringify(this._locations);
    }
    getCurrent() {
      return this._current;
    }
    setCurrent(curr) {
      var loc;
      if (typeof curr == "string") {
        this._currentCfi = curr;
      } else if (typeof curr == "number") {
        this._current = curr;
      } else {
        return;
      }
      if (this._locations.length === 0) {
        return;
      }
      if (typeof curr == "string") {
        loc = this.locationFromCfi(curr);
        this._current = loc;
      } else {
        loc = curr;
      }
      this.emit(EVENTS.LOCATIONS.CHANGED, {
        percentage: this.percentageFromLocation(loc)
      });
    }
    get currentLocation() {
      return this._current;
    }
    set currentLocation(curr) {
      this.setCurrent(curr);
    }
    length() {
      return this._locations.length;
    }
    destroy() {
      this.spine = void 0;
      this.request = void 0;
      this.pause = void 0;
      this.q.stop();
      this.q = void 0;
      this.epubcfi = void 0;
      this._locations = void 0;
      this.total = void 0;
      this.break = void 0;
      this._current = void 0;
      this.currentLocation = void 0;
      this._currentCfi = void 0;
      clearTimeout(this.processingTimeout);
    }
  };
  (0, import_event_emitter.default)(Locations.prototype);
  var locations_default = Locations;

  // ../library_management/node_modules/epubjs/src/container.js
  var import_path_webpack3 = __toESM(require_path());
  var Container = class {
    constructor(containerDocument) {
      this.packagePath = "";
      this.directory = "";
      this.encoding = "";
      if (containerDocument) {
        this.parse(containerDocument);
      }
    }
    parse(containerDocument) {
      var rootfile;
      if (!containerDocument) {
        throw new Error("Container File Not Found");
      }
      rootfile = qs(containerDocument, "rootfile");
      if (!rootfile) {
        throw new Error("No RootFile Found");
      }
      this.packagePath = rootfile.getAttribute("full-path");
      this.directory = import_path_webpack3.default.dirname(this.packagePath);
      this.encoding = containerDocument.xmlEncoding;
    }
    destroy() {
      this.packagePath = void 0;
      this.directory = void 0;
      this.encoding = void 0;
    }
  };
  var container_default = Container;

  // ../library_management/node_modules/epubjs/src/packaging.js
  var Packaging = class {
    constructor(packageDocument) {
      this.manifest = {};
      this.navPath = "";
      this.ncxPath = "";
      this.coverPath = "";
      this.spineNodeIndex = 0;
      this.spine = [];
      this.metadata = {};
      if (packageDocument) {
        this.parse(packageDocument);
      }
    }
    parse(packageDocument) {
      var metadataNode, manifestNode, spineNode;
      if (!packageDocument) {
        throw new Error("Package File Not Found");
      }
      metadataNode = qs(packageDocument, "metadata");
      if (!metadataNode) {
        throw new Error("No Metadata Found");
      }
      manifestNode = qs(packageDocument, "manifest");
      if (!manifestNode) {
        throw new Error("No Manifest Found");
      }
      spineNode = qs(packageDocument, "spine");
      if (!spineNode) {
        throw new Error("No Spine Found");
      }
      this.manifest = this.parseManifest(manifestNode);
      this.navPath = this.findNavPath(manifestNode);
      this.ncxPath = this.findNcxPath(manifestNode, spineNode);
      this.coverPath = this.findCoverPath(packageDocument);
      this.spineNodeIndex = indexOfElementNode(spineNode);
      this.spine = this.parseSpine(spineNode, this.manifest);
      this.uniqueIdentifier = this.findUniqueIdentifier(packageDocument);
      this.metadata = this.parseMetadata(metadataNode);
      this.metadata.direction = spineNode.getAttribute("page-progression-direction");
      return {
        "metadata": this.metadata,
        "spine": this.spine,
        "manifest": this.manifest,
        "navPath": this.navPath,
        "ncxPath": this.ncxPath,
        "coverPath": this.coverPath,
        "spineNodeIndex": this.spineNodeIndex
      };
    }
    parseMetadata(xml) {
      var metadata = {};
      metadata.title = this.getElementText(xml, "title");
      metadata.creator = this.getElementText(xml, "creator");
      metadata.description = this.getElementText(xml, "description");
      metadata.pubdate = this.getElementText(xml, "date");
      metadata.publisher = this.getElementText(xml, "publisher");
      metadata.identifier = this.getElementText(xml, "identifier");
      metadata.language = this.getElementText(xml, "language");
      metadata.rights = this.getElementText(xml, "rights");
      metadata.modified_date = this.getPropertyText(xml, "dcterms:modified");
      metadata.layout = this.getPropertyText(xml, "rendition:layout");
      metadata.orientation = this.getPropertyText(xml, "rendition:orientation");
      metadata.flow = this.getPropertyText(xml, "rendition:flow");
      metadata.viewport = this.getPropertyText(xml, "rendition:viewport");
      metadata.media_active_class = this.getPropertyText(xml, "media:active-class");
      metadata.spread = this.getPropertyText(xml, "rendition:spread");
      return metadata;
    }
    parseManifest(manifestXml) {
      var manifest = {};
      var selected = qsa(manifestXml, "item");
      var items = Array.prototype.slice.call(selected);
      items.forEach(function(item) {
        var id = item.getAttribute("id"), href = item.getAttribute("href") || "", type2 = item.getAttribute("media-type") || "", overlay = item.getAttribute("media-overlay") || "", properties = item.getAttribute("properties") || "";
        manifest[id] = {
          "href": href,
          "type": type2,
          "overlay": overlay,
          "properties": properties.length ? properties.split(" ") : []
        };
      });
      return manifest;
    }
    parseSpine(spineXml, manifest) {
      var spine = [];
      var selected = qsa(spineXml, "itemref");
      var items = Array.prototype.slice.call(selected);
      items.forEach(function(item, index) {
        var idref = item.getAttribute("idref");
        var props = item.getAttribute("properties") || "";
        var propArray = props.length ? props.split(" ") : [];
        var itemref = {
          "id": item.getAttribute("id"),
          "idref": idref,
          "linear": item.getAttribute("linear") || "yes",
          "properties": propArray,
          "index": index
        };
        spine.push(itemref);
      });
      return spine;
    }
    findUniqueIdentifier(packageXml) {
      var uniqueIdentifierId = packageXml.documentElement.getAttribute("unique-identifier");
      if (!uniqueIdentifierId) {
        return "";
      }
      var identifier = packageXml.getElementById(uniqueIdentifierId);
      if (!identifier) {
        return "";
      }
      if (identifier.localName === "identifier" && identifier.namespaceURI === "http://purl.org/dc/elements/1.1/") {
        return identifier.childNodes.length > 0 ? identifier.childNodes[0].nodeValue.trim() : "";
      }
      return "";
    }
    findNavPath(manifestNode) {
      var node = qsp(manifestNode, "item", { "properties": "nav" });
      return node ? node.getAttribute("href") : false;
    }
    findNcxPath(manifestNode, spineNode) {
      var node = qsp(manifestNode, "item", { "media-type": "application/x-dtbncx+xml" });
      var tocId;
      if (!node) {
        tocId = spineNode.getAttribute("toc");
        if (tocId) {
          node = manifestNode.querySelector(`#${tocId}`);
        }
      }
      return node ? node.getAttribute("href") : false;
    }
    findCoverPath(packageXml) {
      var pkg = qs(packageXml, "package");
      var epubVersion = pkg.getAttribute("version");
      var node = qsp(packageXml, "item", { "properties": "cover-image" });
      if (node)
        return node.getAttribute("href");
      var metaCover = qsp(packageXml, "meta", { "name": "cover" });
      if (metaCover) {
        var coverId = metaCover.getAttribute("content");
        var cover = packageXml.getElementById(coverId);
        return cover ? cover.getAttribute("href") : "";
      } else {
        return false;
      }
    }
    getElementText(xml, tag) {
      var found = xml.getElementsByTagNameNS("http://purl.org/dc/elements/1.1/", tag);
      var el;
      if (!found || found.length === 0)
        return "";
      el = found[0];
      if (el.childNodes.length) {
        return el.childNodes[0].nodeValue;
      }
      return "";
    }
    getPropertyText(xml, property) {
      var el = qsp(xml, "meta", { "property": property });
      if (el && el.childNodes.length) {
        return el.childNodes[0].nodeValue;
      }
      return "";
    }
    load(json) {
      this.metadata = json.metadata;
      let spine = json.readingOrder || json.spine;
      this.spine = spine.map((item, index) => {
        item.index = index;
        item.linear = item.linear || "yes";
        return item;
      });
      json.resources.forEach((item, index) => {
        this.manifest[index] = item;
        if (item.rel && item.rel[0] === "cover") {
          this.coverPath = item.href;
        }
      });
      this.spineNodeIndex = 0;
      this.toc = json.toc.map((item, index) => {
        item.label = item.title;
        return item;
      });
      return {
        "metadata": this.metadata,
        "spine": this.spine,
        "manifest": this.manifest,
        "navPath": this.navPath,
        "ncxPath": this.ncxPath,
        "coverPath": this.coverPath,
        "spineNodeIndex": this.spineNodeIndex,
        "toc": this.toc
      };
    }
    destroy() {
      this.manifest = void 0;
      this.navPath = void 0;
      this.ncxPath = void 0;
      this.coverPath = void 0;
      this.spineNodeIndex = void 0;
      this.spine = void 0;
      this.metadata = void 0;
    }
  };
  var packaging_default = Packaging;

  // ../library_management/node_modules/epubjs/src/navigation.js
  var Navigation = class {
    constructor(xml) {
      this.toc = [];
      this.tocByHref = {};
      this.tocById = {};
      this.landmarks = [];
      this.landmarksByType = {};
      this.length = 0;
      if (xml) {
        this.parse(xml);
      }
    }
    parse(xml) {
      let isXml2 = xml.nodeType;
      let html;
      let ncx;
      if (isXml2) {
        html = qs(xml, "html");
        ncx = qs(xml, "ncx");
      }
      if (!isXml2) {
        this.toc = this.load(xml);
      } else if (html) {
        this.toc = this.parseNav(xml);
        this.landmarks = this.parseLandmarks(xml);
      } else if (ncx) {
        this.toc = this.parseNcx(xml);
      }
      this.length = 0;
      this.unpack(this.toc);
    }
    unpack(toc) {
      var item;
      for (var i = 0; i < toc.length; i++) {
        item = toc[i];
        if (item.href) {
          this.tocByHref[item.href] = i;
        }
        if (item.id) {
          this.tocById[item.id] = i;
        }
        this.length++;
        if (item.subitems.length) {
          this.unpack(item.subitems);
        }
      }
    }
    get(target) {
      var index;
      if (!target) {
        return this.toc;
      }
      if (target.indexOf("#") === 0) {
        index = this.tocById[target.substring(1)];
      } else if (target in this.tocByHref) {
        index = this.tocByHref[target];
      }
      return this.getByIndex(target, index, this.toc);
    }
    getByIndex(target, index, navItems) {
      if (navItems.length === 0) {
        return;
      }
      const item = navItems[index];
      if (item && (target === item.id || target === item.href)) {
        return item;
      } else {
        let result;
        for (let i = 0; i < navItems.length; ++i) {
          result = this.getByIndex(target, index, navItems[i].subitems);
          if (result) {
            break;
          }
        }
        return result;
      }
    }
    landmark(type2) {
      var index;
      if (!type2) {
        return this.landmarks;
      }
      index = this.landmarksByType[type2];
      return this.landmarks[index];
    }
    parseNav(navHtml) {
      var navElement = querySelectorByType(navHtml, "nav", "toc");
      var list = [];
      if (!navElement)
        return list;
      let navList = filterChildren(navElement, "ol", true);
      if (!navList)
        return list;
      list = this.parseNavList(navList);
      return list;
    }
    parseNavList(navListHtml, parent2) {
      const result = [];
      if (!navListHtml)
        return result;
      if (!navListHtml.children)
        return result;
      for (let i = 0; i < navListHtml.children.length; i++) {
        const item = this.navItem(navListHtml.children[i], parent2);
        if (item) {
          result.push(item);
        }
      }
      return result;
    }
    navItem(item, parent2) {
      let id = item.getAttribute("id") || void 0;
      let content = filterChildren(item, "a", true) || filterChildren(item, "span", true);
      if (!content) {
        return;
      }
      let src = content.getAttribute("href") || "";
      if (!id) {
        id = src;
      }
      let text = content.textContent || "";
      let subitems = [];
      let nested = filterChildren(item, "ol", true);
      if (nested) {
        subitems = this.parseNavList(nested, id);
      }
      return {
        "id": id,
        "href": src,
        "label": text,
        "subitems": subitems,
        "parent": parent2
      };
    }
    parseLandmarks(navHtml) {
      var navElement = querySelectorByType(navHtml, "nav", "landmarks");
      var navItems = navElement ? qsa(navElement, "li") : [];
      var length = navItems.length;
      var i;
      var list = [];
      var item;
      if (!navItems || length === 0)
        return list;
      for (i = 0; i < length; ++i) {
        item = this.landmarkItem(navItems[i]);
        if (item) {
          list.push(item);
          this.landmarksByType[item.type] = i;
        }
      }
      return list;
    }
    landmarkItem(item) {
      let content = filterChildren(item, "a", true);
      if (!content) {
        return;
      }
      let type2 = content.getAttributeNS("http://www.idpf.org/2007/ops", "type") || void 0;
      let href = content.getAttribute("href") || "";
      let text = content.textContent || "";
      return {
        "href": href,
        "label": text,
        "type": type2
      };
    }
    parseNcx(tocXml) {
      var navPoints = qsa(tocXml, "navPoint");
      var length = navPoints.length;
      var i;
      var toc = {};
      var list = [];
      var item, parent2;
      if (!navPoints || length === 0)
        return list;
      for (i = 0; i < length; ++i) {
        item = this.ncxItem(navPoints[i]);
        toc[item.id] = item;
        if (!item.parent) {
          list.push(item);
        } else {
          parent2 = toc[item.parent];
          parent2.subitems.push(item);
        }
      }
      return list;
    }
    ncxItem(item) {
      var id = item.getAttribute("id") || false, content = qs(item, "content"), src = content.getAttribute("src"), navLabel = qs(item, "navLabel"), text = navLabel.textContent ? navLabel.textContent : "", subitems = [], parentNode = item.parentNode, parent2;
      if (parentNode && (parentNode.nodeName === "navPoint" || parentNode.nodeName.split(":").slice(-1)[0] === "navPoint")) {
        parent2 = parentNode.getAttribute("id");
      }
      return {
        "id": id,
        "href": src,
        "label": text,
        "subitems": subitems,
        "parent": parent2
      };
    }
    load(json) {
      return json.map((item) => {
        item.label = item.title;
        item.subitems = item.children ? this.load(item.children) : [];
        return item;
      });
    }
    forEach(fn) {
      return this.toc.forEach(fn);
    }
  };
  var navigation_default = Navigation;

  // ../library_management/node_modules/epubjs/src/utils/mime.js
  var table = {
    "application": {
      "ecmascript": ["es", "ecma"],
      "javascript": "js",
      "ogg": "ogx",
      "pdf": "pdf",
      "postscript": ["ps", "ai", "eps", "epsi", "epsf", "eps2", "eps3"],
      "rdf+xml": "rdf",
      "smil": ["smi", "smil"],
      "xhtml+xml": ["xhtml", "xht"],
      "xml": ["xml", "xsl", "xsd", "opf", "ncx"],
      "zip": "zip",
      "x-httpd-eruby": "rhtml",
      "x-latex": "latex",
      "x-maker": ["frm", "maker", "frame", "fm", "fb", "book", "fbdoc"],
      "x-object": "o",
      "x-shockwave-flash": ["swf", "swfl"],
      "x-silverlight": "scr",
      "epub+zip": "epub",
      "font-tdpfr": "pfr",
      "inkml+xml": ["ink", "inkml"],
      "json": "json",
      "jsonml+json": "jsonml",
      "mathml+xml": "mathml",
      "metalink+xml": "metalink",
      "mp4": "mp4s",
      "omdoc+xml": "omdoc",
      "oxps": "oxps",
      "vnd.amazon.ebook": "azw",
      "widget": "wgt",
      "x-dtbook+xml": "dtb",
      "x-dtbresource+xml": "res",
      "x-font-bdf": "bdf",
      "x-font-ghostscript": "gsf",
      "x-font-linux-psf": "psf",
      "x-font-otf": "otf",
      "x-font-pcf": "pcf",
      "x-font-snf": "snf",
      "x-font-ttf": ["ttf", "ttc"],
      "x-font-type1": ["pfa", "pfb", "pfm", "afm"],
      "x-font-woff": "woff",
      "x-mobipocket-ebook": ["prc", "mobi"],
      "x-mspublisher": "pub",
      "x-nzb": "nzb",
      "x-tgif": "obj",
      "xaml+xml": "xaml",
      "xml-dtd": "dtd",
      "xproc+xml": "xpl",
      "xslt+xml": "xslt",
      "internet-property-stream": "acx",
      "x-compress": "z",
      "x-compressed": "tgz",
      "x-gzip": "gz"
    },
    "audio": {
      "flac": "flac",
      "midi": ["mid", "midi", "kar", "rmi"],
      "mpeg": ["mpga", "mpega", "mp2", "mp3", "m4a", "mp2a", "m2a", "m3a"],
      "mpegurl": "m3u",
      "ogg": ["oga", "ogg", "spx"],
      "x-aiff": ["aif", "aiff", "aifc"],
      "x-ms-wma": "wma",
      "x-wav": "wav",
      "adpcm": "adp",
      "mp4": "mp4a",
      "webm": "weba",
      "x-aac": "aac",
      "x-caf": "caf",
      "x-matroska": "mka",
      "x-pn-realaudio-plugin": "rmp",
      "xm": "xm",
      "mid": ["mid", "rmi"]
    },
    "image": {
      "gif": "gif",
      "ief": "ief",
      "jpeg": ["jpeg", "jpg", "jpe"],
      "pcx": "pcx",
      "png": "png",
      "svg+xml": ["svg", "svgz"],
      "tiff": ["tiff", "tif"],
      "x-icon": "ico",
      "bmp": "bmp",
      "webp": "webp",
      "x-pict": ["pic", "pct"],
      "x-tga": "tga",
      "cis-cod": "cod"
    },
    "text": {
      "cache-manifest": ["manifest", "appcache"],
      "css": "css",
      "csv": "csv",
      "html": ["html", "htm", "shtml", "stm"],
      "mathml": "mml",
      "plain": ["txt", "text", "brf", "conf", "def", "list", "log", "in", "bas"],
      "richtext": "rtx",
      "tab-separated-values": "tsv",
      "x-bibtex": "bib"
    },
    "video": {
      "mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v", "mp2", "mpa", "mpv2"],
      "mp4": ["mp4", "mp4v", "mpg4"],
      "quicktime": ["qt", "mov"],
      "ogg": "ogv",
      "vnd.mpegurl": ["mxu", "m4u"],
      "x-flv": "flv",
      "x-la-asf": ["lsf", "lsx"],
      "x-mng": "mng",
      "x-ms-asf": ["asf", "asx", "asr"],
      "x-ms-wm": "wm",
      "x-ms-wmv": "wmv",
      "x-ms-wmx": "wmx",
      "x-ms-wvx": "wvx",
      "x-msvideo": "avi",
      "x-sgi-movie": "movie",
      "x-matroska": ["mpv", "mkv", "mk3d", "mks"],
      "3gpp2": "3g2",
      "h261": "h261",
      "h263": "h263",
      "h264": "h264",
      "jpeg": "jpgv",
      "jpm": ["jpm", "jpgm"],
      "mj2": ["mj2", "mjp2"],
      "vnd.ms-playready.media.pyv": "pyv",
      "vnd.uvvu.mp4": ["uvu", "uvvu"],
      "vnd.vivo": "viv",
      "webm": "webm",
      "x-f4v": "f4v",
      "x-m4v": "m4v",
      "x-ms-vob": "vob",
      "x-smv": "smv"
    }
  };
  var mimeTypes = function() {
    var type2, subtype, val, index, mimeTypes2 = {};
    for (type2 in table) {
      if (table.hasOwnProperty(type2)) {
        for (subtype in table[type2]) {
          if (table[type2].hasOwnProperty(subtype)) {
            val = table[type2][subtype];
            if (typeof val == "string") {
              mimeTypes2[val] = type2 + "/" + subtype;
            } else {
              for (index = 0; index < val.length; index++) {
                mimeTypes2[val[index]] = type2 + "/" + subtype;
              }
            }
          }
        }
      }
    }
    return mimeTypes2;
  }();
  var defaultValue = "text/plain";
  function lookup(filename) {
    return filename && mimeTypes[filename.split(".").pop().toLowerCase()] || defaultValue;
  }
  var mime_default = { lookup };

  // ../library_management/node_modules/epubjs/src/resources.js
  var import_path_webpack4 = __toESM(require_path());
  var Resources = class {
    constructor(manifest, options) {
      this.settings = {
        replacements: options && options.replacements || "base64",
        archive: options && options.archive,
        resolver: options && options.resolver,
        request: options && options.request
      };
      this.process(manifest);
    }
    process(manifest) {
      this.manifest = manifest;
      this.resources = Object.keys(manifest).map(function(key) {
        return manifest[key];
      });
      this.replacementUrls = [];
      this.html = [];
      this.assets = [];
      this.css = [];
      this.urls = [];
      this.cssUrls = [];
      this.split();
      this.splitUrls();
    }
    split() {
      this.html = this.resources.filter(function(item) {
        if (item.type === "application/xhtml+xml" || item.type === "text/html") {
          return true;
        }
      });
      this.assets = this.resources.filter(function(item) {
        if (item.type !== "application/xhtml+xml" && item.type !== "text/html") {
          return true;
        }
      });
      this.css = this.resources.filter(function(item) {
        if (item.type === "text/css") {
          return true;
        }
      });
    }
    splitUrls() {
      this.urls = this.assets.map(function(item) {
        return item.href;
      }.bind(this));
      this.cssUrls = this.css.map(function(item) {
        return item.href;
      });
    }
    createUrl(url) {
      var parsedUrl = new url_default(url);
      var mimeType = mime_default.lookup(parsedUrl.filename);
      if (this.settings.archive) {
        return this.settings.archive.createUrl(url, { "base64": this.settings.replacements === "base64" });
      } else {
        if (this.settings.replacements === "base64") {
          return this.settings.request(url, "blob").then((blob) => {
            return blob2base64(blob);
          }).then((blob) => {
            return createBase64Url(blob, mimeType);
          });
        } else {
          return this.settings.request(url, "blob").then((blob) => {
            return createBlobUrl(blob, mimeType);
          });
        }
      }
    }
    replacements() {
      if (this.settings.replacements === "none") {
        return new Promise(function(resolve2) {
          resolve2(this.urls);
        }.bind(this));
      }
      var replacements = this.urls.map((url) => {
        var absolute = this.settings.resolver(url);
        return this.createUrl(absolute).catch((err) => {
          console.error(err);
          return null;
        });
      });
      return Promise.all(replacements).then((replacementUrls) => {
        this.replacementUrls = replacementUrls.filter((url) => {
          return typeof url === "string";
        });
        return replacementUrls;
      });
    }
    replaceCss(archive, resolver) {
      var replaced = [];
      archive = archive || this.settings.archive;
      resolver = resolver || this.settings.resolver;
      this.cssUrls.forEach(function(href) {
        var replacement = this.createCssFile(href, archive, resolver).then(function(replacementUrl) {
          var indexInUrls = this.urls.indexOf(href);
          if (indexInUrls > -1) {
            this.replacementUrls[indexInUrls] = replacementUrl;
          }
        }.bind(this));
        replaced.push(replacement);
      }.bind(this));
      return Promise.all(replaced);
    }
    createCssFile(href) {
      var newUrl;
      if (import_path_webpack4.default.isAbsolute(href)) {
        return new Promise(function(resolve2) {
          resolve2();
        });
      }
      var absolute = this.settings.resolver(href);
      var textResponse;
      if (this.settings.archive) {
        textResponse = this.settings.archive.getText(absolute);
      } else {
        textResponse = this.settings.request(absolute, "text");
      }
      var relUrls = this.urls.map((assetHref) => {
        var resolved = this.settings.resolver(assetHref);
        var relative = new path_default(absolute).relative(resolved);
        return relative;
      });
      if (!textResponse) {
        return new Promise(function(resolve2) {
          resolve2();
        });
      }
      return textResponse.then((text) => {
        text = substitute(text, relUrls, this.replacementUrls);
        if (this.settings.replacements === "base64") {
          newUrl = createBase64Url(text, "text/css");
        } else {
          newUrl = createBlobUrl(text, "text/css");
        }
        return newUrl;
      }, (err) => {
        return new Promise(function(resolve2) {
          resolve2();
        });
      });
    }
    relativeTo(absolute, resolver) {
      resolver = resolver || this.settings.resolver;
      return this.urls.map(function(href) {
        var resolved = resolver(href);
        var relative = new path_default(absolute).relative(resolved);
        return relative;
      }.bind(this));
    }
    get(path5) {
      var indexInUrls = this.urls.indexOf(path5);
      if (indexInUrls === -1) {
        return;
      }
      if (this.replacementUrls.length) {
        return new Promise(function(resolve2, reject) {
          resolve2(this.replacementUrls[indexInUrls]);
        }.bind(this));
      } else {
        return this.createUrl(path5);
      }
    }
    substitute(content, url) {
      var relUrls;
      if (url) {
        relUrls = this.relativeTo(url);
      } else {
        relUrls = this.urls;
      }
      return substitute(content, relUrls, this.replacementUrls);
    }
    destroy() {
      this.settings = void 0;
      this.manifest = void 0;
      this.resources = void 0;
      this.replacementUrls = void 0;
      this.html = void 0;
      this.assets = void 0;
      this.css = void 0;
      this.urls = void 0;
      this.cssUrls = void 0;
    }
  };
  var resources_default = Resources;

  // ../library_management/node_modules/epubjs/src/pagelist.js
  var PageList = class {
    constructor(xml) {
      this.pages = [];
      this.locations = [];
      this.epubcfi = new epubcfi_default();
      this.firstPage = 0;
      this.lastPage = 0;
      this.totalPages = 0;
      this.toc = void 0;
      this.ncx = void 0;
      if (xml) {
        this.pageList = this.parse(xml);
      }
      if (this.pageList && this.pageList.length) {
        this.process(this.pageList);
      }
    }
    parse(xml) {
      var html = qs(xml, "html");
      var ncx = qs(xml, "ncx");
      if (html) {
        return this.parseNav(xml);
      } else if (ncx) {
        return this.parseNcx(xml);
      }
    }
    parseNav(navHtml) {
      var navElement = querySelectorByType(navHtml, "nav", "page-list");
      var navItems = navElement ? qsa(navElement, "li") : [];
      var length = navItems.length;
      var i;
      var list = [];
      var item;
      if (!navItems || length === 0)
        return list;
      for (i = 0; i < length; ++i) {
        item = this.item(navItems[i]);
        list.push(item);
      }
      return list;
    }
    parseNcx(navXml) {
      var list = [];
      var i = 0;
      var item;
      var pageList;
      var pageTargets;
      var length = 0;
      pageList = qs(navXml, "pageList");
      if (!pageList)
        return list;
      pageTargets = qsa(pageList, "pageTarget");
      length = pageTargets.length;
      if (!pageTargets || pageTargets.length === 0) {
        return list;
      }
      for (i = 0; i < length; ++i) {
        item = this.ncxItem(pageTargets[i]);
        list.push(item);
      }
      return list;
    }
    ncxItem(item) {
      var navLabel = qs(item, "navLabel");
      var navLabelText = qs(navLabel, "text");
      var pageText = navLabelText.textContent;
      var content = qs(item, "content");
      var href = content.getAttribute("src");
      var page = parseInt(pageText, 10);
      return {
        "href": href,
        "page": page
      };
    }
    item(item) {
      var content = qs(item, "a"), href = content.getAttribute("href") || "", text = content.textContent || "", page = parseInt(text), isCfi = href.indexOf("epubcfi"), split, packageUrl, cfi;
      if (isCfi != -1) {
        split = href.split("#");
        packageUrl = split[0];
        cfi = split.length > 1 ? split[1] : false;
        return {
          "cfi": cfi,
          "href": href,
          "packageUrl": packageUrl,
          "page": page
        };
      } else {
        return {
          "href": href,
          "page": page
        };
      }
    }
    process(pageList) {
      pageList.forEach(function(item) {
        this.pages.push(item.page);
        if (item.cfi) {
          this.locations.push(item.cfi);
        }
      }, this);
      this.firstPage = parseInt(this.pages[0]);
      this.lastPage = parseInt(this.pages[this.pages.length - 1]);
      this.totalPages = this.lastPage - this.firstPage;
    }
    pageFromCfi(cfi) {
      var pg = -1;
      if (this.locations.length === 0) {
        return -1;
      }
      var index = indexOfSorted(cfi, this.locations, this.epubcfi.compare);
      if (index != -1) {
        pg = this.pages[index];
      } else {
        index = locationOf(cfi, this.locations, this.epubcfi.compare);
        pg = index - 1 >= 0 ? this.pages[index - 1] : this.pages[0];
        if (pg !== void 0) {
        } else {
          pg = -1;
        }
      }
      return pg;
    }
    cfiFromPage(pg) {
      var cfi = -1;
      if (typeof pg != "number") {
        pg = parseInt(pg);
      }
      var index = this.pages.indexOf(pg);
      if (index != -1) {
        cfi = this.locations[index];
      }
      return cfi;
    }
    pageFromPercentage(percent) {
      var pg = Math.round(this.totalPages * percent);
      return pg;
    }
    percentageFromPage(pg) {
      var percentage = (pg - this.firstPage) / this.totalPages;
      return Math.round(percentage * 1e3) / 1e3;
    }
    percentageFromCfi(cfi) {
      var pg = this.pageFromCfi(cfi);
      var percentage = this.percentageFromPage(pg);
      return percentage;
    }
    destroy() {
      this.pages = void 0;
      this.locations = void 0;
      this.epubcfi = void 0;
      this.pageList = void 0;
      this.toc = void 0;
      this.ncx = void 0;
    }
  };
  var pagelist_default = PageList;

  // ../library_management/node_modules/epubjs/src/rendition.js
  var import_event_emitter8 = __toESM(require_event_emitter());

  // ../library_management/node_modules/epubjs/src/layout.js
  var import_event_emitter2 = __toESM(require_event_emitter());
  var Layout = class {
    constructor(settings) {
      this.settings = settings;
      this.name = settings.layout || "reflowable";
      this._spread = settings.spread === "none" ? false : true;
      this._minSpreadWidth = settings.minSpreadWidth || 800;
      this._evenSpreads = settings.evenSpreads || false;
      if (settings.flow === "scrolled" || settings.flow === "scrolled-continuous" || settings.flow === "scrolled-doc") {
        this._flow = "scrolled";
      } else {
        this._flow = "paginated";
      }
      this.width = 0;
      this.height = 0;
      this.spreadWidth = 0;
      this.delta = 0;
      this.columnWidth = 0;
      this.gap = 0;
      this.divisor = 1;
      this.props = {
        name: this.name,
        spread: this._spread,
        flow: this._flow,
        width: 0,
        height: 0,
        spreadWidth: 0,
        delta: 0,
        columnWidth: 0,
        gap: 0,
        divisor: 1
      };
    }
    flow(flow) {
      if (typeof flow != "undefined") {
        if (flow === "scrolled" || flow === "scrolled-continuous" || flow === "scrolled-doc") {
          this._flow = "scrolled";
        } else {
          this._flow = "paginated";
        }
        this.update({ flow: this._flow });
      }
      return this._flow;
    }
    spread(spread, min) {
      if (spread) {
        this._spread = spread === "none" ? false : true;
        this.update({ spread: this._spread });
      }
      if (min >= 0) {
        this._minSpreadWidth = min;
      }
      return this._spread;
    }
    calculate(_width, _height, _gap) {
      var divisor = 1;
      var gap = _gap || 0;
      var width = _width;
      var height = _height;
      var section = Math.floor(width / 12);
      var columnWidth;
      var spreadWidth;
      var pageWidth;
      var delta2;
      if (this._spread && width >= this._minSpreadWidth) {
        divisor = 2;
      } else {
        divisor = 1;
      }
      if (this.name === "reflowable" && this._flow === "paginated" && !(_gap >= 0)) {
        gap = section % 2 === 0 ? section : section - 1;
      }
      if (this.name === "pre-paginated") {
        gap = 0;
      }
      if (divisor > 1) {
        columnWidth = width / divisor - gap;
        pageWidth = columnWidth + gap;
      } else {
        columnWidth = width;
        pageWidth = width;
      }
      if (this.name === "pre-paginated" && divisor > 1) {
        width = columnWidth;
      }
      spreadWidth = columnWidth * divisor + gap;
      delta2 = width;
      this.width = width;
      this.height = height;
      this.spreadWidth = spreadWidth;
      this.pageWidth = pageWidth;
      this.delta = delta2;
      this.columnWidth = columnWidth;
      this.gap = gap;
      this.divisor = divisor;
      this.update({
        width,
        height,
        spreadWidth,
        pageWidth,
        delta: delta2,
        columnWidth,
        gap,
        divisor
      });
    }
    format(contents, section, axis) {
      var formating;
      if (this.name === "pre-paginated") {
        formating = contents.fit(this.columnWidth, this.height, section);
      } else if (this._flow === "paginated") {
        formating = contents.columns(this.width, this.height, this.columnWidth, this.gap, this.settings.direction);
      } else if (axis && axis === "horizontal") {
        formating = contents.size(null, this.height);
      } else {
        formating = contents.size(this.width, null);
      }
      return formating;
    }
    count(totalLength, pageLength) {
      let spreads, pages;
      if (this.name === "pre-paginated") {
        spreads = 1;
        pages = 1;
      } else if (this._flow === "paginated") {
        pageLength = pageLength || this.delta;
        spreads = Math.ceil(totalLength / pageLength);
        pages = spreads * this.divisor;
      } else {
        pageLength = pageLength || this.height;
        spreads = Math.ceil(totalLength / pageLength);
        pages = spreads;
      }
      return {
        spreads,
        pages
      };
    }
    update(props) {
      Object.keys(props).forEach((propName) => {
        if (this.props[propName] === props[propName]) {
          delete props[propName];
        }
      });
      if (Object.keys(props).length > 0) {
        let newProps = extend2(this.props, props);
        this.emit(EVENTS.LAYOUT.UPDATED, newProps, props);
      }
    }
  };
  (0, import_event_emitter2.default)(Layout.prototype);
  var layout_default = Layout;

  // ../library_management/node_modules/epubjs/src/themes.js
  var Themes = class {
    constructor(rendition) {
      this.rendition = rendition;
      this._themes = {
        "default": {
          "rules": {},
          "url": "",
          "serialized": ""
        }
      };
      this._overrides = {};
      this._current = "default";
      this._injected = [];
      this.rendition.hooks.content.register(this.inject.bind(this));
      this.rendition.hooks.content.register(this.overrides.bind(this));
    }
    register() {
      if (arguments.length === 0) {
        return;
      }
      if (arguments.length === 1 && typeof arguments[0] === "object") {
        return this.registerThemes(arguments[0]);
      }
      if (arguments.length === 1 && typeof arguments[0] === "string") {
        return this.default(arguments[0]);
      }
      if (arguments.length === 2 && typeof arguments[1] === "string") {
        return this.registerUrl(arguments[0], arguments[1]);
      }
      if (arguments.length === 2 && typeof arguments[1] === "object") {
        return this.registerRules(arguments[0], arguments[1]);
      }
    }
    default(theme) {
      if (!theme) {
        return;
      }
      if (typeof theme === "string") {
        return this.registerUrl("default", theme);
      }
      if (typeof theme === "object") {
        return this.registerRules("default", theme);
      }
    }
    registerThemes(themes) {
      for (var theme in themes) {
        if (themes.hasOwnProperty(theme)) {
          if (typeof themes[theme] === "string") {
            this.registerUrl(theme, themes[theme]);
          } else {
            this.registerRules(theme, themes[theme]);
          }
        }
      }
    }
    registerCss(name, css) {
      this._themes[name] = { "serialized": css };
      if (this._injected[name] || name == "default") {
        this.update(name);
      }
    }
    registerUrl(name, input) {
      var url = new url_default(input);
      this._themes[name] = { "url": url.toString() };
      if (this._injected[name] || name == "default") {
        this.update(name);
      }
    }
    registerRules(name, rules) {
      this._themes[name] = { "rules": rules };
      if (this._injected[name] || name == "default") {
        this.update(name);
      }
    }
    select(name) {
      var prev = this._current;
      var contents;
      this._current = name;
      this.update(name);
      contents = this.rendition.getContents();
      contents.forEach((content) => {
        content.removeClass(prev);
        content.addClass(name);
      });
    }
    update(name) {
      var contents = this.rendition.getContents();
      contents.forEach((content) => {
        this.add(name, content);
      });
    }
    inject(contents) {
      var links = [];
      var themes = this._themes;
      var theme;
      for (var name in themes) {
        if (themes.hasOwnProperty(name) && (name === this._current || name === "default")) {
          theme = themes[name];
          if (theme.rules && Object.keys(theme.rules).length > 0 || theme.url && links.indexOf(theme.url) === -1) {
            this.add(name, contents);
          }
          this._injected.push(name);
        }
      }
      if (this._current != "default") {
        contents.addClass(this._current);
      }
    }
    add(name, contents) {
      var theme = this._themes[name];
      if (!theme || !contents) {
        return;
      }
      if (theme.url) {
        contents.addStylesheet(theme.url);
      } else if (theme.serialized) {
        contents.addStylesheetCss(theme.serialized, name);
        theme.injected = true;
      } else if (theme.rules) {
        contents.addStylesheetRules(theme.rules, name);
        theme.injected = true;
      }
    }
    override(name, value, priority) {
      var contents = this.rendition.getContents();
      this._overrides[name] = {
        value,
        priority: priority === true
      };
      contents.forEach((content) => {
        content.css(name, this._overrides[name].value, this._overrides[name].priority);
      });
    }
    removeOverride(name) {
      var contents = this.rendition.getContents();
      delete this._overrides[name];
      contents.forEach((content) => {
        content.css(name);
      });
    }
    overrides(contents) {
      var overrides = this._overrides;
      for (var rule in overrides) {
        if (overrides.hasOwnProperty(rule)) {
          contents.css(rule, overrides[rule].value, overrides[rule].priority);
        }
      }
    }
    fontSize(size2) {
      this.override("font-size", size2);
    }
    font(f) {
      this.override("font-family", f, true);
    }
    destroy() {
      this.rendition = void 0;
      this._themes = void 0;
      this._overrides = void 0;
      this._current = void 0;
      this._injected = void 0;
    }
  };
  var themes_default = Themes;

  // ../library_management/node_modules/epubjs/src/contents.js
  var import_event_emitter3 = __toESM(require_event_emitter());

  // ../library_management/node_modules/epubjs/src/mapping.js
  var Mapping = class {
    constructor(layout, direction, axis, dev = false) {
      this.layout = layout;
      this.horizontal = axis === "horizontal" ? true : false;
      this.direction = direction || "ltr";
      this._dev = dev;
    }
    section(view) {
      var ranges = this.findRanges(view);
      var map2 = this.rangeListToCfiList(view.section.cfiBase, ranges);
      return map2;
    }
    page(contents, cfiBase, start, end) {
      var root = contents && contents.document ? contents.document.body : false;
      var result;
      if (!root) {
        return;
      }
      result = this.rangePairToCfiPair(cfiBase, {
        start: this.findStart(root, start, end),
        end: this.findEnd(root, start, end)
      });
      if (this._dev === true) {
        let doc2 = contents.document;
        let startRange = new epubcfi_default(result.start).toRange(doc2);
        let endRange = new epubcfi_default(result.end).toRange(doc2);
        let selection = doc2.defaultView.getSelection();
        let r = doc2.createRange();
        selection.removeAllRanges();
        r.setStart(startRange.startContainer, startRange.startOffset);
        r.setEnd(endRange.endContainer, endRange.endOffset);
        selection.addRange(r);
      }
      return result;
    }
    walk(root, func) {
      if (root && root.nodeType === Node.TEXT_NODE) {
        return;
      }
      var filter = {
        acceptNode: function(node2) {
          if (node2.data.trim().length > 0) {
            return NodeFilter.FILTER_ACCEPT;
          } else {
            return NodeFilter.FILTER_REJECT;
          }
        }
      };
      var safeFilter = filter.acceptNode;
      safeFilter.acceptNode = filter.acceptNode;
      var treeWalker2 = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, safeFilter, false);
      var node;
      var result;
      while (node = treeWalker2.nextNode()) {
        result = func(node);
        if (result)
          break;
      }
      return result;
    }
    findRanges(view) {
      var columns = [];
      var scrollWidth = view.contents.scrollWidth();
      var spreads = Math.ceil(scrollWidth / this.layout.spreadWidth);
      var count = spreads * this.layout.divisor;
      var columnWidth = this.layout.columnWidth;
      var gap = this.layout.gap;
      var start, end;
      for (var i = 0; i < count.pages; i++) {
        start = (columnWidth + gap) * i;
        end = columnWidth * (i + 1) + gap * i;
        columns.push({
          start: this.findStart(view.document.body, start, end),
          end: this.findEnd(view.document.body, start, end)
        });
      }
      return columns;
    }
    findStart(root, start, end) {
      var stack2 = [root];
      var $el;
      var found;
      var $prev = root;
      while (stack2.length) {
        $el = stack2.shift();
        found = this.walk($el, (node) => {
          var left, right, top, bottom;
          var elPos;
          var elRange;
          elPos = nodeBounds(node);
          if (this.horizontal && this.direction === "ltr") {
            left = this.horizontal ? elPos.left : elPos.top;
            right = this.horizontal ? elPos.right : elPos.bottom;
            if (left >= start && left <= end) {
              return node;
            } else if (right > start) {
              return node;
            } else {
              $prev = node;
              stack2.push(node);
            }
          } else if (this.horizontal && this.direction === "rtl") {
            left = elPos.left;
            right = elPos.right;
            if (right <= end && right >= start) {
              return node;
            } else if (left < end) {
              return node;
            } else {
              $prev = node;
              stack2.push(node);
            }
          } else {
            top = elPos.top;
            bottom = elPos.bottom;
            if (top >= start && top <= end) {
              return node;
            } else if (bottom > start) {
              return node;
            } else {
              $prev = node;
              stack2.push(node);
            }
          }
        });
        if (found) {
          return this.findTextStartRange(found, start, end);
        }
      }
      return this.findTextStartRange($prev, start, end);
    }
    findEnd(root, start, end) {
      var stack2 = [root];
      var $el;
      var $prev = root;
      var found;
      while (stack2.length) {
        $el = stack2.shift();
        found = this.walk($el, (node) => {
          var left, right, top, bottom;
          var elPos;
          var elRange;
          elPos = nodeBounds(node);
          if (this.horizontal && this.direction === "ltr") {
            left = Math.round(elPos.left);
            right = Math.round(elPos.right);
            if (left > end && $prev) {
              return $prev;
            } else if (right > end) {
              return node;
            } else {
              $prev = node;
              stack2.push(node);
            }
          } else if (this.horizontal && this.direction === "rtl") {
            left = Math.round(this.horizontal ? elPos.left : elPos.top);
            right = Math.round(this.horizontal ? elPos.right : elPos.bottom);
            if (right < start && $prev) {
              return $prev;
            } else if (left < start) {
              return node;
            } else {
              $prev = node;
              stack2.push(node);
            }
          } else {
            top = Math.round(elPos.top);
            bottom = Math.round(elPos.bottom);
            if (top > end && $prev) {
              return $prev;
            } else if (bottom > end) {
              return node;
            } else {
              $prev = node;
              stack2.push(node);
            }
          }
        });
        if (found) {
          return this.findTextEndRange(found, start, end);
        }
      }
      return this.findTextEndRange($prev, start, end);
    }
    findTextStartRange(node, start, end) {
      var ranges = this.splitTextNodeIntoRanges(node);
      var range;
      var pos;
      var left, top, right;
      for (var i = 0; i < ranges.length; i++) {
        range = ranges[i];
        pos = range.getBoundingClientRect();
        if (this.horizontal && this.direction === "ltr") {
          left = pos.left;
          if (left >= start) {
            return range;
          }
        } else if (this.horizontal && this.direction === "rtl") {
          right = pos.right;
          if (right <= end) {
            return range;
          }
        } else {
          top = pos.top;
          if (top >= start) {
            return range;
          }
        }
      }
      return ranges[0];
    }
    findTextEndRange(node, start, end) {
      var ranges = this.splitTextNodeIntoRanges(node);
      var prev;
      var range;
      var pos;
      var left, right, top, bottom;
      for (var i = 0; i < ranges.length; i++) {
        range = ranges[i];
        pos = range.getBoundingClientRect();
        if (this.horizontal && this.direction === "ltr") {
          left = pos.left;
          right = pos.right;
          if (left > end && prev) {
            return prev;
          } else if (right > end) {
            return range;
          }
        } else if (this.horizontal && this.direction === "rtl") {
          left = pos.left;
          right = pos.right;
          if (right < start && prev) {
            return prev;
          } else if (left < start) {
            return range;
          }
        } else {
          top = pos.top;
          bottom = pos.bottom;
          if (top > end && prev) {
            return prev;
          } else if (bottom > end) {
            return range;
          }
        }
        prev = range;
      }
      return ranges[ranges.length - 1];
    }
    splitTextNodeIntoRanges(node, _splitter) {
      var ranges = [];
      var textContent = node.textContent || "";
      var text = textContent.trim();
      var range;
      var doc2 = node.ownerDocument;
      var splitter = _splitter || " ";
      var pos = text.indexOf(splitter);
      if (pos === -1 || node.nodeType != Node.TEXT_NODE) {
        range = doc2.createRange();
        range.selectNodeContents(node);
        return [range];
      }
      range = doc2.createRange();
      range.setStart(node, 0);
      range.setEnd(node, pos);
      ranges.push(range);
      range = false;
      while (pos != -1) {
        pos = text.indexOf(splitter, pos + 1);
        if (pos > 0) {
          if (range) {
            range.setEnd(node, pos);
            ranges.push(range);
          }
          range = doc2.createRange();
          range.setStart(node, pos + 1);
        }
      }
      if (range) {
        range.setEnd(node, text.length);
        ranges.push(range);
      }
      return ranges;
    }
    rangePairToCfiPair(cfiBase, rangePair) {
      var startRange = rangePair.start;
      var endRange = rangePair.end;
      startRange.collapse(true);
      endRange.collapse(false);
      let startCfi = new epubcfi_default(startRange, cfiBase).toString();
      let endCfi = new epubcfi_default(endRange, cfiBase).toString();
      return {
        start: startCfi,
        end: endCfi
      };
    }
    rangeListToCfiList(cfiBase, columns) {
      var map2 = [];
      var cifPair;
      for (var i = 0; i < columns.length; i++) {
        cifPair = this.rangePairToCfiPair(cfiBase, columns[i]);
        map2.push(cifPair);
      }
      return map2;
    }
    axis(axis) {
      if (axis) {
        this.horizontal = axis === "horizontal" ? true : false;
      }
      return this.horizontal;
    }
  };
  var mapping_default = Mapping;

  // ../library_management/node_modules/epubjs/src/contents.js
  var hasNavigator = typeof navigator !== "undefined";
  var isChrome = hasNavigator && /Chrome/.test(navigator.userAgent);
  var isWebkit = hasNavigator && !isChrome && /AppleWebKit/.test(navigator.userAgent);
  var ELEMENT_NODE3 = 1;
  var Contents = class {
    constructor(doc2, content, cfiBase, sectionIndex) {
      this.epubcfi = new epubcfi_default();
      this.document = doc2;
      this.documentElement = this.document.documentElement;
      this.content = content || this.document.body;
      this.window = this.document.defaultView;
      this._size = {
        width: 0,
        height: 0
      };
      this.sectionIndex = sectionIndex || 0;
      this.cfiBase = cfiBase || "";
      this.epubReadingSystem("epub.js", EPUBJS_VERSION);
      this.called = 0;
      this.active = true;
      this.listeners();
    }
    static get listenedEvents() {
      return DOM_EVENTS;
    }
    width(w) {
      var frame = this.content;
      if (w && isNumber(w)) {
        w = w + "px";
      }
      if (w) {
        frame.style.width = w;
      }
      return parseInt(this.window.getComputedStyle(frame)["width"]);
    }
    height(h2) {
      var frame = this.content;
      if (h2 && isNumber(h2)) {
        h2 = h2 + "px";
      }
      if (h2) {
        frame.style.height = h2;
      }
      return parseInt(this.window.getComputedStyle(frame)["height"]);
    }
    contentWidth(w) {
      var content = this.content || this.document.body;
      if (w && isNumber(w)) {
        w = w + "px";
      }
      if (w) {
        content.style.width = w;
      }
      return parseInt(this.window.getComputedStyle(content)["width"]);
    }
    contentHeight(h2) {
      var content = this.content || this.document.body;
      if (h2 && isNumber(h2)) {
        h2 = h2 + "px";
      }
      if (h2) {
        content.style.height = h2;
      }
      return parseInt(this.window.getComputedStyle(content)["height"]);
    }
    textWidth() {
      let rect;
      let width;
      let range = this.document.createRange();
      let content = this.content || this.document.body;
      let border = borders(content);
      range.selectNodeContents(content);
      rect = range.getBoundingClientRect();
      width = rect.width;
      if (border && border.width) {
        width += border.width;
      }
      return Math.round(width);
    }
    textHeight() {
      let rect;
      let height;
      let range = this.document.createRange();
      let content = this.content || this.document.body;
      range.selectNodeContents(content);
      rect = range.getBoundingClientRect();
      height = rect.bottom;
      return Math.round(height);
    }
    scrollWidth() {
      var width = this.documentElement.scrollWidth;
      return width;
    }
    scrollHeight() {
      var height = this.documentElement.scrollHeight;
      return height;
    }
    overflow(overflow) {
      if (overflow) {
        this.documentElement.style.overflow = overflow;
      }
      return this.window.getComputedStyle(this.documentElement)["overflow"];
    }
    overflowX(overflow) {
      if (overflow) {
        this.documentElement.style.overflowX = overflow;
      }
      return this.window.getComputedStyle(this.documentElement)["overflowX"];
    }
    overflowY(overflow) {
      if (overflow) {
        this.documentElement.style.overflowY = overflow;
      }
      return this.window.getComputedStyle(this.documentElement)["overflowY"];
    }
    css(property, value, priority) {
      var content = this.content || this.document.body;
      if (value) {
        content.style.setProperty(property, value, priority ? "important" : "");
      } else {
        content.style.removeProperty(property);
      }
      return this.window.getComputedStyle(content)[property];
    }
    viewport(options) {
      var _width, _height, _scale, _minimum, _maximum, _scalable;
      var $viewport = this.document.querySelector("meta[name='viewport']");
      var parsed = {
        "width": void 0,
        "height": void 0,
        "scale": void 0,
        "minimum": void 0,
        "maximum": void 0,
        "scalable": void 0
      };
      var newContent = [];
      var settings = {};
      if ($viewport && $viewport.hasAttribute("content")) {
        let content = $viewport.getAttribute("content");
        let _width2 = content.match(/width\s*=\s*([^,]*)/);
        let _height2 = content.match(/height\s*=\s*([^,]*)/);
        let _scale2 = content.match(/initial-scale\s*=\s*([^,]*)/);
        let _minimum2 = content.match(/minimum-scale\s*=\s*([^,]*)/);
        let _maximum2 = content.match(/maximum-scale\s*=\s*([^,]*)/);
        let _scalable2 = content.match(/user-scalable\s*=\s*([^,]*)/);
        if (_width2 && _width2.length && typeof _width2[1] !== "undefined") {
          parsed.width = _width2[1];
        }
        if (_height2 && _height2.length && typeof _height2[1] !== "undefined") {
          parsed.height = _height2[1];
        }
        if (_scale2 && _scale2.length && typeof _scale2[1] !== "undefined") {
          parsed.scale = _scale2[1];
        }
        if (_minimum2 && _minimum2.length && typeof _minimum2[1] !== "undefined") {
          parsed.minimum = _minimum2[1];
        }
        if (_maximum2 && _maximum2.length && typeof _maximum2[1] !== "undefined") {
          parsed.maximum = _maximum2[1];
        }
        if (_scalable2 && _scalable2.length && typeof _scalable2[1] !== "undefined") {
          parsed.scalable = _scalable2[1];
        }
      }
      settings = defaults(options || {}, parsed);
      if (options) {
        if (settings.width) {
          newContent.push("width=" + settings.width);
        }
        if (settings.height) {
          newContent.push("height=" + settings.height);
        }
        if (settings.scale) {
          newContent.push("initial-scale=" + settings.scale);
        }
        if (settings.scalable === "no") {
          newContent.push("minimum-scale=" + settings.scale);
          newContent.push("maximum-scale=" + settings.scale);
          newContent.push("user-scalable=" + settings.scalable);
        } else {
          if (settings.scalable) {
            newContent.push("user-scalable=" + settings.scalable);
          }
          if (settings.minimum) {
            newContent.push("minimum-scale=" + settings.minimum);
          }
          if (settings.maximum) {
            newContent.push("minimum-scale=" + settings.maximum);
          }
        }
        if (!$viewport) {
          $viewport = this.document.createElement("meta");
          $viewport.setAttribute("name", "viewport");
          this.document.querySelector("head").appendChild($viewport);
        }
        $viewport.setAttribute("content", newContent.join(", "));
        this.window.scrollTo(0, 0);
      }
      return settings;
    }
    expand() {
      this.emit(EVENTS.CONTENTS.EXPAND);
    }
    listeners() {
      this.imageLoadListeners();
      this.mediaQueryListeners();
      this.addEventListeners();
      this.addSelectionListeners();
      if (typeof ResizeObserver === "undefined") {
        this.resizeListeners();
        this.visibilityListeners();
      } else {
        this.resizeObservers();
      }
      this.linksHandler();
    }
    removeListeners() {
      this.removeEventListeners();
      this.removeSelectionListeners();
      if (this.observer) {
        this.observer.disconnect();
      }
      clearTimeout(this.expanding);
    }
    resizeCheck() {
      let width = this.textWidth();
      let height = this.textHeight();
      if (width != this._size.width || height != this._size.height) {
        this._size = {
          width,
          height
        };
        this.onResize && this.onResize(this._size);
        this.emit(EVENTS.CONTENTS.RESIZE, this._size);
      }
    }
    resizeListeners() {
      var width, height;
      clearTimeout(this.expanding);
      requestAnimationFrame(this.resizeCheck.bind(this));
      this.expanding = setTimeout(this.resizeListeners.bind(this), 350);
    }
    visibilityListeners() {
      document.addEventListener("visibilitychange", () => {
        if (document.visibilityState === "visible" && this.active === false) {
          this.active = true;
          this.resizeListeners();
        } else {
          this.active = false;
          clearTimeout(this.expanding);
        }
      });
    }
    transitionListeners() {
      let body = this.content;
      body.style["transitionProperty"] = "font, font-size, font-size-adjust, font-stretch, font-variation-settings, font-weight, width, height";
      body.style["transitionDuration"] = "0.001ms";
      body.style["transitionTimingFunction"] = "linear";
      body.style["transitionDelay"] = "0";
      this._resizeCheck = this.resizeCheck.bind(this);
      this.document.addEventListener("transitionend", this._resizeCheck);
    }
    mediaQueryListeners() {
      var sheets = this.document.styleSheets;
      var mediaChangeHandler = function(m) {
        if (m.matches && !this._expanding) {
          setTimeout(this.expand.bind(this), 1);
        }
      }.bind(this);
      for (var i = 0; i < sheets.length; i += 1) {
        var rules;
        try {
          rules = sheets[i].cssRules;
        } catch (e) {
          return;
        }
        if (!rules)
          return;
        for (var j = 0; j < rules.length; j += 1) {
          if (rules[j].media) {
            var mql = this.window.matchMedia(rules[j].media.mediaText);
            mql.addListener(mediaChangeHandler);
          }
        }
      }
    }
    resizeObservers() {
      this.observer = new ResizeObserver((e) => {
        requestAnimationFrame(this.resizeCheck.bind(this));
      });
      this.observer.observe(this.document.documentElement);
    }
    mutationObservers() {
      this.observer = new MutationObserver((mutations) => {
        this.resizeCheck();
      });
      let config = { attributes: true, childList: true, characterData: true, subtree: true };
      this.observer.observe(this.document, config);
    }
    imageLoadListeners() {
      var images = this.document.querySelectorAll("img");
      var img;
      for (var i = 0; i < images.length; i++) {
        img = images[i];
        if (typeof img.naturalWidth !== "undefined" && img.naturalWidth === 0) {
          img.onload = this.expand.bind(this);
        }
      }
    }
    fontLoadListeners() {
      if (!this.document || !this.document.fonts) {
        return;
      }
      this.document.fonts.ready.then(function() {
        this.resizeCheck();
      }.bind(this));
    }
    root() {
      if (!this.document)
        return null;
      return this.document.documentElement;
    }
    locationOf(target, ignoreClass) {
      var position;
      var targetPos = { "left": 0, "top": 0 };
      if (!this.document)
        return targetPos;
      if (this.epubcfi.isCfiString(target)) {
        let range = new epubcfi_default(target).toRange(this.document, ignoreClass);
        if (range) {
          try {
            if (!range.endContainer || range.startContainer == range.endContainer && range.startOffset == range.endOffset) {
              let pos = range.startContainer.textContent.indexOf(" ", range.startOffset);
              if (pos == -1) {
                pos = range.startContainer.textContent.length;
              }
              range.setEnd(range.startContainer, pos);
            }
          } catch (e) {
            console.error("setting end offset to start container length failed", e);
          }
          if (range.startContainer.nodeType === Node.ELEMENT_NODE) {
            position = range.startContainer.getBoundingClientRect();
            targetPos.left = position.left;
            targetPos.top = position.top;
          } else {
            if (isWebkit) {
              let container = range.startContainer;
              let newRange = new Range();
              try {
                if (container.nodeType === ELEMENT_NODE3) {
                  position = container.getBoundingClientRect();
                } else if (range.startOffset + 2 < container.length) {
                  newRange.setStart(container, range.startOffset);
                  newRange.setEnd(container, range.startOffset + 2);
                  position = newRange.getBoundingClientRect();
                } else if (range.startOffset - 2 > 0) {
                  newRange.setStart(container, range.startOffset - 2);
                  newRange.setEnd(container, range.startOffset);
                  position = newRange.getBoundingClientRect();
                } else {
                  position = container.parentNode.getBoundingClientRect();
                }
              } catch (e) {
                console.error(e, e.stack);
              }
            } else {
              position = range.getBoundingClientRect();
            }
          }
        }
      } else if (typeof target === "string" && target.indexOf("#") > -1) {
        let id = target.substring(target.indexOf("#") + 1);
        let el = this.document.getElementById(id);
        if (el) {
          if (isWebkit) {
            let newRange = new Range();
            newRange.selectNode(el);
            position = newRange.getBoundingClientRect();
          } else {
            position = el.getBoundingClientRect();
          }
        }
      }
      if (position) {
        targetPos.left = position.left;
        targetPos.top = position.top;
      }
      return targetPos;
    }
    addStylesheet(src) {
      return new Promise(function(resolve2, reject) {
        var $stylesheet;
        var ready = false;
        if (!this.document) {
          resolve2(false);
          return;
        }
        $stylesheet = this.document.querySelector("link[href='" + src + "']");
        if ($stylesheet) {
          resolve2(true);
          return;
        }
        $stylesheet = this.document.createElement("link");
        $stylesheet.type = "text/css";
        $stylesheet.rel = "stylesheet";
        $stylesheet.href = src;
        $stylesheet.onload = $stylesheet.onreadystatechange = function() {
          if (!ready && (!this.readyState || this.readyState == "complete")) {
            ready = true;
            setTimeout(() => {
              resolve2(true);
            }, 1);
          }
        };
        this.document.head.appendChild($stylesheet);
      }.bind(this));
    }
    _getStylesheetNode(key) {
      var styleEl;
      key = "epubjs-inserted-css-" + (key || "");
      if (!this.document)
        return false;
      styleEl = this.document.getElementById(key);
      if (!styleEl) {
        styleEl = this.document.createElement("style");
        styleEl.id = key;
        this.document.head.appendChild(styleEl);
      }
      return styleEl;
    }
    addStylesheetCss(serializedCss, key) {
      if (!this.document || !serializedCss)
        return false;
      var styleEl;
      styleEl = this._getStylesheetNode(key);
      styleEl.innerHTML = serializedCss;
      return true;
    }
    addStylesheetRules(rules, key) {
      var styleSheet;
      if (!this.document || !rules || rules.length === 0)
        return;
      styleSheet = this._getStylesheetNode(key).sheet;
      if (Object.prototype.toString.call(rules) === "[object Array]") {
        for (var i = 0, rl = rules.length; i < rl; i++) {
          var j = 1, rule = rules[i], selector = rules[i][0], propStr = "";
          if (Object.prototype.toString.call(rule[1][0]) === "[object Array]") {
            rule = rule[1];
            j = 0;
          }
          for (var pl = rule.length; j < pl; j++) {
            var prop = rule[j];
            propStr += prop[0] + ":" + prop[1] + (prop[2] ? " !important" : "") + ";\n";
          }
          styleSheet.insertRule(selector + "{" + propStr + "}", styleSheet.cssRules.length);
        }
      } else {
        const selectors = Object.keys(rules);
        selectors.forEach((selector2) => {
          const definition = rules[selector2];
          if (Array.isArray(definition)) {
            definition.forEach((item) => {
              const _rules = Object.keys(item);
              const result = _rules.map((rule2) => {
                return `${rule2}:${item[rule2]}`;
              }).join(";");
              styleSheet.insertRule(`${selector2}{${result}}`, styleSheet.cssRules.length);
            });
          } else {
            const _rules = Object.keys(definition);
            const result = _rules.map((rule2) => {
              return `${rule2}:${definition[rule2]}`;
            }).join(";");
            styleSheet.insertRule(`${selector2}{${result}}`, styleSheet.cssRules.length);
          }
        });
      }
    }
    addScript(src) {
      return new Promise(function(resolve2, reject) {
        var $script;
        var ready = false;
        if (!this.document) {
          resolve2(false);
          return;
        }
        $script = this.document.createElement("script");
        $script.type = "text/javascript";
        $script.async = true;
        $script.src = src;
        $script.onload = $script.onreadystatechange = function() {
          if (!ready && (!this.readyState || this.readyState == "complete")) {
            ready = true;
            setTimeout(function() {
              resolve2(true);
            }, 1);
          }
        };
        this.document.head.appendChild($script);
      }.bind(this));
    }
    addClass(className) {
      var content;
      if (!this.document)
        return;
      content = this.content || this.document.body;
      if (content) {
        content.classList.add(className);
      }
    }
    removeClass(className) {
      var content;
      if (!this.document)
        return;
      content = this.content || this.document.body;
      if (content) {
        content.classList.remove(className);
      }
    }
    addEventListeners() {
      if (!this.document) {
        return;
      }
      this._triggerEvent = this.triggerEvent.bind(this);
      DOM_EVENTS.forEach(function(eventName2) {
        this.document.addEventListener(eventName2, this._triggerEvent, { passive: true });
      }, this);
    }
    removeEventListeners() {
      if (!this.document) {
        return;
      }
      DOM_EVENTS.forEach(function(eventName2) {
        this.document.removeEventListener(eventName2, this._triggerEvent, { passive: true });
      }, this);
      this._triggerEvent = void 0;
    }
    triggerEvent(e) {
      this.emit(e.type, e);
    }
    addSelectionListeners() {
      if (!this.document) {
        return;
      }
      this._onSelectionChange = this.onSelectionChange.bind(this);
      this.document.addEventListener("selectionchange", this._onSelectionChange, { passive: true });
    }
    removeSelectionListeners() {
      if (!this.document) {
        return;
      }
      this.document.removeEventListener("selectionchange", this._onSelectionChange, { passive: true });
      this._onSelectionChange = void 0;
    }
    onSelectionChange(e) {
      if (this.selectionEndTimeout) {
        clearTimeout(this.selectionEndTimeout);
      }
      this.selectionEndTimeout = setTimeout(function() {
        var selection = this.window.getSelection();
        this.triggerSelectedEvent(selection);
      }.bind(this), 250);
    }
    triggerSelectedEvent(selection) {
      var range, cfirange;
      if (selection && selection.rangeCount > 0) {
        range = selection.getRangeAt(0);
        if (!range.collapsed) {
          cfirange = new epubcfi_default(range, this.cfiBase).toString();
          this.emit(EVENTS.CONTENTS.SELECTED, cfirange);
          this.emit(EVENTS.CONTENTS.SELECTED_RANGE, range);
        }
      }
    }
    range(_cfi, ignoreClass) {
      var cfi = new epubcfi_default(_cfi);
      return cfi.toRange(this.document, ignoreClass);
    }
    cfiFromRange(range, ignoreClass) {
      return new epubcfi_default(range, this.cfiBase, ignoreClass).toString();
    }
    cfiFromNode(node, ignoreClass) {
      return new epubcfi_default(node, this.cfiBase, ignoreClass).toString();
    }
    map(layout) {
      var map2 = new mapping_default(layout);
      return map2.section();
    }
    size(width, height) {
      var viewport = { scale: 1, scalable: "no" };
      this.layoutStyle("scrolling");
      if (width >= 0) {
        this.width(width);
        viewport.width = width;
        this.css("padding", "0 " + width / 12 + "px");
      }
      if (height >= 0) {
        this.height(height);
        viewport.height = height;
      }
      this.css("margin", "0");
      this.css("box-sizing", "border-box");
      this.viewport(viewport);
    }
    columns(width, height, columnWidth, gap, dir) {
      let COLUMN_AXIS = prefixed("column-axis");
      let COLUMN_GAP = prefixed("column-gap");
      let COLUMN_WIDTH = prefixed("column-width");
      let COLUMN_FILL = prefixed("column-fill");
      let writingMode = this.writingMode();
      let axis = writingMode.indexOf("vertical") === 0 ? "vertical" : "horizontal";
      this.layoutStyle("paginated");
      if (dir === "rtl" && axis === "horizontal") {
        this.direction(dir);
      }
      this.width(width);
      this.height(height);
      this.viewport({ width, height, scale: 1, scalable: "no" });
      this.css("overflow-y", "hidden");
      this.css("margin", "0", true);
      if (axis === "vertical") {
        this.css("padding-top", gap / 2 + "px", true);
        this.css("padding-bottom", gap / 2 + "px", true);
        this.css("padding-left", "20px");
        this.css("padding-right", "20px");
        this.css(COLUMN_AXIS, "vertical");
      } else {
        this.css("padding-top", "20px");
        this.css("padding-bottom", "20px");
        this.css("padding-left", gap / 2 + "px", true);
        this.css("padding-right", gap / 2 + "px", true);
        this.css(COLUMN_AXIS, "horizontal");
      }
      this.css("box-sizing", "border-box");
      this.css("max-width", "inherit");
      this.css(COLUMN_FILL, "auto");
      this.css(COLUMN_GAP, gap + "px");
      this.css(COLUMN_WIDTH, columnWidth + "px");
      this.css("-webkit-line-box-contain", "block glyphs replaced");
    }
    scaler(scale, offsetX, offsetY) {
      var scaleStr = "scale(" + scale + ")";
      var translateStr = "";
      this.css("transform-origin", "top left");
      if (offsetX >= 0 || offsetY >= 0) {
        translateStr = " translate(" + (offsetX || 0) + "px, " + (offsetY || 0) + "px )";
      }
      this.css("transform", scaleStr + translateStr);
    }
    fit(width, height, section) {
      var viewport = this.viewport();
      var viewportWidth = parseInt(viewport.width);
      var viewportHeight = parseInt(viewport.height);
      var widthScale = width / viewportWidth;
      var heightScale = height / viewportHeight;
      var scale = widthScale < heightScale ? widthScale : heightScale;
      this.layoutStyle("paginated");
      this.width(viewportWidth);
      this.height(viewportHeight);
      this.overflow("hidden");
      this.scaler(scale, 0, 0);
      this.css("background-size", viewportWidth * scale + "px " + viewportHeight * scale + "px");
      this.css("background-color", "transparent");
      if (section && section.properties.includes("page-spread-left")) {
        var marginLeft = width - viewportWidth * scale;
        this.css("margin-left", marginLeft + "px");
      }
    }
    direction(dir) {
      if (this.documentElement) {
        this.documentElement.style["direction"] = dir;
      }
    }
    mapPage(cfiBase, layout, start, end, dev) {
      var mapping = new mapping_default(layout, dev);
      return mapping.page(this, cfiBase, start, end);
    }
    linksHandler() {
      replaceLinks(this.content, (href) => {
        this.emit(EVENTS.CONTENTS.LINK_CLICKED, href);
      });
    }
    writingMode(mode) {
      let WRITING_MODE = prefixed("writing-mode");
      if (mode && this.documentElement) {
        this.documentElement.style[WRITING_MODE] = mode;
      }
      return this.window.getComputedStyle(this.documentElement)[WRITING_MODE] || "";
    }
    layoutStyle(style) {
      if (style) {
        this._layoutStyle = style;
        navigator.epubReadingSystem.layoutStyle = this._layoutStyle;
      }
      return this._layoutStyle || "paginated";
    }
    epubReadingSystem(name, version3) {
      navigator.epubReadingSystem = {
        name,
        version: version3,
        layoutStyle: this.layoutStyle(),
        hasFeature: function(feature) {
          switch (feature) {
            case "dom-manipulation":
              return true;
            case "layout-changes":
              return true;
            case "touch-events":
              return true;
            case "mouse-events":
              return true;
            case "keyboard-events":
              return true;
            case "spine-scripting":
              return false;
            default:
              return false;
          }
        }
      };
      return navigator.epubReadingSystem;
    }
    destroy() {
      this.removeListeners();
    }
  };
  (0, import_event_emitter3.default)(Contents.prototype);
  var contents_default = Contents;

  // ../library_management/node_modules/epubjs/src/annotations.js
  var import_event_emitter4 = __toESM(require_event_emitter());
  var Annotations = class {
    constructor(rendition) {
      this.rendition = rendition;
      this.highlights = [];
      this.underlines = [];
      this.marks = [];
      this._annotations = {};
      this._annotationsBySectionIndex = {};
      this.rendition.hooks.render.register(this.inject.bind(this));
      this.rendition.hooks.unloaded.register(this.clear.bind(this));
    }
    add(type2, cfiRange, data, cb, className, styles) {
      let hash = encodeURI(cfiRange + type2);
      let cfi = new epubcfi_default(cfiRange);
      let sectionIndex = cfi.spinePos;
      let annotation = new Annotation({
        type: type2,
        cfiRange,
        data,
        sectionIndex,
        cb,
        className,
        styles
      });
      this._annotations[hash] = annotation;
      if (sectionIndex in this._annotationsBySectionIndex) {
        this._annotationsBySectionIndex[sectionIndex].push(hash);
      } else {
        this._annotationsBySectionIndex[sectionIndex] = [hash];
      }
      let views = this.rendition.views();
      views.forEach((view) => {
        if (annotation.sectionIndex === view.index) {
          annotation.attach(view);
        }
      });
      return annotation;
    }
    remove(cfiRange, type2) {
      let hash = encodeURI(cfiRange + type2);
      if (hash in this._annotations) {
        let annotation = this._annotations[hash];
        if (type2 && annotation.type !== type2) {
          return;
        }
        let views = this.rendition.views();
        views.forEach((view) => {
          this._removeFromAnnotationBySectionIndex(annotation.sectionIndex, hash);
          if (annotation.sectionIndex === view.index) {
            annotation.detach(view);
          }
        });
        delete this._annotations[hash];
      }
    }
    _removeFromAnnotationBySectionIndex(sectionIndex, hash) {
      this._annotationsBySectionIndex[sectionIndex] = this._annotationsAt(sectionIndex).filter((h2) => h2 !== hash);
    }
    _annotationsAt(index) {
      return this._annotationsBySectionIndex[index];
    }
    highlight(cfiRange, data, cb, className, styles) {
      return this.add("highlight", cfiRange, data, cb, className, styles);
    }
    underline(cfiRange, data, cb, className, styles) {
      return this.add("underline", cfiRange, data, cb, className, styles);
    }
    mark(cfiRange, data, cb) {
      return this.add("mark", cfiRange, data, cb);
    }
    each() {
      return this._annotations.forEach.apply(this._annotations, arguments);
    }
    inject(view) {
      let sectionIndex = view.index;
      if (sectionIndex in this._annotationsBySectionIndex) {
        let annotations = this._annotationsBySectionIndex[sectionIndex];
        annotations.forEach((hash) => {
          let annotation = this._annotations[hash];
          annotation.attach(view);
        });
      }
    }
    clear(view) {
      let sectionIndex = view.index;
      if (sectionIndex in this._annotationsBySectionIndex) {
        let annotations = this._annotationsBySectionIndex[sectionIndex];
        annotations.forEach((hash) => {
          let annotation = this._annotations[hash];
          annotation.detach(view);
        });
      }
    }
    show() {
    }
    hide() {
    }
  };
  var Annotation = class {
    constructor({
      type: type2,
      cfiRange,
      data,
      sectionIndex,
      cb,
      className,
      styles
    }) {
      this.type = type2;
      this.cfiRange = cfiRange;
      this.data = data;
      this.sectionIndex = sectionIndex;
      this.mark = void 0;
      this.cb = cb;
      this.className = className;
      this.styles = styles;
    }
    update(data) {
      this.data = data;
    }
    attach(view) {
      let { cfiRange, data, type: type2, mark, cb, className, styles } = this;
      let result;
      if (type2 === "highlight") {
        result = view.highlight(cfiRange, data, cb, className, styles);
      } else if (type2 === "underline") {
        result = view.underline(cfiRange, data, cb, className, styles);
      } else if (type2 === "mark") {
        result = view.mark(cfiRange, data, cb);
      }
      this.mark = result;
      this.emit(EVENTS.ANNOTATION.ATTACH, result);
      return result;
    }
    detach(view) {
      let { cfiRange, type: type2 } = this;
      let result;
      if (view) {
        if (type2 === "highlight") {
          result = view.unhighlight(cfiRange);
        } else if (type2 === "underline") {
          result = view.ununderline(cfiRange);
        } else if (type2 === "mark") {
          result = view.unmark(cfiRange);
        }
      }
      this.mark = void 0;
      this.emit(EVENTS.ANNOTATION.DETACH, result);
      return result;
    }
    text() {
    }
  };
  (0, import_event_emitter4.default)(Annotation.prototype);
  var annotations_default = Annotations;

  // ../library_management/node_modules/epubjs/src/managers/views/iframe.js
  var import_event_emitter5 = __toESM(require_event_emitter());
  var import_marks_pane = __toESM(require_marks());
  var IframeView = class {
    constructor(section, options) {
      this.settings = extend2({
        ignoreClass: "",
        axis: void 0,
        direction: void 0,
        width: 0,
        height: 0,
        layout: void 0,
        globalLayoutProperties: {},
        method: void 0,
        forceRight: false,
        allowScriptedContent: false,
        allowPopups: false
      }, options || {});
      this.id = "epubjs-view-" + uuid();
      this.section = section;
      this.index = section.index;
      this.element = this.container(this.settings.axis);
      this.added = false;
      this.displayed = false;
      this.rendered = false;
      this.fixedWidth = 0;
      this.fixedHeight = 0;
      this.epubcfi = new epubcfi_default();
      this.layout = this.settings.layout;
      this.pane = void 0;
      this.highlights = {};
      this.underlines = {};
      this.marks = {};
    }
    container(axis) {
      var element = document.createElement("div");
      element.classList.add("epub-view");
      element.style.height = "0px";
      element.style.width = "0px";
      element.style.overflow = "hidden";
      element.style.position = "relative";
      element.style.display = "block";
      if (axis && axis == "horizontal") {
        element.style.flex = "none";
      } else {
        element.style.flex = "initial";
      }
      return element;
    }
    create() {
      if (this.iframe) {
        return this.iframe;
      }
      if (!this.element) {
        this.element = this.createContainer();
      }
      this.iframe = document.createElement("iframe");
      this.iframe.id = this.id;
      this.iframe.scrolling = "no";
      this.iframe.style.overflow = "hidden";
      this.iframe.seamless = "seamless";
      this.iframe.style.border = "none";
      this.iframe.sandbox = "allow-same-origin";
      if (this.settings.allowScriptedContent) {
        this.iframe.sandbox += " allow-scripts";
      }
      if (this.settings.allowPopups) {
        this.iframe.sandbox += " allow-popups";
      }
      this.iframe.setAttribute("enable-annotation", "true");
      this.resizing = true;
      this.element.style.visibility = "hidden";
      this.iframe.style.visibility = "hidden";
      this.iframe.style.width = "0";
      this.iframe.style.height = "0";
      this._width = 0;
      this._height = 0;
      this.element.setAttribute("ref", this.index);
      this.added = true;
      this.elementBounds = bounds(this.element);
      if ("srcdoc" in this.iframe) {
        this.supportsSrcdoc = true;
      } else {
        this.supportsSrcdoc = false;
      }
      if (!this.settings.method) {
        this.settings.method = this.supportsSrcdoc ? "srcdoc" : "write";
      }
      return this.iframe;
    }
    render(request2, show) {
      this.create();
      this.size();
      if (!this.sectionRender) {
        this.sectionRender = this.section.render(request2);
      }
      return this.sectionRender.then(function(contents) {
        return this.load(contents);
      }.bind(this)).then(function() {
        let writingMode = this.contents.writingMode();
        let axis;
        if (this.settings.flow === "scrolled") {
          axis = writingMode.indexOf("vertical") === 0 ? "horizontal" : "vertical";
        } else {
          axis = writingMode.indexOf("vertical") === 0 ? "vertical" : "horizontal";
        }
        if (writingMode.indexOf("vertical") === 0 && this.settings.flow === "paginated") {
          this.layout.delta = this.layout.height;
        }
        this.setAxis(axis);
        this.emit(EVENTS.VIEWS.AXIS, axis);
        this.setWritingMode(writingMode);
        this.emit(EVENTS.VIEWS.WRITING_MODE, writingMode);
        this.layout.format(this.contents, this.section, this.axis);
        this.addListeners();
        return new Promise((resolve2, reject) => {
          this.expand();
          if (this.settings.forceRight) {
            this.element.style.marginLeft = this.width() + "px";
          }
          resolve2();
        });
      }.bind(this), function(e) {
        this.emit(EVENTS.VIEWS.LOAD_ERROR, e);
        return new Promise((resolve2, reject) => {
          reject(e);
        });
      }.bind(this)).then(function() {
        this.emit(EVENTS.VIEWS.RENDERED, this.section);
      }.bind(this));
    }
    reset() {
      if (this.iframe) {
        this.iframe.style.width = "0";
        this.iframe.style.height = "0";
        this._width = 0;
        this._height = 0;
        this._textWidth = void 0;
        this._contentWidth = void 0;
        this._textHeight = void 0;
        this._contentHeight = void 0;
      }
      this._needsReframe = true;
    }
    size(_width, _height) {
      var width = _width || this.settings.width;
      var height = _height || this.settings.height;
      if (this.layout.name === "pre-paginated") {
        this.lock("both", width, height);
      } else if (this.settings.axis === "horizontal") {
        this.lock("height", width, height);
      } else {
        this.lock("width", width, height);
      }
      this.settings.width = width;
      this.settings.height = height;
    }
    lock(what, width, height) {
      var elBorders = borders(this.element);
      var iframeBorders;
      if (this.iframe) {
        iframeBorders = borders(this.iframe);
      } else {
        iframeBorders = { width: 0, height: 0 };
      }
      if (what == "width" && isNumber(width)) {
        this.lockedWidth = width - elBorders.width - iframeBorders.width;
      }
      if (what == "height" && isNumber(height)) {
        this.lockedHeight = height - elBorders.height - iframeBorders.height;
      }
      if (what === "both" && isNumber(width) && isNumber(height)) {
        this.lockedWidth = width - elBorders.width - iframeBorders.width;
        this.lockedHeight = height - elBorders.height - iframeBorders.height;
      }
      if (this.displayed && this.iframe) {
        this.expand();
      }
    }
    expand(force) {
      var width = this.lockedWidth;
      var height = this.lockedHeight;
      var columns;
      var textWidth, textHeight;
      if (!this.iframe || this._expanding)
        return;
      this._expanding = true;
      if (this.layout.name === "pre-paginated") {
        width = this.layout.columnWidth;
        height = this.layout.height;
      } else if (this.settings.axis === "horizontal") {
        width = this.contents.textWidth();
        if (width % this.layout.pageWidth > 0) {
          width = Math.ceil(width / this.layout.pageWidth) * this.layout.pageWidth;
        }
        if (this.settings.forceEvenPages) {
          columns = width / this.layout.pageWidth;
          if (this.layout.divisor > 1 && this.layout.name === "reflowable" && columns % 2 > 0) {
            width += this.layout.pageWidth;
          }
        }
      } else if (this.settings.axis === "vertical") {
        height = this.contents.textHeight();
        if (this.settings.flow === "paginated" && height % this.layout.height > 0) {
          height = Math.ceil(height / this.layout.height) * this.layout.height;
        }
      }
      if (this._needsReframe || width != this._width || height != this._height) {
        this.reframe(width, height);
      }
      this._expanding = false;
    }
    reframe(width, height) {
      var size2;
      if (isNumber(width)) {
        this.element.style.width = width + "px";
        this.iframe.style.width = width + "px";
        this._width = width;
      }
      if (isNumber(height)) {
        this.element.style.height = height + "px";
        this.iframe.style.height = height + "px";
        this._height = height;
      }
      let widthDelta = this.prevBounds ? width - this.prevBounds.width : width;
      let heightDelta = this.prevBounds ? height - this.prevBounds.height : height;
      size2 = {
        width,
        height,
        widthDelta,
        heightDelta
      };
      this.pane && this.pane.render();
      requestAnimationFrame(() => {
        let mark;
        for (let m in this.marks) {
          if (this.marks.hasOwnProperty(m)) {
            mark = this.marks[m];
            this.placeMark(mark.element, mark.range);
          }
        }
      });
      this.onResize(this, size2);
      this.emit(EVENTS.VIEWS.RESIZED, size2);
      this.prevBounds = size2;
      this.elementBounds = bounds(this.element);
    }
    load(contents) {
      var loading = new defer();
      var loaded = loading.promise;
      if (!this.iframe) {
        loading.reject(new Error("No Iframe Available"));
        return loaded;
      }
      this.iframe.onload = function(event) {
        this.onLoad(event, loading);
      }.bind(this);
      if (this.settings.method === "blobUrl") {
        this.blobUrl = createBlobUrl(contents, "application/xhtml+xml");
        this.iframe.src = this.blobUrl;
        this.element.appendChild(this.iframe);
      } else if (this.settings.method === "srcdoc") {
        this.iframe.srcdoc = contents;
        this.element.appendChild(this.iframe);
      } else {
        this.element.appendChild(this.iframe);
        this.document = this.iframe.contentDocument;
        if (!this.document) {
          loading.reject(new Error("No Document Available"));
          return loaded;
        }
        this.iframe.contentDocument.open();
        if (window.MSApp && MSApp.execUnsafeLocalFunction) {
          var outerThis = this;
          MSApp.execUnsafeLocalFunction(function() {
            outerThis.iframe.contentDocument.write(contents);
          });
        } else {
          this.iframe.contentDocument.write(contents);
        }
        this.iframe.contentDocument.close();
      }
      return loaded;
    }
    onLoad(event, promise) {
      this.window = this.iframe.contentWindow;
      this.document = this.iframe.contentDocument;
      this.contents = new contents_default(this.document, this.document.body, this.section.cfiBase, this.section.index);
      this.rendering = false;
      var link = this.document.querySelector("link[rel='canonical']");
      if (link) {
        link.setAttribute("href", this.section.canonical);
      } else {
        link = this.document.createElement("link");
        link.setAttribute("rel", "canonical");
        link.setAttribute("href", this.section.canonical);
        this.document.querySelector("head").appendChild(link);
      }
      this.contents.on(EVENTS.CONTENTS.EXPAND, () => {
        if (this.displayed && this.iframe) {
          this.expand();
          if (this.contents) {
            this.layout.format(this.contents);
          }
        }
      });
      this.contents.on(EVENTS.CONTENTS.RESIZE, (e) => {
        if (this.displayed && this.iframe) {
          this.expand();
          if (this.contents) {
            this.layout.format(this.contents);
          }
        }
      });
      promise.resolve(this.contents);
    }
    setLayout(layout) {
      this.layout = layout;
      if (this.contents) {
        this.layout.format(this.contents);
        this.expand();
      }
    }
    setAxis(axis) {
      this.settings.axis = axis;
      if (axis == "horizontal") {
        this.element.style.flex = "none";
      } else {
        this.element.style.flex = "initial";
      }
      this.size();
    }
    setWritingMode(mode) {
      this.writingMode = mode;
    }
    addListeners() {
    }
    removeListeners(layoutFunc) {
    }
    display(request2) {
      var displayed = new defer();
      if (!this.displayed) {
        this.render(request2).then(function() {
          this.emit(EVENTS.VIEWS.DISPLAYED, this);
          this.onDisplayed(this);
          this.displayed = true;
          displayed.resolve(this);
        }.bind(this), function(err) {
          displayed.reject(err, this);
        });
      } else {
        displayed.resolve(this);
      }
      return displayed.promise;
    }
    show() {
      this.element.style.visibility = "visible";
      if (this.iframe) {
        this.iframe.style.visibility = "visible";
        this.iframe.style.transform = "translateZ(0)";
        this.iframe.offsetWidth;
        this.iframe.style.transform = null;
      }
      this.emit(EVENTS.VIEWS.SHOWN, this);
    }
    hide() {
      this.element.style.visibility = "hidden";
      this.iframe.style.visibility = "hidden";
      this.stopExpanding = true;
      this.emit(EVENTS.VIEWS.HIDDEN, this);
    }
    offset() {
      return {
        top: this.element.offsetTop,
        left: this.element.offsetLeft
      };
    }
    width() {
      return this._width;
    }
    height() {
      return this._height;
    }
    position() {
      return this.element.getBoundingClientRect();
    }
    locationOf(target) {
      var parentPos = this.iframe.getBoundingClientRect();
      var targetPos = this.contents.locationOf(target, this.settings.ignoreClass);
      return {
        "left": targetPos.left,
        "top": targetPos.top
      };
    }
    onDisplayed(view) {
    }
    onResize(view, e) {
    }
    bounds(force) {
      if (force || !this.elementBounds) {
        this.elementBounds = bounds(this.element);
      }
      return this.elementBounds;
    }
    highlight(cfiRange, data = {}, cb, className = "epubjs-hl", styles = {}) {
      if (!this.contents) {
        return;
      }
      const attributes = Object.assign({ "fill": "yellow", "fill-opacity": "0.3", "mix-blend-mode": "multiply" }, styles);
      let range = this.contents.range(cfiRange);
      let emitter = () => {
        this.emit(EVENTS.VIEWS.MARK_CLICKED, cfiRange, data);
      };
      data["epubcfi"] = cfiRange;
      if (!this.pane) {
        this.pane = new import_marks_pane.Pane(this.iframe, this.element);
      }
      let m = new import_marks_pane.Highlight(range, className, data, attributes);
      let h2 = this.pane.addMark(m);
      this.highlights[cfiRange] = { "mark": h2, "element": h2.element, "listeners": [emitter, cb] };
      h2.element.setAttribute("ref", className);
      h2.element.addEventListener("click", emitter);
      h2.element.addEventListener("touchstart", emitter);
      if (cb) {
        h2.element.addEventListener("click", cb);
        h2.element.addEventListener("touchstart", cb);
      }
      return h2;
    }
    underline(cfiRange, data = {}, cb, className = "epubjs-ul", styles = {}) {
      if (!this.contents) {
        return;
      }
      const attributes = Object.assign({ "stroke": "black", "stroke-opacity": "0.3", "mix-blend-mode": "multiply" }, styles);
      let range = this.contents.range(cfiRange);
      let emitter = () => {
        this.emit(EVENTS.VIEWS.MARK_CLICKED, cfiRange, data);
      };
      data["epubcfi"] = cfiRange;
      if (!this.pane) {
        this.pane = new import_marks_pane.Pane(this.iframe, this.element);
      }
      let m = new import_marks_pane.Underline(range, className, data, attributes);
      let h2 = this.pane.addMark(m);
      this.underlines[cfiRange] = { "mark": h2, "element": h2.element, "listeners": [emitter, cb] };
      h2.element.setAttribute("ref", className);
      h2.element.addEventListener("click", emitter);
      h2.element.addEventListener("touchstart", emitter);
      if (cb) {
        h2.element.addEventListener("click", cb);
        h2.element.addEventListener("touchstart", cb);
      }
      return h2;
    }
    mark(cfiRange, data = {}, cb) {
      if (!this.contents) {
        return;
      }
      if (cfiRange in this.marks) {
        let item = this.marks[cfiRange];
        return item;
      }
      let range = this.contents.range(cfiRange);
      if (!range) {
        return;
      }
      let container = range.commonAncestorContainer;
      let parent2 = container.nodeType === 1 ? container : container.parentNode;
      let emitter = (e) => {
        this.emit(EVENTS.VIEWS.MARK_CLICKED, cfiRange, data);
      };
      if (range.collapsed && container.nodeType === 1) {
        range = new Range();
        range.selectNodeContents(container);
      } else if (range.collapsed) {
        range = new Range();
        range.selectNodeContents(parent2);
      }
      let mark = this.document.createElement("a");
      mark.setAttribute("ref", "epubjs-mk");
      mark.style.position = "absolute";
      mark.dataset["epubcfi"] = cfiRange;
      if (data) {
        Object.keys(data).forEach((key) => {
          mark.dataset[key] = data[key];
        });
      }
      if (cb) {
        mark.addEventListener("click", cb);
        mark.addEventListener("touchstart", cb);
      }
      mark.addEventListener("click", emitter);
      mark.addEventListener("touchstart", emitter);
      this.placeMark(mark, range);
      this.element.appendChild(mark);
      this.marks[cfiRange] = { "element": mark, "range": range, "listeners": [emitter, cb] };
      return parent2;
    }
    placeMark(element, range) {
      let top, right, left;
      if (this.layout.name === "pre-paginated" || this.settings.axis !== "horizontal") {
        let pos = range.getBoundingClientRect();
        top = pos.top;
        right = pos.right;
      } else {
        let rects = range.getClientRects();
        let rect;
        for (var i = 0; i != rects.length; i++) {
          rect = rects[i];
          if (!left || rect.left < left) {
            left = rect.left;
            right = Math.ceil(left / this.layout.props.pageWidth) * this.layout.props.pageWidth - this.layout.gap / 2;
            top = rect.top;
          }
        }
      }
      element.style.top = `${top}px`;
      element.style.left = `${right}px`;
    }
    unhighlight(cfiRange) {
      let item;
      if (cfiRange in this.highlights) {
        item = this.highlights[cfiRange];
        this.pane.removeMark(item.mark);
        item.listeners.forEach((l) => {
          if (l) {
            item.element.removeEventListener("click", l);
            item.element.removeEventListener("touchstart", l);
          }
          ;
        });
        delete this.highlights[cfiRange];
      }
    }
    ununderline(cfiRange) {
      let item;
      if (cfiRange in this.underlines) {
        item = this.underlines[cfiRange];
        this.pane.removeMark(item.mark);
        item.listeners.forEach((l) => {
          if (l) {
            item.element.removeEventListener("click", l);
            item.element.removeEventListener("touchstart", l);
          }
          ;
        });
        delete this.underlines[cfiRange];
      }
    }
    unmark(cfiRange) {
      let item;
      if (cfiRange in this.marks) {
        item = this.marks[cfiRange];
        this.element.removeChild(item.element);
        item.listeners.forEach((l) => {
          if (l) {
            item.element.removeEventListener("click", l);
            item.element.removeEventListener("touchstart", l);
          }
          ;
        });
        delete this.marks[cfiRange];
      }
    }
    destroy() {
      for (let cfiRange in this.highlights) {
        this.unhighlight(cfiRange);
      }
      for (let cfiRange in this.underlines) {
        this.ununderline(cfiRange);
      }
      for (let cfiRange in this.marks) {
        this.unmark(cfiRange);
      }
      if (this.blobUrl) {
        revokeBlobUrl(this.blobUrl);
      }
      if (this.displayed) {
        this.displayed = false;
        this.removeListeners();
        this.contents.destroy();
        this.stopExpanding = true;
        this.element.removeChild(this.iframe);
        if (this.pane) {
          this.pane.element.remove();
          this.pane = void 0;
        }
        this.iframe = void 0;
        this.contents = void 0;
        this._textWidth = null;
        this._textHeight = null;
        this._width = null;
        this._height = null;
      }
    }
  };
  (0, import_event_emitter5.default)(IframeView.prototype);
  var iframe_default = IframeView;

  // ../library_management/node_modules/epubjs/src/managers/default/index.js
  var import_event_emitter6 = __toESM(require_event_emitter());

  // ../library_management/node_modules/epubjs/src/utils/scrolltype.js
  function scrollType() {
    var type2 = "reverse";
    var definer = createDefiner();
    document.body.appendChild(definer);
    if (definer.scrollLeft > 0) {
      type2 = "default";
    } else {
      if (typeof Element !== "undefined" && Element.prototype.scrollIntoView) {
        definer.children[0].children[1].scrollIntoView();
        if (definer.scrollLeft < 0) {
          type2 = "negative";
        }
      } else {
        definer.scrollLeft = 1;
        if (definer.scrollLeft === 0) {
          type2 = "negative";
        }
      }
    }
    document.body.removeChild(definer);
    return type2;
  }
  function createDefiner() {
    var definer = document.createElement("div");
    definer.dir = "rtl";
    definer.style.position = "fixed";
    definer.style.width = "1px";
    definer.style.height = "1px";
    definer.style.top = "0px";
    definer.style.left = "0px";
    definer.style.overflow = "hidden";
    var innerDiv = document.createElement("div");
    innerDiv.style.width = "2px";
    var spanA = document.createElement("span");
    spanA.style.width = "1px";
    spanA.style.display = "inline-block";
    var spanB = document.createElement("span");
    spanB.style.width = "1px";
    spanB.style.display = "inline-block";
    innerDiv.appendChild(spanA);
    innerDiv.appendChild(spanB);
    definer.appendChild(innerDiv);
    return definer;
  }

  // ../library_management/node_modules/epubjs/src/managers/helpers/stage.js
  var import_throttle = __toESM(require_throttle());
  var Stage = class {
    constructor(_options) {
      this.settings = _options || {};
      this.id = "epubjs-container-" + uuid();
      this.container = this.create(this.settings);
      if (this.settings.hidden) {
        this.wrapper = this.wrap(this.container);
      }
    }
    create(options) {
      let height = options.height;
      let width = options.width;
      let overflow = options.overflow || false;
      let axis = options.axis || "vertical";
      let direction = options.direction;
      extend2(this.settings, options);
      if (options.height && isNumber(options.height)) {
        height = options.height + "px";
      }
      if (options.width && isNumber(options.width)) {
        width = options.width + "px";
      }
      let container = document.createElement("div");
      container.id = this.id;
      container.classList.add("epub-container");
      container.style.wordSpacing = "0";
      container.style.lineHeight = "0";
      container.style.verticalAlign = "top";
      container.style.position = "relative";
      if (axis === "horizontal") {
        container.style.display = "flex";
        container.style.flexDirection = "row";
        container.style.flexWrap = "nowrap";
      }
      if (width) {
        container.style.width = width;
      }
      if (height) {
        container.style.height = height;
      }
      if (overflow) {
        if (overflow === "scroll" && axis === "vertical") {
          container.style["overflow-y"] = overflow;
          container.style["overflow-x"] = "hidden";
        } else if (overflow === "scroll" && axis === "horizontal") {
          container.style["overflow-y"] = "hidden";
          container.style["overflow-x"] = overflow;
        } else {
          container.style["overflow"] = overflow;
        }
      }
      if (direction) {
        container.dir = direction;
        container.style["direction"] = direction;
      }
      if (direction && this.settings.fullsize) {
        document.body.style["direction"] = direction;
      }
      return container;
    }
    wrap(container) {
      var wrapper = document.createElement("div");
      wrapper.style.visibility = "hidden";
      wrapper.style.overflow = "hidden";
      wrapper.style.width = "0";
      wrapper.style.height = "0";
      wrapper.appendChild(container);
      return wrapper;
    }
    getElement(_element) {
      var element;
      if (isElement(_element)) {
        element = _element;
      } else if (typeof _element === "string") {
        element = document.getElementById(_element);
      }
      if (!element) {
        throw new Error("Not an Element");
      }
      return element;
    }
    attachTo(what) {
      var element = this.getElement(what);
      var base;
      if (!element) {
        return;
      }
      if (this.settings.hidden) {
        base = this.wrapper;
      } else {
        base = this.container;
      }
      element.appendChild(base);
      this.element = element;
      return element;
    }
    getContainer() {
      return this.container;
    }
    onResize(func) {
      if (!isNumber(this.settings.width) || !isNumber(this.settings.height)) {
        this.resizeFunc = (0, import_throttle.default)(func, 50);
        window.addEventListener("resize", this.resizeFunc, false);
      }
    }
    onOrientationChange(func) {
      this.orientationChangeFunc = func;
      window.addEventListener("orientationchange", this.orientationChangeFunc, false);
    }
    size(width, height) {
      var bounds2;
      let _width = width || this.settings.width;
      let _height = height || this.settings.height;
      if (width === null) {
        bounds2 = this.element.getBoundingClientRect();
        if (bounds2.width) {
          width = Math.floor(bounds2.width);
          this.container.style.width = width + "px";
        }
      } else {
        if (isNumber(width)) {
          this.container.style.width = width + "px";
        } else {
          this.container.style.width = width;
        }
      }
      if (height === null) {
        bounds2 = bounds2 || this.element.getBoundingClientRect();
        if (bounds2.height) {
          height = bounds2.height;
          this.container.style.height = height + "px";
        }
      } else {
        if (isNumber(height)) {
          this.container.style.height = height + "px";
        } else {
          this.container.style.height = height;
        }
      }
      if (!isNumber(width)) {
        width = this.container.clientWidth;
      }
      if (!isNumber(height)) {
        height = this.container.clientHeight;
      }
      this.containerStyles = window.getComputedStyle(this.container);
      this.containerPadding = {
        left: parseFloat(this.containerStyles["padding-left"]) || 0,
        right: parseFloat(this.containerStyles["padding-right"]) || 0,
        top: parseFloat(this.containerStyles["padding-top"]) || 0,
        bottom: parseFloat(this.containerStyles["padding-bottom"]) || 0
      };
      let _windowBounds = windowBounds();
      let bodyStyles = window.getComputedStyle(document.body);
      let bodyPadding = {
        left: parseFloat(bodyStyles["padding-left"]) || 0,
        right: parseFloat(bodyStyles["padding-right"]) || 0,
        top: parseFloat(bodyStyles["padding-top"]) || 0,
        bottom: parseFloat(bodyStyles["padding-bottom"]) || 0
      };
      if (!_width) {
        width = _windowBounds.width - bodyPadding.left - bodyPadding.right;
      }
      if (this.settings.fullsize && !_height || !_height) {
        height = _windowBounds.height - bodyPadding.top - bodyPadding.bottom;
      }
      return {
        width: width - this.containerPadding.left - this.containerPadding.right,
        height: height - this.containerPadding.top - this.containerPadding.bottom
      };
    }
    bounds() {
      let box;
      if (this.container.style.overflow !== "visible") {
        box = this.container && this.container.getBoundingClientRect();
      }
      if (!box || !box.width || !box.height) {
        return windowBounds();
      } else {
        return box;
      }
    }
    getSheet() {
      var style = document.createElement("style");
      style.appendChild(document.createTextNode(""));
      document.head.appendChild(style);
      return style.sheet;
    }
    addStyleRules(selector, rulesArray) {
      var scope = "#" + this.id + " ";
      var rules = "";
      if (!this.sheet) {
        this.sheet = this.getSheet();
      }
      rulesArray.forEach(function(set3) {
        for (var prop in set3) {
          if (set3.hasOwnProperty(prop)) {
            rules += prop + ":" + set3[prop] + ";";
          }
        }
      });
      this.sheet.insertRule(scope + selector + " {" + rules + "}", 0);
    }
    axis(axis) {
      if (axis === "horizontal") {
        this.container.style.display = "flex";
        this.container.style.flexDirection = "row";
        this.container.style.flexWrap = "nowrap";
      } else {
        this.container.style.display = "block";
      }
      this.settings.axis = axis;
    }
    direction(dir) {
      if (this.container) {
        this.container.dir = dir;
        this.container.style["direction"] = dir;
      }
      if (this.settings.fullsize) {
        document.body.style["direction"] = dir;
      }
      this.settings.dir = dir;
    }
    overflow(overflow) {
      if (this.container) {
        if (overflow === "scroll" && this.settings.axis === "vertical") {
          this.container.style["overflow-y"] = overflow;
          this.container.style["overflow-x"] = "hidden";
        } else if (overflow === "scroll" && this.settings.axis === "horizontal") {
          this.container.style["overflow-y"] = "hidden";
          this.container.style["overflow-x"] = overflow;
        } else {
          this.container.style["overflow"] = overflow;
        }
      }
      this.settings.overflow = overflow;
    }
    destroy() {
      var base;
      if (this.element) {
        if (this.settings.hidden) {
          base = this.wrapper;
        } else {
          base = this.container;
        }
        if (this.element.contains(this.container)) {
          this.element.removeChild(this.container);
        }
        window.removeEventListener("resize", this.resizeFunc);
        window.removeEventListener("orientationChange", this.orientationChangeFunc);
      }
    }
  };
  var stage_default = Stage;

  // ../library_management/node_modules/epubjs/src/managers/helpers/views.js
  var Views = class {
    constructor(container) {
      this.container = container;
      this._views = [];
      this.length = 0;
      this.hidden = false;
    }
    all() {
      return this._views;
    }
    first() {
      return this._views[0];
    }
    last() {
      return this._views[this._views.length - 1];
    }
    indexOf(view) {
      return this._views.indexOf(view);
    }
    slice() {
      return this._views.slice.apply(this._views, arguments);
    }
    get(i) {
      return this._views[i];
    }
    append(view) {
      this._views.push(view);
      if (this.container) {
        this.container.appendChild(view.element);
      }
      this.length++;
      return view;
    }
    prepend(view) {
      this._views.unshift(view);
      if (this.container) {
        this.container.insertBefore(view.element, this.container.firstChild);
      }
      this.length++;
      return view;
    }
    insert(view, index) {
      this._views.splice(index, 0, view);
      if (this.container) {
        if (index < this.container.children.length) {
          this.container.insertBefore(view.element, this.container.children[index]);
        } else {
          this.container.appendChild(view.element);
        }
      }
      this.length++;
      return view;
    }
    remove(view) {
      var index = this._views.indexOf(view);
      if (index > -1) {
        this._views.splice(index, 1);
      }
      this.destroy(view);
      this.length--;
    }
    destroy(view) {
      if (view.displayed) {
        view.destroy();
      }
      if (this.container) {
        this.container.removeChild(view.element);
      }
      view = null;
    }
    forEach() {
      return this._views.forEach.apply(this._views, arguments);
    }
    clear() {
      var view;
      var len = this.length;
      if (!this.length)
        return;
      for (var i = 0; i < len; i++) {
        view = this._views[i];
        this.destroy(view);
      }
      this._views = [];
      this.length = 0;
    }
    find(section) {
      var view;
      var len = this.length;
      for (var i = 0; i < len; i++) {
        view = this._views[i];
        if (view.displayed && view.section.index == section.index) {
          return view;
        }
      }
    }
    displayed() {
      var displayed = [];
      var view;
      var len = this.length;
      for (var i = 0; i < len; i++) {
        view = this._views[i];
        if (view.displayed) {
          displayed.push(view);
        }
      }
      return displayed;
    }
    show() {
      var view;
      var len = this.length;
      for (var i = 0; i < len; i++) {
        view = this._views[i];
        if (view.displayed) {
          view.show();
        }
      }
      this.hidden = false;
    }
    hide() {
      var view;
      var len = this.length;
      for (var i = 0; i < len; i++) {
        view = this._views[i];
        if (view.displayed) {
          view.hide();
        }
      }
      this.hidden = true;
    }
  };
  var views_default = Views;

  // ../library_management/node_modules/epubjs/src/managers/default/index.js
  var DefaultViewManager = class {
    constructor(options) {
      this.name = "default";
      this.optsSettings = options.settings;
      this.View = options.view;
      this.request = options.request;
      this.renditionQueue = options.queue;
      this.q = new queue_default(this);
      this.settings = extend2(this.settings || {}, {
        infinite: true,
        hidden: false,
        width: void 0,
        height: void 0,
        axis: void 0,
        writingMode: void 0,
        flow: "scrolled",
        ignoreClass: "",
        fullsize: void 0,
        allowScriptedContent: false,
        allowPopups: false
      });
      extend2(this.settings, options.settings || {});
      this.viewSettings = {
        ignoreClass: this.settings.ignoreClass,
        axis: this.settings.axis,
        flow: this.settings.flow,
        layout: this.layout,
        method: this.settings.method,
        width: 0,
        height: 0,
        forceEvenPages: true,
        allowScriptedContent: this.settings.allowScriptedContent,
        allowPopups: this.settings.allowPopups
      };
      this.rendered = false;
    }
    render(element, size2) {
      let tag = element.tagName;
      if (typeof this.settings.fullsize === "undefined" && tag && (tag.toLowerCase() == "body" || tag.toLowerCase() == "html")) {
        this.settings.fullsize = true;
      }
      if (this.settings.fullsize) {
        this.settings.overflow = "visible";
        this.overflow = this.settings.overflow;
      }
      this.settings.size = size2;
      this.settings.rtlScrollType = scrollType();
      this.stage = new stage_default({
        width: size2.width,
        height: size2.height,
        overflow: this.overflow,
        hidden: this.settings.hidden,
        axis: this.settings.axis,
        fullsize: this.settings.fullsize,
        direction: this.settings.direction
      });
      this.stage.attachTo(element);
      this.container = this.stage.getContainer();
      this.views = new views_default(this.container);
      this._bounds = this.bounds();
      this._stageSize = this.stage.size();
      this.viewSettings.width = this._stageSize.width;
      this.viewSettings.height = this._stageSize.height;
      this.stage.onResize(this.onResized.bind(this));
      this.stage.onOrientationChange(this.onOrientationChange.bind(this));
      this.addEventListeners();
      if (this.layout) {
        this.updateLayout();
      }
      this.rendered = true;
    }
    addEventListeners() {
      var scroller;
      window.addEventListener("unload", function(e) {
        this.destroy();
      }.bind(this));
      if (!this.settings.fullsize) {
        scroller = this.container;
      } else {
        scroller = window;
      }
      this._onScroll = this.onScroll.bind(this);
      scroller.addEventListener("scroll", this._onScroll);
    }
    removeEventListeners() {
      var scroller;
      if (!this.settings.fullsize) {
        scroller = this.container;
      } else {
        scroller = window;
      }
      scroller.removeEventListener("scroll", this._onScroll);
      this._onScroll = void 0;
    }
    destroy() {
      clearTimeout(this.orientationTimeout);
      clearTimeout(this.resizeTimeout);
      clearTimeout(this.afterScrolled);
      this.clear();
      this.removeEventListeners();
      this.stage.destroy();
      this.rendered = false;
    }
    onOrientationChange(e) {
      let { orientation } = window;
      if (this.optsSettings.resizeOnOrientationChange) {
        this.resize();
      }
      clearTimeout(this.orientationTimeout);
      this.orientationTimeout = setTimeout(function() {
        this.orientationTimeout = void 0;
        if (this.optsSettings.resizeOnOrientationChange) {
          this.resize();
        }
        this.emit(EVENTS.MANAGERS.ORIENTATION_CHANGE, orientation);
      }.bind(this), 500);
    }
    onResized(e) {
      this.resize();
    }
    resize(width, height, epubcfi) {
      let stageSize = this.stage.size(width, height);
      this.winBounds = windowBounds();
      if (this.orientationTimeout && this.winBounds.width === this.winBounds.height) {
        this._stageSize = void 0;
        return;
      }
      if (this._stageSize && this._stageSize.width === stageSize.width && this._stageSize.height === stageSize.height) {
        return;
      }
      this._stageSize = stageSize;
      this._bounds = this.bounds();
      this.clear();
      this.viewSettings.width = this._stageSize.width;
      this.viewSettings.height = this._stageSize.height;
      this.updateLayout();
      this.emit(EVENTS.MANAGERS.RESIZED, {
        width: this._stageSize.width,
        height: this._stageSize.height
      }, epubcfi);
    }
    createView(section, forceRight) {
      return new this.View(section, extend2(this.viewSettings, { forceRight }));
    }
    handleNextPrePaginated(forceRight, section, action) {
      let next;
      if (this.layout.name === "pre-paginated" && this.layout.divisor > 1) {
        if (forceRight || section.index === 0) {
          return;
        }
        next = section.next();
        if (next && !next.properties.includes("page-spread-left")) {
          return action.call(this, next);
        }
      }
    }
    display(section, target) {
      var displaying = new defer();
      var displayed = displaying.promise;
      if (target === section.href || isNumber(target)) {
        target = void 0;
      }
      var visible = this.views.find(section);
      if (visible && section && this.layout.name !== "pre-paginated") {
        let offset = visible.offset();
        if (this.settings.direction === "ltr") {
          this.scrollTo(offset.left, offset.top, true);
        } else {
          let width = visible.width();
          this.scrollTo(offset.left + width, offset.top, true);
        }
        if (target) {
          let offset2 = visible.locationOf(target);
          let width = visible.width();
          this.moveTo(offset2, width);
        }
        displaying.resolve();
        return displayed;
      }
      this.clear();
      let forceRight = false;
      if (this.layout.name === "pre-paginated" && this.layout.divisor === 2 && section.properties.includes("page-spread-right")) {
        forceRight = true;
      }
      this.add(section, forceRight).then(function(view) {
        if (target) {
          let offset = view.locationOf(target);
          let width = view.width();
          this.moveTo(offset, width);
        }
      }.bind(this), (err) => {
        displaying.reject(err);
      }).then(function() {
        return this.handleNextPrePaginated(forceRight, section, this.add);
      }.bind(this)).then(function() {
        this.views.show();
        displaying.resolve();
      }.bind(this));
      return displayed;
    }
    afterDisplayed(view) {
      this.emit(EVENTS.MANAGERS.ADDED, view);
    }
    afterResized(view) {
      this.emit(EVENTS.MANAGERS.RESIZE, view.section);
    }
    moveTo(offset, width) {
      var distX = 0, distY = 0;
      if (!this.isPaginated) {
        distY = offset.top;
      } else {
        distX = Math.floor(offset.left / this.layout.delta) * this.layout.delta;
        if (distX + this.layout.delta > this.container.scrollWidth) {
          distX = this.container.scrollWidth - this.layout.delta;
        }
        distY = Math.floor(offset.top / this.layout.delta) * this.layout.delta;
        if (distY + this.layout.delta > this.container.scrollHeight) {
          distY = this.container.scrollHeight - this.layout.delta;
        }
      }
      if (this.settings.direction === "rtl") {
        distX = distX + this.layout.delta;
        distX = distX - width;
      }
      this.scrollTo(distX, distY, true);
    }
    add(section, forceRight) {
      var view = this.createView(section, forceRight);
      this.views.append(view);
      view.onDisplayed = this.afterDisplayed.bind(this);
      view.onResize = this.afterResized.bind(this);
      view.on(EVENTS.VIEWS.AXIS, (axis) => {
        this.updateAxis(axis);
      });
      view.on(EVENTS.VIEWS.WRITING_MODE, (mode) => {
        this.updateWritingMode(mode);
      });
      return view.display(this.request);
    }
    append(section, forceRight) {
      var view = this.createView(section, forceRight);
      this.views.append(view);
      view.onDisplayed = this.afterDisplayed.bind(this);
      view.onResize = this.afterResized.bind(this);
      view.on(EVENTS.VIEWS.AXIS, (axis) => {
        this.updateAxis(axis);
      });
      view.on(EVENTS.VIEWS.WRITING_MODE, (mode) => {
        this.updateWritingMode(mode);
      });
      return view.display(this.request);
    }
    prepend(section, forceRight) {
      var view = this.createView(section, forceRight);
      view.on(EVENTS.VIEWS.RESIZED, (bounds2) => {
        this.counter(bounds2);
      });
      this.views.prepend(view);
      view.onDisplayed = this.afterDisplayed.bind(this);
      view.onResize = this.afterResized.bind(this);
      view.on(EVENTS.VIEWS.AXIS, (axis) => {
        this.updateAxis(axis);
      });
      view.on(EVENTS.VIEWS.WRITING_MODE, (mode) => {
        this.updateWritingMode(mode);
      });
      return view.display(this.request);
    }
    counter(bounds2) {
      if (this.settings.axis === "vertical") {
        this.scrollBy(0, bounds2.heightDelta, true);
      } else {
        this.scrollBy(bounds2.widthDelta, 0, true);
      }
    }
    next() {
      var next;
      var left;
      let dir = this.settings.direction;
      if (!this.views.length)
        return;
      if (this.isPaginated && this.settings.axis === "horizontal" && (!dir || dir === "ltr")) {
        this.scrollLeft = this.container.scrollLeft;
        left = this.container.scrollLeft + this.container.offsetWidth + this.layout.delta;
        if (left <= this.container.scrollWidth) {
          this.scrollBy(this.layout.delta, 0, true);
        } else {
          next = this.views.last().section.next();
        }
      } else if (this.isPaginated && this.settings.axis === "horizontal" && dir === "rtl") {
        this.scrollLeft = this.container.scrollLeft;
        if (this.settings.rtlScrollType === "default") {
          left = this.container.scrollLeft;
          if (left > 0) {
            this.scrollBy(this.layout.delta, 0, true);
          } else {
            next = this.views.last().section.next();
          }
        } else {
          left = this.container.scrollLeft + this.layout.delta * -1;
          if (left > this.container.scrollWidth * -1) {
            this.scrollBy(this.layout.delta, 0, true);
          } else {
            next = this.views.last().section.next();
          }
        }
      } else if (this.isPaginated && this.settings.axis === "vertical") {
        this.scrollTop = this.container.scrollTop;
        let top = this.container.scrollTop + this.container.offsetHeight;
        if (top < this.container.scrollHeight) {
          this.scrollBy(0, this.layout.height, true);
        } else {
          next = this.views.last().section.next();
        }
      } else {
        next = this.views.last().section.next();
      }
      if (next) {
        this.clear();
        this.updateLayout();
        let forceRight = false;
        if (this.layout.name === "pre-paginated" && this.layout.divisor === 2 && next.properties.includes("page-spread-right")) {
          forceRight = true;
        }
        return this.append(next, forceRight).then(function() {
          return this.handleNextPrePaginated(forceRight, next, this.append);
        }.bind(this), (err) => {
          return err;
        }).then(function() {
          if (!this.isPaginated && this.settings.axis === "horizontal" && this.settings.direction === "rtl" && this.settings.rtlScrollType === "default") {
            this.scrollTo(this.container.scrollWidth, 0, true);
          }
          this.views.show();
        }.bind(this));
      }
    }
    prev() {
      var prev;
      var left;
      let dir = this.settings.direction;
      if (!this.views.length)
        return;
      if (this.isPaginated && this.settings.axis === "horizontal" && (!dir || dir === "ltr")) {
        this.scrollLeft = this.container.scrollLeft;
        left = this.container.scrollLeft;
        if (left > 0) {
          this.scrollBy(-this.layout.delta, 0, true);
        } else {
          prev = this.views.first().section.prev();
        }
      } else if (this.isPaginated && this.settings.axis === "horizontal" && dir === "rtl") {
        this.scrollLeft = this.container.scrollLeft;
        if (this.settings.rtlScrollType === "default") {
          left = this.container.scrollLeft + this.container.offsetWidth;
          if (left < this.container.scrollWidth) {
            this.scrollBy(-this.layout.delta, 0, true);
          } else {
            prev = this.views.first().section.prev();
          }
        } else {
          left = this.container.scrollLeft;
          if (left < 0) {
            this.scrollBy(-this.layout.delta, 0, true);
          } else {
            prev = this.views.first().section.prev();
          }
        }
      } else if (this.isPaginated && this.settings.axis === "vertical") {
        this.scrollTop = this.container.scrollTop;
        let top = this.container.scrollTop;
        if (top > 0) {
          this.scrollBy(0, -this.layout.height, true);
        } else {
          prev = this.views.first().section.prev();
        }
      } else {
        prev = this.views.first().section.prev();
      }
      if (prev) {
        this.clear();
        this.updateLayout();
        let forceRight = false;
        if (this.layout.name === "pre-paginated" && this.layout.divisor === 2 && typeof prev.prev() !== "object") {
          forceRight = true;
        }
        return this.prepend(prev, forceRight).then(function() {
          var left2;
          if (this.layout.name === "pre-paginated" && this.layout.divisor > 1) {
            left2 = prev.prev();
            if (left2) {
              return this.prepend(left2);
            }
          }
        }.bind(this), (err) => {
          return err;
        }).then(function() {
          if (this.isPaginated && this.settings.axis === "horizontal") {
            if (this.settings.direction === "rtl") {
              if (this.settings.rtlScrollType === "default") {
                this.scrollTo(0, 0, true);
              } else {
                this.scrollTo(this.container.scrollWidth * -1 + this.layout.delta, 0, true);
              }
            } else {
              this.scrollTo(this.container.scrollWidth - this.layout.delta, 0, true);
            }
          }
          this.views.show();
        }.bind(this));
      }
    }
    current() {
      var visible = this.visible();
      if (visible.length) {
        return visible[visible.length - 1];
      }
      return null;
    }
    clear() {
      if (this.views) {
        this.views.hide();
        this.scrollTo(0, 0, true);
        this.views.clear();
      }
    }
    currentLocation() {
      this.updateLayout();
      if (this.isPaginated && this.settings.axis === "horizontal") {
        this.location = this.paginatedLocation();
      } else {
        this.location = this.scrolledLocation();
      }
      return this.location;
    }
    scrolledLocation() {
      let visible = this.visible();
      let container = this.container.getBoundingClientRect();
      let pageHeight = container.height < window.innerHeight ? container.height : window.innerHeight;
      let pageWidth = container.width < window.innerWidth ? container.width : window.innerWidth;
      let vertical = this.settings.axis === "vertical";
      let rtl = this.settings.direction === "rtl";
      let offset = 0;
      let used = 0;
      if (this.settings.fullsize) {
        offset = vertical ? window.scrollY : window.scrollX;
      }
      let sections = visible.map((view) => {
        let { index, href } = view.section;
        let position = view.position();
        let width = view.width();
        let height = view.height();
        let startPos;
        let endPos;
        let stopPos;
        let totalPages;
        if (vertical) {
          startPos = offset + container.top - position.top + used;
          endPos = startPos + pageHeight - used;
          totalPages = this.layout.count(height, pageHeight).pages;
          stopPos = pageHeight;
        } else {
          startPos = offset + container.left - position.left + used;
          endPos = startPos + pageWidth - used;
          totalPages = this.layout.count(width, pageWidth).pages;
          stopPos = pageWidth;
        }
        let currPage = Math.ceil(startPos / stopPos);
        let pages = [];
        let endPage = Math.ceil(endPos / stopPos);
        if (this.settings.direction === "rtl" && !vertical) {
          let tempStartPage = currPage;
          currPage = totalPages - endPage;
          endPage = totalPages - tempStartPage;
        }
        pages = [];
        for (var i = currPage; i <= endPage; i++) {
          let pg = i + 1;
          pages.push(pg);
        }
        let mapping = this.mapping.page(view.contents, view.section.cfiBase, startPos, endPos);
        return {
          index,
          href,
          pages,
          totalPages,
          mapping
        };
      });
      return sections;
    }
    paginatedLocation() {
      let visible = this.visible();
      let container = this.container.getBoundingClientRect();
      let left = 0;
      let used = 0;
      if (this.settings.fullsize) {
        left = window.scrollX;
      }
      let sections = visible.map((view) => {
        let { index, href } = view.section;
        let offset;
        let position = view.position();
        let width = view.width();
        let start;
        let end;
        let pageWidth;
        if (this.settings.direction === "rtl") {
          offset = container.right - left;
          pageWidth = Math.min(Math.abs(offset - position.left), this.layout.width) - used;
          end = position.width - (position.right - offset) - used;
          start = end - pageWidth;
        } else {
          offset = container.left + left;
          pageWidth = Math.min(position.right - offset, this.layout.width) - used;
          start = offset - position.left + used;
          end = start + pageWidth;
        }
        used += pageWidth;
        let mapping = this.mapping.page(view.contents, view.section.cfiBase, start, end);
        let totalPages = this.layout.count(width).pages;
        let startPage = Math.floor(start / this.layout.pageWidth);
        let pages = [];
        let endPage = Math.floor(end / this.layout.pageWidth);
        if (startPage < 0) {
          startPage = 0;
          endPage = endPage + 1;
        }
        if (this.settings.direction === "rtl") {
          let tempStartPage = startPage;
          startPage = totalPages - endPage;
          endPage = totalPages - tempStartPage;
        }
        for (var i = startPage + 1; i <= endPage; i++) {
          let pg = i;
          pages.push(pg);
        }
        return {
          index,
          href,
          pages,
          totalPages,
          mapping
        };
      });
      return sections;
    }
    isVisible(view, offsetPrev, offsetNext, _container) {
      var position = view.position();
      var container = _container || this.bounds();
      if (this.settings.axis === "horizontal" && position.right > container.left - offsetPrev && position.left < container.right + offsetNext) {
        return true;
      } else if (this.settings.axis === "vertical" && position.bottom > container.top - offsetPrev && position.top < container.bottom + offsetNext) {
        return true;
      }
      return false;
    }
    visible() {
      var container = this.bounds();
      var views = this.views.displayed();
      var viewsLength = views.length;
      var visible = [];
      var isVisible;
      var view;
      for (var i = 0; i < viewsLength; i++) {
        view = views[i];
        isVisible = this.isVisible(view, 0, 0, container);
        if (isVisible === true) {
          visible.push(view);
        }
      }
      return visible;
    }
    scrollBy(x, y, silent) {
      let dir = this.settings.direction === "rtl" ? -1 : 1;
      if (silent) {
        this.ignore = true;
      }
      if (!this.settings.fullsize) {
        if (x)
          this.container.scrollLeft += x * dir;
        if (y)
          this.container.scrollTop += y;
      } else {
        window.scrollBy(x * dir, y * dir);
      }
      this.scrolled = true;
    }
    scrollTo(x, y, silent) {
      if (silent) {
        this.ignore = true;
      }
      if (!this.settings.fullsize) {
        this.container.scrollLeft = x;
        this.container.scrollTop = y;
      } else {
        window.scrollTo(x, y);
      }
      this.scrolled = true;
    }
    onScroll() {
      let scrollTop;
      let scrollLeft;
      if (!this.settings.fullsize) {
        scrollTop = this.container.scrollTop;
        scrollLeft = this.container.scrollLeft;
      } else {
        scrollTop = window.scrollY;
        scrollLeft = window.scrollX;
      }
      this.scrollTop = scrollTop;
      this.scrollLeft = scrollLeft;
      if (!this.ignore) {
        this.emit(EVENTS.MANAGERS.SCROLL, {
          top: scrollTop,
          left: scrollLeft
        });
        clearTimeout(this.afterScrolled);
        this.afterScrolled = setTimeout(function() {
          this.emit(EVENTS.MANAGERS.SCROLLED, {
            top: this.scrollTop,
            left: this.scrollLeft
          });
        }.bind(this), 20);
      } else {
        this.ignore = false;
      }
    }
    bounds() {
      var bounds2;
      bounds2 = this.stage.bounds();
      return bounds2;
    }
    applyLayout(layout) {
      this.layout = layout;
      this.updateLayout();
      if (this.views && this.views.length > 0 && this.layout.name === "pre-paginated") {
        this.display(this.views.first().section);
      }
    }
    updateLayout() {
      if (!this.stage) {
        return;
      }
      this._stageSize = this.stage.size();
      if (!this.isPaginated) {
        this.layout.calculate(this._stageSize.width, this._stageSize.height);
      } else {
        this.layout.calculate(
          this._stageSize.width,
          this._stageSize.height,
          this.settings.gap
        );
        this.settings.offset = this.layout.delta / this.layout.divisor;
      }
      this.viewSettings.width = this.layout.width;
      this.viewSettings.height = this.layout.height;
      this.setLayout(this.layout);
    }
    setLayout(layout) {
      this.viewSettings.layout = layout;
      this.mapping = new mapping_default(layout.props, this.settings.direction, this.settings.axis);
      if (this.views) {
        this.views.forEach(function(view) {
          if (view) {
            view.setLayout(layout);
          }
        });
      }
    }
    updateWritingMode(mode) {
      this.writingMode = mode;
    }
    updateAxis(axis, forceUpdate) {
      if (!forceUpdate && axis === this.settings.axis) {
        return;
      }
      this.settings.axis = axis;
      this.stage && this.stage.axis(axis);
      this.viewSettings.axis = axis;
      if (this.mapping) {
        this.mapping = new mapping_default(this.layout.props, this.settings.direction, this.settings.axis);
      }
      if (this.layout) {
        if (axis === "vertical") {
          this.layout.spread("none");
        } else {
          this.layout.spread(this.layout.settings.spread);
        }
      }
    }
    updateFlow(flow, defaultScrolledOverflow = "auto") {
      let isPaginated = flow === "paginated" || flow === "auto";
      this.isPaginated = isPaginated;
      if (flow === "scrolled-doc" || flow === "scrolled-continuous" || flow === "scrolled") {
        this.updateAxis("vertical");
      } else {
        this.updateAxis("horizontal");
      }
      this.viewSettings.flow = flow;
      if (!this.settings.overflow) {
        this.overflow = isPaginated ? "hidden" : defaultScrolledOverflow;
      } else {
        this.overflow = this.settings.overflow;
      }
      this.stage && this.stage.overflow(this.overflow);
      this.updateLayout();
    }
    getContents() {
      var contents = [];
      if (!this.views) {
        return contents;
      }
      this.views.forEach(function(view) {
        const viewContents = view && view.contents;
        if (viewContents) {
          contents.push(viewContents);
        }
      });
      return contents;
    }
    direction(dir = "ltr") {
      this.settings.direction = dir;
      this.stage && this.stage.direction(dir);
      this.viewSettings.direction = dir;
      this.updateLayout();
    }
    isRendered() {
      return this.rendered;
    }
  };
  (0, import_event_emitter6.default)(DefaultViewManager.prototype);
  var default_default = DefaultViewManager;

  // ../library_management/node_modules/epubjs/src/managers/helpers/snap.js
  var import_event_emitter7 = __toESM(require_event_emitter());
  var PI_D2 = Math.PI / 2;
  var EASING_EQUATIONS = {
    easeOutSine: function(pos) {
      return Math.sin(pos * PI_D2);
    },
    easeInOutSine: function(pos) {
      return -0.5 * (Math.cos(Math.PI * pos) - 1);
    },
    easeInOutQuint: function(pos) {
      if ((pos /= 0.5) < 1) {
        return 0.5 * Math.pow(pos, 5);
      }
      return 0.5 * (Math.pow(pos - 2, 5) + 2);
    },
    easeInCubic: function(pos) {
      return Math.pow(pos, 3);
    }
  };
  var Snap = class {
    constructor(manager, options) {
      this.settings = extend2({
        duration: 80,
        minVelocity: 0.2,
        minDistance: 10,
        easing: EASING_EQUATIONS["easeInCubic"]
      }, options || {});
      this.supportsTouch = this.supportsTouch();
      if (this.supportsTouch) {
        this.setup(manager);
      }
    }
    setup(manager) {
      this.manager = manager;
      this.layout = this.manager.layout;
      this.fullsize = this.manager.settings.fullsize;
      if (this.fullsize) {
        this.element = this.manager.stage.element;
        this.scroller = window;
        this.disableScroll();
      } else {
        this.element = this.manager.stage.container;
        this.scroller = this.element;
        this.element.style["WebkitOverflowScrolling"] = "touch";
      }
      this.manager.settings.offset = this.layout.width;
      this.manager.settings.afterScrolledTimeout = this.settings.duration * 2;
      this.isVertical = this.manager.settings.axis === "vertical";
      if (!this.manager.isPaginated || this.isVertical) {
        return;
      }
      this.touchCanceler = false;
      this.resizeCanceler = false;
      this.snapping = false;
      this.scrollLeft;
      this.scrollTop;
      this.startTouchX = void 0;
      this.startTouchY = void 0;
      this.startTime = void 0;
      this.endTouchX = void 0;
      this.endTouchY = void 0;
      this.endTime = void 0;
      this.addListeners();
    }
    supportsTouch() {
      if ("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch) {
        return true;
      }
      return false;
    }
    disableScroll() {
      this.element.style.overflow = "hidden";
    }
    enableScroll() {
      this.element.style.overflow = "";
    }
    addListeners() {
      this._onResize = this.onResize.bind(this);
      window.addEventListener("resize", this._onResize);
      this._onScroll = this.onScroll.bind(this);
      this.scroller.addEventListener("scroll", this._onScroll);
      this._onTouchStart = this.onTouchStart.bind(this);
      this.scroller.addEventListener("touchstart", this._onTouchStart, { passive: true });
      this.on("touchstart", this._onTouchStart);
      this._onTouchMove = this.onTouchMove.bind(this);
      this.scroller.addEventListener("touchmove", this._onTouchMove, { passive: true });
      this.on("touchmove", this._onTouchMove);
      this._onTouchEnd = this.onTouchEnd.bind(this);
      this.scroller.addEventListener("touchend", this._onTouchEnd, { passive: true });
      this.on("touchend", this._onTouchEnd);
      this._afterDisplayed = this.afterDisplayed.bind(this);
      this.manager.on(EVENTS.MANAGERS.ADDED, this._afterDisplayed);
    }
    removeListeners() {
      window.removeEventListener("resize", this._onResize);
      this._onResize = void 0;
      this.scroller.removeEventListener("scroll", this._onScroll);
      this._onScroll = void 0;
      this.scroller.removeEventListener("touchstart", this._onTouchStart, { passive: true });
      this.off("touchstart", this._onTouchStart);
      this._onTouchStart = void 0;
      this.scroller.removeEventListener("touchmove", this._onTouchMove, { passive: true });
      this.off("touchmove", this._onTouchMove);
      this._onTouchMove = void 0;
      this.scroller.removeEventListener("touchend", this._onTouchEnd, { passive: true });
      this.off("touchend", this._onTouchEnd);
      this._onTouchEnd = void 0;
      this.manager.off(EVENTS.MANAGERS.ADDED, this._afterDisplayed);
      this._afterDisplayed = void 0;
    }
    afterDisplayed(view) {
      let contents = view.contents;
      ["touchstart", "touchmove", "touchend"].forEach((e) => {
        contents.on(e, (ev) => this.triggerViewEvent(ev, contents));
      });
    }
    triggerViewEvent(e, contents) {
      this.emit(e.type, e, contents);
    }
    onScroll(e) {
      this.scrollLeft = this.fullsize ? window.scrollX : this.scroller.scrollLeft;
      this.scrollTop = this.fullsize ? window.scrollY : this.scroller.scrollTop;
    }
    onResize(e) {
      this.resizeCanceler = true;
    }
    onTouchStart(e) {
      let { screenX, screenY } = e.touches[0];
      if (this.fullsize) {
        this.enableScroll();
      }
      this.touchCanceler = true;
      if (!this.startTouchX) {
        this.startTouchX = screenX;
        this.startTouchY = screenY;
        this.startTime = this.now();
      }
      this.endTouchX = screenX;
      this.endTouchY = screenY;
      this.endTime = this.now();
    }
    onTouchMove(e) {
      let { screenX, screenY } = e.touches[0];
      let deltaY = Math.abs(screenY - this.endTouchY);
      this.touchCanceler = true;
      if (!this.fullsize && deltaY < 10) {
        this.element.scrollLeft -= screenX - this.endTouchX;
      }
      this.endTouchX = screenX;
      this.endTouchY = screenY;
      this.endTime = this.now();
    }
    onTouchEnd(e) {
      if (this.fullsize) {
        this.disableScroll();
      }
      this.touchCanceler = false;
      let swipped = this.wasSwiped();
      if (swipped !== 0) {
        this.snap(swipped);
      } else {
        this.snap();
      }
      this.startTouchX = void 0;
      this.startTouchY = void 0;
      this.startTime = void 0;
      this.endTouchX = void 0;
      this.endTouchY = void 0;
      this.endTime = void 0;
    }
    wasSwiped() {
      let snapWidth = this.layout.pageWidth * this.layout.divisor;
      let distance = this.endTouchX - this.startTouchX;
      let absolute = Math.abs(distance);
      let time = this.endTime - this.startTime;
      let velocity = distance / time;
      let minVelocity = this.settings.minVelocity;
      if (absolute <= this.settings.minDistance || absolute >= snapWidth) {
        return 0;
      }
      if (velocity > minVelocity) {
        return -1;
      } else if (velocity < -minVelocity) {
        return 1;
      }
    }
    needsSnap() {
      let left = this.scrollLeft;
      let snapWidth = this.layout.pageWidth * this.layout.divisor;
      return left % snapWidth !== 0;
    }
    snap(howMany = 0) {
      let left = this.scrollLeft;
      let snapWidth = this.layout.pageWidth * this.layout.divisor;
      let snapTo = Math.round(left / snapWidth) * snapWidth;
      if (howMany) {
        snapTo += howMany * snapWidth;
      }
      return this.smoothScrollTo(snapTo);
    }
    smoothScrollTo(destination) {
      const deferred = new defer();
      const start = this.scrollLeft;
      const startTime = this.now();
      const duration = this.settings.duration;
      const easing = this.settings.easing;
      this.snapping = true;
      function tick() {
        const now2 = this.now();
        const time = Math.min(1, (now2 - startTime) / duration);
        const timeFunction = easing(time);
        if (this.touchCanceler || this.resizeCanceler) {
          this.resizeCanceler = false;
          this.snapping = false;
          deferred.resolve();
          return;
        }
        if (time < 1) {
          window.requestAnimationFrame(tick.bind(this));
          this.scrollTo(start + (destination - start) * time, 0);
        } else {
          this.scrollTo(destination, 0);
          this.snapping = false;
          deferred.resolve();
        }
      }
      tick.call(this);
      return deferred.promise;
    }
    scrollTo(left = 0, top = 0) {
      if (this.fullsize) {
        window.scroll(left, top);
      } else {
        this.scroller.scrollLeft = left;
        this.scroller.scrollTop = top;
      }
    }
    now() {
      return "now" in window.performance ? performance.now() : new Date().getTime();
    }
    destroy() {
      if (!this.scroller) {
        return;
      }
      if (this.fullsize) {
        this.enableScroll();
      }
      this.removeListeners();
      this.scroller = void 0;
    }
  };
  (0, import_event_emitter7.default)(Snap.prototype);
  var snap_default = Snap;

  // ../library_management/node_modules/epubjs/src/managers/continuous/index.js
  var import_debounce = __toESM(require_debounce());
  var ContinuousViewManager = class extends default_default {
    constructor(options) {
      super(options);
      this.name = "continuous";
      this.settings = extend2(this.settings || {}, {
        infinite: true,
        overflow: void 0,
        axis: void 0,
        writingMode: void 0,
        flow: "scrolled",
        offset: 500,
        offsetDelta: 250,
        width: void 0,
        height: void 0,
        snap: false,
        afterScrolledTimeout: 10,
        allowScriptedContent: false,
        allowPopups: false
      });
      extend2(this.settings, options.settings || {});
      if (options.settings.gap != "undefined" && options.settings.gap === 0) {
        this.settings.gap = options.settings.gap;
      }
      this.viewSettings = {
        ignoreClass: this.settings.ignoreClass,
        axis: this.settings.axis,
        flow: this.settings.flow,
        layout: this.layout,
        width: 0,
        height: 0,
        forceEvenPages: false,
        allowScriptedContent: this.settings.allowScriptedContent,
        allowPopups: this.settings.allowPopups
      };
      this.scrollTop = 0;
      this.scrollLeft = 0;
    }
    display(section, target) {
      return default_default.prototype.display.call(this, section, target).then(function() {
        return this.fill();
      }.bind(this));
    }
    fill(_full) {
      var full = _full || new defer();
      this.q.enqueue(() => {
        return this.check();
      }).then((result) => {
        if (result) {
          this.fill(full);
        } else {
          full.resolve();
        }
      });
      return full.promise;
    }
    moveTo(offset) {
      var distX = 0, distY = 0;
      var offsetX = 0, offsetY = 0;
      if (!this.isPaginated) {
        distY = offset.top;
        offsetY = offset.top + this.settings.offsetDelta;
      } else {
        distX = Math.floor(offset.left / this.layout.delta) * this.layout.delta;
        offsetX = distX + this.settings.offsetDelta;
      }
      if (distX > 0 || distY > 0) {
        this.scrollBy(distX, distY, true);
      }
    }
    afterResized(view) {
      this.emit(EVENTS.MANAGERS.RESIZE, view.section);
    }
    removeShownListeners(view) {
      view.onDisplayed = function() {
      };
    }
    add(section) {
      var view = this.createView(section);
      this.views.append(view);
      view.on(EVENTS.VIEWS.RESIZED, (bounds2) => {
        view.expanded = true;
      });
      view.on(EVENTS.VIEWS.AXIS, (axis) => {
        this.updateAxis(axis);
      });
      view.on(EVENTS.VIEWS.WRITING_MODE, (mode) => {
        this.updateWritingMode(mode);
      });
      view.onDisplayed = this.afterDisplayed.bind(this);
      view.onResize = this.afterResized.bind(this);
      return view.display(this.request);
    }
    append(section) {
      var view = this.createView(section);
      view.on(EVENTS.VIEWS.RESIZED, (bounds2) => {
        view.expanded = true;
      });
      view.on(EVENTS.VIEWS.AXIS, (axis) => {
        this.updateAxis(axis);
      });
      view.on(EVENTS.VIEWS.WRITING_MODE, (mode) => {
        this.updateWritingMode(mode);
      });
      this.views.append(view);
      view.onDisplayed = this.afterDisplayed.bind(this);
      return view;
    }
    prepend(section) {
      var view = this.createView(section);
      view.on(EVENTS.VIEWS.RESIZED, (bounds2) => {
        this.counter(bounds2);
        view.expanded = true;
      });
      view.on(EVENTS.VIEWS.AXIS, (axis) => {
        this.updateAxis(axis);
      });
      view.on(EVENTS.VIEWS.WRITING_MODE, (mode) => {
        this.updateWritingMode(mode);
      });
      this.views.prepend(view);
      view.onDisplayed = this.afterDisplayed.bind(this);
      return view;
    }
    counter(bounds2) {
      if (this.settings.axis === "vertical") {
        this.scrollBy(0, bounds2.heightDelta, true);
      } else {
        this.scrollBy(bounds2.widthDelta, 0, true);
      }
    }
    update(_offset) {
      var container = this.bounds();
      var views = this.views.all();
      var viewsLength = views.length;
      var visible = [];
      var offset = typeof _offset != "undefined" ? _offset : this.settings.offset || 0;
      var isVisible;
      var view;
      var updating = new defer();
      var promises = [];
      for (var i = 0; i < viewsLength; i++) {
        view = views[i];
        isVisible = this.isVisible(view, offset, offset, container);
        if (isVisible === true) {
          if (!view.displayed) {
            let displayed = view.display(this.request).then(function(view2) {
              view2.show();
            }, (err) => {
              view.hide();
            });
            promises.push(displayed);
          } else {
            view.show();
          }
          visible.push(view);
        } else {
          this.q.enqueue(view.destroy.bind(view));
          clearTimeout(this.trimTimeout);
          this.trimTimeout = setTimeout(function() {
            this.q.enqueue(this.trim.bind(this));
          }.bind(this), 250);
        }
      }
      if (promises.length) {
        return Promise.all(promises).catch((err) => {
          updating.reject(err);
        });
      } else {
        updating.resolve();
        return updating.promise;
      }
    }
    check(_offsetLeft, _offsetTop) {
      var checking = new defer();
      var newViews = [];
      var horizontal = this.settings.axis === "horizontal";
      var delta2 = this.settings.offset || 0;
      if (_offsetLeft && horizontal) {
        delta2 = _offsetLeft;
      }
      if (_offsetTop && !horizontal) {
        delta2 = _offsetTop;
      }
      var bounds2 = this._bounds;
      let offset = horizontal ? this.scrollLeft : this.scrollTop;
      let visibleLength = horizontal ? Math.floor(bounds2.width) : bounds2.height;
      let contentLength = horizontal ? this.container.scrollWidth : this.container.scrollHeight;
      let writingMode = this.writingMode && this.writingMode.indexOf("vertical") === 0 ? "vertical" : "horizontal";
      let rtlScrollType = this.settings.rtlScrollType;
      let rtl = this.settings.direction === "rtl";
      if (!this.settings.fullsize) {
        if (rtl && rtlScrollType === "default" && writingMode === "horizontal") {
          offset = contentLength - visibleLength - offset;
        }
        if (rtl && rtlScrollType === "negative" && writingMode === "horizontal") {
          offset = offset * -1;
        }
      } else {
        if (horizontal && rtl && rtlScrollType === "negative" || !horizontal && rtl && rtlScrollType === "default") {
          offset = offset * -1;
        }
      }
      let prepend = () => {
        let first = this.views.first();
        let prev = first && first.section.prev();
        if (prev) {
          newViews.push(this.prepend(prev));
        }
      };
      let append = () => {
        let last = this.views.last();
        let next = last && last.section.next();
        if (next) {
          newViews.push(this.append(next));
        }
      };
      let end = offset + visibleLength + delta2;
      let start = offset - delta2;
      if (end >= contentLength) {
        append();
      }
      if (start < 0) {
        prepend();
      }
      let promises = newViews.map((view) => {
        return view.display(this.request);
      });
      if (newViews.length) {
        return Promise.all(promises).then(() => {
          return this.check();
        }).then(() => {
          return this.update(delta2);
        }, (err) => {
          return err;
        });
      } else {
        this.q.enqueue(function() {
          this.update();
        }.bind(this));
        checking.resolve(false);
        return checking.promise;
      }
    }
    trim() {
      var task = new defer();
      var displayed = this.views.displayed();
      var first = displayed[0];
      var last = displayed[displayed.length - 1];
      var firstIndex = this.views.indexOf(first);
      var lastIndex = this.views.indexOf(last);
      var above = this.views.slice(0, firstIndex);
      var below = this.views.slice(lastIndex + 1);
      for (var i = 0; i < above.length - 1; i++) {
        this.erase(above[i], above);
      }
      for (var j = 1; j < below.length; j++) {
        this.erase(below[j]);
      }
      task.resolve();
      return task.promise;
    }
    erase(view, above) {
      var prevTop;
      var prevLeft;
      if (!this.settings.fullsize) {
        prevTop = this.container.scrollTop;
        prevLeft = this.container.scrollLeft;
      } else {
        prevTop = window.scrollY;
        prevLeft = window.scrollX;
      }
      var bounds2 = view.bounds();
      this.views.remove(view);
      if (above) {
        if (this.settings.axis === "vertical") {
          this.scrollTo(0, prevTop - bounds2.height, true);
        } else {
          if (this.settings.direction === "rtl") {
            if (!this.settings.fullsize) {
              this.scrollTo(prevLeft, 0, true);
            } else {
              this.scrollTo(prevLeft + Math.floor(bounds2.width), 0, true);
            }
          } else {
            this.scrollTo(prevLeft - Math.floor(bounds2.width), 0, true);
          }
        }
      }
    }
    addEventListeners(stage) {
      window.addEventListener("unload", function(e) {
        this.ignore = true;
        this.destroy();
      }.bind(this));
      this.addScrollListeners();
      if (this.isPaginated && this.settings.snap) {
        this.snapper = new snap_default(this, this.settings.snap && typeof this.settings.snap === "object" && this.settings.snap);
      }
    }
    addScrollListeners() {
      var scroller;
      this.tick = requestAnimationFrame2;
      let dir = this.settings.direction === "rtl" && this.settings.rtlScrollType === "default" ? -1 : 1;
      this.scrollDeltaVert = 0;
      this.scrollDeltaHorz = 0;
      if (!this.settings.fullsize) {
        scroller = this.container;
        this.scrollTop = this.container.scrollTop;
        this.scrollLeft = this.container.scrollLeft;
      } else {
        scroller = window;
        this.scrollTop = window.scrollY * dir;
        this.scrollLeft = window.scrollX * dir;
      }
      this._onScroll = this.onScroll.bind(this);
      scroller.addEventListener("scroll", this._onScroll);
      this._scrolled = (0, import_debounce.default)(this.scrolled.bind(this), 30);
      this.didScroll = false;
    }
    removeEventListeners() {
      var scroller;
      if (!this.settings.fullsize) {
        scroller = this.container;
      } else {
        scroller = window;
      }
      scroller.removeEventListener("scroll", this._onScroll);
      this._onScroll = void 0;
    }
    onScroll() {
      let scrollTop;
      let scrollLeft;
      let dir = this.settings.direction === "rtl" && this.settings.rtlScrollType === "default" ? -1 : 1;
      if (!this.settings.fullsize) {
        scrollTop = this.container.scrollTop;
        scrollLeft = this.container.scrollLeft;
      } else {
        scrollTop = window.scrollY * dir;
        scrollLeft = window.scrollX * dir;
      }
      this.scrollTop = scrollTop;
      this.scrollLeft = scrollLeft;
      if (!this.ignore) {
        this._scrolled();
      } else {
        this.ignore = false;
      }
      this.scrollDeltaVert += Math.abs(scrollTop - this.prevScrollTop);
      this.scrollDeltaHorz += Math.abs(scrollLeft - this.prevScrollLeft);
      this.prevScrollTop = scrollTop;
      this.prevScrollLeft = scrollLeft;
      clearTimeout(this.scrollTimeout);
      this.scrollTimeout = setTimeout(function() {
        this.scrollDeltaVert = 0;
        this.scrollDeltaHorz = 0;
      }.bind(this), 150);
      clearTimeout(this.afterScrolled);
      this.didScroll = false;
    }
    scrolled() {
      this.q.enqueue(function() {
        return this.check();
      }.bind(this));
      this.emit(EVENTS.MANAGERS.SCROLL, {
        top: this.scrollTop,
        left: this.scrollLeft
      });
      clearTimeout(this.afterScrolled);
      this.afterScrolled = setTimeout(function() {
        if (this.snapper && this.snapper.supportsTouch && this.snapper.needsSnap()) {
          return;
        }
        this.emit(EVENTS.MANAGERS.SCROLLED, {
          top: this.scrollTop,
          left: this.scrollLeft
        });
      }.bind(this), this.settings.afterScrolledTimeout);
    }
    next() {
      let delta2 = this.layout.props.name === "pre-paginated" && this.layout.props.spread ? this.layout.props.delta * 2 : this.layout.props.delta;
      if (!this.views.length)
        return;
      if (this.isPaginated && this.settings.axis === "horizontal") {
        this.scrollBy(delta2, 0, true);
      } else {
        this.scrollBy(0, this.layout.height, true);
      }
      this.q.enqueue(function() {
        return this.check();
      }.bind(this));
    }
    prev() {
      let delta2 = this.layout.props.name === "pre-paginated" && this.layout.props.spread ? this.layout.props.delta * 2 : this.layout.props.delta;
      if (!this.views.length)
        return;
      if (this.isPaginated && this.settings.axis === "horizontal") {
        this.scrollBy(-delta2, 0, true);
      } else {
        this.scrollBy(0, -this.layout.height, true);
      }
      this.q.enqueue(function() {
        return this.check();
      }.bind(this));
    }
    updateFlow(flow) {
      if (this.rendered && this.snapper) {
        this.snapper.destroy();
        this.snapper = void 0;
      }
      super.updateFlow(flow, "scroll");
      if (this.rendered && this.isPaginated && this.settings.snap) {
        this.snapper = new snap_default(this, this.settings.snap && typeof this.settings.snap === "object" && this.settings.snap);
      }
    }
    destroy() {
      super.destroy();
      if (this.snapper) {
        this.snapper.destroy();
      }
    }
  };
  var continuous_default = ContinuousViewManager;

  // ../library_management/node_modules/epubjs/src/rendition.js
  var Rendition = class {
    constructor(book, options) {
      this.settings = extend2(this.settings || {}, {
        width: null,
        height: null,
        ignoreClass: "",
        manager: "default",
        view: "iframe",
        flow: null,
        layout: null,
        spread: null,
        minSpreadWidth: 800,
        stylesheet: null,
        resizeOnOrientationChange: true,
        script: null,
        snap: false,
        defaultDirection: "ltr",
        allowScriptedContent: false,
        allowPopups: false
      });
      extend2(this.settings, options);
      if (typeof this.settings.manager === "object") {
        this.manager = this.settings.manager;
      }
      this.book = book;
      this.hooks = {};
      this.hooks.display = new hook_default(this);
      this.hooks.serialize = new hook_default(this);
      this.hooks.content = new hook_default(this);
      this.hooks.unloaded = new hook_default(this);
      this.hooks.layout = new hook_default(this);
      this.hooks.render = new hook_default(this);
      this.hooks.show = new hook_default(this);
      this.hooks.content.register(this.handleLinks.bind(this));
      this.hooks.content.register(this.passEvents.bind(this));
      this.hooks.content.register(this.adjustImages.bind(this));
      this.book.spine.hooks.content.register(this.injectIdentifier.bind(this));
      if (this.settings.stylesheet) {
        this.book.spine.hooks.content.register(this.injectStylesheet.bind(this));
      }
      if (this.settings.script) {
        this.book.spine.hooks.content.register(this.injectScript.bind(this));
      }
      this.themes = new themes_default(this);
      this.annotations = new annotations_default(this);
      this.epubcfi = new epubcfi_default();
      this.q = new queue_default(this);
      this.location = void 0;
      this.q.enqueue(this.book.opened);
      this.starting = new defer();
      this.started = this.starting.promise;
      this.q.enqueue(this.start);
    }
    setManager(manager) {
      this.manager = manager;
    }
    requireManager(manager) {
      var viewManager;
      if (typeof manager === "string" && manager === "default") {
        viewManager = default_default;
      } else if (typeof manager === "string" && manager === "continuous") {
        viewManager = continuous_default;
      } else {
        viewManager = manager;
      }
      return viewManager;
    }
    requireView(view) {
      var View;
      if (typeof view == "string" && view === "iframe") {
        View = iframe_default;
      } else {
        View = view;
      }
      return View;
    }
    start() {
      if (!this.settings.layout && (this.book.package.metadata.layout === "pre-paginated" || this.book.displayOptions.fixedLayout === "true")) {
        this.settings.layout = "pre-paginated";
      }
      switch (this.book.package.metadata.spread) {
        case "none":
          this.settings.spread = "none";
          break;
        case "both":
          this.settings.spread = true;
          break;
      }
      if (!this.manager) {
        this.ViewManager = this.requireManager(this.settings.manager);
        this.View = this.requireView(this.settings.view);
        this.manager = new this.ViewManager({
          view: this.View,
          queue: this.q,
          request: this.book.load.bind(this.book),
          settings: this.settings
        });
      }
      this.direction(this.book.package.metadata.direction || this.settings.defaultDirection);
      this.settings.globalLayoutProperties = this.determineLayoutProperties(this.book.package.metadata);
      this.flow(this.settings.globalLayoutProperties.flow);
      this.layout(this.settings.globalLayoutProperties);
      this.manager.on(EVENTS.MANAGERS.ADDED, this.afterDisplayed.bind(this));
      this.manager.on(EVENTS.MANAGERS.REMOVED, this.afterRemoved.bind(this));
      this.manager.on(EVENTS.MANAGERS.RESIZED, this.onResized.bind(this));
      this.manager.on(EVENTS.MANAGERS.ORIENTATION_CHANGE, this.onOrientationChange.bind(this));
      this.manager.on(EVENTS.MANAGERS.SCROLLED, this.reportLocation.bind(this));
      this.emit(EVENTS.RENDITION.STARTED);
      this.starting.resolve();
    }
    attachTo(element) {
      return this.q.enqueue(function() {
        this.manager.render(element, {
          "width": this.settings.width,
          "height": this.settings.height
        });
        this.emit(EVENTS.RENDITION.ATTACHED);
      }.bind(this));
    }
    display(target) {
      if (this.displaying) {
        this.displaying.resolve();
      }
      return this.q.enqueue(this._display, target);
    }
    _display(target) {
      if (!this.book) {
        return;
      }
      var isCfiString = this.epubcfi.isCfiString(target);
      var displaying = new defer();
      var displayed = displaying.promise;
      var section;
      var moveTo;
      this.displaying = displaying;
      if (this.book.locations.length() && isFloat(target)) {
        target = this.book.locations.cfiFromPercentage(parseFloat(target));
      }
      section = this.book.spine.get(target);
      if (!section) {
        displaying.reject(new Error("No Section Found"));
        return displayed;
      }
      this.manager.display(section, target).then(() => {
        displaying.resolve(section);
        this.displaying = void 0;
        this.emit(EVENTS.RENDITION.DISPLAYED, section);
        this.reportLocation();
      }, (err) => {
        this.emit(EVENTS.RENDITION.DISPLAY_ERROR, err);
      });
      return displayed;
    }
    afterDisplayed(view) {
      view.on(EVENTS.VIEWS.MARK_CLICKED, (cfiRange, data) => this.triggerMarkEvent(cfiRange, data, view.contents));
      this.hooks.render.trigger(view, this).then(() => {
        if (view.contents) {
          this.hooks.content.trigger(view.contents, this).then(() => {
            this.emit(EVENTS.RENDITION.RENDERED, view.section, view);
          });
        } else {
          this.emit(EVENTS.RENDITION.RENDERED, view.section, view);
        }
      });
    }
    afterRemoved(view) {
      this.hooks.unloaded.trigger(view, this).then(() => {
        this.emit(EVENTS.RENDITION.REMOVED, view.section, view);
      });
    }
    onResized(size2, epubcfi) {
      this.emit(EVENTS.RENDITION.RESIZED, {
        width: size2.width,
        height: size2.height
      }, epubcfi);
      if (this.location && this.location.start) {
        this.display(epubcfi || this.location.start.cfi);
      }
    }
    onOrientationChange(orientation) {
      this.emit(EVENTS.RENDITION.ORIENTATION_CHANGE, orientation);
    }
    moveTo(offset) {
      this.manager.moveTo(offset);
    }
    resize(width, height, epubcfi) {
      if (width) {
        this.settings.width = width;
      }
      if (height) {
        this.settings.height = height;
      }
      this.manager.resize(width, height, epubcfi);
    }
    clear() {
      this.manager.clear();
    }
    next() {
      return this.q.enqueue(this.manager.next.bind(this.manager)).then(this.reportLocation.bind(this));
    }
    prev() {
      return this.q.enqueue(this.manager.prev.bind(this.manager)).then(this.reportLocation.bind(this));
    }
    determineLayoutProperties(metadata) {
      var properties;
      var layout = this.settings.layout || metadata.layout || "reflowable";
      var spread = this.settings.spread || metadata.spread || "auto";
      var orientation = this.settings.orientation || metadata.orientation || "auto";
      var flow = this.settings.flow || metadata.flow || "auto";
      var viewport = metadata.viewport || "";
      var minSpreadWidth = this.settings.minSpreadWidth || metadata.minSpreadWidth || 800;
      var direction = this.settings.direction || metadata.direction || "ltr";
      if ((this.settings.width === 0 || this.settings.width > 0) && (this.settings.height === 0 || this.settings.height > 0)) {
      }
      properties = {
        layout,
        spread,
        orientation,
        flow,
        viewport,
        minSpreadWidth,
        direction
      };
      return properties;
    }
    flow(flow) {
      var _flow = flow;
      if (flow === "scrolled" || flow === "scrolled-doc" || flow === "scrolled-continuous") {
        _flow = "scrolled";
      }
      if (flow === "auto" || flow === "paginated") {
        _flow = "paginated";
      }
      this.settings.flow = flow;
      if (this._layout) {
        this._layout.flow(_flow);
      }
      if (this.manager && this._layout) {
        this.manager.applyLayout(this._layout);
      }
      if (this.manager) {
        this.manager.updateFlow(_flow);
      }
      if (this.manager && this.manager.isRendered() && this.location) {
        this.manager.clear();
        this.display(this.location.start.cfi);
      }
    }
    layout(settings) {
      if (settings) {
        this._layout = new layout_default(settings);
        this._layout.spread(settings.spread, this.settings.minSpreadWidth);
        this._layout.on(EVENTS.LAYOUT.UPDATED, (props, changed) => {
          this.emit(EVENTS.RENDITION.LAYOUT, props, changed);
        });
      }
      if (this.manager && this._layout) {
        this.manager.applyLayout(this._layout);
      }
      return this._layout;
    }
    spread(spread, min) {
      this.settings.spread = spread;
      if (min) {
        this.settings.minSpreadWidth = min;
      }
      if (this._layout) {
        this._layout.spread(spread, min);
      }
      if (this.manager && this.manager.isRendered()) {
        this.manager.updateLayout();
      }
    }
    direction(dir) {
      this.settings.direction = dir || "ltr";
      if (this.manager) {
        this.manager.direction(this.settings.direction);
      }
      if (this.manager && this.manager.isRendered() && this.location) {
        this.manager.clear();
        this.display(this.location.start.cfi);
      }
    }
    reportLocation() {
      return this.q.enqueue(function reportedLocation() {
        requestAnimationFrame(function reportedLocationAfterRAF() {
          var location2 = this.manager.currentLocation();
          if (location2 && location2.then && typeof location2.then === "function") {
            location2.then(function(result) {
              let located = this.located(result);
              if (!located || !located.start || !located.end) {
                return;
              }
              this.location = located;
              this.emit(EVENTS.RENDITION.LOCATION_CHANGED, {
                index: this.location.start.index,
                href: this.location.start.href,
                start: this.location.start.cfi,
                end: this.location.end.cfi,
                percentage: this.location.start.percentage
              });
              this.emit(EVENTS.RENDITION.RELOCATED, this.location);
            }.bind(this));
          } else if (location2) {
            let located = this.located(location2);
            if (!located || !located.start || !located.end) {
              return;
            }
            this.location = located;
            this.emit(EVENTS.RENDITION.LOCATION_CHANGED, {
              index: this.location.start.index,
              href: this.location.start.href,
              start: this.location.start.cfi,
              end: this.location.end.cfi,
              percentage: this.location.start.percentage
            });
            this.emit(EVENTS.RENDITION.RELOCATED, this.location);
          }
        }.bind(this));
      }.bind(this));
    }
    currentLocation() {
      var location2 = this.manager.currentLocation();
      if (location2 && location2.then && typeof location2.then === "function") {
        location2.then(function(result) {
          let located = this.located(result);
          return located;
        }.bind(this));
      } else if (location2) {
        let located = this.located(location2);
        return located;
      }
    }
    located(location2) {
      if (!location2.length) {
        return {};
      }
      let start = location2[0];
      let end = location2[location2.length - 1];
      let located = {
        start: {
          index: start.index,
          href: start.href,
          cfi: start.mapping.start,
          displayed: {
            page: start.pages[0] || 1,
            total: start.totalPages
          }
        },
        end: {
          index: end.index,
          href: end.href,
          cfi: end.mapping.end,
          displayed: {
            page: end.pages[end.pages.length - 1] || 1,
            total: end.totalPages
          }
        }
      };
      let locationStart = this.book.locations.locationFromCfi(start.mapping.start);
      let locationEnd = this.book.locations.locationFromCfi(end.mapping.end);
      if (locationStart != null) {
        located.start.location = locationStart;
        located.start.percentage = this.book.locations.percentageFromLocation(locationStart);
      }
      if (locationEnd != null) {
        located.end.location = locationEnd;
        located.end.percentage = this.book.locations.percentageFromLocation(locationEnd);
      }
      let pageStart = this.book.pageList.pageFromCfi(start.mapping.start);
      let pageEnd = this.book.pageList.pageFromCfi(end.mapping.end);
      if (pageStart != -1) {
        located.start.page = pageStart;
      }
      if (pageEnd != -1) {
        located.end.page = pageEnd;
      }
      if (end.index === this.book.spine.last().index && located.end.displayed.page >= located.end.displayed.total) {
        located.atEnd = true;
      }
      if (start.index === this.book.spine.first().index && located.start.displayed.page === 1) {
        located.atStart = true;
      }
      return located;
    }
    destroy() {
      this.manager && this.manager.destroy();
      this.book = void 0;
    }
    passEvents(contents) {
      DOM_EVENTS.forEach((e) => {
        contents.on(e, (ev) => this.triggerViewEvent(ev, contents));
      });
      contents.on(EVENTS.CONTENTS.SELECTED, (e) => this.triggerSelectedEvent(e, contents));
    }
    triggerViewEvent(e, contents) {
      this.emit(e.type, e, contents);
    }
    triggerSelectedEvent(cfirange, contents) {
      this.emit(EVENTS.RENDITION.SELECTED, cfirange, contents);
    }
    triggerMarkEvent(cfiRange, data, contents) {
      this.emit(EVENTS.RENDITION.MARK_CLICKED, cfiRange, data, contents);
    }
    getRange(cfi, ignoreClass) {
      var _cfi = new epubcfi_default(cfi);
      var found = this.manager.visible().filter(function(view) {
        if (_cfi.spinePos === view.index)
          return true;
      });
      if (found.length) {
        return found[0].contents.range(_cfi, ignoreClass);
      }
    }
    adjustImages(contents) {
      if (this._layout.name === "pre-paginated") {
        return new Promise(function(resolve2) {
          resolve2();
        });
      }
      let computed3 = contents.window.getComputedStyle(contents.content, null);
      let height = (contents.content.offsetHeight - (parseFloat(computed3.paddingTop) + parseFloat(computed3.paddingBottom))) * 0.95;
      let horizontalPadding = parseFloat(computed3.paddingLeft) + parseFloat(computed3.paddingRight);
      contents.addStylesheetRules({
        "img": {
          "max-width": (this._layout.columnWidth ? this._layout.columnWidth - horizontalPadding + "px" : "100%") + "!important",
          "max-height": height + "px!important",
          "object-fit": "contain",
          "page-break-inside": "avoid",
          "break-inside": "avoid",
          "box-sizing": "border-box"
        },
        "svg": {
          "max-width": (this._layout.columnWidth ? this._layout.columnWidth - horizontalPadding + "px" : "100%") + "!important",
          "max-height": height + "px!important",
          "page-break-inside": "avoid",
          "break-inside": "avoid"
        }
      });
      return new Promise(function(resolve2, reject) {
        setTimeout(function() {
          resolve2();
        }, 1);
      });
    }
    getContents() {
      return this.manager ? this.manager.getContents() : [];
    }
    views() {
      let views = this.manager ? this.manager.views : void 0;
      return views || [];
    }
    handleLinks(contents) {
      if (contents) {
        contents.on(EVENTS.CONTENTS.LINK_CLICKED, (href) => {
          let relative = this.book.path.relative(href);
          this.display(relative);
        });
      }
    }
    injectStylesheet(doc2, section) {
      let style = doc2.createElement("link");
      style.setAttribute("type", "text/css");
      style.setAttribute("rel", "stylesheet");
      style.setAttribute("href", this.settings.stylesheet);
      doc2.getElementsByTagName("head")[0].appendChild(style);
    }
    injectScript(doc2, section) {
      let script = doc2.createElement("script");
      script.setAttribute("type", "text/javascript");
      script.setAttribute("src", this.settings.script);
      script.textContent = " ";
      doc2.getElementsByTagName("head")[0].appendChild(script);
    }
    injectIdentifier(doc2, section) {
      let ident = this.book.packaging.metadata.identifier;
      let meta = doc2.createElement("meta");
      meta.setAttribute("name", "dc.relation.ispartof");
      if (ident) {
        meta.setAttribute("content", ident);
      }
      doc2.getElementsByTagName("head")[0].appendChild(meta);
    }
  };
  (0, import_event_emitter8.default)(Rendition.prototype);
  var rendition_default = Rendition;

  // ../library_management/node_modules/epubjs/src/archive.js
  var import_jszip = __toESM(require_jszip());
  var Archive = class {
    constructor() {
      this.zip = void 0;
      this.urlCache = {};
      this.checkRequirements();
    }
    checkRequirements() {
      try {
        this.zip = new import_jszip.default();
      } catch (e) {
        throw new Error("JSZip lib not loaded");
      }
    }
    open(input, isBase64) {
      return this.zip.loadAsync(input, { "base64": isBase64 });
    }
    openUrl(zipUrl, isBase64) {
      return request_default(zipUrl, "binary").then(function(data) {
        return this.zip.loadAsync(data, { "base64": isBase64 });
      }.bind(this));
    }
    request(url, type2) {
      var deferred = new defer();
      var response;
      var path5 = new path_default(url);
      if (!type2) {
        type2 = path5.extension;
      }
      if (type2 == "blob") {
        response = this.getBlob(url);
      } else {
        response = this.getText(url);
      }
      if (response) {
        response.then(function(r) {
          let result = this.handleResponse(r, type2);
          deferred.resolve(result);
        }.bind(this));
      } else {
        deferred.reject({
          message: "File not found in the epub: " + url,
          stack: new Error().stack
        });
      }
      return deferred.promise;
    }
    handleResponse(response, type2) {
      var r;
      if (type2 == "json") {
        r = JSON.parse(response);
      } else if (isXml(type2)) {
        r = parse(response, "text/xml");
      } else if (type2 == "xhtml") {
        r = parse(response, "application/xhtml+xml");
      } else if (type2 == "html" || type2 == "htm") {
        r = parse(response, "text/html");
      } else {
        r = response;
      }
      return r;
    }
    getBlob(url, mimeType) {
      var decodededUrl = window.decodeURIComponent(url.substr(1));
      var entry = this.zip.file(decodededUrl);
      if (entry) {
        mimeType = mimeType || mime_default.lookup(entry.name);
        return entry.async("uint8array").then(function(uint8array) {
          return new Blob([uint8array], { type: mimeType });
        });
      }
    }
    getText(url, encoding) {
      var decodededUrl = window.decodeURIComponent(url.substr(1));
      var entry = this.zip.file(decodededUrl);
      if (entry) {
        return entry.async("string").then(function(text) {
          return text;
        });
      }
    }
    getBase64(url, mimeType) {
      var decodededUrl = window.decodeURIComponent(url.substr(1));
      var entry = this.zip.file(decodededUrl);
      if (entry) {
        mimeType = mimeType || mime_default.lookup(entry.name);
        return entry.async("base64").then(function(data) {
          return "data:" + mimeType + ";base64," + data;
        });
      }
    }
    createUrl(url, options) {
      var deferred = new defer();
      var _URL2 = window.URL || window.webkitURL || window.mozURL;
      var tempUrl;
      var response;
      var useBase64 = options && options.base64;
      if (url in this.urlCache) {
        deferred.resolve(this.urlCache[url]);
        return deferred.promise;
      }
      if (useBase64) {
        response = this.getBase64(url);
        if (response) {
          response.then(function(tempUrl2) {
            this.urlCache[url] = tempUrl2;
            deferred.resolve(tempUrl2);
          }.bind(this));
        }
      } else {
        response = this.getBlob(url);
        if (response) {
          response.then(function(blob) {
            tempUrl = _URL2.createObjectURL(blob);
            this.urlCache[url] = tempUrl;
            deferred.resolve(tempUrl);
          }.bind(this));
        }
      }
      if (!response) {
        deferred.reject({
          message: "File not found in the epub: " + url,
          stack: new Error().stack
        });
      }
      return deferred.promise;
    }
    revokeUrl(url) {
      var _URL2 = window.URL || window.webkitURL || window.mozURL;
      var fromCache = this.urlCache[url];
      if (fromCache)
        _URL2.revokeObjectURL(fromCache);
    }
    destroy() {
      var _URL2 = window.URL || window.webkitURL || window.mozURL;
      for (let fromCache in this.urlCache) {
        _URL2.revokeObjectURL(fromCache);
      }
      this.zip = void 0;
      this.urlCache = {};
    }
  };
  var archive_default = Archive;

  // ../library_management/node_modules/epubjs/src/store.js
  var import_event_emitter9 = __toESM(require_event_emitter());
  var import_localforage = __toESM(require_localforage());
  var Store = class {
    constructor(name, requester, resolver) {
      this.urlCache = {};
      this.storage = void 0;
      this.name = name;
      this.requester = requester || request_default;
      this.resolver = resolver;
      this.online = true;
      this.checkRequirements();
      this.addListeners();
    }
    checkRequirements() {
      try {
        let store;
        if (typeof import_localforage.default === "undefined") {
          store = import_localforage.default;
        }
        this.storage = store.createInstance({
          name: this.name
        });
      } catch (e) {
        throw new Error("localForage lib not loaded");
      }
    }
    addListeners() {
      this._status = this.status.bind(this);
      window.addEventListener("online", this._status);
      window.addEventListener("offline", this._status);
    }
    removeListeners() {
      window.removeEventListener("online", this._status);
      window.removeEventListener("offline", this._status);
      this._status = void 0;
    }
    status(event) {
      let online = navigator.onLine;
      this.online = online;
      if (online) {
        this.emit("online", this);
      } else {
        this.emit("offline", this);
      }
    }
    add(resources, force) {
      let mapped = resources.resources.map((item) => {
        let { href } = item;
        let url = this.resolver(href);
        let encodedUrl = window.encodeURIComponent(url);
        return this.storage.getItem(encodedUrl).then((item2) => {
          if (!item2 || force) {
            return this.requester(url, "binary").then((data) => {
              return this.storage.setItem(encodedUrl, data);
            });
          } else {
            return item2;
          }
        });
      });
      return Promise.all(mapped);
    }
    put(url, withCredentials, headers) {
      let encodedUrl = window.encodeURIComponent(url);
      return this.storage.getItem(encodedUrl).then((result) => {
        if (!result) {
          return this.requester(url, "binary", withCredentials, headers).then((data) => {
            return this.storage.setItem(encodedUrl, data);
          });
        }
        return result;
      });
    }
    request(url, type2, withCredentials, headers) {
      if (this.online) {
        return this.requester(url, type2, withCredentials, headers).then((data) => {
          this.put(url);
          return data;
        });
      } else {
        return this.retrieve(url, type2);
      }
    }
    retrieve(url, type2) {
      var deferred = new defer();
      var response;
      var path5 = new path_default(url);
      if (!type2) {
        type2 = path5.extension;
      }
      if (type2 == "blob") {
        response = this.getBlob(url);
      } else {
        response = this.getText(url);
      }
      return response.then((r) => {
        var deferred2 = new defer();
        var result;
        if (r) {
          result = this.handleResponse(r, type2);
          deferred2.resolve(result);
        } else {
          deferred2.reject({
            message: "File not found in storage: " + url,
            stack: new Error().stack
          });
        }
        return deferred2.promise;
      });
    }
    handleResponse(response, type2) {
      var r;
      if (type2 == "json") {
        r = JSON.parse(response);
      } else if (isXml(type2)) {
        r = parse(response, "text/xml");
      } else if (type2 == "xhtml") {
        r = parse(response, "application/xhtml+xml");
      } else if (type2 == "html" || type2 == "htm") {
        r = parse(response, "text/html");
      } else {
        r = response;
      }
      return r;
    }
    getBlob(url, mimeType) {
      let encodedUrl = window.encodeURIComponent(url);
      return this.storage.getItem(encodedUrl).then(function(uint8array) {
        if (!uint8array)
          return;
        mimeType = mimeType || mime_default.lookup(url);
        return new Blob([uint8array], { type: mimeType });
      });
    }
    getText(url, mimeType) {
      let encodedUrl = window.encodeURIComponent(url);
      mimeType = mimeType || mime_default.lookup(url);
      return this.storage.getItem(encodedUrl).then(function(uint8array) {
        var deferred = new defer();
        var reader = new FileReader();
        var blob;
        if (!uint8array)
          return;
        blob = new Blob([uint8array], { type: mimeType });
        reader.addEventListener("loadend", () => {
          deferred.resolve(reader.result);
        });
        reader.readAsText(blob, mimeType);
        return deferred.promise;
      });
    }
    getBase64(url, mimeType) {
      let encodedUrl = window.encodeURIComponent(url);
      mimeType = mimeType || mime_default.lookup(url);
      return this.storage.getItem(encodedUrl).then((uint8array) => {
        var deferred = new defer();
        var reader = new FileReader();
        var blob;
        if (!uint8array)
          return;
        blob = new Blob([uint8array], { type: mimeType });
        reader.addEventListener("loadend", () => {
          deferred.resolve(reader.result);
        });
        reader.readAsDataURL(blob, mimeType);
        return deferred.promise;
      });
    }
    createUrl(url, options) {
      var deferred = new defer();
      var _URL2 = window.URL || window.webkitURL || window.mozURL;
      var tempUrl;
      var response;
      var useBase64 = options && options.base64;
      if (url in this.urlCache) {
        deferred.resolve(this.urlCache[url]);
        return deferred.promise;
      }
      if (useBase64) {
        response = this.getBase64(url);
        if (response) {
          response.then(function(tempUrl2) {
            this.urlCache[url] = tempUrl2;
            deferred.resolve(tempUrl2);
          }.bind(this));
        }
      } else {
        response = this.getBlob(url);
        if (response) {
          response.then(function(blob) {
            tempUrl = _URL2.createObjectURL(blob);
            this.urlCache[url] = tempUrl;
            deferred.resolve(tempUrl);
          }.bind(this));
        }
      }
      if (!response) {
        deferred.reject({
          message: "File not found in storage: " + url,
          stack: new Error().stack
        });
      }
      return deferred.promise;
    }
    revokeUrl(url) {
      var _URL2 = window.URL || window.webkitURL || window.mozURL;
      var fromCache = this.urlCache[url];
      if (fromCache)
        _URL2.revokeObjectURL(fromCache);
    }
    destroy() {
      var _URL2 = window.URL || window.webkitURL || window.mozURL;
      for (let fromCache in this.urlCache) {
        _URL2.revokeObjectURL(fromCache);
      }
      this.urlCache = {};
      this.removeListeners();
    }
  };
  (0, import_event_emitter9.default)(Store.prototype);
  var store_default = Store;

  // ../library_management/node_modules/epubjs/src/displayoptions.js
  var DisplayOptions = class {
    constructor(displayOptionsDocument) {
      this.interactive = "";
      this.fixedLayout = "";
      this.openToSpread = "";
      this.orientationLock = "";
      if (displayOptionsDocument) {
        this.parse(displayOptionsDocument);
      }
    }
    parse(displayOptionsDocument) {
      if (!displayOptionsDocument) {
        return this;
      }
      const displayOptionsNode = qs(displayOptionsDocument, "display_options");
      if (!displayOptionsNode) {
        return this;
      }
      const options = qsa(displayOptionsNode, "option");
      options.forEach((el) => {
        let value = "";
        if (el.childNodes.length) {
          value = el.childNodes[0].nodeValue;
        }
        switch (el.attributes.name.value) {
          case "interactive":
            this.interactive = value;
            break;
          case "fixed-layout":
            this.fixedLayout = value;
            break;
          case "open-to-spread":
            this.openToSpread = value;
            break;
          case "orientation-lock":
            this.orientationLock = value;
            break;
        }
      });
      return this;
    }
    destroy() {
      this.interactive = void 0;
      this.fixedLayout = void 0;
      this.openToSpread = void 0;
      this.orientationLock = void 0;
    }
  };
  var displayoptions_default = DisplayOptions;

  // ../library_management/node_modules/epubjs/src/book.js
  var CONTAINER_PATH = "META-INF/container.xml";
  var IBOOKS_DISPLAY_OPTIONS_PATH = "META-INF/com.apple.ibooks.display-options.xml";
  var INPUT_TYPE = {
    BINARY: "binary",
    BASE64: "base64",
    EPUB: "epub",
    OPF: "opf",
    MANIFEST: "json",
    DIRECTORY: "directory"
  };
  var Book = class {
    constructor(url, options) {
      if (typeof options === "undefined" && typeof url !== "string" && url instanceof Blob === false && url instanceof ArrayBuffer === false) {
        options = url;
        url = void 0;
      }
      this.settings = extend2(this.settings || {}, {
        requestMethod: void 0,
        requestCredentials: void 0,
        requestHeaders: void 0,
        encoding: void 0,
        replacements: void 0,
        canonical: void 0,
        openAs: void 0,
        store: void 0
      });
      extend2(this.settings, options);
      this.opening = new defer();
      this.opened = this.opening.promise;
      this.isOpen = false;
      this.loading = {
        manifest: new defer(),
        spine: new defer(),
        metadata: new defer(),
        cover: new defer(),
        navigation: new defer(),
        pageList: new defer(),
        resources: new defer(),
        displayOptions: new defer()
      };
      this.loaded = {
        manifest: this.loading.manifest.promise,
        spine: this.loading.spine.promise,
        metadata: this.loading.metadata.promise,
        cover: this.loading.cover.promise,
        navigation: this.loading.navigation.promise,
        pageList: this.loading.pageList.promise,
        resources: this.loading.resources.promise,
        displayOptions: this.loading.displayOptions.promise
      };
      this.ready = Promise.all([
        this.loaded.manifest,
        this.loaded.spine,
        this.loaded.metadata,
        this.loaded.cover,
        this.loaded.navigation,
        this.loaded.resources,
        this.loaded.displayOptions
      ]);
      this.isRendered = false;
      this.request = this.settings.requestMethod || request_default;
      this.spine = new spine_default();
      this.locations = new locations_default(this.spine, this.load.bind(this));
      this.navigation = void 0;
      this.pageList = void 0;
      this.url = void 0;
      this.path = void 0;
      this.archived = false;
      this.archive = void 0;
      this.storage = void 0;
      this.resources = void 0;
      this.rendition = void 0;
      this.container = void 0;
      this.packaging = void 0;
      this.displayOptions = void 0;
      if (this.settings.store) {
        this.store(this.settings.store);
      }
      if (url) {
        this.open(url, this.settings.openAs).catch((error) => {
          var err = new Error("Cannot load book at " + url);
          this.emit(EVENTS.BOOK.OPEN_FAILED, err);
        });
      }
    }
    open(input, what) {
      var opening;
      var type2 = what || this.determineType(input);
      if (type2 === INPUT_TYPE.BINARY) {
        this.archived = true;
        this.url = new url_default("/", "");
        opening = this.openEpub(input);
      } else if (type2 === INPUT_TYPE.BASE64) {
        this.archived = true;
        this.url = new url_default("/", "");
        opening = this.openEpub(input, type2);
      } else if (type2 === INPUT_TYPE.EPUB) {
        this.archived = true;
        this.url = new url_default("/", "");
        opening = this.request(input, "binary", this.settings.requestCredentials, this.settings.requestHeaders).then(this.openEpub.bind(this));
      } else if (type2 == INPUT_TYPE.OPF) {
        this.url = new url_default(input);
        opening = this.openPackaging(this.url.Path.toString());
      } else if (type2 == INPUT_TYPE.MANIFEST) {
        this.url = new url_default(input);
        opening = this.openManifest(this.url.Path.toString());
      } else {
        this.url = new url_default(input);
        opening = this.openContainer(CONTAINER_PATH).then(this.openPackaging.bind(this));
      }
      return opening;
    }
    openEpub(data, encoding) {
      return this.unarchive(data, encoding || this.settings.encoding).then(() => {
        return this.openContainer(CONTAINER_PATH);
      }).then((packagePath) => {
        return this.openPackaging(packagePath);
      });
    }
    openContainer(url) {
      return this.load(url).then((xml) => {
        this.container = new container_default(xml);
        return this.resolve(this.container.packagePath);
      });
    }
    openPackaging(url) {
      this.path = new path_default(url);
      return this.load(url).then((xml) => {
        this.packaging = new packaging_default(xml);
        return this.unpack(this.packaging);
      });
    }
    openManifest(url) {
      this.path = new path_default(url);
      return this.load(url).then((json) => {
        this.packaging = new packaging_default();
        this.packaging.load(json);
        return this.unpack(this.packaging);
      });
    }
    load(path5) {
      var resolved = this.resolve(path5);
      if (this.archived) {
        return this.archive.request(resolved);
      } else {
        return this.request(resolved, null, this.settings.requestCredentials, this.settings.requestHeaders);
      }
    }
    resolve(path5, absolute) {
      if (!path5) {
        return;
      }
      var resolved = path5;
      var isAbsolute = path5.indexOf("://") > -1;
      if (isAbsolute) {
        return path5;
      }
      if (this.path) {
        resolved = this.path.resolve(path5);
      }
      if (absolute != false && this.url) {
        resolved = this.url.resolve(resolved);
      }
      return resolved;
    }
    canonical(path5) {
      var url = path5;
      if (!path5) {
        return "";
      }
      if (this.settings.canonical) {
        url = this.settings.canonical(path5);
      } else {
        url = this.resolve(path5, true);
      }
      return url;
    }
    determineType(input) {
      var url;
      var path5;
      var extension;
      if (this.settings.encoding === "base64") {
        return INPUT_TYPE.BASE64;
      }
      if (typeof input != "string") {
        return INPUT_TYPE.BINARY;
      }
      url = new url_default(input);
      path5 = url.path();
      extension = path5.extension;
      if (extension) {
        extension = extension.replace(/\?.*$/, "");
      }
      if (!extension) {
        return INPUT_TYPE.DIRECTORY;
      }
      if (extension === "epub") {
        return INPUT_TYPE.EPUB;
      }
      if (extension === "opf") {
        return INPUT_TYPE.OPF;
      }
      if (extension === "json") {
        return INPUT_TYPE.MANIFEST;
      }
    }
    unpack(packaging) {
      this.package = packaging;
      if (this.packaging.metadata.layout === "") {
        this.load(this.url.resolve(IBOOKS_DISPLAY_OPTIONS_PATH)).then((xml) => {
          this.displayOptions = new displayoptions_default(xml);
          this.loading.displayOptions.resolve(this.displayOptions);
        }).catch((err) => {
          this.displayOptions = new displayoptions_default();
          this.loading.displayOptions.resolve(this.displayOptions);
        });
      } else {
        this.displayOptions = new displayoptions_default();
        this.loading.displayOptions.resolve(this.displayOptions);
      }
      this.spine.unpack(this.packaging, this.resolve.bind(this), this.canonical.bind(this));
      this.resources = new resources_default(this.packaging.manifest, {
        archive: this.archive,
        resolver: this.resolve.bind(this),
        request: this.request.bind(this),
        replacements: this.settings.replacements || (this.archived ? "blobUrl" : "base64")
      });
      this.loadNavigation(this.packaging).then(() => {
        this.loading.navigation.resolve(this.navigation);
      });
      if (this.packaging.coverPath) {
        this.cover = this.resolve(this.packaging.coverPath);
      }
      this.loading.manifest.resolve(this.packaging.manifest);
      this.loading.metadata.resolve(this.packaging.metadata);
      this.loading.spine.resolve(this.spine);
      this.loading.cover.resolve(this.cover);
      this.loading.resources.resolve(this.resources);
      this.loading.pageList.resolve(this.pageList);
      this.isOpen = true;
      if (this.archived || this.settings.replacements && this.settings.replacements != "none") {
        this.replacements().then(() => {
          this.loaded.displayOptions.then(() => {
            this.opening.resolve(this);
          });
        }).catch((err) => {
          console.error(err);
        });
      } else {
        this.loaded.displayOptions.then(() => {
          this.opening.resolve(this);
        });
      }
    }
    loadNavigation(packaging) {
      let navPath = packaging.navPath || packaging.ncxPath;
      let toc = packaging.toc;
      if (toc) {
        return new Promise((resolve2, reject) => {
          this.navigation = new navigation_default(toc);
          if (packaging.pageList) {
            this.pageList = new pagelist_default(packaging.pageList);
          }
          resolve2(this.navigation);
        });
      }
      if (!navPath) {
        return new Promise((resolve2, reject) => {
          this.navigation = new navigation_default();
          this.pageList = new pagelist_default();
          resolve2(this.navigation);
        });
      }
      return this.load(navPath, "xml").then((xml) => {
        this.navigation = new navigation_default(xml);
        this.pageList = new pagelist_default(xml);
        return this.navigation;
      });
    }
    section(target) {
      return this.spine.get(target);
    }
    renderTo(element, options) {
      this.rendition = new rendition_default(this, options);
      this.rendition.attachTo(element);
      return this.rendition;
    }
    setRequestCredentials(credentials) {
      this.settings.requestCredentials = credentials;
    }
    setRequestHeaders(headers) {
      this.settings.requestHeaders = headers;
    }
    unarchive(input, encoding) {
      this.archive = new archive_default();
      return this.archive.open(input, encoding);
    }
    store(name) {
      let replacementsSetting = this.settings.replacements && this.settings.replacements !== "none";
      let originalUrl = this.url;
      let requester = this.settings.requestMethod || request_default.bind(this);
      this.storage = new store_default(name, requester, this.resolve.bind(this));
      this.request = this.storage.request.bind(this.storage);
      this.opened.then(() => {
        if (this.archived) {
          this.storage.requester = this.archive.request.bind(this.archive);
        }
        let substituteResources = (output, section) => {
          section.output = this.resources.substitute(output, section.url);
        };
        this.resources.settings.replacements = replacementsSetting || "blobUrl";
        this.resources.replacements().then(() => {
          return this.resources.replaceCss();
        });
        this.storage.on("offline", () => {
          this.url = new url_default("/", "");
          this.spine.hooks.serialize.register(substituteResources);
        });
        this.storage.on("online", () => {
          this.url = originalUrl;
          this.spine.hooks.serialize.deregister(substituteResources);
        });
      });
      return this.storage;
    }
    coverUrl() {
      return this.loaded.cover.then(() => {
        if (!this.cover) {
          return null;
        }
        if (this.archived) {
          return this.archive.createUrl(this.cover);
        } else {
          return this.cover;
        }
      });
    }
    replacements() {
      this.spine.hooks.serialize.register((output, section) => {
        section.output = this.resources.substitute(output, section.url);
      });
      return this.resources.replacements().then(() => {
        return this.resources.replaceCss();
      });
    }
    getRange(cfiRange) {
      var cfi = new epubcfi_default(cfiRange);
      var item = this.spine.get(cfi.spinePos);
      var _request = this.load.bind(this);
      if (!item) {
        return new Promise((resolve2, reject) => {
          reject("CFI could not be found");
        });
      }
      return item.load(_request).then(function(contents) {
        var range = cfi.toRange(item.document);
        return range;
      });
    }
    key(identifier) {
      var ident = identifier || this.packaging.metadata.identifier || this.url.filename;
      return `epubjs:${EPUBJS_VERSION}:${ident}`;
    }
    destroy() {
      this.opened = void 0;
      this.loading = void 0;
      this.loaded = void 0;
      this.ready = void 0;
      this.isOpen = false;
      this.isRendered = false;
      this.spine && this.spine.destroy();
      this.locations && this.locations.destroy();
      this.pageList && this.pageList.destroy();
      this.archive && this.archive.destroy();
      this.resources && this.resources.destroy();
      this.container && this.container.destroy();
      this.packaging && this.packaging.destroy();
      this.rendition && this.rendition.destroy();
      this.displayOptions && this.displayOptions.destroy();
      this.spine = void 0;
      this.locations = void 0;
      this.pageList = void 0;
      this.archive = void 0;
      this.resources = void 0;
      this.container = void 0;
      this.packaging = void 0;
      this.rendition = void 0;
      this.navigation = void 0;
      this.url = void 0;
      this.path = void 0;
      this.archived = false;
    }
  };
  (0, import_event_emitter10.default)(Book.prototype);
  var book_default = Book;

  // ../library_management/node_modules/epubjs/src/epub.js
  function ePub(url, options) {
    return new book_default(url, options);
  }
  ePub.VERSION = EPUBJS_VERSION;
  if (typeof global !== "undefined") {
    global.EPUBJS_VERSION = EPUBJS_VERSION;
  }
  ePub.Book = book_default;
  ePub.Rendition = rendition_default;
  ePub.Contents = contents_default;
  ePub.CFI = epubcfi_default;
  ePub.utils = core_exports;

  // sfc-script:/home/dev2/projects/v15/apps/library_management/library_management/public/js/ebook_reader/components/EpubTitlebar.vue?type=script
  var EpubTitlebar_default = {
    name: "EpubTitlebar",
    props: {
      title: {
        default: "Libms",
        type: String
      }
    },
    data() {
      return {
        isfullScreen: false
      };
    },
    mounted() {
      document.addEventListener("fullscreenchange", this.handleFullscreenChange);
    },
    beforeUnmount() {
      document.removeEventListener("fullscreenchange", this.handleFullscreenChange);
    },
    methods: {
      CloseReader() {
        if (document.isFullscreen) {
          document.exitFullscreen();
        }
        this.$emit("close-reader");
      },
      toggleFullscreen() {
        const reader_container = document.querySelector(".v-overlay-container");
        if (reader_container) {
          if (!document.fullscreenElement) {
            reader_container.requestFullscreen().then(() => {
              this.isfullScreen = true;
            }).catch((err) => {
              console.error(`Error attempting to enable fullscreen mode: ${err.message} (${err.name})`);
            });
          } else {
            document.exitFullscreen().then(() => {
              this.isfullScreen = false;
            }).catch((err) => {
              console.error(`Error attempting to exit fullscreen mode: ${err.message} (${err.name})`);
            });
          }
        }
      },
      handleFullscreenChange() {
        this.isFullscreen = !!document.fullscreenElement;
      }
    }
  };

  // sfc-template:/home/dev2/projects/v15/apps/library_management/library_management/public/js/ebook_reader/components/EpubTitlebar.vue?type=template
  function render2(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_app_bar_nav_icon = resolveComponent("v-app-bar-nav-icon");
    const _component_v_spacer = resolveComponent("v-spacer");
    const _component_v_toolbar_title = resolveComponent("v-toolbar-title");
    const _component_v_icon = resolveComponent("v-icon");
    const _component_v_btn = resolveComponent("v-btn");
    const _component_v_toolbar = resolveComponent("v-toolbar");
    return openBlock(), createBlock(_component_v_toolbar, { density: "compact" }, {
      default: withCtx(() => [
        createVNode(_component_v_app_bar_nav_icon),
        createVNode(_component_v_spacer),
        createVNode(_component_v_spacer),
        createVNode(_component_v_toolbar_title, null, {
          default: withCtx(() => [
            createTextVNode(toDisplayString($props.title), 1)
          ]),
          _: 1
        }),
        createVNode(_component_v_spacer),
        createVNode(_component_v_btn, { icon: "" }, {
          default: withCtx(() => [
            createVNode(_component_v_icon, null, {
              default: withCtx(() => [
                createTextVNode("mdi-crosshairs-gps")
              ]),
              _: 1
            })
          ]),
          _: 1
        }),
        createVNode(_component_v_btn, { icon: "" }, {
          default: withCtx(() => [
            createVNode(_component_v_icon, null, {
              default: withCtx(() => [
                createTextVNode("mdi-dots-vertical")
              ]),
              _: 1
            })
          ]),
          _: 1
        }),
        createVNode(_component_v_btn, {
          icon: "",
          onClick: $options.toggleFullscreen
        }, {
          default: withCtx(() => [
            createVNode(_component_v_icon, null, {
              default: withCtx(() => [
                createTextVNode(toDisplayString($data.isfullScreen ? "mdi-window-minimize" : "mdi-window-maximize"), 1)
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["onClick"]),
        createVNode(_component_v_btn, {
          icon: "",
          small: "",
          onClick: $options.CloseReader
        }, {
          default: withCtx(() => [
            createVNode(_component_v_icon, null, {
              default: withCtx(() => [
                createTextVNode("mdi-close")
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["onClick"])
      ]),
      _: 1
    });
  }

  // ../library_management/library_management/public/js/ebook_reader/components/EpubTitlebar.vue
  EpubTitlebar_default.render = render2;
  EpubTitlebar_default.__file = "../library_management/library_management/public/js/ebook_reader/components/EpubTitlebar.vue";
  EpubTitlebar_default.__scopeId = "data-v-66b69e18";
  var EpubTitlebar_default2 = EpubTitlebar_default;

  // sfc-script:/home/dev2/projects/v15/apps/library_management/library_management/public/js/ebook_reader/components/EpubReader.vue?type=script
  var EpubReader_default = {
    name: "EpubReader",
    components: {
      EpubTitlebar: EpubTitlebar_default2
    },
    props: {
      book: {
        type: Object,
        required: true
      }
    },
    data() {
      return {
        show: false,
        url: "",
        bookInstance: null,
        rendition: null,
        page: 1,
        totalPages: 0,
        manualPage: ""
      };
    },
    watch: {
      page(newVal) {
        this.manualPage = newVal.toString();
        this.updatePlaceholder();
      }
    },
    methods: {
      async loadEPUB() {
        if (this.book && this.book.book_url) {
          try {
            this.url = frappe.urllib.get_full_url(this.book.book_url);
            this.bookInstance = new book_default(this.url);
            await this.bookInstance.ready;
            this.rendition = new rendition_default(this.bookInstance, {
              width: "100%",
              height: "100%"
            });
            this.rendition.attachTo("epub-render-area");
            this.rendition.display();
            this.totalPages = this.bookInstance.spine.length;
            this.show = true;
          } catch (error) {
            console.error("Error loading book:", error);
          }
        }
      },
      nextPage() {
        if (this.book.type === "epub" && this.rendition) {
          this.page++;
          this.rendition.next();
          this.updatePlaceholder();
        }
      },
      previousPage() {
        if (this.book.type === "epub" && this.rendition) {
          this.page--;
          this.rendition.prev();
          this.updatePlaceholder();
        }
      },
      navigateToPage(pageNum) {
        pageNum = parseInt(pageNum, 10);
        if (pageNum && pageNum >= 1 && pageNum <= this.totalPages) {
          this.page = pageNum;
          this.rendition.display(this.page);
          this.updatePlaceholder();
        }
      },
      updatePlaceholder() {
        this.manualPage = `${this.page}/${this.totalPages}`;
      },
      closeReader() {
        if (document.fullscreenElement) {
          document.exitFullscreen();
        }
        this.show = false;
        this.$emit("close-reader");
      }
    },
    created() {
      this.loadEPUB();
    }
  };

  // sfc-template:/home/dev2/projects/v15/apps/library_management/library_management/public/js/ebook_reader/components/EpubReader.vue?type=template
  var _hoisted_1 = {
    key: 0,
    id: "epub-render-area",
    style: { "height": "calc(80vh - 80px)" }
  };
  var _hoisted_2 = { class: "d-flex justify-center align-items-center" };
  function render3(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_EpubTitlebar = resolveComponent("EpubTitlebar");
    const _component_v_app_bar = resolveComponent("v-app-bar");
    const _component_v_icon = resolveComponent("v-icon");
    const _component_v_btn = resolveComponent("v-btn");
    const _component_v_col = resolveComponent("v-col");
    const _component_v_card_text = resolveComponent("v-card-text");
    const _component_v_card = resolveComponent("v-card");
    const _component_v_row = resolveComponent("v-row");
    const _component_v_main = resolveComponent("v-main");
    const _component_v_spacer = resolveComponent("v-spacer");
    const _component_v_text_field = resolveComponent("v-text-field");
    const _component_v_bottom_navigation = resolveComponent("v-bottom-navigation");
    const _component_v_app = resolveComponent("v-app");
    const _component_v_dialog = resolveComponent("v-dialog");
    return openBlock(), createBlock(_component_v_dialog, {
      modelValue: $data.show,
      "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.show = $event),
      fullscreen: "",
      "hide-overlay": ""
    }, {
      default: withCtx(() => [
        createVNode(_component_v_app, null, {
          default: withCtx(() => [
            createVNode(_component_v_app_bar, {
              dense: "",
              elevatedwill: ""
            }, {
              default: withCtx(() => [
                createVNode(_component_EpubTitlebar, {
                  title: $props.book.title,
                  onCloseReader: $options.closeReader
                }, null, 8, ["title", "onCloseReader"])
              ]),
              _: 1
            }),
            createVNode(_component_v_main, null, {
              default: withCtx(() => [
                createVNode(_component_v_row, null, {
                  default: withCtx(() => [
                    createVNode(_component_v_col, { class: "d-flex justify-start align-items-center" }, {
                      default: withCtx(() => [
                        createVNode(_component_v_btn, {
                          icon: "",
                          onClick: $options.previousPage
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_icon, null, {
                              default: withCtx(() => [
                                createTextVNode("mdi-chevron-left")
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        }, 8, ["onClick"])
                      ]),
                      _: 1
                    }),
                    createVNode(_component_v_col, { class: "align-items-center" }, {
                      default: withCtx(() => [
                        createVNode(_component_v_card, {
                          class: "mx-auto mt-8",
                          "max-width": "1000",
                          "max-height": "800",
                          hover: ""
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_card_text, null, {
                              default: withCtx(() => [
                                $props.book.type === "epub" ? (openBlock(), createElementBlock("div", _hoisted_1)) : createCommentVNode("v-if", true)
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    createVNode(_component_v_col, { class: "d-flex justify-end align-items-center" }, {
                      default: withCtx(() => [
                        createVNode(_component_v_btn, {
                          icon: "",
                          onClick: $options.nextPage
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_icon, null, {
                              default: withCtx(() => [
                                createTextVNode("mdi-chevron-right")
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        }, 8, ["onClick"])
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }),
            createVNode(_component_v_bottom_navigation, { class: "bg-light" }, {
              default: withCtx(() => [
                createVNode(_component_v_spacer),
                createBaseVNode("div", _hoisted_2, [
                  createVNode(_component_v_btn, {
                    icon: "",
                    onClick: $options.previousPage
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_v_icon, null, {
                        default: withCtx(() => [
                          createTextVNode("mdi-arrow-left")
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["onClick"]),
                  createVNode(_component_v_text_field, {
                    modelValue: $data.manualPage,
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.manualPage = $event),
                    onKeyup: _cache[1] || (_cache[1] = withKeys(($event) => $options.navigateToPage($data.manualPage), ["enter"])),
                    onMouseleave: $options.updatePlaceholder,
                    class: "mx-2 page-input-field",
                    min: "1",
                    max: $data.totalPages,
                    outlined: "",
                    dense: "",
                    small: ""
                  }, null, 8, ["modelValue", "onMouseleave", "max"]),
                  createVNode(_component_v_btn, {
                    icon: "",
                    onClick: $options.nextPage
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_v_icon, null, {
                        default: withCtx(() => [
                          createTextVNode("mdi-arrow-right")
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["onClick"])
                ]),
                createVNode(_component_v_spacer)
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["modelValue"]);
  }

  // ../library_management/library_management/public/js/ebook_reader/components/EpubReader.vue
  EpubReader_default.render = render3;
  EpubReader_default.__file = "../library_management/library_management/public/js/ebook_reader/components/EpubReader.vue";
  EpubReader_default.__scopeId = "data-v-a7e9f2db";
  var EpubReader_default2 = EpubReader_default;

  // sfc-script:/home/dev2/projects/v15/apps/library_management/library_management/public/js/ebook_reader/components/PdfTitlebar.vue?type=script
  var PdfTitlebar_default = {
    name: "PdfTitlebar",
    props: {
      title: {
        default: "Libms",
        type: String
      }
    },
    data() {
      return {
        isfullScreen: false
      };
    },
    mounted() {
      document.addEventListener("fullscreenchange", this.handleFullscreenChange);
    },
    beforeUnmount() {
      document.removeEventListener("fullscreenchange", this.handleFullscreenChange);
    },
    methods: {
      CloseReader() {
        if (document.fullscreenElement) {
          document.exitFullscreen();
        }
        this.$emit("close-reader");
      },
      toggleFullscreen() {
        const reader_container = document.querySelector(".v-overlay-container");
        if (reader_container) {
          if (!document.fullscreenElement) {
            reader_container.requestFullscreen().then(() => {
              this.isfullScreen = true;
            }).catch((err) => {
              console.error(`Error attempting to enable fullscreen mode: ${err.message} (${err.name})`);
            });
          } else {
            document.exitFullscreen().then(() => {
              this.isfullScreen = false;
            }).catch((err) => {
              console.error(`Error attempting to exit fullscreen mode: ${err.message} (${err.name})`);
            });
          }
        }
      },
      handleFullscreenChange() {
        this.isFullscreen = !!document.fullscreenElement;
      }
    }
  };

  // sfc-template:/home/dev2/projects/v15/apps/library_management/library_management/public/js/ebook_reader/components/PdfTitlebar.vue?type=template
  function render4(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_app_bar_nav_icon = resolveComponent("v-app-bar-nav-icon");
    const _component_v_tooltip = resolveComponent("v-tooltip");
    const _component_v_spacer = resolveComponent("v-spacer");
    const _component_v_toolbar_title = resolveComponent("v-toolbar-title");
    const _component_v_icon = resolveComponent("v-icon");
    const _component_v_btn = resolveComponent("v-btn");
    const _component_v_toolbar = resolveComponent("v-toolbar");
    return openBlock(), createBlock(_component_v_toolbar, {
      density: "compact",
      flat: ""
    }, {
      prepend: withCtx(() => [
        createVNode(_component_v_app_bar_nav_icon, {
          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("toggle-toc"))
        }),
        createVNode(_component_v_tooltip, {
          activator: "parent",
          location: "bottom"
        }, {
          default: withCtx(() => [
            createTextVNode("Table of Content")
          ]),
          _: 1
        })
      ]),
      default: withCtx(() => [
        createVNode(_component_v_spacer),
        createVNode(_component_v_spacer),
        createVNode(_component_v_toolbar_title, null, {
          default: withCtx(() => [
            createTextVNode(toDisplayString($props.title), 1)
          ]),
          _: 1
        }),
        createVNode(_component_v_spacer),
        createVNode(_component_v_btn, { icon: "" }, {
          default: withCtx(() => [
            createVNode(_component_v_icon, null, {
              default: withCtx(() => [
                createTextVNode("mdi-crosshairs-gps")
              ]),
              _: 1
            }),
            createVNode(_component_v_tooltip, {
              activator: "parent",
              location: "bottom"
            }, {
              default: withCtx(() => [
                createTextVNode("Theme")
              ]),
              _: 1
            })
          ]),
          _: 1
        }),
        createVNode(_component_v_btn, { icon: "" }, {
          default: withCtx(() => [
            createVNode(_component_v_icon, null, {
              default: withCtx(() => [
                createTextVNode("mdi-dots-vertical")
              ]),
              _: 1
            })
          ]),
          _: 1
        }),
        createVNode(_component_v_btn, {
          icon: "",
          onClick: $options.toggleFullscreen
        }, {
          default: withCtx(() => [
            createVNode(_component_v_icon, null, {
              default: withCtx(() => [
                createTextVNode(toDisplayString($data.isfullScreen ? "mdi-window-minimize" : "mdi-window-maximize"), 1)
              ]),
              _: 1
            }),
            $data.isfullScreen ? (openBlock(), createBlock(_component_v_tooltip, {
              key: 0,
              activator: "parent",
              location: "bottom"
            }, {
              default: withCtx(() => [
                createTextVNode("Exit Full Screen")
              ]),
              _: 1
            })) : !$data.isfullScreen ? (openBlock(), createBlock(_component_v_tooltip, {
              key: 1,
              activator: "parent",
              location: "bottom"
            }, {
              default: withCtx(() => [
                createTextVNode("Go Full Screen")
              ]),
              _: 1
            })) : createCommentVNode("v-if", true)
          ]),
          _: 1
        }, 8, ["onClick"]),
        createVNode(_component_v_btn, {
          icon: "",
          small: "",
          onClick: $options.CloseReader
        }, {
          default: withCtx(() => [
            createVNode(_component_v_icon, null, {
              default: withCtx(() => [
                createTextVNode("mdi-close")
              ]),
              _: 1
            }),
            createVNode(_component_v_tooltip, {
              activator: "parent",
              location: "bottom"
            }, {
              default: withCtx(() => [
                createTextVNode("Close")
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["onClick"])
      ]),
      _: 1
    });
  }

  // ../library_management/library_management/public/js/ebook_reader/components/PdfTitlebar.vue
  PdfTitlebar_default.render = render4;
  PdfTitlebar_default.__file = "../library_management/library_management/public/js/ebook_reader/components/PdfTitlebar.vue";
  PdfTitlebar_default.__scopeId = "data-v-51668b80";
  var PdfTitlebar_default2 = PdfTitlebar_default;

  // sfc-script:/home/dev2/projects/v15/apps/library_management/library_management/public/js/ebook_reader/components/PdfReader.vue?type=script
  var PdfReader_default = {
    name: "PdfReader",
    components: {
      PdfTitlebar: PdfTitlebar_default2
    },
    props: {
      book: {
        type: Object,
        required: true
      }
    },
    data() {
      return {
        show: false,
        url: "",
        bookInstance: null,
        rendition: null,
        pdfDoc: null,
        page: 1,
        totalPages: 0,
        toc: [],
        isTocVisible: false,
        manualPage: "",
        scale: 0.5,
        showToc: ["Toc"]
      };
    },
    watch: {
      page(newVal) {
        this.manualPage = newVal.toString();
        this.updatePlaceholder();
      }
    },
    methods: {
      async loadPdf() {
        try {
          this.url = frappe.urllib.get_full_url(this.book.book_url);
          const loadingTask = pdfjsLib.getDocument(this.url);
          this.pdfDoc = await loadingTask.promise;
          this.totalPages = this.pdfDoc.numPages;
          this.loadToc();
          this.renderPage();
          this.updatePlaceholder();
          this.show = true;
        } catch (error) {
          console.error("Error loading PDF:", error);
        }
      },
      async renderPage() {
        try {
          const page = await this.pdfDoc.getPage(this.page);
          const canvas = document.getElementById("pdf-canvas");
          const context = canvas.getContext("2d");
          const container = canvas.parentElement;
          const containerWidth = container.clientWidth;
          const viewport = page.getViewport({ scale: this.scale });
          const scale = containerWidth / viewport.width;
          const scaledViewport = page.getViewport({ scale });
          canvas.width = scaledViewport.width;
          canvas.height = scaledViewport.height;
          const renderContext = {
            canvasContext: context,
            viewport: scaledViewport
          };
          await page.render(renderContext).promise;
        } catch (error) {
          console.error("Error rendering page:", error);
        }
      },
      async loadToc() {
        const outline = await this.pdfDoc.getOutline();
        if (outline) {
          this.toc = await this.parseOutlineItems(outline);
        }
      },
      async parseOutlineItems(items, result = []) {
        for (const item of items) {
          if (item.dest) {
            try {
              let pageNumber = null;
              if (typeof item.dest === "string") {
                const destination = await this.pdfDoc.getDestination(item.dest);
                if (destination) {
                  if (typeof destination === "string") {
                    const destRef = await this.pdfDoc.getDestination(destination[0]);
                    pageNumber = destRef ? await this.pdfDoc.getPageIndex(destRef[0]) + 1 : null;
                  } else if (destination instanceof Array && destination[0]) {
                    pageNumber = await this.pdfDoc.getPageIndex(destination[0]) + 1;
                  }
                }
              } else if (item.dest instanceof Array && item.dest[0]) {
                pageNumber = await this.pdfDoc.getPageIndex(item.dest[0]) + 1;
              }
              result.push({
                id: item.dest,
                title: item.title.trim(),
                pageNumber
              });
            } catch (error) {
              result.push({
                id: item.dest,
                title: item.title.trim(),
                pageNumber: null
              });
            }
          }
          if (item.items.length) {
            await this.parseOutlineItems(item.items, result);
          }
        }
        return result;
      },
      navigateToPage(pageNum) {
        pageNum = parseInt(pageNum, 10);
        if (pageNum && pageNum >= 1 && pageNum <= this.totalPages) {
          this.page = pageNum;
          this.renderPage();
          this.updatePlaceholder();
        }
      },
      updatePlaceholder() {
        this.manualPage = `${this.page}/${this.totalPages}`;
      },
      nextPage() {
        if (this.book.type === "pdf" && this.page < this.totalPages) {
          this.page++;
          this.renderPage();
          this.updatePlaceholder();
        }
      },
      previousPage() {
        if (this.book.type === "pdf" && this.page > 1) {
          this.page--;
          this.renderPage();
          this.updatePlaceholder();
        }
      },
      closeReader() {
        if (document.fullscreenElement) {
          document.exitFullscreen();
        }
        this.show = false;
        this.$emit("close-reader");
      },
      toggleToc() {
        this.isTocVisible = !this.isTocVisible;
      },
      zoomIn() {
        const pdfCanvas = document.querySelector("#pdf-canvas");
        pdfCanvas.style.width = `${pdfCanvas.offsetWidth * 1.1}px`;
        pdfCanvas.style.height = `${pdfCanvas.offsetHeight * 1.1}px`;
      },
      zoomOut() {
        const pdfCanvas = document.querySelector("#pdf-canvas");
        pdfCanvas.style.width = `${pdfCanvas.offsetWidth / 1.1}px`;
        pdfCanvas.style.height = `${pdfCanvas.offsetHeight / 1.1}px`;
      }
    },
    created() {
      this.loadPdf();
    }
  };

  // sfc-template:/home/dev2/projects/v15/apps/library_management/library_management/public/js/ebook_reader/components/PdfReader.vue?type=template
  var _withScopeId = (n) => (pushScopeId("data-v-64b5f53b"), n = n(), popScopeId(), n);
  var _hoisted_12 = { class: "pdf-container" };
  var _hoisted_22 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("canvas", { id: "pdf-canvas" }, null, -1));
  var _hoisted_3 = { class: "d-flex justify-center align-items-center" };
  var _hoisted_4 = { class: "d-flex justify-end align-items-right" };
  function render5(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_PdfTitlebar = resolveComponent("PdfTitlebar");
    const _component_v_app_bar = resolveComponent("v-app-bar");
    const _component_v_btn = resolveComponent("v-btn");
    const _component_v_tooltip = resolveComponent("v-tooltip");
    const _component_v_list_item = resolveComponent("v-list-item");
    const _component_v_list_item_title = resolveComponent("v-list-item-title");
    const _component_v_list_group = resolveComponent("v-list-group");
    const _component_v_list = resolveComponent("v-list");
    const _component_v_navigation_drawer = resolveComponent("v-navigation-drawer");
    const _component_v_col = resolveComponent("v-col");
    const _component_v_icon = resolveComponent("v-icon");
    const _component_v_card = resolveComponent("v-card");
    const _component_v_row = resolveComponent("v-row");
    const _component_v_main = resolveComponent("v-main");
    const _component_v_spacer = resolveComponent("v-spacer");
    const _component_v_text_field = resolveComponent("v-text-field");
    const _component_v_bottom_navigation = resolveComponent("v-bottom-navigation");
    const _component_v_app = resolveComponent("v-app");
    const _component_v_dialog = resolveComponent("v-dialog");
    return openBlock(), createBlock(_component_v_dialog, {
      modelValue: $data.show,
      "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $data.show = $event),
      fullscreen: "",
      "hide-overlay": ""
    }, {
      default: withCtx(() => [
        createVNode(_component_v_app, null, {
          default: withCtx(() => [
            createVNode(_component_v_app_bar, {
              dense: "",
              elevatedwill: ""
            }, {
              default: withCtx(() => [
                createVNode(_component_PdfTitlebar, {
                  title: $props.book.title,
                  onCloseReader: $options.closeReader,
                  onToggleToc: $options.toggleToc
                }, null, 8, ["title", "onCloseReader", "onToggleToc"])
              ]),
              _: 1
            }),
            createVNode(_component_v_main, null, {
              default: withCtx(() => [
                createVNode(_component_v_row, null, {
                  default: withCtx(() => [
                    $data.isTocVisible ? (openBlock(), createBlock(_component_v_col, {
                      key: 0,
                      cols: "2",
                      hover: "",
                      class: "d-flex justify-start align-items-left"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_v_navigation_drawer, {
                          permanent: "",
                          class: "deep-purple lighten-1 white--text",
                          width: "300"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_list, {
                              opened: $data.showToc,
                              "onUpdate:opened": _cache[0] || (_cache[0] = ($event) => $data.showToc = $event),
                              lines: false,
                              density: "compact",
                              dense: "",
                              nav: ""
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_v_list_group, { value: "Toc" }, {
                                  activator: withCtx(({ props }) => [
                                    createVNode(_component_v_list_item, mergeProps(props, { title: "Table of Content" }), {
                                      prepend: withCtx(() => [
                                        createVNode(_component_v_btn, {
                                          icon: "mdi-table-of-contents",
                                          size: "large",
                                          variant: "text"
                                        }),
                                        createVNode(_component_v_tooltip, {
                                          activator: "parent",
                                          location: "bottom"
                                        }, {
                                          default: withCtx(() => [
                                            createTextVNode("Content")
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      _: 2
                                    }, 1040)
                                  ]),
                                  default: withCtx(() => [
                                    (openBlock(true), createElementBlock(Fragment, null, renderList($data.toc, (item, index) => {
                                      return openBlock(), createBlock(_component_v_list_item, {
                                        key: item.id,
                                        onClick: ($event) => $options.navigateToPage(item.pageNumber),
                                        link: ""
                                      }, {
                                        default: withCtx(() => [
                                          createVNode(_component_v_list_item_title, { class: "wrap-text" }, {
                                            default: withCtx(() => [
                                              createTextVNode(toDisplayString(index + 1) + ". " + toDisplayString(item.title) + " ", 1),
                                              createCommentVNode(" ------- {{ item.pageNumber }} ")
                                            ]),
                                            _: 2
                                          }, 1024)
                                        ]),
                                        _: 2
                                      }, 1032, ["onClick"]);
                                    }), 128))
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 1
                            }, 8, ["opened"])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })) : createCommentVNode("v-if", true),
                    createVNode(_component_v_col, { class: "d-flex justify-start align-items-center" }, {
                      default: withCtx(() => [
                        createVNode(_component_v_btn, {
                          icon: "",
                          onClick: $options.previousPage
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_icon, null, {
                              default: withCtx(() => [
                                createTextVNode("mdi-chevron-left")
                              ]),
                              _: 1
                            }),
                            createVNode(_component_v_tooltip, {
                              activator: "parent",
                              location: "top"
                            }, {
                              default: withCtx(() => [
                                createTextVNode("Previous Page")
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        }, 8, ["onClick"])
                      ]),
                      _: 1
                    }),
                    createVNode(_component_v_col, { class: "justify-center align-items-center" }, {
                      default: withCtx(() => [
                        createBaseVNode("div", _hoisted_12, [
                          createVNode(_component_v_card, {
                            class: "mt-0",
                            hover: ""
                          }, {
                            default: withCtx(() => [
                              _hoisted_22
                            ]),
                            _: 1
                          })
                        ])
                      ]),
                      _: 1
                    }),
                    createVNode(_component_v_col, { class: "d-flex justify-end align-items-center" }, {
                      default: withCtx(() => [
                        createVNode(_component_v_btn, {
                          icon: "",
                          onClick: $options.nextPage
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_icon, null, {
                              default: withCtx(() => [
                                createTextVNode("mdi-chevron-right")
                              ]),
                              _: 1
                            }),
                            createVNode(_component_v_tooltip, {
                              activator: "parent",
                              location: "top"
                            }, {
                              default: withCtx(() => [
                                createTextVNode("Next Page")
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        }, 8, ["onClick"])
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }),
            createVNode(_component_v_bottom_navigation, { class: "bg-light" }, {
              default: withCtx(() => [
                createVNode(_component_v_spacer),
                createBaseVNode("div", _hoisted_3, [
                  createVNode(_component_v_btn, {
                    icon: "",
                    onClick: $options.previousPage
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_v_icon, null, {
                        default: withCtx(() => [
                          createTextVNode("mdi-arrow-left")
                        ]),
                        _: 1
                      }),
                      createVNode(_component_v_tooltip, {
                        activator: "parent",
                        location: "top"
                      }, {
                        default: withCtx(() => [
                          createTextVNode("Previous Page")
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["onClick"]),
                  createVNode(_component_v_text_field, {
                    modelValue: $data.manualPage,
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.manualPage = $event),
                    onKeyup: _cache[2] || (_cache[2] = withKeys(($event) => $options.navigateToPage($data.manualPage), ["enter"])),
                    onMouseleave: $options.updatePlaceholder,
                    class: "mx-2 page-input-field",
                    min: "1",
                    max: $data.totalPages,
                    outlined: "",
                    dense: "",
                    small: ""
                  }, null, 8, ["modelValue", "onMouseleave", "max"]),
                  createVNode(_component_v_btn, {
                    icon: "",
                    onClick: $options.nextPage
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_v_icon, null, {
                        default: withCtx(() => [
                          createTextVNode("mdi-arrow-right")
                        ]),
                        _: 1
                      }),
                      createVNode(_component_v_tooltip, {
                        activator: "parent",
                        location: "top"
                      }, {
                        default: withCtx(() => [
                          createTextVNode("Next Page")
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["onClick"])
                ]),
                createVNode(_component_v_spacer),
                createBaseVNode("div", _hoisted_4, [
                  createVNode(_component_v_btn, {
                    icon: "",
                    size: "small",
                    onClick: $options.zoomOut,
                    class: "mb-2"
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_v_icon, null, {
                        default: withCtx(() => [
                          createTextVNode("mdi-minus")
                        ]),
                        _: 1
                      }),
                      createVNode(_component_v_tooltip, {
                        activator: "parent",
                        location: "top"
                      }, {
                        default: withCtx(() => [
                          createTextVNode("zoomOut")
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["onClick"]),
                  createVNode(_component_v_btn, {
                    icon: "",
                    size: "small",
                    onClick: $options.zoomIn,
                    class: "mb-2"
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_v_icon, null, {
                        default: withCtx(() => [
                          createTextVNode("mdi-plus")
                        ]),
                        _: 1
                      }),
                      createVNode(_component_v_tooltip, {
                        activator: "parent",
                        location: "top"
                      }, {
                        default: withCtx(() => [
                          createTextVNode("zoomIn")
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["onClick"])
                ])
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["modelValue"]);
  }

  // ../library_management/library_management/public/js/ebook_reader/components/PdfReader.vue
  PdfReader_default.render = render5;
  PdfReader_default.__file = "../library_management/library_management/public/js/ebook_reader/components/PdfReader.vue";
  PdfReader_default.__scopeId = "data-v-64b5f53b";
  var PdfReader_default2 = PdfReader_default;

  // sfc-script:/home/dev2/projects/v15/apps/library_management/library_management/public/js/books/Books.vue?type=script
  var Books_default = {
    __name: "Books",
    setup(__props, { expose: __expose }) {
      __expose();
      const bookstore = useBooksStore();
      const selectedBook = ref(null);
      const isReaderOpen = ref(false);
      const drawer = ref(true);
      const selectBook = (book) => {
        selectedBook.value = book;
        isReaderOpen.value = true;
      };
      const toggleDrawer = () => {
        drawer.value = !drawer.value;
      };
      onMounted(() => {
        bookstore.get_books();
        bookstore.get_book_categories();
      });
      const __returned__ = { bookstore, selectedBook, isReaderOpen, drawer, selectBook, toggleDrawer, ref, onMounted, get useBooksStore() {
        return useBooksStore;
      }, Sidebar: Sidebar_default2, EpubReader: EpubReader_default2, PdfReader: PdfReader_default2 };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };

  // sfc-template:/home/dev2/projects/v15/apps/library_management/library_management/public/js/books/Books.vue?type=template
  var _withScopeId2 = (n) => (pushScopeId("data-v-3dde91c7"), n = n(), popScopeId(), n);
  var _hoisted_13 = { id: "app-container" };
  var _hoisted_23 = { class: "mt-1 text-center" };
  var _hoisted_32 = { class: "ma-0 text-body-6 text-sm-left" };
  var _hoisted_42 = { class: "font-weight-medium" };
  var _hoisted_5 = { class: "text-caption text-sm-left" };
  var _hoisted_6 = { class: "font-weight-medium" };
  var _hoisted_7 = { class: "text-center justify-content" };
  var _hoisted_8 = /* @__PURE__ */ _withScopeId2(() => /* @__PURE__ */ createBaseVNode("span", { class: "mdi mdi-read" }, null, -1));
  function render6(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_divider = resolveComponent("v-divider");
    const _component_v_img = resolveComponent("v-img");
    const _component_v_card_subtitle = resolveComponent("v-card-subtitle");
    const _component_v_btn = resolveComponent("v-btn");
    const _component_v_card_text = resolveComponent("v-card-text");
    const _component_v_card = resolveComponent("v-card");
    const _component_v_hover = resolveComponent("v-hover");
    const _component_v_col = resolveComponent("v-col");
    const _component_v_row = resolveComponent("v-row");
    const _component_v_container = resolveComponent("v-container");
    const _component_v_dialog = resolveComponent("v-dialog");
    const _component_v_main = resolveComponent("v-main");
    const _component_v_app = resolveComponent("v-app");
    return openBlock(), createElementBlock("div", _hoisted_13, [
      createVNode(_component_v_app, null, {
        default: withCtx(() => [
          createVNode(_component_v_main, null, {
            default: withCtx(() => [
              createVNode($setup["Sidebar"], {
                drawer: $setup.drawer,
                bookstore: $setup.bookstore,
                onToggleDrawer: $setup.toggleDrawer
              }, null, 8, ["drawer", "bookstore"]),
              createVNode(_component_v_container, {
                fluid: "",
                class: normalizeClass(["pa-0 ma-0", { "drawer-open": $setup.drawer }])
              }, {
                default: withCtx(() => [
                  createVNode(_component_v_row, { class: "align-center pa-0 ma-0" }, {
                    default: withCtx(() => [
                      createVNode(_component_v_col, {
                        cols: "11",
                        class: "rounded-shaped"
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_v_card, {
                            outlined: "",
                            class: "rounded-shaped"
                          }, {
                            default: withCtx(() => [
                              createVNode(_component_v_divider),
                              createVNode(_component_v_container, {
                                class: "overflow-y-auto",
                                style: { "max-height": "calc(100vh - 112px)" }
                              }, {
                                default: withCtx(() => [
                                  createVNode(_component_v_row, {
                                    align: "center",
                                    class: "fill-height",
                                    justify: "center"
                                  }, {
                                    default: withCtx(() => [
                                      (openBlock(true), createElementBlock(Fragment, null, renderList($setup.bookstore.books, (item) => {
                                        return openBlock(), createBlock(_component_v_col, {
                                          key: item.title,
                                          cols: "12",
                                          sm: "6",
                                          md: "4",
                                          lg: "3"
                                        }, {
                                          default: withCtx(() => [
                                            createVNode(_component_v_hover, null, {
                                              default: withCtx(({ isHovering, props }) => [
                                                createVNode(_component_v_card, mergeProps({
                                                  class: { "on-hover": isHovering },
                                                  elevation: isHovering ? 12 : 2
                                                }, props, {
                                                  onClick: ($event) => $setup.selectBook(item)
                                                }), {
                                                  default: withCtx(() => [
                                                    createVNode(_component_v_img, {
                                                      src: item.image ? item.image : "https://placehold.co/150?text=Item",
                                                      height: "300px",
                                                      class: "white--text align-end"
                                                    }, null, 8, ["src"]),
                                                    createVNode(_component_v_card_subtitle, { class: "text-h6 text-center text-body-3 text-sm-left text-dark d-flex flex-column" }, {
                                                      default: withCtx(() => [
                                                        createBaseVNode("p", _hoisted_23, toDisplayString(item.title), 1)
                                                      ]),
                                                      _: 2
                                                    }, 1024),
                                                    createVNode(_component_v_card_text, { class: "pa-1" }, {
                                                      default: withCtx(() => [
                                                        createBaseVNode("p", _hoisted_32, [
                                                          createTextVNode(" By: "),
                                                          createBaseVNode("span", _hoisted_42, toDisplayString(item.author), 1)
                                                        ]),
                                                        createBaseVNode("p", _hoisted_5, [
                                                          createTextVNode(" Subject: "),
                                                          createBaseVNode("span", _hoisted_6, toDisplayString(item.subject), 1)
                                                        ]),
                                                        withDirectives(createBaseVNode("div", _hoisted_7, [
                                                          createVNode(_component_v_btn, {
                                                            onClick: withModifiers(($event) => $setup.selectBook(item), ["stop"]),
                                                            class: normalizeClass(["mt-2", { "show-btns": isHovering }]),
                                                            color: "primary"
                                                          }, {
                                                            default: withCtx(() => [
                                                              _hoisted_8,
                                                              createTextVNode(" Read ")
                                                            ]),
                                                            _: 2
                                                          }, 1032, ["onClick", "class"])
                                                        ], 512), [
                                                          [vShow, isHovering]
                                                        ])
                                                      ]),
                                                      _: 2
                                                    }, 1024)
                                                  ]),
                                                  _: 2
                                                }, 1040, ["class", "elevation", "onClick"])
                                              ]),
                                              _: 2
                                            }, 1024)
                                          ]),
                                          _: 2
                                        }, 1024);
                                      }), 128))
                                    ]),
                                    _: 1
                                  })
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }),
                  createVNode(_component_v_dialog, {
                    modelValue: $setup.isReaderOpen,
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $setup.isReaderOpen = $event),
                    fullscreen: "",
                    "hide-overlay": "",
                    transition: "dialog-bottom-transition"
                  }, {
                    default: withCtx(() => [
                      $setup.selectedBook.type === "epub" ? (openBlock(), createBlock($setup["EpubReader"], {
                        key: 0,
                        book: $setup.selectedBook,
                        show: $setup.isReaderOpen,
                        onCloseReader: _cache[0] || (_cache[0] = ($event) => $setup.isReaderOpen = false)
                      }, null, 8, ["book", "show"])) : createCommentVNode("v-if", true),
                      $setup.selectedBook.type === "pdf" ? (openBlock(), createBlock($setup["PdfReader"], {
                        key: 1,
                        book: $setup.selectedBook,
                        show: $setup.isReaderOpen,
                        onCloseReader: _cache[1] || (_cache[1] = ($event) => $setup.isReaderOpen = false)
                      }, null, 8, ["book", "show"])) : createCommentVNode("v-if", true)
                    ]),
                    _: 1
                  }, 8, ["modelValue"])
                ]),
                _: 1
              }, 8, ["class"])
            ]),
            _: 1
          })
        ]),
        _: 1
      })
    ]);
  }

  // ../library_management/library_management/public/js/books/Books.vue
  Books_default.render = render6;
  Books_default.__file = "../library_management/library_management/public/js/books/Books.vue";
  Books_default.__scopeId = "data-v-3dde91c7";
  var Books_default2 = Books_default;

  // ../library_management/node_modules/vuetify/lib/composables/toggleScope.mjs
  function useToggleScope(source, fn) {
    let scope;
    function start() {
      scope = effectScope();
      scope.run(() => fn.length ? fn(() => {
        scope == null ? void 0 : scope.stop();
        start();
      }) : fn());
    }
    watch(source, (active) => {
      if (active && !scope) {
        start();
      } else if (!active) {
        scope == null ? void 0 : scope.stop();
        scope = void 0;
      }
    }, {
      immediate: true
    });
    onScopeDispose(() => {
      scope == null ? void 0 : scope.stop();
    });
  }

  // ../library_management/node_modules/vuetify/lib/util/globals.mjs
  var IN_BROWSER = typeof window !== "undefined";
  var SUPPORTS_INTERSECTION = IN_BROWSER && "IntersectionObserver" in window;
  var SUPPORTS_TOUCH = IN_BROWSER && ("ontouchstart" in window || window.navigator.maxTouchPoints > 0);
  var SUPPORTS_EYE_DROPPER = IN_BROWSER && "EyeDropper" in window;

  // ../library_management/node_modules/vuetify/lib/util/helpers.mjs
  function _classPrivateFieldInitSpec(obj, privateMap, value) {
    _checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
  }
  function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
      throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
  }
  function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
    _classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
  function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
      descriptor.set.call(receiver, value);
    } else {
      if (!descriptor.writable) {
        throw new TypeError("attempted to set read only private field");
      }
      descriptor.value = value;
    }
  }
  function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
    return _classApplyDescriptorGet(receiver, descriptor);
  }
  function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
  }
  function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
      return descriptor.get.call(receiver);
    }
    return descriptor.value;
  }
  function getNestedValue(obj, path5, fallback) {
    const last = path5.length - 1;
    if (last < 0)
      return obj === void 0 ? fallback : obj;
    for (let i = 0; i < last; i++) {
      if (obj == null) {
        return fallback;
      }
      obj = obj[path5[i]];
    }
    if (obj == null)
      return fallback;
    return obj[path5[last]] === void 0 ? fallback : obj[path5[last]];
  }
  function deepEqual(a, b) {
    if (a === b)
      return true;
    if (a instanceof Date && b instanceof Date && a.getTime() !== b.getTime()) {
      return false;
    }
    if (a !== Object(a) || b !== Object(b)) {
      return false;
    }
    const props = Object.keys(a);
    if (props.length !== Object.keys(b).length) {
      return false;
    }
    return props.every((p2) => deepEqual(a[p2], b[p2]));
  }
  function getObjectValueByPath(obj, path5, fallback) {
    if (obj == null || !path5 || typeof path5 !== "string")
      return fallback;
    if (obj[path5] !== void 0)
      return obj[path5];
    path5 = path5.replace(/\[(\w+)\]/g, ".$1");
    path5 = path5.replace(/^\./, "");
    return getNestedValue(obj, path5.split("."), fallback);
  }
  function getPropertyFromItem(item, property, fallback) {
    if (property === true)
      return item === void 0 ? fallback : item;
    if (property == null || typeof property === "boolean")
      return fallback;
    if (item !== Object(item)) {
      if (typeof property !== "function")
        return fallback;
      const value2 = property(item, fallback);
      return typeof value2 === "undefined" ? fallback : value2;
    }
    if (typeof property === "string")
      return getObjectValueByPath(item, property, fallback);
    if (Array.isArray(property))
      return getNestedValue(item, property, fallback);
    if (typeof property !== "function")
      return fallback;
    const value = property(item, fallback);
    return typeof value === "undefined" ? fallback : value;
  }
  function createRange(length) {
    let start = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return Array.from({
      length
    }, (v, k) => start + k);
  }
  function convertToUnit(str) {
    let unit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "px";
    if (str == null || str === "") {
      return void 0;
    } else if (isNaN(+str)) {
      return String(str);
    } else if (!isFinite(+str)) {
      return void 0;
    } else {
      return `${Number(str)}${unit}`;
    }
  }
  function isObject2(obj) {
    return obj !== null && typeof obj === "object" && !Array.isArray(obj);
  }
  function refElement(obj) {
    if (obj && "$el" in obj) {
      const el = obj.$el;
      if ((el == null ? void 0 : el.nodeType) === Node.TEXT_NODE) {
        return el.nextElementSibling;
      }
      return el;
    }
    return obj;
  }
  var keyCodes = Object.freeze({
    enter: 13,
    tab: 9,
    delete: 46,
    esc: 27,
    space: 32,
    up: 38,
    down: 40,
    left: 37,
    right: 39,
    end: 35,
    home: 36,
    del: 46,
    backspace: 8,
    insert: 45,
    pageup: 33,
    pagedown: 34,
    shift: 16
  });
  var keyValues = Object.freeze({
    enter: "Enter",
    tab: "Tab",
    delete: "Delete",
    esc: "Escape",
    space: "Space",
    up: "ArrowUp",
    down: "ArrowDown",
    left: "ArrowLeft",
    right: "ArrowRight",
    end: "End",
    home: "Home",
    del: "Delete",
    backspace: "Backspace",
    insert: "Insert",
    pageup: "PageUp",
    pagedown: "PageDown",
    shift: "Shift"
  });
  function keys(o) {
    return Object.keys(o);
  }
  function has2(obj, key) {
    return key.every((k) => obj.hasOwnProperty(k));
  }
  function pick(obj, paths) {
    const found = {};
    const keys2 = new Set(Object.keys(obj));
    for (const path5 of paths) {
      if (keys2.has(path5)) {
        found[path5] = obj[path5];
      }
    }
    return found;
  }
  function pickWithRest(obj, paths, exclude) {
    const found = /* @__PURE__ */ Object.create(null);
    const rest = /* @__PURE__ */ Object.create(null);
    for (const key in obj) {
      if (paths.some((path5) => path5 instanceof RegExp ? path5.test(key) : path5 === key) && !(exclude == null ? void 0 : exclude.some((path5) => path5 === key))) {
        found[key] = obj[key];
      } else {
        rest[key] = obj[key];
      }
    }
    return [found, rest];
  }
  function omit(obj, exclude) {
    const clone = __spreadValues({}, obj);
    exclude.forEach((prop) => delete clone[prop]);
    return clone;
  }
  function only(obj, include) {
    const clone = {};
    include.forEach((prop) => clone[prop] = obj[prop]);
    return clone;
  }
  var onRE = /^on[^a-z]/;
  var isOn2 = (key) => onRE.test(key);
  var bubblingEvents = ["onAfterscriptexecute", "onAnimationcancel", "onAnimationend", "onAnimationiteration", "onAnimationstart", "onAuxclick", "onBeforeinput", "onBeforescriptexecute", "onChange", "onClick", "onCompositionend", "onCompositionstart", "onCompositionupdate", "onContextmenu", "onCopy", "onCut", "onDblclick", "onFocusin", "onFocusout", "onFullscreenchange", "onFullscreenerror", "onGesturechange", "onGestureend", "onGesturestart", "onGotpointercapture", "onInput", "onKeydown", "onKeypress", "onKeyup", "onLostpointercapture", "onMousedown", "onMousemove", "onMouseout", "onMouseover", "onMouseup", "onMousewheel", "onPaste", "onPointercancel", "onPointerdown", "onPointerenter", "onPointerleave", "onPointermove", "onPointerout", "onPointerover", "onPointerup", "onReset", "onSelect", "onSubmit", "onTouchcancel", "onTouchend", "onTouchmove", "onTouchstart", "onTransitioncancel", "onTransitionend", "onTransitionrun", "onTransitionstart", "onWheel"];
  var compositionIgnoreKeys = ["ArrowUp", "ArrowDown", "ArrowRight", "ArrowLeft", "Enter", "Escape", "Tab", " "];
  function isComposingIgnoreKey(e) {
    return e.isComposing && compositionIgnoreKeys.includes(e.key);
  }
  function filterInputAttrs(attrs) {
    const [events, props] = pickWithRest(attrs, [onRE]);
    const inputEvents = omit(events, bubblingEvents);
    const [rootAttrs, inputAttrs] = pickWithRest(props, ["class", "style", "id", /^data-/]);
    Object.assign(rootAttrs, events);
    Object.assign(inputAttrs, inputEvents);
    return [rootAttrs, inputAttrs];
  }
  function wrapInArray(v) {
    return v == null ? [] : Array.isArray(v) ? v : [v];
  }
  function debounce2(fn, delay) {
    let timeoutId = 0;
    const wrap = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => fn(...args), unref(delay));
    };
    wrap.clear = () => {
      clearTimeout(timeoutId);
    };
    wrap.immediate = fn;
    return wrap;
  }
  function clamp(value) {
    let min = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    let max = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    return Math.max(min, Math.min(max, value));
  }
  function getDecimals(value) {
    const trimmedStr = value.toString().trim();
    return trimmedStr.includes(".") ? trimmedStr.length - trimmedStr.indexOf(".") - 1 : 0;
  }
  function padEnd(str, length) {
    let char = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
    return str + char.repeat(Math.max(0, length - str.length));
  }
  function padStart(str, length) {
    let char = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
    return char.repeat(Math.max(0, length - str.length)) + str;
  }
  function chunk(str) {
    let size2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    const chunked = [];
    let index = 0;
    while (index < str.length) {
      chunked.push(str.substr(index, size2));
      index += size2;
    }
    return chunked;
  }
  function humanReadableFileSize(bytes) {
    let base = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
    if (bytes < base) {
      return `${bytes} B`;
    }
    const prefix = base === 1024 ? ["Ki", "Mi", "Gi"] : ["k", "M", "G"];
    let unit = -1;
    while (Math.abs(bytes) >= base && unit < prefix.length - 1) {
      bytes /= base;
      ++unit;
    }
    return `${bytes.toFixed(1)} ${prefix[unit]}B`;
  }
  function mergeDeep() {
    let source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let arrayFn = arguments.length > 2 ? arguments[2] : void 0;
    const out = {};
    for (const key in source) {
      out[key] = source[key];
    }
    for (const key in target) {
      const sourceProperty = source[key];
      const targetProperty = target[key];
      if (isObject2(sourceProperty) && isObject2(targetProperty)) {
        out[key] = mergeDeep(sourceProperty, targetProperty, arrayFn);
        continue;
      }
      if (Array.isArray(sourceProperty) && Array.isArray(targetProperty) && arrayFn) {
        out[key] = arrayFn(sourceProperty, targetProperty);
        continue;
      }
      out[key] = targetProperty;
    }
    return out;
  }
  function flattenFragments(nodes) {
    return nodes.map((node) => {
      if (node.type === Fragment) {
        return flattenFragments(node.children);
      } else {
        return node;
      }
    }).flat();
  }
  function toKebabCase() {
    let str = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    if (toKebabCase.cache.has(str))
      return toKebabCase.cache.get(str);
    const kebab = str.replace(/[^a-z]/gi, "-").replace(/\B([A-Z])/g, "-$1").toLowerCase();
    toKebabCase.cache.set(str, kebab);
    return kebab;
  }
  toKebabCase.cache = /* @__PURE__ */ new Map();
  function findChildrenWithProvide(key, vnode) {
    if (!vnode || typeof vnode !== "object")
      return [];
    if (Array.isArray(vnode)) {
      return vnode.map((child) => findChildrenWithProvide(key, child)).flat(1);
    } else if (Array.isArray(vnode.children)) {
      return vnode.children.map((child) => findChildrenWithProvide(key, child)).flat(1);
    } else if (vnode.component) {
      if (Object.getOwnPropertySymbols(vnode.component.provides).includes(key)) {
        return [vnode.component];
      } else if (vnode.component.subTree) {
        return findChildrenWithProvide(key, vnode.component.subTree).flat(1);
      }
    }
    return [];
  }
  var _arr = /* @__PURE__ */ new WeakMap();
  var _pointer = /* @__PURE__ */ new WeakMap();
  var CircularBuffer = class {
    constructor(size2) {
      _classPrivateFieldInitSpec(this, _arr, {
        writable: true,
        value: []
      });
      _classPrivateFieldInitSpec(this, _pointer, {
        writable: true,
        value: 0
      });
      this.size = size2;
    }
    push(val) {
      _classPrivateFieldGet(this, _arr)[_classPrivateFieldGet(this, _pointer)] = val;
      _classPrivateFieldSet(this, _pointer, (_classPrivateFieldGet(this, _pointer) + 1) % this.size);
    }
    values() {
      return _classPrivateFieldGet(this, _arr).slice(_classPrivateFieldGet(this, _pointer)).concat(_classPrivateFieldGet(this, _arr).slice(0, _classPrivateFieldGet(this, _pointer)));
    }
  };
  function getEventCoordinates(e) {
    if ("touches" in e) {
      return {
        clientX: e.touches[0].clientX,
        clientY: e.touches[0].clientY
      };
    }
    return {
      clientX: e.clientX,
      clientY: e.clientY
    };
  }
  function destructComputed(getter) {
    const refs = reactive({});
    const base = computed2(getter);
    watchEffect(() => {
      for (const key in base.value) {
        refs[key] = base.value[key];
      }
    }, {
      flush: "sync"
    });
    return toRefs(refs);
  }
  function includes(arr, val) {
    return arr.includes(val);
  }
  function eventName(propName) {
    return propName[2].toLowerCase() + propName.slice(3);
  }
  var EventProp = () => [Function, Array];
  function hasEvent(props, name) {
    name = "on" + capitalize(name);
    return !!(props[name] || props[`${name}Once`] || props[`${name}Capture`] || props[`${name}OnceCapture`] || props[`${name}CaptureOnce`]);
  }
  function callEvent(handler) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    if (Array.isArray(handler)) {
      for (const h2 of handler) {
        h2(...args);
      }
    } else if (typeof handler === "function") {
      handler(...args);
    }
  }
  function focusableChildren(el) {
    let filterByTabIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    const targets = ["button", "[href]", 'input:not([type="hidden"])', "select", "textarea", "[tabindex]"].map((s) => `${s}${filterByTabIndex ? ':not([tabindex="-1"])' : ""}:not([disabled])`).join(", ");
    return [...el.querySelectorAll(targets)];
  }
  function getNextElement(elements, location2, condition) {
    var _a2;
    let _el;
    let idx = elements.indexOf(document.activeElement);
    const inc = location2 === "next" ? 1 : -1;
    do {
      idx += inc;
      _el = elements[idx];
    } while ((!_el || _el.offsetParent == null || !((_a2 = condition == null ? void 0 : condition(_el)) != null ? _a2 : true)) && idx < elements.length && idx >= 0);
    return _el;
  }
  function focusChild(el, location2) {
    var _a2, _b, _c, _d;
    const focusable = focusableChildren(el);
    if (!location2) {
      if (el === document.activeElement || !el.contains(document.activeElement)) {
        (_a2 = focusable[0]) == null ? void 0 : _a2.focus();
      }
    } else if (location2 === "first") {
      (_b = focusable[0]) == null ? void 0 : _b.focus();
    } else if (location2 === "last") {
      (_c = focusable.at(-1)) == null ? void 0 : _c.focus();
    } else if (typeof location2 === "number") {
      (_d = focusable[location2]) == null ? void 0 : _d.focus();
    } else {
      const _el = getNextElement(focusable, location2);
      if (_el)
        _el.focus();
      else
        focusChild(el, location2 === "next" ? "first" : "last");
    }
  }
  function isEmpty(val) {
    return val === null || val === void 0 || typeof val === "string" && val.trim() === "";
  }
  function noop2() {
  }
  function matchesSelector(el, selector) {
    const supportsSelector = IN_BROWSER && typeof CSS !== "undefined" && typeof CSS.supports !== "undefined" && CSS.supports(`selector(${selector})`);
    if (!supportsSelector)
      return null;
    try {
      return !!el && el.matches(selector);
    } catch (err) {
      return null;
    }
  }
  function ensureValidVNode(vnodes) {
    return vnodes.some((child) => {
      if (!isVNode(child))
        return true;
      if (child.type === Comment)
        return false;
      return child.type !== Fragment || ensureValidVNode(child.children);
    }) ? vnodes : null;
  }
  function defer2(timeout, cb) {
    if (!IN_BROWSER || timeout === 0) {
      cb();
      return () => {
      };
    }
    const timeoutId = window.setTimeout(cb, timeout);
    return () => window.clearTimeout(timeoutId);
  }
  function isClickInsideElement(event, targetDiv) {
    const mouseX = event.clientX;
    const mouseY = event.clientY;
    const divRect = targetDiv.getBoundingClientRect();
    const divLeft = divRect.left;
    const divTop = divRect.top;
    const divRight = divRect.right;
    const divBottom = divRect.bottom;
    return mouseX >= divLeft && mouseX <= divRight && mouseY >= divTop && mouseY <= divBottom;
  }

  // ../library_management/node_modules/vuetify/lib/util/anchor.mjs
  var block = ["top", "bottom"];
  var inline = ["start", "end", "left", "right"];
  function parseAnchor(anchor, isRtl) {
    let [side, align] = anchor.split(" ");
    if (!align) {
      align = includes(block, side) ? "start" : includes(inline, side) ? "top" : "center";
    }
    return {
      side: toPhysical(side, isRtl),
      align: toPhysical(align, isRtl)
    };
  }
  function toPhysical(str, isRtl) {
    if (str === "start")
      return isRtl ? "right" : "left";
    if (str === "end")
      return isRtl ? "left" : "right";
    return str;
  }
  function flipSide(anchor) {
    return {
      side: {
        center: "center",
        top: "bottom",
        bottom: "top",
        left: "right",
        right: "left"
      }[anchor.side],
      align: anchor.align
    };
  }
  function flipAlign(anchor) {
    return {
      side: anchor.side,
      align: {
        center: "center",
        top: "bottom",
        bottom: "top",
        left: "right",
        right: "left"
      }[anchor.align]
    };
  }
  function flipCorner(anchor) {
    return {
      side: anchor.align,
      align: anchor.side
    };
  }
  function getAxis(anchor) {
    return includes(block, anchor.side) ? "y" : "x";
  }

  // ../library_management/node_modules/vuetify/lib/util/box.mjs
  var Box = class {
    constructor(_ref) {
      let {
        x,
        y,
        width,
        height
      } = _ref;
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
    }
    get top() {
      return this.y;
    }
    get bottom() {
      return this.y + this.height;
    }
    get left() {
      return this.x;
    }
    get right() {
      return this.x + this.width;
    }
  };
  function getOverflow(a, b) {
    return {
      x: {
        before: Math.max(0, b.left - a.left),
        after: Math.max(0, a.right - b.right)
      },
      y: {
        before: Math.max(0, b.top - a.top),
        after: Math.max(0, a.bottom - b.bottom)
      }
    };
  }
  function getTargetBox(target) {
    if (Array.isArray(target)) {
      return new Box({
        x: target[0],
        y: target[1],
        width: 0,
        height: 0
      });
    } else {
      return target.getBoundingClientRect();
    }
  }

  // ../library_management/node_modules/vuetify/lib/util/animation.mjs
  function nullifyTransforms(el) {
    const rect = el.getBoundingClientRect();
    const style = getComputedStyle(el);
    const tx = style.transform;
    if (tx) {
      let ta, sx, sy, dx, dy;
      if (tx.startsWith("matrix3d(")) {
        ta = tx.slice(9, -1).split(/, /);
        sx = +ta[0];
        sy = +ta[5];
        dx = +ta[12];
        dy = +ta[13];
      } else if (tx.startsWith("matrix(")) {
        ta = tx.slice(7, -1).split(/, /);
        sx = +ta[0];
        sy = +ta[3];
        dx = +ta[4];
        dy = +ta[5];
      } else {
        return new Box(rect);
      }
      const to = style.transformOrigin;
      const x = rect.x - dx - (1 - sx) * parseFloat(to);
      const y = rect.y - dy - (1 - sy) * parseFloat(to.slice(to.indexOf(" ") + 1));
      const w = sx ? rect.width / sx : el.offsetWidth + 1;
      const h2 = sy ? rect.height / sy : el.offsetHeight + 1;
      return new Box({
        x,
        y,
        width: w,
        height: h2
      });
    } else {
      return new Box(rect);
    }
  }
  function animate(el, keyframes, options) {
    if (typeof el.animate === "undefined")
      return {
        finished: Promise.resolve()
      };
    let animation;
    try {
      animation = el.animate(keyframes, options);
    } catch (err) {
      return {
        finished: Promise.resolve()
      };
    }
    if (typeof animation.finished === "undefined") {
      animation.finished = new Promise((resolve2) => {
        animation.onfinish = () => {
          resolve2(animation);
        };
      });
    }
    return animation;
  }

  // ../library_management/node_modules/vuetify/lib/util/bindProps.mjs
  var handlers = /* @__PURE__ */ new WeakMap();
  function bindProps(el, props) {
    Object.keys(props).forEach((k) => {
      var _a2;
      if (isOn2(k)) {
        const name = eventName(k);
        const handler = handlers.get(el);
        if (props[k] == null) {
          handler == null ? void 0 : handler.forEach((v) => {
            const [n, fn] = v;
            if (n === name) {
              el.removeEventListener(name, fn);
              handler.delete(v);
            }
          });
        } else if (!handler || !((_a2 = [...handler]) == null ? void 0 : _a2.some((v) => v[0] === name && v[1] === props[k]))) {
          el.addEventListener(name, props[k]);
          const _handler = handler || /* @__PURE__ */ new Set();
          _handler.add([name, props[k]]);
          if (!handlers.has(el))
            handlers.set(el, _handler);
        }
      } else {
        if (props[k] == null) {
          el.removeAttribute(k);
        } else {
          el.setAttribute(k, props[k]);
        }
      }
    });
  }
  function unbindProps(el, props) {
    Object.keys(props).forEach((k) => {
      if (isOn2(k)) {
        const name = eventName(k);
        const handler = handlers.get(el);
        handler == null ? void 0 : handler.forEach((v) => {
          const [n, fn] = v;
          if (n === name) {
            el.removeEventListener(name, fn);
            handler.delete(v);
          }
        });
      } else {
        el.removeAttribute(k);
      }
    });
  }

  // ../library_management/node_modules/vuetify/lib/util/color/APCA.mjs
  var mainTRC = 2.4;
  var Rco = 0.2126729;
  var Gco = 0.7151522;
  var Bco = 0.072175;
  var normBG = 0.55;
  var normTXT = 0.58;
  var revTXT = 0.57;
  var revBG = 0.62;
  var blkThrs = 0.03;
  var blkClmp = 1.45;
  var deltaYmin = 5e-4;
  var scaleBoW = 1.25;
  var scaleWoB = 1.25;
  var loConThresh = 0.078;
  var loConFactor = 12.82051282051282;
  var loConOffset = 0.06;
  var loClip = 1e-3;
  function APCAcontrast(text, background) {
    const Rtxt = (text.r / 255) ** mainTRC;
    const Gtxt = (text.g / 255) ** mainTRC;
    const Btxt = (text.b / 255) ** mainTRC;
    const Rbg = (background.r / 255) ** mainTRC;
    const Gbg = (background.g / 255) ** mainTRC;
    const Bbg = (background.b / 255) ** mainTRC;
    let Ytxt = Rtxt * Rco + Gtxt * Gco + Btxt * Bco;
    let Ybg = Rbg * Rco + Gbg * Gco + Bbg * Bco;
    if (Ytxt <= blkThrs)
      Ytxt += (blkThrs - Ytxt) ** blkClmp;
    if (Ybg <= blkThrs)
      Ybg += (blkThrs - Ybg) ** blkClmp;
    if (Math.abs(Ybg - Ytxt) < deltaYmin)
      return 0;
    let outputContrast;
    if (Ybg > Ytxt) {
      const SAPC = (Ybg ** normBG - Ytxt ** normTXT) * scaleBoW;
      outputContrast = SAPC < loClip ? 0 : SAPC < loConThresh ? SAPC - SAPC * loConFactor * loConOffset : SAPC - loConOffset;
    } else {
      const SAPC = (Ybg ** revBG - Ytxt ** revTXT) * scaleWoB;
      outputContrast = SAPC > -loClip ? 0 : SAPC > -loConThresh ? SAPC - SAPC * loConFactor * loConOffset : SAPC + loConOffset;
    }
    return outputContrast * 100;
  }

  // ../library_management/node_modules/vuetify/lib/util/console.mjs
  function consoleWarn(message) {
    warn2(`Vuetify: ${message}`);
  }
  function consoleError(message) {
    warn2(`Vuetify error: ${message}`);
  }
  function deprecate(original, replacement) {
    replacement = Array.isArray(replacement) ? replacement.slice(0, -1).map((s) => `'${s}'`).join(", ") + ` or '${replacement.at(-1)}'` : `'${replacement}'`;
    warn2(`[Vuetify UPGRADE] '${original}' is deprecated, use ${replacement} instead.`);
  }

  // ../library_management/node_modules/vuetify/lib/util/color/transformCIELAB.mjs
  var delta = 0.20689655172413793;
  var cielabForwardTransform = (t) => t > delta ** 3 ? Math.cbrt(t) : t / (3 * delta ** 2) + 4 / 29;
  var cielabReverseTransform = (t) => t > delta ? t ** 3 : 3 * delta ** 2 * (t - 4 / 29);
  function fromXYZ(xyz) {
    const transform2 = cielabForwardTransform;
    const transformedY = transform2(xyz[1]);
    return [116 * transformedY - 16, 500 * (transform2(xyz[0] / 0.95047) - transformedY), 200 * (transformedY - transform2(xyz[2] / 1.08883))];
  }
  function toXYZ(lab) {
    const transform2 = cielabReverseTransform;
    const Ln = (lab[0] + 16) / 116;
    return [transform2(Ln + lab[1] / 500) * 0.95047, transform2(Ln), transform2(Ln - lab[2] / 200) * 1.08883];
  }

  // ../library_management/node_modules/vuetify/lib/util/color/transformSRGB.mjs
  var srgbForwardMatrix = [[3.2406, -1.5372, -0.4986], [-0.9689, 1.8758, 0.0415], [0.0557, -0.204, 1.057]];
  var srgbForwardTransform = (C) => C <= 31308e-7 ? C * 12.92 : 1.055 * C ** (1 / 2.4) - 0.055;
  var srgbReverseMatrix = [[0.4124, 0.3576, 0.1805], [0.2126, 0.7152, 0.0722], [0.0193, 0.1192, 0.9505]];
  var srgbReverseTransform = (C) => C <= 0.04045 ? C / 12.92 : ((C + 0.055) / 1.055) ** 2.4;
  function fromXYZ2(xyz) {
    const rgb2 = Array(3);
    const transform2 = srgbForwardTransform;
    const matrix = srgbForwardMatrix;
    for (let i = 0; i < 3; ++i) {
      rgb2[i] = Math.round(clamp(transform2(matrix[i][0] * xyz[0] + matrix[i][1] * xyz[1] + matrix[i][2] * xyz[2])) * 255);
    }
    return {
      r: rgb2[0],
      g: rgb2[1],
      b: rgb2[2]
    };
  }
  function toXYZ2(_ref) {
    let {
      r,
      g,
      b
    } = _ref;
    const xyz = [0, 0, 0];
    const transform2 = srgbReverseTransform;
    const matrix = srgbReverseMatrix;
    r = transform2(r / 255);
    g = transform2(g / 255);
    b = transform2(b / 255);
    for (let i = 0; i < 3; ++i) {
      xyz[i] = matrix[i][0] * r + matrix[i][1] * g + matrix[i][2] * b;
    }
    return xyz;
  }

  // ../library_management/node_modules/vuetify/lib/util/colorUtils.mjs
  function isCssColor(color) {
    return !!color && /^(#|var\(--|(rgb|hsl)a?\()/.test(color);
  }
  function isParsableColor(color) {
    return isCssColor(color) && !/^((rgb|hsl)a?\()?var\(--/.test(color);
  }
  var cssColorRe = new RegExp("^(?<fn>(?:rgb|hsl)a?)\\((?<values>.+)\\)");
  var mappers = {
    rgb: (r, g, b, a) => ({
      r,
      g,
      b,
      a
    }),
    rgba: (r, g, b, a) => ({
      r,
      g,
      b,
      a
    }),
    hsl: (h2, s, l, a) => HSLtoRGB({
      h: h2,
      s,
      l,
      a
    }),
    hsla: (h2, s, l, a) => HSLtoRGB({
      h: h2,
      s,
      l,
      a
    }),
    hsv: (h2, s, v, a) => HSVtoRGB({
      h: h2,
      s,
      v,
      a
    }),
    hsva: (h2, s, v, a) => HSVtoRGB({
      h: h2,
      s,
      v,
      a
    })
  };
  function parseColor(color) {
    if (typeof color === "number") {
      if (isNaN(color) || color < 0 || color > 16777215) {
        consoleWarn(`'${color}' is not a valid hex color`);
      }
      return {
        r: (color & 16711680) >> 16,
        g: (color & 65280) >> 8,
        b: color & 255
      };
    } else if (typeof color === "string" && cssColorRe.test(color)) {
      const {
        groups
      } = color.match(cssColorRe);
      const {
        fn,
        values
      } = groups;
      const realValues = values.split(/,\s*/).map((v) => {
        if (v.endsWith("%") && ["hsl", "hsla", "hsv", "hsva"].includes(fn)) {
          return parseFloat(v) / 100;
        } else {
          return parseFloat(v);
        }
      });
      return mappers[fn](...realValues);
    } else if (typeof color === "string") {
      let hex2 = color.startsWith("#") ? color.slice(1) : color;
      if ([3, 4].includes(hex2.length)) {
        hex2 = hex2.split("").map((char) => char + char).join("");
      } else if (![6, 8].includes(hex2.length)) {
        consoleWarn(`'${color}' is not a valid hex(a) color`);
      }
      const int = parseInt(hex2, 16);
      if (isNaN(int) || int < 0 || int > 4294967295) {
        consoleWarn(`'${color}' is not a valid hex(a) color`);
      }
      return HexToRGB(hex2);
    } else if (typeof color === "object") {
      if (has2(color, ["r", "g", "b"])) {
        return color;
      } else if (has2(color, ["h", "s", "l"])) {
        return HSVtoRGB(HSLtoHSV(color));
      } else if (has2(color, ["h", "s", "v"])) {
        return HSVtoRGB(color);
      }
    }
    throw new TypeError(`Invalid color: ${color == null ? color : String(color) || color.constructor.name}
Expected #hex, #hexa, rgb(), rgba(), hsl(), hsla(), object or number`);
  }
  function HSVtoRGB(hsva) {
    const {
      h: h2,
      s,
      v,
      a
    } = hsva;
    const f = (n) => {
      const k = (n + h2 / 60) % 6;
      return v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
    };
    const rgb2 = [f(5), f(3), f(1)].map((v2) => Math.round(v2 * 255));
    return {
      r: rgb2[0],
      g: rgb2[1],
      b: rgb2[2],
      a
    };
  }
  function HSLtoRGB(hsla2) {
    return HSVtoRGB(HSLtoHSV(hsla2));
  }
  function RGBtoHSV(rgba2) {
    if (!rgba2)
      return {
        h: 0,
        s: 1,
        v: 1,
        a: 1
      };
    const r = rgba2.r / 255;
    const g = rgba2.g / 255;
    const b = rgba2.b / 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h2 = 0;
    if (max !== min) {
      if (max === r) {
        h2 = 60 * (0 + (g - b) / (max - min));
      } else if (max === g) {
        h2 = 60 * (2 + (b - r) / (max - min));
      } else if (max === b) {
        h2 = 60 * (4 + (r - g) / (max - min));
      }
    }
    if (h2 < 0)
      h2 = h2 + 360;
    const s = max === 0 ? 0 : (max - min) / max;
    const hsv = [h2, s, max];
    return {
      h: hsv[0],
      s: hsv[1],
      v: hsv[2],
      a: rgba2.a
    };
  }
  function HSVtoHSL(hsva) {
    const {
      h: h2,
      s,
      v,
      a
    } = hsva;
    const l = v - v * s / 2;
    const sprime = l === 1 || l === 0 ? 0 : (v - l) / Math.min(l, 1 - l);
    return {
      h: h2,
      s: sprime,
      l,
      a
    };
  }
  function HSLtoHSV(hsl2) {
    const {
      h: h2,
      s,
      l,
      a
    } = hsl2;
    const v = l + s * Math.min(l, 1 - l);
    const sprime = v === 0 ? 0 : 2 - 2 * l / v;
    return {
      h: h2,
      s: sprime,
      v,
      a
    };
  }
  function RGBtoCSS(_ref) {
    let {
      r,
      g,
      b,
      a
    } = _ref;
    return a === void 0 ? `rgb(${r}, ${g}, ${b})` : `rgba(${r}, ${g}, ${b}, ${a})`;
  }
  function HSVtoCSS(hsva) {
    return RGBtoCSS(HSVtoRGB(hsva));
  }
  function toHex(v) {
    const h2 = Math.round(v).toString(16);
    return ("00".substr(0, 2 - h2.length) + h2).toUpperCase();
  }
  function RGBtoHex(_ref2) {
    let {
      r,
      g,
      b,
      a
    } = _ref2;
    return `#${[toHex(r), toHex(g), toHex(b), a !== void 0 ? toHex(Math.round(a * 255)) : ""].join("")}`;
  }
  function HexToRGB(hex2) {
    hex2 = parseHex(hex2);
    let [r, g, b, a] = chunk(hex2, 2).map((c) => parseInt(c, 16));
    a = a === void 0 ? a : a / 255;
    return {
      r,
      g,
      b,
      a
    };
  }
  function HexToHSV(hex2) {
    const rgb2 = HexToRGB(hex2);
    return RGBtoHSV(rgb2);
  }
  function HSVtoHex(hsva) {
    return RGBtoHex(HSVtoRGB(hsva));
  }
  function parseHex(hex2) {
    if (hex2.startsWith("#")) {
      hex2 = hex2.slice(1);
    }
    hex2 = hex2.replace(/([^0-9a-f])/gi, "F");
    if (hex2.length === 3 || hex2.length === 4) {
      hex2 = hex2.split("").map((x) => x + x).join("");
    }
    if (hex2.length !== 6) {
      hex2 = padEnd(padEnd(hex2, 6), 8, "F");
    }
    return hex2;
  }
  function lighten(value, amount) {
    const lab = fromXYZ(toXYZ2(value));
    lab[0] = lab[0] + amount * 10;
    return fromXYZ2(toXYZ(lab));
  }
  function darken(value, amount) {
    const lab = fromXYZ(toXYZ2(value));
    lab[0] = lab[0] - amount * 10;
    return fromXYZ2(toXYZ(lab));
  }
  function getLuma(color) {
    const rgb2 = parseColor(color);
    return toXYZ2(rgb2)[1];
  }
  function getContrast(first, second) {
    const l1 = getLuma(first);
    const l2 = getLuma(second);
    const light = Math.max(l1, l2);
    const dark = Math.min(l1, l2);
    return (light + 0.05) / (dark + 0.05);
  }
  function getForeground(color) {
    const blackContrast = Math.abs(APCAcontrast(parseColor(0), parseColor(color)));
    const whiteContrast = Math.abs(APCAcontrast(parseColor(16777215), parseColor(color)));
    return whiteContrast > Math.min(blackContrast, 50) ? "#fff" : "#000";
  }

  // ../library_management/node_modules/vuetify/lib/util/propsFactory.mjs
  function propsFactory(props, source) {
    return (defaults2) => {
      return Object.keys(props).reduce((obj, prop) => {
        const isObjectDefinition = typeof props[prop] === "object" && props[prop] != null && !Array.isArray(props[prop]);
        const definition = isObjectDefinition ? props[prop] : {
          type: props[prop]
        };
        if (defaults2 && prop in defaults2) {
          obj[prop] = __spreadProps(__spreadValues({}, definition), {
            default: defaults2[prop]
          });
        } else {
          obj[prop] = definition;
        }
        if (source && !obj[prop].source) {
          obj[prop].source = source;
        }
        return obj;
      }, {});
    };
  }

  // ../library_management/node_modules/vuetify/lib/composables/component.mjs
  var makeComponentProps = propsFactory({
    class: [String, Array],
    style: {
      type: [String, Array, Object],
      default: null
    }
  }, "component");

  // ../library_management/node_modules/vuetify/lib/composables/defaults.mjs
  var DefaultsSymbol = Symbol.for("vuetify:defaults");
  function createDefaults(options) {
    return ref(options);
  }
  function injectDefaults() {
    const defaults2 = inject(DefaultsSymbol);
    if (!defaults2)
      throw new Error("[Vuetify] Could not find defaults instance");
    return defaults2;
  }
  function provideDefaults(defaults2, options) {
    const injectedDefaults = injectDefaults();
    const providedDefaults = ref(defaults2);
    const newDefaults = computed2(() => {
      const disabled = unref(options == null ? void 0 : options.disabled);
      if (disabled)
        return injectedDefaults.value;
      const scoped = unref(options == null ? void 0 : options.scoped);
      const reset = unref(options == null ? void 0 : options.reset);
      const root = unref(options == null ? void 0 : options.root);
      if (providedDefaults.value == null && !(scoped || reset || root))
        return injectedDefaults.value;
      let properties = mergeDeep(providedDefaults.value, {
        prev: injectedDefaults.value
      });
      if (scoped)
        return properties;
      if (reset || root) {
        const len = Number(reset || Infinity);
        for (let i = 0; i <= len; i++) {
          if (!properties || !("prev" in properties)) {
            break;
          }
          properties = properties.prev;
        }
        if (properties && typeof root === "string" && root in properties) {
          properties = mergeDeep(mergeDeep(properties, {
            prev: properties
          }), properties[root]);
        }
        return properties;
      }
      return properties.prev ? mergeDeep(properties.prev, properties) : properties;
    });
    provide(DefaultsSymbol, newDefaults);
    return newDefaults;
  }
  function propIsDefined(vnode, prop) {
    var _a2, _b;
    return typeof ((_a2 = vnode.props) == null ? void 0 : _a2[prop]) !== "undefined" || typeof ((_b = vnode.props) == null ? void 0 : _b[toKebabCase(prop)]) !== "undefined";
  }
  function internalUseDefaults() {
    var _a2;
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let name = arguments.length > 1 ? arguments[1] : void 0;
    let defaults2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : injectDefaults();
    const vm = getCurrentInstance2("useDefaults");
    name = (_a2 = name != null ? name : vm.type.name) != null ? _a2 : vm.type.__name;
    if (!name) {
      throw new Error("[Vuetify] Could not determine component name");
    }
    const componentDefaults = computed2(() => {
      var _a3, _b;
      return (_b = defaults2.value) == null ? void 0 : _b[(_a3 = props._as) != null ? _a3 : name];
    });
    const _props = new Proxy(props, {
      get(target, prop) {
        var _a3, _b, _c, _d, _e, _f;
        const propValue = Reflect.get(target, prop);
        if (prop === "class" || prop === "style") {
          return [(_a3 = componentDefaults.value) == null ? void 0 : _a3[prop], propValue].filter((v) => v != null);
        } else if (typeof prop === "string" && !propIsDefined(vm.vnode, prop)) {
          return (_f = (_e = (_b = componentDefaults.value) == null ? void 0 : _b[prop]) != null ? _e : (_d = (_c = defaults2.value) == null ? void 0 : _c.global) == null ? void 0 : _d[prop]) != null ? _f : propValue;
        }
        return propValue;
      }
    });
    const _subcomponentDefaults = shallowRef();
    watchEffect(() => {
      if (componentDefaults.value) {
        const subComponents = Object.entries(componentDefaults.value).filter((_ref) => {
          let [key] = _ref;
          return key.startsWith(key[0].toUpperCase());
        });
        _subcomponentDefaults.value = subComponents.length ? Object.fromEntries(subComponents) : void 0;
      } else {
        _subcomponentDefaults.value = void 0;
      }
    });
    function provideSubDefaults() {
      const injected = injectSelf(DefaultsSymbol, vm);
      provide(DefaultsSymbol, computed2(() => {
        var _a3;
        return _subcomponentDefaults.value ? mergeDeep((_a3 = injected == null ? void 0 : injected.value) != null ? _a3 : {}, _subcomponentDefaults.value) : injected == null ? void 0 : injected.value;
      }));
    }
    return {
      props: _props,
      provideSubDefaults
    };
  }

  // ../library_management/node_modules/vuetify/lib/util/defineComponent.mjs
  function defineComponent2(options) {
    var _a2, _b;
    options._setup = (_a2 = options._setup) != null ? _a2 : options.setup;
    if (!options.name) {
      consoleWarn("The component is missing an explicit name, unable to generate default prop value");
      return options;
    }
    if (options._setup) {
      options.props = propsFactory((_b = options.props) != null ? _b : {}, options.name)();
      const propKeys = Object.keys(options.props).filter((key) => key !== "class" && key !== "style");
      options.filterProps = function filterProps(props) {
        return pick(props, propKeys);
      };
      options.props._as = String;
      options.setup = function setup(props, ctx) {
        var _a3;
        const defaults2 = injectDefaults();
        if (!defaults2.value)
          return options._setup(props, ctx);
        const {
          props: _props,
          provideSubDefaults
        } = internalUseDefaults(props, (_a3 = props._as) != null ? _a3 : options.name, defaults2);
        const setupBindings = options._setup(_props, ctx);
        provideSubDefaults();
        return setupBindings;
      };
    }
    return options;
  }
  function genericComponent() {
    let exposeDefaults = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    return (options) => (exposeDefaults ? defineComponent2 : defineComponent)(options);
  }
  function defineFunctionalComponent(props, render7) {
    render7.props = props;
    return render7;
  }

  // ../library_management/node_modules/vuetify/lib/util/createSimpleFunctional.mjs
  function createSimpleFunctional(klass) {
    let tag = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "div";
    let name = arguments.length > 2 ? arguments[2] : void 0;
    return genericComponent()({
      name: name != null ? name : capitalize(camelize(klass.replace(/__/g, "-"))),
      props: __spreadValues({
        tag: {
          type: String,
          default: tag
        }
      }, makeComponentProps()),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        return () => {
          var _a2;
          return h(props.tag, {
            class: [klass, props.class],
            style: props.style
          }, (_a2 = slots.default) == null ? void 0 : _a2.call(slots));
        };
      }
    });
  }

  // ../library_management/node_modules/vuetify/lib/util/dom.mjs
  function attachedRoot(node) {
    if (typeof node.getRootNode !== "function") {
      while (node.parentNode)
        node = node.parentNode;
      if (node !== document)
        return null;
      return document;
    }
    const root = node.getRootNode();
    if (root !== document && root.getRootNode({
      composed: true
    }) !== document)
      return null;
    return root;
  }

  // ../library_management/node_modules/vuetify/lib/util/easing.mjs
  var standardEasing = "cubic-bezier(0.4, 0, 0.2, 1)";
  var deceleratedEasing = "cubic-bezier(0.0, 0, 0.2, 1)";
  var acceleratedEasing = "cubic-bezier(0.4, 0, 1, 1)";

  // ../library_management/node_modules/vuetify/lib/util/events.mjs
  function getPrefixedEventHandlers(attrs, suffix, getData) {
    return Object.keys(attrs).filter((key) => isOn2(key) && key.endsWith(suffix)).reduce((acc, key) => {
      acc[key.slice(0, -suffix.length)] = (event) => attrs[key](event, getData(event));
      return acc;
    }, {});
  }

  // ../library_management/node_modules/vuetify/lib/util/getCurrentInstance.mjs
  function getCurrentInstance2(name, message) {
    const vm = getCurrentInstance();
    if (!vm) {
      throw new Error(`[Vuetify] ${name} ${message || "must be called from inside a setup function"}`);
    }
    return vm;
  }
  function getCurrentInstanceName() {
    let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "composables";
    const vm = getCurrentInstance2(name).type;
    return toKebabCase((vm == null ? void 0 : vm.aliasName) || (vm == null ? void 0 : vm.name));
  }
  var _uid = 0;
  var _map = /* @__PURE__ */ new WeakMap();
  function getUid() {
    const vm = getCurrentInstance2("getUid");
    if (_map.has(vm))
      return _map.get(vm);
    else {
      const uid2 = _uid++;
      _map.set(vm, uid2);
      return uid2;
    }
  }
  getUid.reset = () => {
    _uid = 0;
    _map = /* @__PURE__ */ new WeakMap();
  };

  // ../library_management/node_modules/vuetify/lib/util/getScrollParent.mjs
  function getScrollParent(el) {
    let includeHidden = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    while (el) {
      if (includeHidden ? isPotentiallyScrollable(el) : hasScrollbar(el))
        return el;
      el = el.parentElement;
    }
    return document.scrollingElement;
  }
  function getScrollParents(el, stopAt) {
    const elements = [];
    if (stopAt && el && !stopAt.contains(el))
      return elements;
    while (el) {
      if (hasScrollbar(el))
        elements.push(el);
      if (el === stopAt)
        break;
      el = el.parentElement;
    }
    return elements;
  }
  function hasScrollbar(el) {
    if (!el || el.nodeType !== Node.ELEMENT_NODE)
      return false;
    const style = window.getComputedStyle(el);
    return style.overflowY === "scroll" || style.overflowY === "auto" && el.scrollHeight > el.clientHeight;
  }
  function isPotentiallyScrollable(el) {
    if (!el || el.nodeType !== Node.ELEMENT_NODE)
      return false;
    const style = window.getComputedStyle(el);
    return ["scroll", "auto"].includes(style.overflowY);
  }

  // ../library_management/node_modules/vuetify/lib/util/injectSelf.mjs
  function injectSelf(key) {
    let vm = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstance2("injectSelf");
    const {
      provides
    } = vm;
    if (provides && key in provides) {
      return provides[key];
    }
    return void 0;
  }

  // ../library_management/node_modules/vuetify/lib/util/isFixedPosition.mjs
  function isFixedPosition(el) {
    while (el) {
      if (window.getComputedStyle(el).position === "fixed") {
        return true;
      }
      el = el.offsetParent;
    }
    return false;
  }

  // ../library_management/node_modules/vuetify/lib/util/useRender.mjs
  function useRender(render7) {
    const vm = getCurrentInstance2("useRender");
    vm.render = render7;
  }

  // ../library_management/node_modules/vuetify/lib/composables/proxiedModel.mjs
  function useProxiedModel(props, prop, defaultValue2) {
    let transformIn = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : (v) => v;
    let transformOut = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : (v) => v;
    const vm = getCurrentInstance2("useProxiedModel");
    const internal = ref(props[prop] !== void 0 ? props[prop] : defaultValue2);
    const kebabProp = toKebabCase(prop);
    const checkKebab = kebabProp !== prop;
    const isControlled = checkKebab ? computed2(() => {
      var _a2, _b, _c, _d;
      void props[prop];
      return !!((((_a2 = vm.vnode.props) == null ? void 0 : _a2.hasOwnProperty(prop)) || ((_b = vm.vnode.props) == null ? void 0 : _b.hasOwnProperty(kebabProp))) && (((_c = vm.vnode.props) == null ? void 0 : _c.hasOwnProperty(`onUpdate:${prop}`)) || ((_d = vm.vnode.props) == null ? void 0 : _d.hasOwnProperty(`onUpdate:${kebabProp}`))));
    }) : computed2(() => {
      var _a2, _b;
      void props[prop];
      return !!(((_a2 = vm.vnode.props) == null ? void 0 : _a2.hasOwnProperty(prop)) && ((_b = vm.vnode.props) == null ? void 0 : _b.hasOwnProperty(`onUpdate:${prop}`)));
    });
    useToggleScope(() => !isControlled.value, () => {
      watch(() => props[prop], (val) => {
        internal.value = val;
      });
    });
    const model = computed2({
      get() {
        const externalValue = props[prop];
        return transformIn(isControlled.value ? externalValue : internal.value);
      },
      set(internalValue) {
        const newValue = transformOut(internalValue);
        const value = toRaw(isControlled.value ? props[prop] : internal.value);
        if (value === newValue || transformIn(value) === internalValue) {
          return;
        }
        internal.value = newValue;
        vm == null ? void 0 : vm.emit(`update:${prop}`, newValue);
      }
    });
    Object.defineProperty(model, "externalValue", {
      get: () => isControlled.value ? props[prop] : internal.value
    });
    return model;
  }

  // ../library_management/node_modules/vuetify/lib/locale/en.mjs
  var en_default = {
    badge: "Badge",
    open: "Open",
    close: "Close",
    confirmEdit: {
      ok: "OK",
      cancel: "Cancel"
    },
    dataIterator: {
      noResultsText: "No matching records found",
      loadingText: "Loading items..."
    },
    dataTable: {
      itemsPerPageText: "Rows per page:",
      ariaLabel: {
        sortDescending: "Sorted descending.",
        sortAscending: "Sorted ascending.",
        sortNone: "Not sorted.",
        activateNone: "Activate to remove sorting.",
        activateDescending: "Activate to sort descending.",
        activateAscending: "Activate to sort ascending."
      },
      sortBy: "Sort by"
    },
    dataFooter: {
      itemsPerPageText: "Items per page:",
      itemsPerPageAll: "All",
      nextPage: "Next page",
      prevPage: "Previous page",
      firstPage: "First page",
      lastPage: "Last page",
      pageText: "{0}-{1} of {2}"
    },
    dateRangeInput: {
      divider: "to"
    },
    datePicker: {
      itemsSelected: "{0} selected",
      range: {
        title: "Select dates",
        header: "Enter dates"
      },
      title: "Select date",
      header: "Enter date",
      input: {
        placeholder: "Enter date"
      }
    },
    noDataText: "No data available",
    carousel: {
      prev: "Previous visual",
      next: "Next visual",
      ariaLabel: {
        delimiter: "Carousel slide {0} of {1}"
      }
    },
    calendar: {
      moreEvents: "{0} more",
      today: "Today"
    },
    input: {
      clear: "Clear {0}",
      prependAction: "{0} prepended action",
      appendAction: "{0} appended action",
      otp: "Please enter OTP character {0}"
    },
    fileInput: {
      counter: "{0} files",
      counterSize: "{0} files ({1} in total)"
    },
    timePicker: {
      am: "AM",
      pm: "PM",
      title: "Select Time"
    },
    pagination: {
      ariaLabel: {
        root: "Pagination Navigation",
        next: "Next page",
        previous: "Previous page",
        page: "Go to page {0}",
        currentPage: "Page {0}, Current page",
        first: "First page",
        last: "Last page"
      }
    },
    stepper: {
      next: "Next",
      prev: "Previous"
    },
    rating: {
      ariaLabel: {
        item: "Rating {0} of {1}"
      }
    },
    loading: "Loading...",
    infiniteScroll: {
      loadMore: "Load more",
      empty: "No more"
    }
  };

  // ../library_management/node_modules/vuetify/lib/locale/adapters/vuetify.mjs
  var LANG_PREFIX = "$vuetify.";
  var replace = (str, params) => {
    return str.replace(/\{(\d+)\}/g, (match, index) => {
      return String(params[+index]);
    });
  };
  var createTranslateFunction = (current, fallback, messages) => {
    return function(key) {
      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        params[_key - 1] = arguments[_key];
      }
      if (!key.startsWith(LANG_PREFIX)) {
        return replace(key, params);
      }
      const shortKey = key.replace(LANG_PREFIX, "");
      const currentLocale = current.value && messages.value[current.value];
      const fallbackLocale = fallback.value && messages.value[fallback.value];
      let str = getObjectValueByPath(currentLocale, shortKey, null);
      if (!str) {
        consoleWarn(`Translation key "${key}" not found in "${current.value}", trying fallback locale`);
        str = getObjectValueByPath(fallbackLocale, shortKey, null);
      }
      if (!str) {
        consoleError(`Translation key "${key}" not found in fallback`);
        str = key;
      }
      if (typeof str !== "string") {
        consoleError(`Translation key "${key}" has a non-string value`);
        str = key;
      }
      return replace(str, params);
    };
  };
  function createNumberFunction(current, fallback) {
    return (value, options) => {
      const numberFormat = new Intl.NumberFormat([current.value, fallback.value], options);
      return numberFormat.format(value);
    };
  }
  function useProvided(props, prop, provided) {
    var _a2, _b;
    const internal = useProxiedModel(props, prop, (_a2 = props[prop]) != null ? _a2 : provided.value);
    internal.value = (_b = props[prop]) != null ? _b : provided.value;
    watch(provided, (v) => {
      if (props[prop] == null) {
        internal.value = provided.value;
      }
    });
    return internal;
  }
  function createProvideFunction(state) {
    return (props) => {
      const current = useProvided(props, "locale", state.current);
      const fallback = useProvided(props, "fallback", state.fallback);
      const messages = useProvided(props, "messages", state.messages);
      return {
        name: "vuetify",
        current,
        fallback,
        messages,
        t: createTranslateFunction(current, fallback, messages),
        n: createNumberFunction(current, fallback),
        provide: createProvideFunction({
          current,
          fallback,
          messages
        })
      };
    };
  }
  function createVuetifyAdapter(options) {
    var _a2, _b;
    const current = shallowRef((_a2 = options == null ? void 0 : options.locale) != null ? _a2 : "en");
    const fallback = shallowRef((_b = options == null ? void 0 : options.fallback) != null ? _b : "en");
    const messages = ref(__spreadValues({
      en: en_default
    }, options == null ? void 0 : options.messages));
    return {
      name: "vuetify",
      current,
      fallback,
      messages,
      t: createTranslateFunction(current, fallback, messages),
      n: createNumberFunction(current, fallback),
      provide: createProvideFunction({
        current,
        fallback,
        messages
      })
    };
  }

  // ../library_management/node_modules/vuetify/lib/composables/locale.mjs
  var LocaleSymbol = Symbol.for("vuetify:locale");
  function isLocaleInstance(obj) {
    return obj.name != null;
  }
  function createLocale(options) {
    const i18n = (options == null ? void 0 : options.adapter) && isLocaleInstance(options == null ? void 0 : options.adapter) ? options == null ? void 0 : options.adapter : createVuetifyAdapter(options);
    const rtl = createRtl(i18n, options);
    return __spreadValues(__spreadValues({}, i18n), rtl);
  }
  function useLocale() {
    const locale = inject(LocaleSymbol);
    if (!locale)
      throw new Error("[Vuetify] Could not find injected locale instance");
    return locale;
  }
  function provideLocale(props) {
    const locale = inject(LocaleSymbol);
    if (!locale)
      throw new Error("[Vuetify] Could not find injected locale instance");
    const i18n = locale.provide(props);
    const rtl = provideRtl(i18n, locale.rtl, props);
    const data = __spreadValues(__spreadValues({}, i18n), rtl);
    provide(LocaleSymbol, data);
    return data;
  }
  var RtlSymbol = Symbol.for("vuetify:rtl");
  function genDefaults() {
    return {
      af: false,
      ar: true,
      bg: false,
      ca: false,
      ckb: false,
      cs: false,
      de: false,
      el: false,
      en: false,
      es: false,
      et: false,
      fa: true,
      fi: false,
      fr: false,
      hr: false,
      hu: false,
      he: true,
      id: false,
      it: false,
      ja: false,
      km: false,
      ko: false,
      lv: false,
      lt: false,
      nl: false,
      no: false,
      pl: false,
      pt: false,
      ro: false,
      ru: false,
      sk: false,
      sl: false,
      srCyrl: false,
      srLatn: false,
      sv: false,
      th: false,
      tr: false,
      az: false,
      uk: false,
      vi: false,
      zhHans: false,
      zhHant: false
    };
  }
  function createRtl(i18n, options) {
    var _a2;
    const rtl = ref((_a2 = options == null ? void 0 : options.rtl) != null ? _a2 : genDefaults());
    const isRtl = computed2(() => {
      var _a3;
      return (_a3 = rtl.value[i18n.current.value]) != null ? _a3 : false;
    });
    return {
      isRtl,
      rtl,
      rtlClasses: computed2(() => `v-locale--is-${isRtl.value ? "rtl" : "ltr"}`)
    };
  }
  function provideRtl(locale, rtl, props) {
    const isRtl = computed2(() => {
      var _a2, _b;
      return (_b = (_a2 = props.rtl) != null ? _a2 : rtl.value[locale.current.value]) != null ? _b : false;
    });
    return {
      isRtl,
      rtl,
      rtlClasses: computed2(() => `v-locale--is-${isRtl.value ? "rtl" : "ltr"}`)
    };
  }
  function useRtl() {
    const locale = inject(LocaleSymbol);
    if (!locale)
      throw new Error("[Vuetify] Could not find injected rtl instance");
    return {
      isRtl: locale.isRtl,
      rtlClasses: locale.rtlClasses
    };
  }

  // ../library_management/node_modules/vuetify/lib/composables/date/adapters/vuetify.mjs
  var firstDay = {
    "001": 1,
    AD: 1,
    AE: 6,
    AF: 6,
    AG: 0,
    AI: 1,
    AL: 1,
    AM: 1,
    AN: 1,
    AR: 1,
    AS: 0,
    AT: 1,
    AU: 1,
    AX: 1,
    AZ: 1,
    BA: 1,
    BD: 0,
    BE: 1,
    BG: 1,
    BH: 6,
    BM: 1,
    BN: 1,
    BR: 0,
    BS: 0,
    BT: 0,
    BW: 0,
    BY: 1,
    BZ: 0,
    CA: 0,
    CH: 1,
    CL: 1,
    CM: 1,
    CN: 1,
    CO: 0,
    CR: 1,
    CY: 1,
    CZ: 1,
    DE: 1,
    DJ: 6,
    DK: 1,
    DM: 0,
    DO: 0,
    DZ: 6,
    EC: 1,
    EE: 1,
    EG: 6,
    ES: 1,
    ET: 0,
    FI: 1,
    FJ: 1,
    FO: 1,
    FR: 1,
    GB: 1,
    "GB-alt-variant": 0,
    GE: 1,
    GF: 1,
    GP: 1,
    GR: 1,
    GT: 0,
    GU: 0,
    HK: 0,
    HN: 0,
    HR: 1,
    HU: 1,
    ID: 0,
    IE: 1,
    IL: 0,
    IN: 0,
    IQ: 6,
    IR: 6,
    IS: 1,
    IT: 1,
    JM: 0,
    JO: 6,
    JP: 0,
    KE: 0,
    KG: 1,
    KH: 0,
    KR: 0,
    KW: 6,
    KZ: 1,
    LA: 0,
    LB: 1,
    LI: 1,
    LK: 1,
    LT: 1,
    LU: 1,
    LV: 1,
    LY: 6,
    MC: 1,
    MD: 1,
    ME: 1,
    MH: 0,
    MK: 1,
    MM: 0,
    MN: 1,
    MO: 0,
    MQ: 1,
    MT: 0,
    MV: 5,
    MX: 0,
    MY: 1,
    MZ: 0,
    NI: 0,
    NL: 1,
    NO: 1,
    NP: 0,
    NZ: 1,
    OM: 6,
    PA: 0,
    PE: 0,
    PH: 0,
    PK: 0,
    PL: 1,
    PR: 0,
    PT: 0,
    PY: 0,
    QA: 6,
    RE: 1,
    RO: 1,
    RS: 1,
    RU: 1,
    SA: 0,
    SD: 6,
    SE: 1,
    SG: 0,
    SI: 1,
    SK: 1,
    SM: 1,
    SV: 0,
    SY: 6,
    TH: 0,
    TJ: 1,
    TM: 1,
    TR: 1,
    TT: 0,
    TW: 0,
    UA: 1,
    UM: 0,
    US: 0,
    UY: 1,
    UZ: 1,
    VA: 1,
    VE: 0,
    VI: 0,
    VN: 1,
    WS: 0,
    XK: 1,
    YE: 0,
    ZA: 0,
    ZW: 0
  };
  function getWeekArray(date2, locale) {
    const weeks = [];
    let currentWeek = [];
    const firstDayOfMonth = startOfMonth(date2);
    const lastDayOfMonth = endOfMonth(date2);
    const firstDayWeekIndex = (firstDayOfMonth.getDay() - firstDay[locale.slice(-2).toUpperCase()] + 7) % 7;
    const lastDayWeekIndex = (lastDayOfMonth.getDay() - firstDay[locale.slice(-2).toUpperCase()] + 7) % 7;
    for (let i = 0; i < firstDayWeekIndex; i++) {
      const adjacentDay = new Date(firstDayOfMonth);
      adjacentDay.setDate(adjacentDay.getDate() - (firstDayWeekIndex - i));
      currentWeek.push(adjacentDay);
    }
    for (let i = 1; i <= lastDayOfMonth.getDate(); i++) {
      const day = new Date(date2.getFullYear(), date2.getMonth(), i);
      currentWeek.push(day);
      if (currentWeek.length === 7) {
        weeks.push(currentWeek);
        currentWeek = [];
      }
    }
    for (let i = 1; i < 7 - lastDayWeekIndex; i++) {
      const adjacentDay = new Date(lastDayOfMonth);
      adjacentDay.setDate(adjacentDay.getDate() + i);
      currentWeek.push(adjacentDay);
    }
    if (currentWeek.length > 0) {
      weeks.push(currentWeek);
    }
    return weeks;
  }
  function startOfWeek(date2) {
    const d = new Date(date2);
    while (d.getDay() !== 0) {
      d.setDate(d.getDate() - 1);
    }
    return d;
  }
  function endOfWeek(date2) {
    const d = new Date(date2);
    while (d.getDay() !== 6) {
      d.setDate(d.getDate() + 1);
    }
    return d;
  }
  function startOfMonth(date2) {
    return new Date(date2.getFullYear(), date2.getMonth(), 1);
  }
  function endOfMonth(date2) {
    return new Date(date2.getFullYear(), date2.getMonth() + 1, 0);
  }
  function parseLocalDate(value) {
    const parts = value.split("-").map(Number);
    return new Date(parts[0], parts[1] - 1, parts[2]);
  }
  var _YYYMMDD = /^([12]\d{3}-([1-9]|0[1-9]|1[0-2])-([1-9]|0[1-9]|[12]\d|3[01]))$/;
  function date(value) {
    if (value == null)
      return new Date();
    if (value instanceof Date)
      return value;
    if (typeof value === "string") {
      let parsed;
      if (_YYYMMDD.test(value)) {
        return parseLocalDate(value);
      } else {
        parsed = Date.parse(value);
      }
      if (!isNaN(parsed))
        return new Date(parsed);
    }
    return null;
  }
  var sundayJanuarySecond2000 = new Date(2e3, 0, 2);
  function getWeekdays(locale) {
    const daysFromSunday = firstDay[locale.slice(-2).toUpperCase()];
    return createRange(7).map((i) => {
      const weekday = new Date(sundayJanuarySecond2000);
      weekday.setDate(sundayJanuarySecond2000.getDate() + daysFromSunday + i);
      return new Intl.DateTimeFormat(locale, {
        weekday: "narrow"
      }).format(weekday);
    });
  }
  function format(value, formatString, locale, formats) {
    var _a2;
    const newDate = (_a2 = date(value)) != null ? _a2 : new Date();
    const customFormat = formats == null ? void 0 : formats[formatString];
    if (typeof customFormat === "function") {
      return customFormat(newDate, formatString, locale);
    }
    let options = {};
    switch (formatString) {
      case "fullDateWithWeekday":
        options = {
          weekday: "long",
          day: "numeric",
          month: "long",
          year: "numeric"
        };
        break;
      case "hours12h":
        options = {
          hour: "numeric",
          hour12: true
        };
        break;
      case "normalDateWithWeekday":
        options = {
          weekday: "short",
          day: "numeric",
          month: "short"
        };
        break;
      case "keyboardDate":
        options = {
          day: "2-digit",
          month: "2-digit",
          year: "numeric"
        };
        break;
      case "monthAndDate":
        options = {
          month: "long",
          day: "numeric"
        };
        break;
      case "monthAndYear":
        options = {
          month: "long",
          year: "numeric"
        };
        break;
      case "month":
        options = {
          month: "long"
        };
        break;
      case "monthShort":
        options = {
          month: "short"
        };
        break;
      case "dayOfMonth":
        return new Intl.NumberFormat(locale).format(newDate.getDate());
      case "shortDate":
        options = {
          year: "2-digit",
          month: "numeric",
          day: "numeric"
        };
        break;
      case "weekdayShort":
        options = {
          weekday: "short"
        };
        break;
      case "year":
        options = {
          year: "numeric"
        };
        break;
      default:
        options = customFormat != null ? customFormat : {
          timeZone: "UTC",
          timeZoneName: "short"
        };
    }
    return new Intl.DateTimeFormat(locale, options).format(newDate);
  }
  function toISO(adapter, value) {
    const date2 = adapter.toJsDate(value);
    const year = date2.getFullYear();
    const month = padStart(String(date2.getMonth() + 1), 2, "0");
    const day = padStart(String(date2.getDate()), 2, "0");
    return `${year}-${month}-${day}`;
  }
  function parseISO(value) {
    const [year, month, day] = value.split("-").map(Number);
    return new Date(year, month - 1, day);
  }
  function addMinutes(date2, amount) {
    const d = new Date(date2);
    d.setMinutes(d.getMinutes() + amount);
    return d;
  }
  function addHours(date2, amount) {
    const d = new Date(date2);
    d.setHours(d.getHours() + amount);
    return d;
  }
  function addDays(date2, amount) {
    const d = new Date(date2);
    d.setDate(d.getDate() + amount);
    return d;
  }
  function addWeeks(date2, amount) {
    const d = new Date(date2);
    d.setDate(d.getDate() + amount * 7);
    return d;
  }
  function addMonths(date2, amount) {
    const d = new Date(date2);
    d.setMonth(d.getMonth() + amount);
    return d;
  }
  function getYear(date2) {
    return date2.getFullYear();
  }
  function getMonth(date2) {
    return date2.getMonth();
  }
  function getDate(date2) {
    return date2.getDate();
  }
  function getNextMonth(date2) {
    return new Date(date2.getFullYear(), date2.getMonth() + 1, 1);
  }
  function getHours(date2) {
    return date2.getHours();
  }
  function getMinutes(date2) {
    return date2.getMinutes();
  }
  function startOfYear(date2) {
    return new Date(date2.getFullYear(), 0, 1);
  }
  function endOfYear(date2) {
    return new Date(date2.getFullYear(), 11, 31);
  }
  function isWithinRange(date2, range) {
    return isAfter(date2, range[0]) && isBefore(date2, range[1]);
  }
  function isValid(date2) {
    const d = new Date(date2);
    return d instanceof Date && !isNaN(d.getTime());
  }
  function isAfter(date2, comparing) {
    return date2.getTime() > comparing.getTime();
  }
  function isBefore(date2, comparing) {
    return date2.getTime() < comparing.getTime();
  }
  function isEqual(date2, comparing) {
    return date2.getTime() === comparing.getTime();
  }
  function isSameDay(date2, comparing) {
    return date2.getDate() === comparing.getDate() && date2.getMonth() === comparing.getMonth() && date2.getFullYear() === comparing.getFullYear();
  }
  function isSameMonth(date2, comparing) {
    return date2.getMonth() === comparing.getMonth() && date2.getFullYear() === comparing.getFullYear();
  }
  function getDiff(date2, comparing, unit) {
    const d = new Date(date2);
    const c = new Date(comparing);
    switch (unit) {
      case "years":
        return d.getFullYear() - c.getFullYear();
      case "quarters":
        return Math.floor((d.getMonth() - c.getMonth() + (d.getFullYear() - c.getFullYear()) * 12) / 4);
      case "months":
        return d.getMonth() - c.getMonth() + (d.getFullYear() - c.getFullYear()) * 12;
      case "weeks":
        return Math.floor((d.getTime() - c.getTime()) / (1e3 * 60 * 60 * 24 * 7));
      case "days":
        return Math.floor((d.getTime() - c.getTime()) / (1e3 * 60 * 60 * 24));
      case "hours":
        return Math.floor((d.getTime() - c.getTime()) / (1e3 * 60 * 60));
      case "minutes":
        return Math.floor((d.getTime() - c.getTime()) / (1e3 * 60));
      case "seconds":
        return Math.floor((d.getTime() - c.getTime()) / 1e3);
      default: {
        return d.getTime() - c.getTime();
      }
    }
  }
  function setHours(date2, count) {
    const d = new Date(date2);
    d.setHours(count);
    return d;
  }
  function setMinutes(date2, count) {
    const d = new Date(date2);
    d.setMinutes(count);
    return d;
  }
  function setMonth(date2, count) {
    const d = new Date(date2);
    d.setMonth(count);
    return d;
  }
  function setDate(date2, day) {
    const d = new Date(date2);
    d.setDate(day);
    return d;
  }
  function setYear(date2, year) {
    const d = new Date(date2);
    d.setFullYear(year);
    return d;
  }
  function startOfDay(date2) {
    return new Date(date2.getFullYear(), date2.getMonth(), date2.getDate(), 0, 0, 0, 0);
  }
  function endOfDay(date2) {
    return new Date(date2.getFullYear(), date2.getMonth(), date2.getDate(), 23, 59, 59, 999);
  }
  var VuetifyDateAdapter = class {
    constructor(options) {
      this.locale = options.locale;
      this.formats = options.formats;
    }
    date(value) {
      return date(value);
    }
    toJsDate(date2) {
      return date2;
    }
    toISO(date2) {
      return toISO(this, date2);
    }
    parseISO(date2) {
      return parseISO(date2);
    }
    addMinutes(date2, amount) {
      return addMinutes(date2, amount);
    }
    addHours(date2, amount) {
      return addHours(date2, amount);
    }
    addDays(date2, amount) {
      return addDays(date2, amount);
    }
    addWeeks(date2, amount) {
      return addWeeks(date2, amount);
    }
    addMonths(date2, amount) {
      return addMonths(date2, amount);
    }
    getWeekArray(date2) {
      return getWeekArray(date2, this.locale);
    }
    startOfWeek(date2) {
      return startOfWeek(date2);
    }
    endOfWeek(date2) {
      return endOfWeek(date2);
    }
    startOfMonth(date2) {
      return startOfMonth(date2);
    }
    endOfMonth(date2) {
      return endOfMonth(date2);
    }
    format(date2, formatString) {
      return format(date2, formatString, this.locale, this.formats);
    }
    isEqual(date2, comparing) {
      return isEqual(date2, comparing);
    }
    isValid(date2) {
      return isValid(date2);
    }
    isWithinRange(date2, range) {
      return isWithinRange(date2, range);
    }
    isAfter(date2, comparing) {
      return isAfter(date2, comparing);
    }
    isBefore(date2, comparing) {
      return !isAfter(date2, comparing) && !isEqual(date2, comparing);
    }
    isSameDay(date2, comparing) {
      return isSameDay(date2, comparing);
    }
    isSameMonth(date2, comparing) {
      return isSameMonth(date2, comparing);
    }
    setMinutes(date2, count) {
      return setMinutes(date2, count);
    }
    setHours(date2, count) {
      return setHours(date2, count);
    }
    setMonth(date2, count) {
      return setMonth(date2, count);
    }
    setDate(date2, day) {
      return setDate(date2, day);
    }
    setYear(date2, year) {
      return setYear(date2, year);
    }
    getDiff(date2, comparing, unit) {
      return getDiff(date2, comparing, unit);
    }
    getWeekdays() {
      return getWeekdays(this.locale);
    }
    getYear(date2) {
      return getYear(date2);
    }
    getMonth(date2) {
      return getMonth(date2);
    }
    getDate(date2) {
      return getDate(date2);
    }
    getNextMonth(date2) {
      return getNextMonth(date2);
    }
    getHours(date2) {
      return getHours(date2);
    }
    getMinutes(date2) {
      return getMinutes(date2);
    }
    startOfDay(date2) {
      return startOfDay(date2);
    }
    endOfDay(date2) {
      return endOfDay(date2);
    }
    startOfYear(date2) {
      return startOfYear(date2);
    }
    endOfYear(date2) {
      return endOfYear(date2);
    }
  };

  // ../library_management/node_modules/vuetify/lib/composables/date/date.mjs
  var DateOptionsSymbol = Symbol.for("vuetify:date-options");
  var DateAdapterSymbol = Symbol.for("vuetify:date-adapter");
  function createDate(options, locale) {
    const _options = mergeDeep({
      adapter: VuetifyDateAdapter,
      locale: {
        af: "af-ZA",
        bg: "bg-BG",
        ca: "ca-ES",
        ckb: "",
        cs: "cs-CZ",
        de: "de-DE",
        el: "el-GR",
        en: "en-US",
        et: "et-EE",
        fa: "fa-IR",
        fi: "fi-FI",
        hr: "hr-HR",
        hu: "hu-HU",
        he: "he-IL",
        id: "id-ID",
        it: "it-IT",
        ja: "ja-JP",
        ko: "ko-KR",
        lv: "lv-LV",
        lt: "lt-LT",
        nl: "nl-NL",
        no: "no-NO",
        pl: "pl-PL",
        pt: "pt-PT",
        ro: "ro-RO",
        ru: "ru-RU",
        sk: "sk-SK",
        sl: "sl-SI",
        srCyrl: "sr-SP",
        srLatn: "sr-SP",
        sv: "sv-SE",
        th: "th-TH",
        tr: "tr-TR",
        az: "az-AZ",
        uk: "uk-UA",
        vi: "vi-VN",
        zhHans: "zh-CN",
        zhHant: "zh-TW"
      }
    }, options);
    return {
      options: _options,
      instance: createInstance(_options, locale)
    };
  }
  function createInstance(options, locale) {
    var _a2;
    const instance = reactive(typeof options.adapter === "function" ? new options.adapter({
      locale: (_a2 = options.locale[locale.current.value]) != null ? _a2 : locale.current.value,
      formats: options.formats
    }) : options.adapter);
    watch(locale.current, (value) => {
      var _a3, _b;
      instance.locale = (_b = (_a3 = options.locale[value]) != null ? _a3 : value) != null ? _b : instance.locale;
    });
    return instance;
  }
  function useDate() {
    const options = inject(DateOptionsSymbol);
    if (!options)
      throw new Error("[Vuetify] Could not find injected date options");
    const locale = useLocale();
    return createInstance(options, locale);
  }
  function getWeek(adapter, value) {
    const date2 = adapter.toJsDate(value);
    let year = date2.getFullYear();
    let d1w1 = new Date(year, 0, 1);
    if (date2 < d1w1) {
      year = year - 1;
      d1w1 = new Date(year, 0, 1);
    } else {
      const tv = new Date(year + 1, 0, 1);
      if (date2 >= tv) {
        year = year + 1;
        d1w1 = tv;
      }
    }
    const diffTime = Math.abs(date2.getTime() - d1w1.getTime());
    const diffDays = Math.ceil(diffTime / (1e3 * 60 * 60 * 24));
    return Math.floor(diffDays / 7) + 1;
  }

  // ../library_management/node_modules/vuetify/lib/composables/display.mjs
  var breakpoints = ["sm", "md", "lg", "xl", "xxl"];
  var DisplaySymbol = Symbol.for("vuetify:display");
  var defaultDisplayOptions = {
    mobileBreakpoint: "lg",
    thresholds: {
      xs: 0,
      sm: 600,
      md: 960,
      lg: 1280,
      xl: 1920,
      xxl: 2560
    }
  };
  var parseDisplayOptions = function() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultDisplayOptions;
    return mergeDeep(defaultDisplayOptions, options);
  };
  function getClientWidth(ssr) {
    return IN_BROWSER && !ssr ? window.innerWidth : typeof ssr === "object" && ssr.clientWidth || 0;
  }
  function getClientHeight(ssr) {
    return IN_BROWSER && !ssr ? window.innerHeight : typeof ssr === "object" && ssr.clientHeight || 0;
  }
  function getPlatform(ssr) {
    const userAgent = IN_BROWSER && !ssr ? window.navigator.userAgent : "ssr";
    function match(regexp) {
      return Boolean(userAgent.match(regexp));
    }
    const android = match(/android/i);
    const ios = match(/iphone|ipad|ipod/i);
    const cordova = match(/cordova/i);
    const electron = match(/electron/i);
    const chrome = match(/chrome/i);
    const edge = match(/edge/i);
    const firefox = match(/firefox/i);
    const opera = match(/opera/i);
    const win = match(/win/i);
    const mac = match(/mac/i);
    const linux = match(/linux/i);
    return {
      android,
      ios,
      cordova,
      electron,
      chrome,
      edge,
      firefox,
      opera,
      win,
      mac,
      linux,
      touch: SUPPORTS_TOUCH,
      ssr: userAgent === "ssr"
    };
  }
  function createDisplay(options, ssr) {
    const {
      thresholds,
      mobileBreakpoint
    } = parseDisplayOptions(options);
    const height = shallowRef(getClientHeight(ssr));
    const platform = shallowRef(getPlatform(ssr));
    const state = reactive({});
    const width = shallowRef(getClientWidth(ssr));
    function updateSize() {
      height.value = getClientHeight();
      width.value = getClientWidth();
    }
    function update() {
      updateSize();
      platform.value = getPlatform();
    }
    watchEffect(() => {
      const xs = width.value < thresholds.sm;
      const sm = width.value < thresholds.md && !xs;
      const md = width.value < thresholds.lg && !(sm || xs);
      const lg = width.value < thresholds.xl && !(md || sm || xs);
      const xl = width.value < thresholds.xxl && !(lg || md || sm || xs);
      const xxl = width.value >= thresholds.xxl;
      const name = xs ? "xs" : sm ? "sm" : md ? "md" : lg ? "lg" : xl ? "xl" : "xxl";
      const breakpointValue = typeof mobileBreakpoint === "number" ? mobileBreakpoint : thresholds[mobileBreakpoint];
      const mobile = width.value < breakpointValue;
      state.xs = xs;
      state.sm = sm;
      state.md = md;
      state.lg = lg;
      state.xl = xl;
      state.xxl = xxl;
      state.smAndUp = !xs;
      state.mdAndUp = !(xs || sm);
      state.lgAndUp = !(xs || sm || md);
      state.xlAndUp = !(xs || sm || md || lg);
      state.smAndDown = !(md || lg || xl || xxl);
      state.mdAndDown = !(lg || xl || xxl);
      state.lgAndDown = !(xl || xxl);
      state.xlAndDown = !xxl;
      state.name = name;
      state.height = height.value;
      state.width = width.value;
      state.mobile = mobile;
      state.mobileBreakpoint = mobileBreakpoint;
      state.platform = platform.value;
      state.thresholds = thresholds;
    });
    if (IN_BROWSER) {
      window.addEventListener("resize", updateSize, {
        passive: true
      });
    }
    return __spreadProps(__spreadValues({}, toRefs(state)), {
      update,
      ssr: !!ssr
    });
  }
  var makeDisplayProps = propsFactory({
    mobileBreakpoint: [Number, String]
  }, "display");
  function useDisplay() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    const display = inject(DisplaySymbol);
    if (!display)
      throw new Error("Could not find Vuetify display injection");
    const mobile = computed2(() => {
      if (!props.mobileBreakpoint)
        return display.mobile.value;
      const breakpointValue = typeof props.mobileBreakpoint === "number" ? props.mobileBreakpoint : display.thresholds.value[props.mobileBreakpoint];
      return display.width.value < breakpointValue;
    });
    const displayClasses = computed2(() => {
      if (!name)
        return {};
      return {
        [`${name}--mobile`]: mobile.value
      };
    });
    return __spreadProps(__spreadValues({}, display), {
      displayClasses,
      mobile
    });
  }

  // ../library_management/node_modules/vuetify/lib/composables/goto.mjs
  var GoToSymbol = Symbol.for("vuetify:goto");
  function genDefaults2() {
    return {
      container: void 0,
      duration: 300,
      layout: false,
      offset: 0,
      easing: "easeInOutCubic",
      patterns: {
        linear: (t) => t,
        easeInQuad: (t) => t ** 2,
        easeOutQuad: (t) => t * (2 - t),
        easeInOutQuad: (t) => t < 0.5 ? 2 * t ** 2 : -1 + (4 - 2 * t) * t,
        easeInCubic: (t) => t ** 3,
        easeOutCubic: (t) => --t ** 3 + 1,
        easeInOutCubic: (t) => t < 0.5 ? 4 * t ** 3 : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
        easeInQuart: (t) => t ** 4,
        easeOutQuart: (t) => 1 - --t ** 4,
        easeInOutQuart: (t) => t < 0.5 ? 8 * t ** 4 : 1 - 8 * --t ** 4,
        easeInQuint: (t) => t ** 5,
        easeOutQuint: (t) => 1 + --t ** 5,
        easeInOutQuint: (t) => t < 0.5 ? 16 * t ** 5 : 1 + 16 * --t ** 5
      }
    };
  }
  function createGoTo(options, locale) {
    return {
      rtl: locale.isRtl,
      options: mergeDeep(genDefaults2(), options)
    };
  }

  // ../library_management/node_modules/vuetify/lib/iconsets/mdi.mjs
  var aliases = {
    collapse: "mdi-chevron-up",
    complete: "mdi-check",
    cancel: "mdi-close-circle",
    close: "mdi-close",
    delete: "mdi-close-circle",
    clear: "mdi-close-circle",
    success: "mdi-check-circle",
    info: "mdi-information",
    warning: "mdi-alert-circle",
    error: "mdi-close-circle",
    prev: "mdi-chevron-left",
    next: "mdi-chevron-right",
    checkboxOn: "mdi-checkbox-marked",
    checkboxOff: "mdi-checkbox-blank-outline",
    checkboxIndeterminate: "mdi-minus-box",
    delimiter: "mdi-circle",
    sortAsc: "mdi-arrow-up",
    sortDesc: "mdi-arrow-down",
    expand: "mdi-chevron-down",
    menu: "mdi-menu",
    subgroup: "mdi-menu-down",
    dropdown: "mdi-menu-down",
    radioOn: "mdi-radiobox-marked",
    radioOff: "mdi-radiobox-blank",
    edit: "mdi-pencil",
    ratingEmpty: "mdi-star-outline",
    ratingFull: "mdi-star",
    ratingHalf: "mdi-star-half-full",
    loading: "mdi-cached",
    first: "mdi-page-first",
    last: "mdi-page-last",
    unfold: "mdi-unfold-more-horizontal",
    file: "mdi-paperclip",
    plus: "mdi-plus",
    minus: "mdi-minus",
    calendar: "mdi-calendar",
    treeviewCollapse: "mdi-menu-down",
    treeviewExpand: "mdi-menu-right",
    eyeDropper: "mdi-eyedropper"
  };
  var mdi = {
    component: (props) => h(VClassIcon, __spreadProps(__spreadValues({}, props), {
      class: "mdi"
    }))
  };

  // ../library_management/node_modules/vuetify/lib/composables/icons.mjs
  var IconValue = [String, Function, Object, Array];
  var IconSymbol = Symbol.for("vuetify:icons");
  var makeIconProps = propsFactory({
    icon: {
      type: IconValue
    },
    tag: {
      type: String,
      required: true
    }
  }, "icon");
  var VComponentIcon = genericComponent()({
    name: "VComponentIcon",
    props: makeIconProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      return () => {
        const Icon = props.icon;
        return createVNode(props.tag, null, {
          default: () => {
            var _a2;
            return [props.icon ? createVNode(Icon, null, null) : (_a2 = slots.default) == null ? void 0 : _a2.call(slots)];
          }
        });
      };
    }
  });
  var VSvgIcon = defineComponent2({
    name: "VSvgIcon",
    inheritAttrs: false,
    props: makeIconProps(),
    setup(props, _ref2) {
      let {
        attrs
      } = _ref2;
      return () => {
        return createVNode(props.tag, mergeProps(attrs, {
          "style": null
        }), {
          default: () => [createVNode("svg", {
            "class": "v-icon__svg",
            "xmlns": "http://www.w3.org/2000/svg",
            "viewBox": "0 0 24 24",
            "role": "img",
            "aria-hidden": "true"
          }, [Array.isArray(props.icon) ? props.icon.map((path5) => Array.isArray(path5) ? createVNode("path", {
            "d": path5[0],
            "fill-opacity": path5[1]
          }, null) : createVNode("path", {
            "d": path5
          }, null)) : createVNode("path", {
            "d": props.icon
          }, null)])]
        });
      };
    }
  });
  var VLigatureIcon = defineComponent2({
    name: "VLigatureIcon",
    props: makeIconProps(),
    setup(props) {
      return () => {
        return createVNode(props.tag, null, {
          default: () => [props.icon]
        });
      };
    }
  });
  var VClassIcon = defineComponent2({
    name: "VClassIcon",
    props: makeIconProps(),
    setup(props) {
      return () => {
        return createVNode(props.tag, {
          "class": props.icon
        }, null);
      };
    }
  });
  function genDefaults3() {
    return {
      svg: {
        component: VSvgIcon
      },
      class: {
        component: VClassIcon
      }
    };
  }
  function createIcons(options) {
    var _a2;
    const sets = genDefaults3();
    const defaultSet = (_a2 = options == null ? void 0 : options.defaultSet) != null ? _a2 : "mdi";
    if (defaultSet === "mdi" && !sets.mdi) {
      sets.mdi = mdi;
    }
    return mergeDeep({
      defaultSet,
      sets,
      aliases: __spreadProps(__spreadValues({}, aliases), {
        vuetify: ["M8.2241 14.2009L12 21L22 3H14.4459L8.2241 14.2009Z", ["M7.26303 12.4733L7.00113 12L2 3H12.5261C12.5261 3 12.5261 3 12.5261 3L7.26303 12.4733Z", 0.6]],
        "vuetify-outline": "svg:M7.26 12.47 12.53 3H2L7.26 12.47ZM14.45 3 8.22 14.2 12 21 22 3H14.45ZM18.6 5 12 16.88 10.51 14.2 15.62 5ZM7.26 8.35 5.4 5H9.13L7.26 8.35Z"
      })
    }, options);
  }
  var useIcon = (props) => {
    const icons = inject(IconSymbol);
    if (!icons)
      throw new Error("Missing Vuetify Icons provide!");
    const iconData = computed2(() => {
      var _a2;
      const iconAlias = unref(props);
      if (!iconAlias)
        return {
          component: VComponentIcon
        };
      let icon = iconAlias;
      if (typeof icon === "string") {
        icon = icon.trim();
        if (icon.startsWith("$")) {
          icon = (_a2 = icons.aliases) == null ? void 0 : _a2[icon.slice(1)];
        }
      }
      if (!icon)
        throw new Error(`Could not find aliased icon "${iconAlias}"`);
      if (Array.isArray(icon)) {
        return {
          component: VSvgIcon,
          icon
        };
      } else if (typeof icon !== "string") {
        return {
          component: VComponentIcon,
          icon
        };
      }
      const iconSetName = Object.keys(icons.sets).find((setName) => typeof icon === "string" && icon.startsWith(`${setName}:`));
      const iconName = iconSetName ? icon.slice(iconSetName.length + 1) : icon;
      const iconSet = icons.sets[iconSetName != null ? iconSetName : icons.defaultSet];
      return {
        component: iconSet.component,
        icon: iconName
      };
    });
    return {
      iconData
    };
  };

  // ../library_management/node_modules/vuetify/lib/composables/theme.mjs
  var ThemeSymbol = Symbol.for("vuetify:theme");
  var makeThemeProps = propsFactory({
    theme: String
  }, "theme");
  function genDefaults4() {
    return {
      defaultTheme: "light",
      variations: {
        colors: [],
        lighten: 0,
        darken: 0
      },
      themes: {
        light: {
          dark: false,
          colors: {
            background: "#FFFFFF",
            surface: "#FFFFFF",
            "surface-bright": "#FFFFFF",
            "surface-light": "#EEEEEE",
            "surface-variant": "#424242",
            "on-surface-variant": "#EEEEEE",
            primary: "#1867C0",
            "primary-darken-1": "#1F5592",
            secondary: "#48A9A6",
            "secondary-darken-1": "#018786",
            error: "#B00020",
            info: "#2196F3",
            success: "#4CAF50",
            warning: "#FB8C00"
          },
          variables: {
            "border-color": "#000000",
            "border-opacity": 0.12,
            "high-emphasis-opacity": 0.87,
            "medium-emphasis-opacity": 0.6,
            "disabled-opacity": 0.38,
            "idle-opacity": 0.04,
            "hover-opacity": 0.04,
            "focus-opacity": 0.12,
            "selected-opacity": 0.08,
            "activated-opacity": 0.12,
            "pressed-opacity": 0.12,
            "dragged-opacity": 0.08,
            "theme-kbd": "#212529",
            "theme-on-kbd": "#FFFFFF",
            "theme-code": "#F5F5F5",
            "theme-on-code": "#000000"
          }
        },
        dark: {
          dark: true,
          colors: {
            background: "#121212",
            surface: "#212121",
            "surface-bright": "#ccbfd6",
            "surface-light": "#424242",
            "surface-variant": "#a3a3a3",
            "on-surface-variant": "#424242",
            primary: "#2196F3",
            "primary-darken-1": "#277CC1",
            secondary: "#54B6B2",
            "secondary-darken-1": "#48A9A6",
            error: "#CF6679",
            info: "#2196F3",
            success: "#4CAF50",
            warning: "#FB8C00"
          },
          variables: {
            "border-color": "#FFFFFF",
            "border-opacity": 0.12,
            "high-emphasis-opacity": 1,
            "medium-emphasis-opacity": 0.7,
            "disabled-opacity": 0.5,
            "idle-opacity": 0.1,
            "hover-opacity": 0.04,
            "focus-opacity": 0.12,
            "selected-opacity": 0.08,
            "activated-opacity": 0.12,
            "pressed-opacity": 0.16,
            "dragged-opacity": 0.08,
            "theme-kbd": "#212529",
            "theme-on-kbd": "#FFFFFF",
            "theme-code": "#343434",
            "theme-on-code": "#CCCCCC"
          }
        }
      }
    };
  }
  function parseThemeOptions() {
    var _a2, _b, _c;
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : genDefaults4();
    const defaults2 = genDefaults4();
    if (!options)
      return __spreadProps(__spreadValues({}, defaults2), {
        isDisabled: true
      });
    const themes = {};
    for (const [key, theme] of Object.entries((_a2 = options.themes) != null ? _a2 : {})) {
      const defaultTheme = theme.dark || key === "dark" ? (_b = defaults2.themes) == null ? void 0 : _b.dark : (_c = defaults2.themes) == null ? void 0 : _c.light;
      themes[key] = mergeDeep(defaultTheme, theme);
    }
    return mergeDeep(defaults2, __spreadProps(__spreadValues({}, options), {
      themes
    }));
  }
  function createTheme(options) {
    const parsedOptions = parseThemeOptions(options);
    const name = ref(parsedOptions.defaultTheme);
    const themes = ref(parsedOptions.themes);
    const computedThemes = computed2(() => {
      const acc = {};
      for (const [name2, original] of Object.entries(themes.value)) {
        const theme = acc[name2] = __spreadProps(__spreadValues({}, original), {
          colors: __spreadValues({}, original.colors)
        });
        if (parsedOptions.variations) {
          for (const name3 of parsedOptions.variations.colors) {
            const color = theme.colors[name3];
            if (!color)
              continue;
            for (const variation of ["lighten", "darken"]) {
              const fn = variation === "lighten" ? lighten : darken;
              for (const amount of createRange(parsedOptions.variations[variation], 1)) {
                theme.colors[`${name3}-${variation}-${amount}`] = RGBtoHex(fn(parseColor(color), amount));
              }
            }
          }
        }
        for (const color of Object.keys(theme.colors)) {
          if (/^on-[a-z]/.test(color) || theme.colors[`on-${color}`])
            continue;
          const onColor = `on-${color}`;
          const colorVal = parseColor(theme.colors[color]);
          theme.colors[onColor] = getForeground(colorVal);
        }
      }
      return acc;
    });
    const current = computed2(() => computedThemes.value[name.value]);
    const styles = computed2(() => {
      var _a2;
      const lines = [];
      if ((_a2 = current.value) == null ? void 0 : _a2.dark) {
        createCssClass(lines, ":root", ["color-scheme: dark"]);
      }
      createCssClass(lines, ":root", genCssVariables(current.value));
      for (const [themeName, theme] of Object.entries(computedThemes.value)) {
        createCssClass(lines, `.v-theme--${themeName}`, [`color-scheme: ${theme.dark ? "dark" : "normal"}`, ...genCssVariables(theme)]);
      }
      const bgLines = [];
      const fgLines = [];
      const colors = new Set(Object.values(computedThemes.value).flatMap((theme) => Object.keys(theme.colors)));
      for (const key of colors) {
        if (/^on-[a-z]/.test(key)) {
          createCssClass(fgLines, `.${key}`, [`color: rgb(var(--v-theme-${key})) !important`]);
        } else {
          createCssClass(bgLines, `.bg-${key}`, [`--v-theme-overlay-multiplier: var(--v-theme-${key}-overlay-multiplier)`, `background-color: rgb(var(--v-theme-${key})) !important`, `color: rgb(var(--v-theme-on-${key})) !important`]);
          createCssClass(fgLines, `.text-${key}`, [`color: rgb(var(--v-theme-${key})) !important`]);
          createCssClass(fgLines, `.border-${key}`, [`--v-border-color: var(--v-theme-${key})`]);
        }
      }
      lines.push(...bgLines, ...fgLines);
      return lines.map((str, i) => i === 0 ? str : `    ${str}`).join("");
    });
    function getHead() {
      return {
        style: [{
          children: styles.value,
          id: "vuetify-theme-stylesheet",
          nonce: parsedOptions.cspNonce || false
        }]
      };
    }
    function install(app) {
      if (parsedOptions.isDisabled)
        return;
      const head = app._context.provides.usehead;
      if (head) {
        if (head.push) {
          const entry = head.push(getHead);
          if (IN_BROWSER) {
            watch(styles, () => {
              entry.patch(getHead);
            });
          }
        } else {
          if (IN_BROWSER) {
            head.addHeadObjs(computed2(getHead));
            watchEffect(() => head.updateDOM());
          } else {
            head.addHeadObjs(getHead());
          }
        }
      } else {
        let updateStyles = function() {
          if (typeof document !== "undefined" && !styleEl) {
            const el = document.createElement("style");
            el.type = "text/css";
            el.id = "vuetify-theme-stylesheet";
            if (parsedOptions.cspNonce)
              el.setAttribute("nonce", parsedOptions.cspNonce);
            styleEl = el;
            document.head.appendChild(styleEl);
          }
          if (styleEl)
            styleEl.innerHTML = styles.value;
        };
        let styleEl = IN_BROWSER ? document.getElementById("vuetify-theme-stylesheet") : null;
        if (IN_BROWSER) {
          watch(styles, updateStyles, {
            immediate: true
          });
        } else {
          updateStyles();
        }
      }
    }
    const themeClasses = computed2(() => parsedOptions.isDisabled ? void 0 : `v-theme--${name.value}`);
    return {
      install,
      isDisabled: parsedOptions.isDisabled,
      name,
      themes,
      current,
      computedThemes,
      themeClasses,
      styles,
      global: {
        name,
        current
      }
    };
  }
  function provideTheme(props) {
    getCurrentInstance2("provideTheme");
    const theme = inject(ThemeSymbol, null);
    if (!theme)
      throw new Error("Could not find Vuetify theme injection");
    const name = computed2(() => {
      var _a2;
      return (_a2 = props.theme) != null ? _a2 : theme.name.value;
    });
    const current = computed2(() => theme.themes.value[name.value]);
    const themeClasses = computed2(() => theme.isDisabled ? void 0 : `v-theme--${name.value}`);
    const newTheme = __spreadProps(__spreadValues({}, theme), {
      name,
      current,
      themeClasses
    });
    provide(ThemeSymbol, newTheme);
    return newTheme;
  }
  function useTheme() {
    getCurrentInstance2("useTheme");
    const theme = inject(ThemeSymbol, null);
    if (!theme)
      throw new Error("Could not find Vuetify theme injection");
    return theme;
  }
  function createCssClass(lines, selector, content) {
    lines.push(`${selector} {
`, ...content.map((line) => `  ${line};
`), "}\n");
  }
  function genCssVariables(theme) {
    const lightOverlay = theme.dark ? 2 : 1;
    const darkOverlay = theme.dark ? 1 : 2;
    const variables = [];
    for (const [key, value] of Object.entries(theme.colors)) {
      const rgb2 = parseColor(value);
      variables.push(`--v-theme-${key}: ${rgb2.r},${rgb2.g},${rgb2.b}`);
      if (!key.startsWith("on-")) {
        variables.push(`--v-theme-${key}-overlay-multiplier: ${getLuma(value) > 0.18 ? lightOverlay : darkOverlay}`);
      }
    }
    for (const [key, value] of Object.entries(theme.variables)) {
      const color = typeof value === "string" && value.startsWith("#") ? parseColor(value) : void 0;
      const rgb2 = color ? `${color.r}, ${color.g}, ${color.b}` : void 0;
      variables.push(`--v-${key}: ${rgb2 != null ? rgb2 : value}`);
    }
    return variables;
  }

  // ../library_management/node_modules/vuetify/lib/composables/resizeObserver.mjs
  function useResizeObserver(callback) {
    let box = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "content";
    const resizeRef = ref();
    const contentRect = ref();
    if (IN_BROWSER) {
      const observer = new ResizeObserver((entries) => {
        callback == null ? void 0 : callback(entries, observer);
        if (!entries.length)
          return;
        if (box === "content") {
          contentRect.value = entries[0].contentRect;
        } else {
          contentRect.value = entries[0].target.getBoundingClientRect();
        }
      });
      onBeforeUnmount(() => {
        observer.disconnect();
      });
      watch(resizeRef, (newValue, oldValue) => {
        if (oldValue) {
          observer.unobserve(refElement(oldValue));
          contentRect.value = void 0;
        }
        if (newValue)
          observer.observe(refElement(newValue));
      }, {
        flush: "post"
      });
    }
    return {
      resizeRef,
      contentRect: readonly(contentRect)
    };
  }

  // ../library_management/node_modules/vuetify/lib/composables/layout.mjs
  var VuetifyLayoutKey = Symbol.for("vuetify:layout");
  var VuetifyLayoutItemKey = Symbol.for("vuetify:layout-item");
  var ROOT_ZINDEX = 1e3;
  var makeLayoutProps = propsFactory({
    overlaps: {
      type: Array,
      default: () => []
    },
    fullHeight: Boolean
  }, "layout");
  var makeLayoutItemProps = propsFactory({
    name: {
      type: String
    },
    order: {
      type: [Number, String],
      default: 0
    },
    absolute: Boolean
  }, "layout-item");
  function useLayout() {
    const layout = inject(VuetifyLayoutKey);
    if (!layout)
      throw new Error("[Vuetify] Could not find injected layout");
    return {
      getLayoutItem: layout.getLayoutItem,
      mainRect: layout.mainRect,
      mainStyles: layout.mainStyles
    };
  }
  function useLayoutItem(options) {
    var _a2;
    const layout = inject(VuetifyLayoutKey);
    if (!layout)
      throw new Error("[Vuetify] Could not find injected layout");
    const id = (_a2 = options.id) != null ? _a2 : `layout-item-${getUid()}`;
    const vm = getCurrentInstance2("useLayoutItem");
    provide(VuetifyLayoutItemKey, {
      id
    });
    const isKeptAlive = shallowRef(false);
    onDeactivated(() => isKeptAlive.value = true);
    onActivated(() => isKeptAlive.value = false);
    const {
      layoutItemStyles,
      layoutItemScrimStyles
    } = layout.register(vm, __spreadProps(__spreadValues({}, options), {
      active: computed2(() => isKeptAlive.value ? false : options.active.value),
      id
    }));
    onBeforeUnmount(() => layout.unregister(id));
    return {
      layoutItemStyles,
      layoutRect: layout.layoutRect,
      layoutItemScrimStyles
    };
  }
  var generateLayers = (layout, positions, layoutSizes, activeItems) => {
    let previousLayer = {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    };
    const layers = [{
      id: "",
      layer: __spreadValues({}, previousLayer)
    }];
    for (const id of layout) {
      const position = positions.get(id);
      const amount = layoutSizes.get(id);
      const active = activeItems.get(id);
      if (!position || !amount || !active)
        continue;
      const layer = __spreadProps(__spreadValues({}, previousLayer), {
        [position.value]: parseInt(previousLayer[position.value], 10) + (active.value ? parseInt(amount.value, 10) : 0)
      });
      layers.push({
        id,
        layer
      });
      previousLayer = layer;
    }
    return layers;
  };
  function createLayout(props) {
    const parentLayout = inject(VuetifyLayoutKey, null);
    const rootZIndex = computed2(() => parentLayout ? parentLayout.rootZIndex.value - 100 : ROOT_ZINDEX);
    const registered = ref([]);
    const positions = reactive(/* @__PURE__ */ new Map());
    const layoutSizes = reactive(/* @__PURE__ */ new Map());
    const priorities = reactive(/* @__PURE__ */ new Map());
    const activeItems = reactive(/* @__PURE__ */ new Map());
    const disabledTransitions = reactive(/* @__PURE__ */ new Map());
    const {
      resizeRef,
      contentRect: layoutRect
    } = useResizeObserver();
    const computedOverlaps = computed2(() => {
      var _a2;
      const map2 = /* @__PURE__ */ new Map();
      const overlaps = (_a2 = props.overlaps) != null ? _a2 : [];
      for (const overlap of overlaps.filter((item) => item.includes(":"))) {
        const [top, bottom] = overlap.split(":");
        if (!registered.value.includes(top) || !registered.value.includes(bottom))
          continue;
        const topPosition = positions.get(top);
        const bottomPosition = positions.get(bottom);
        const topAmount = layoutSizes.get(top);
        const bottomAmount = layoutSizes.get(bottom);
        if (!topPosition || !bottomPosition || !topAmount || !bottomAmount)
          continue;
        map2.set(bottom, {
          position: topPosition.value,
          amount: parseInt(topAmount.value, 10)
        });
        map2.set(top, {
          position: bottomPosition.value,
          amount: -parseInt(bottomAmount.value, 10)
        });
      }
      return map2;
    });
    const layers = computed2(() => {
      const uniquePriorities = [...new Set([...priorities.values()].map((p2) => p2.value))].sort((a, b) => a - b);
      const layout = [];
      for (const p2 of uniquePriorities) {
        const items2 = registered.value.filter((id) => {
          var _a2;
          return ((_a2 = priorities.get(id)) == null ? void 0 : _a2.value) === p2;
        });
        layout.push(...items2);
      }
      return generateLayers(layout, positions, layoutSizes, activeItems);
    });
    const transitionsEnabled = computed2(() => {
      return !Array.from(disabledTransitions.values()).some((ref2) => ref2.value);
    });
    const mainRect = computed2(() => {
      return layers.value[layers.value.length - 1].layer;
    });
    const mainStyles = computed2(() => {
      return __spreadValues({
        "--v-layout-left": convertToUnit(mainRect.value.left),
        "--v-layout-right": convertToUnit(mainRect.value.right),
        "--v-layout-top": convertToUnit(mainRect.value.top),
        "--v-layout-bottom": convertToUnit(mainRect.value.bottom)
      }, transitionsEnabled.value ? void 0 : {
        transition: "none"
      });
    });
    const items = computed2(() => {
      return layers.value.slice(1).map((_ref, index) => {
        let {
          id
        } = _ref;
        const {
          layer
        } = layers.value[index];
        const size2 = layoutSizes.get(id);
        const position = positions.get(id);
        return __spreadProps(__spreadValues({
          id
        }, layer), {
          size: Number(size2.value),
          position: position.value
        });
      });
    });
    const getLayoutItem = (id) => {
      return items.value.find((item) => item.id === id);
    };
    const rootVm = getCurrentInstance2("createLayout");
    const isMounted = shallowRef(false);
    onMounted(() => {
      isMounted.value = true;
    });
    provide(VuetifyLayoutKey, {
      register: (vm, _ref2) => {
        let {
          id,
          order,
          position,
          layoutSize,
          elementSize,
          active,
          disableTransitions,
          absolute
        } = _ref2;
        priorities.set(id, order);
        positions.set(id, position);
        layoutSizes.set(id, layoutSize);
        activeItems.set(id, active);
        disableTransitions && disabledTransitions.set(id, disableTransitions);
        const instances = findChildrenWithProvide(VuetifyLayoutItemKey, rootVm == null ? void 0 : rootVm.vnode);
        const instanceIndex = instances.indexOf(vm);
        if (instanceIndex > -1)
          registered.value.splice(instanceIndex, 0, id);
        else
          registered.value.push(id);
        const index = computed2(() => items.value.findIndex((i) => i.id === id));
        const zIndex = computed2(() => rootZIndex.value + layers.value.length * 2 - index.value * 2);
        const layoutItemStyles = computed2(() => {
          const isHorizontal = position.value === "left" || position.value === "right";
          const isOppositeHorizontal = position.value === "right";
          const isOppositeVertical = position.value === "bottom";
          const styles = __spreadValues({
            [position.value]: 0,
            zIndex: zIndex.value,
            transform: `translate${isHorizontal ? "X" : "Y"}(${(active.value ? 0 : -110) * (isOppositeHorizontal || isOppositeVertical ? -1 : 1)}%)`,
            position: absolute.value || rootZIndex.value !== ROOT_ZINDEX ? "absolute" : "fixed"
          }, transitionsEnabled.value ? void 0 : {
            transition: "none"
          });
          if (!isMounted.value)
            return styles;
          const item = items.value[index.value];
          if (!item)
            throw new Error(`[Vuetify] Could not find layout item "${id}"`);
          const overlap = computedOverlaps.value.get(id);
          if (overlap) {
            item[overlap.position] += overlap.amount;
          }
          return __spreadProps(__spreadValues({}, styles), {
            height: isHorizontal ? `calc(100% - ${item.top}px - ${item.bottom}px)` : elementSize.value ? `${elementSize.value}px` : void 0,
            left: isOppositeHorizontal ? void 0 : `${item.left}px`,
            right: isOppositeHorizontal ? `${item.right}px` : void 0,
            top: position.value !== "bottom" ? `${item.top}px` : void 0,
            bottom: position.value !== "top" ? `${item.bottom}px` : void 0,
            width: !isHorizontal ? `calc(100% - ${item.left}px - ${item.right}px)` : elementSize.value ? `${elementSize.value}px` : void 0
          });
        });
        const layoutItemScrimStyles = computed2(() => ({
          zIndex: zIndex.value - 1
        }));
        return {
          layoutItemStyles,
          layoutItemScrimStyles,
          zIndex
        };
      },
      unregister: (id) => {
        priorities.delete(id);
        positions.delete(id);
        layoutSizes.delete(id);
        activeItems.delete(id);
        disabledTransitions.delete(id);
        registered.value = registered.value.filter((v) => v !== id);
      },
      mainRect,
      mainStyles,
      getLayoutItem,
      items,
      layoutRect,
      rootZIndex
    });
    const layoutClasses = computed2(() => ["v-layout", {
      "v-layout--full-height": props.fullHeight
    }]);
    const layoutStyles = computed2(() => ({
      zIndex: parentLayout ? rootZIndex.value : void 0,
      position: parentLayout ? "relative" : void 0,
      overflow: parentLayout ? "hidden" : void 0
    }));
    return {
      layoutClasses,
      layoutStyles,
      getLayoutItem,
      items,
      layoutRect,
      layoutRef: resizeRef
    };
  }

  // ../library_management/node_modules/vuetify/lib/framework.mjs
  function createVuetify() {
    let vuetify = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const _a2 = vuetify, {
      blueprint
    } = _a2, rest = __objRest(_a2, [
      "blueprint"
    ]);
    const options = mergeDeep(blueprint, rest);
    const {
      aliases: aliases2 = {},
      components = {},
      directives = {}
    } = options;
    const defaults2 = createDefaults(options.defaults);
    const display = createDisplay(options.display, options.ssr);
    const theme = createTheme(options.theme);
    const icons = createIcons(options.icons);
    const locale = createLocale(options.locale);
    const date2 = createDate(options.date, locale);
    const goTo = createGoTo(options.goTo, locale);
    const install = (app) => {
      for (const key in directives) {
        app.directive(key, directives[key]);
      }
      for (const key in components) {
        app.component(key, components[key]);
      }
      for (const key in aliases2) {
        app.component(key, defineComponent2(__spreadProps(__spreadValues({}, aliases2[key]), {
          name: key,
          aliasName: aliases2[key].name
        })));
      }
      theme.install(app);
      app.provide(DefaultsSymbol, defaults2);
      app.provide(DisplaySymbol, display);
      app.provide(ThemeSymbol, theme);
      app.provide(IconSymbol, icons);
      app.provide(LocaleSymbol, locale);
      app.provide(DateOptionsSymbol, date2.options);
      app.provide(DateAdapterSymbol, date2.instance);
      app.provide(GoToSymbol, goTo);
      if (IN_BROWSER && options.ssr) {
        if (app.$nuxt) {
          app.$nuxt.hook("app:suspense:resolve", () => {
            display.update();
          });
        } else {
          const {
            mount
          } = app;
          app.mount = function() {
            const vm = mount(...arguments);
            nextTick(() => display.update());
            app.mount = mount;
            return vm;
          };
        }
      }
      getUid.reset();
      if (true) {
        app.mixin({
          computed: {
            $vuetify() {
              return reactive({
                defaults: inject2.call(this, DefaultsSymbol),
                display: inject2.call(this, DisplaySymbol),
                theme: inject2.call(this, ThemeSymbol),
                icons: inject2.call(this, IconSymbol),
                locale: inject2.call(this, LocaleSymbol),
                date: inject2.call(this, DateAdapterSymbol)
              });
            }
          }
        });
      }
    };
    return {
      install,
      defaults: defaults2,
      display,
      theme,
      icons,
      locale,
      date: date2,
      goTo
    };
  }
  var version2 = "3.5.14";
  createVuetify.version = version2;
  function inject2(key) {
    var _a2, _b, _c;
    const vm = this.$;
    const provides = (_c = (_a2 = vm.parent) == null ? void 0 : _a2.provides) != null ? _c : (_b = vm.vnode.appContext) == null ? void 0 : _b.provides;
    if (provides && key in provides) {
      return provides[key];
    }
  }

  // ../library_management/node_modules/vuetify/lib/components/index.mjs
  var components_exports = {};
  __export(components_exports, {
    VAlert: () => VAlert,
    VAlertTitle: () => VAlertTitle,
    VApp: () => VApp,
    VAppBar: () => VAppBar,
    VAppBarNavIcon: () => VAppBarNavIcon,
    VAppBarTitle: () => VAppBarTitle,
    VAutocomplete: () => VAutocomplete,
    VAvatar: () => VAvatar,
    VBadge: () => VBadge,
    VBanner: () => VBanner,
    VBannerActions: () => VBannerActions,
    VBannerText: () => VBannerText,
    VBottomNavigation: () => VBottomNavigation,
    VBottomSheet: () => VBottomSheet,
    VBreadcrumbs: () => VBreadcrumbs,
    VBreadcrumbsDivider: () => VBreadcrumbsDivider,
    VBreadcrumbsItem: () => VBreadcrumbsItem,
    VBtn: () => VBtn,
    VBtnGroup: () => VBtnGroup,
    VBtnToggle: () => VBtnToggle,
    VCard: () => VCard,
    VCardActions: () => VCardActions,
    VCardItem: () => VCardItem,
    VCardSubtitle: () => VCardSubtitle,
    VCardText: () => VCardText,
    VCardTitle: () => VCardTitle,
    VCarousel: () => VCarousel,
    VCarouselItem: () => VCarouselItem,
    VCheckbox: () => VCheckbox,
    VCheckboxBtn: () => VCheckboxBtn,
    VChip: () => VChip,
    VChipGroup: () => VChipGroup,
    VClassIcon: () => VClassIcon,
    VCode: () => VCode,
    VCol: () => VCol,
    VColorPicker: () => VColorPicker,
    VCombobox: () => VCombobox,
    VComponentIcon: () => VComponentIcon,
    VContainer: () => VContainer,
    VCounter: () => VCounter,
    VDataIterator: () => VDataIterator,
    VDataTable: () => VDataTable,
    VDataTableFooter: () => VDataTableFooter,
    VDataTableHeaders: () => VDataTableHeaders,
    VDataTableRow: () => VDataTableRow,
    VDataTableRows: () => VDataTableRows,
    VDataTableServer: () => VDataTableServer,
    VDataTableVirtual: () => VDataTableVirtual,
    VDatePicker: () => VDatePicker,
    VDatePickerControls: () => VDatePickerControls,
    VDatePickerHeader: () => VDatePickerHeader,
    VDatePickerMonth: () => VDatePickerMonth,
    VDatePickerMonths: () => VDatePickerMonths,
    VDatePickerYears: () => VDatePickerYears,
    VDefaultsProvider: () => VDefaultsProvider,
    VDialog: () => VDialog,
    VDialogBottomTransition: () => VDialogBottomTransition,
    VDialogTopTransition: () => VDialogTopTransition,
    VDialogTransition: () => VDialogTransition,
    VDivider: () => VDivider,
    VExpandTransition: () => VExpandTransition,
    VExpandXTransition: () => VExpandXTransition,
    VExpansionPanel: () => VExpansionPanel,
    VExpansionPanelText: () => VExpansionPanelText,
    VExpansionPanelTitle: () => VExpansionPanelTitle,
    VExpansionPanels: () => VExpansionPanels,
    VFabTransition: () => VFabTransition,
    VFadeTransition: () => VFadeTransition,
    VField: () => VField,
    VFieldLabel: () => VFieldLabel,
    VFileInput: () => VFileInput,
    VFooter: () => VFooter,
    VForm: () => VForm,
    VHover: () => VHover,
    VIcon: () => VIcon,
    VImg: () => VImg,
    VInfiniteScroll: () => VInfiniteScroll,
    VInput: () => VInput,
    VItem: () => VItem,
    VItemGroup: () => VItemGroup,
    VKbd: () => VKbd,
    VLabel: () => VLabel,
    VLayout: () => VLayout,
    VLayoutItem: () => VLayoutItem,
    VLazy: () => VLazy,
    VLigatureIcon: () => VLigatureIcon,
    VList: () => VList,
    VListGroup: () => VListGroup,
    VListImg: () => VListImg,
    VListItem: () => VListItem,
    VListItemAction: () => VListItemAction,
    VListItemMedia: () => VListItemMedia,
    VListItemSubtitle: () => VListItemSubtitle,
    VListItemTitle: () => VListItemTitle,
    VListSubheader: () => VListSubheader,
    VLocaleProvider: () => VLocaleProvider,
    VMain: () => VMain,
    VMenu: () => VMenu,
    VMessages: () => VMessages,
    VNavigationDrawer: () => VNavigationDrawer,
    VNoSsr: () => VNoSsr,
    VOtpInput: () => VOtpInput,
    VOverlay: () => VOverlay,
    VPagination: () => VPagination,
    VParallax: () => VParallax,
    VProgressCircular: () => VProgressCircular,
    VProgressLinear: () => VProgressLinear,
    VRadio: () => VRadio,
    VRadioGroup: () => VRadioGroup,
    VRangeSlider: () => VRangeSlider,
    VRating: () => VRating,
    VResponsive: () => VResponsive,
    VRow: () => VRow,
    VScaleTransition: () => VScaleTransition,
    VScrollXReverseTransition: () => VScrollXReverseTransition,
    VScrollXTransition: () => VScrollXTransition,
    VScrollYReverseTransition: () => VScrollYReverseTransition,
    VScrollYTransition: () => VScrollYTransition,
    VSelect: () => VSelect,
    VSelectionControl: () => VSelectionControl,
    VSelectionControlGroup: () => VSelectionControlGroup,
    VSheet: () => VSheet,
    VSkeletonLoader: () => VSkeletonLoader,
    VSlideGroup: () => VSlideGroup,
    VSlideGroupItem: () => VSlideGroupItem,
    VSlideXReverseTransition: () => VSlideXReverseTransition,
    VSlideXTransition: () => VSlideXTransition,
    VSlideYReverseTransition: () => VSlideYReverseTransition,
    VSlideYTransition: () => VSlideYTransition,
    VSlider: () => VSlider,
    VSnackbar: () => VSnackbar,
    VSpacer: () => VSpacer,
    VStepper: () => VStepper,
    VStepperActions: () => VStepperActions,
    VStepperHeader: () => VStepperHeader,
    VStepperItem: () => VStepperItem,
    VStepperWindow: () => VStepperWindow,
    VStepperWindowItem: () => VStepperWindowItem,
    VSvgIcon: () => VSvgIcon,
    VSwitch: () => VSwitch,
    VSystemBar: () => VSystemBar,
    VTab: () => VTab,
    VTable: () => VTable,
    VTabs: () => VTabs,
    VTextField: () => VTextField,
    VTextarea: () => VTextarea,
    VThemeProvider: () => VThemeProvider,
    VTimeline: () => VTimeline,
    VTimelineItem: () => VTimelineItem,
    VToolbar: () => VToolbar,
    VToolbarItems: () => VToolbarItems,
    VToolbarTitle: () => VToolbarTitle,
    VTooltip: () => VTooltip,
    VValidation: () => VValidation,
    VVirtualScroll: () => VVirtualScroll,
    VWindow: () => VWindow,
    VWindowItem: () => VWindowItem
  });

  // ../library_management/node_modules/vuetify/lib/components/VApp/VApp.mjs
  var makeVAppProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({}, makeComponentProps()), makeLayoutProps({
    fullHeight: true
  })), makeThemeProps()), "VApp");
  var VApp = genericComponent()({
    name: "VApp",
    props: makeVAppProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const theme = provideTheme(props);
      const {
        layoutClasses,
        getLayoutItem,
        items,
        layoutRef
      } = createLayout(props);
      const {
        rtlClasses
      } = useRtl();
      useRender(() => {
        var _a2;
        return createVNode("div", {
          "ref": layoutRef,
          "class": ["v-application", theme.themeClasses.value, layoutClasses.value, rtlClasses.value, props.class],
          "style": [props.style]
        }, [createVNode("div", {
          "class": "v-application__wrap"
        }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)])]);
      });
      return {
        getLayoutItem,
        items,
        theme
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/composables/tag.mjs
  var makeTagProps = propsFactory({
    tag: {
      type: String,
      default: "div"
    }
  }, "tag");

  // ../library_management/node_modules/vuetify/lib/components/VToolbar/VToolbarTitle.mjs
  var makeVToolbarTitleProps = propsFactory(__spreadValues(__spreadValues({
    text: String
  }, makeComponentProps()), makeTagProps()), "VToolbarTitle");
  var VToolbarTitle = genericComponent()({
    name: "VToolbarTitle",
    props: makeVToolbarTitleProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useRender(() => {
        const hasText = !!(slots.default || slots.text || props.text);
        return createVNode(props.tag, {
          "class": ["v-toolbar-title", props.class],
          "style": props.style
        }, {
          default: () => {
            var _a2;
            return [hasText && createVNode("div", {
              "class": "v-toolbar-title__placeholder"
            }, [slots.text ? slots.text() : props.text, (_a2 = slots.default) == null ? void 0 : _a2.call(slots)])];
          }
        });
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/transitions/createTransition.mjs
  var makeTransitionProps = propsFactory({
    disabled: Boolean,
    group: Boolean,
    hideOnLeave: Boolean,
    leaveAbsolute: Boolean,
    mode: String,
    origin: String
  }, "transition");
  function createCssTransition(name, origin, mode) {
    return genericComponent()({
      name,
      props: makeTransitionProps({
        mode,
        origin
      }),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const functions = {
          onBeforeEnter(el) {
            if (props.origin) {
              el.style.transformOrigin = props.origin;
            }
          },
          onLeave(el) {
            if (props.leaveAbsolute) {
              const {
                offsetTop,
                offsetLeft,
                offsetWidth,
                offsetHeight
              } = el;
              el._transitionInitialStyles = {
                position: el.style.position,
                top: el.style.top,
                left: el.style.left,
                width: el.style.width,
                height: el.style.height
              };
              el.style.position = "absolute";
              el.style.top = `${offsetTop}px`;
              el.style.left = `${offsetLeft}px`;
              el.style.width = `${offsetWidth}px`;
              el.style.height = `${offsetHeight}px`;
            }
            if (props.hideOnLeave) {
              el.style.setProperty("display", "none", "important");
            }
          },
          onAfterLeave(el) {
            if (props.leaveAbsolute && (el == null ? void 0 : el._transitionInitialStyles)) {
              const {
                position,
                top,
                left,
                width,
                height
              } = el._transitionInitialStyles;
              delete el._transitionInitialStyles;
              el.style.position = position || "";
              el.style.top = top || "";
              el.style.left = left || "";
              el.style.width = width || "";
              el.style.height = height || "";
            }
          }
        };
        return () => {
          const tag = props.group ? TransitionGroup : Transition;
          return h(tag, __spreadValues(__spreadValues({
            name: props.disabled ? "" : name,
            css: !props.disabled
          }, props.group ? void 0 : {
            mode: props.mode
          }), props.disabled ? {} : functions), slots.default);
        };
      }
    });
  }
  function createJavascriptTransition(name, functions) {
    let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "in-out";
    return genericComponent()({
      name,
      props: {
        mode: {
          type: String,
          default: mode
        },
        disabled: Boolean
      },
      setup(props, _ref2) {
        let {
          slots
        } = _ref2;
        return () => {
          return h(Transition, __spreadValues({
            name: props.disabled ? "" : name,
            css: !props.disabled
          }, props.disabled ? {} : functions), slots.default);
        };
      }
    });
  }

  // ../library_management/node_modules/vuetify/lib/components/transitions/expand-transition.mjs
  function expand_transition_default() {
    let expandedParentClass = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    let x = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const sizeProperty = x ? "width" : "height";
    const offsetProperty = camelize(`offset-${sizeProperty}`);
    return {
      onBeforeEnter(el) {
        el._parent = el.parentNode;
        el._initialStyle = {
          transition: el.style.transition,
          overflow: el.style.overflow,
          [sizeProperty]: el.style[sizeProperty]
        };
      },
      onEnter(el) {
        const initialStyle = el._initialStyle;
        el.style.setProperty("transition", "none", "important");
        el.style.overflow = "hidden";
        const offset = `${el[offsetProperty]}px`;
        el.style[sizeProperty] = "0";
        void el.offsetHeight;
        el.style.transition = initialStyle.transition;
        if (expandedParentClass && el._parent) {
          el._parent.classList.add(expandedParentClass);
        }
        requestAnimationFrame(() => {
          el.style[sizeProperty] = offset;
        });
      },
      onAfterEnter: resetStyles,
      onEnterCancelled: resetStyles,
      onLeave(el) {
        el._initialStyle = {
          transition: "",
          overflow: el.style.overflow,
          [sizeProperty]: el.style[sizeProperty]
        };
        el.style.overflow = "hidden";
        el.style[sizeProperty] = `${el[offsetProperty]}px`;
        void el.offsetHeight;
        requestAnimationFrame(() => el.style[sizeProperty] = "0");
      },
      onAfterLeave,
      onLeaveCancelled: onAfterLeave
    };
    function onAfterLeave(el) {
      if (expandedParentClass && el._parent) {
        el._parent.classList.remove(expandedParentClass);
      }
      resetStyles(el);
    }
    function resetStyles(el) {
      const size2 = el._initialStyle[sizeProperty];
      el.style.overflow = el._initialStyle.overflow;
      if (size2 != null)
        el.style[sizeProperty] = size2;
      delete el._initialStyle;
    }
  }

  // ../library_management/node_modules/vuetify/lib/components/transitions/dialog-transition.mjs
  var makeVDialogTransitionProps = propsFactory({
    target: [Object, Array]
  }, "v-dialog-transition");
  var VDialogTransition = genericComponent()({
    name: "VDialogTransition",
    props: makeVDialogTransitionProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const functions = {
        onBeforeEnter(el) {
          el.style.pointerEvents = "none";
          el.style.visibility = "hidden";
        },
        async onEnter(el, done) {
          var _a2;
          await new Promise((resolve2) => requestAnimationFrame(resolve2));
          await new Promise((resolve2) => requestAnimationFrame(resolve2));
          el.style.visibility = "";
          const {
            x,
            y,
            sx,
            sy,
            speed
          } = getDimensions(props.target, el);
          const animation = animate(el, [{
            transform: `translate(${x}px, ${y}px) scale(${sx}, ${sy})`,
            opacity: 0
          }, {}], {
            duration: 225 * speed,
            easing: deceleratedEasing
          });
          (_a2 = getChildren(el)) == null ? void 0 : _a2.forEach((el2) => {
            animate(el2, [{
              opacity: 0
            }, {
              opacity: 0,
              offset: 0.33
            }, {}], {
              duration: 225 * 2 * speed,
              easing: standardEasing
            });
          });
          animation.finished.then(() => done());
        },
        onAfterEnter(el) {
          el.style.removeProperty("pointer-events");
        },
        onBeforeLeave(el) {
          el.style.pointerEvents = "none";
        },
        async onLeave(el, done) {
          var _a2;
          await new Promise((resolve2) => requestAnimationFrame(resolve2));
          const {
            x,
            y,
            sx,
            sy,
            speed
          } = getDimensions(props.target, el);
          const animation = animate(el, [{}, {
            transform: `translate(${x}px, ${y}px) scale(${sx}, ${sy})`,
            opacity: 0
          }], {
            duration: 125 * speed,
            easing: acceleratedEasing
          });
          animation.finished.then(() => done());
          (_a2 = getChildren(el)) == null ? void 0 : _a2.forEach((el2) => {
            animate(el2, [{}, {
              opacity: 0,
              offset: 0.2
            }, {
              opacity: 0
            }], {
              duration: 125 * 2 * speed,
              easing: standardEasing
            });
          });
        },
        onAfterLeave(el) {
          el.style.removeProperty("pointer-events");
        }
      };
      return () => {
        return props.target ? createVNode(Transition, mergeProps({
          "name": "dialog-transition"
        }, functions, {
          "css": false
        }), slots) : createVNode(Transition, {
          "name": "dialog-transition"
        }, slots);
      };
    }
  });
  function getChildren(el) {
    var _a2;
    const els = (_a2 = el.querySelector(":scope > .v-card, :scope > .v-sheet, :scope > .v-list")) == null ? void 0 : _a2.children;
    return els && [...els];
  }
  function getDimensions(target, el) {
    const targetBox = getTargetBox(target);
    const elBox = nullifyTransforms(el);
    const [originX, originY] = getComputedStyle(el).transformOrigin.split(" ").map((v) => parseFloat(v));
    const [anchorSide, anchorOffset] = getComputedStyle(el).getPropertyValue("--v-overlay-anchor-origin").split(" ");
    let offsetX = targetBox.left + targetBox.width / 2;
    if (anchorSide === "left" || anchorOffset === "left") {
      offsetX -= targetBox.width / 2;
    } else if (anchorSide === "right" || anchorOffset === "right") {
      offsetX += targetBox.width / 2;
    }
    let offsetY = targetBox.top + targetBox.height / 2;
    if (anchorSide === "top" || anchorOffset === "top") {
      offsetY -= targetBox.height / 2;
    } else if (anchorSide === "bottom" || anchorOffset === "bottom") {
      offsetY += targetBox.height / 2;
    }
    const tsx = targetBox.width / elBox.width;
    const tsy = targetBox.height / elBox.height;
    const maxs = Math.max(1, tsx, tsy);
    const sx = tsx / maxs || 0;
    const sy = tsy / maxs || 0;
    const asa = elBox.width * elBox.height / (window.innerWidth * window.innerHeight);
    const speed = asa > 0.12 ? Math.min(1.5, (asa - 0.12) * 10 + 1) : 1;
    return {
      x: offsetX - (originX + elBox.left),
      y: offsetY - (originY + elBox.top),
      sx,
      sy,
      speed
    };
  }

  // ../library_management/node_modules/vuetify/lib/components/transitions/index.mjs
  var VFabTransition = createCssTransition("fab-transition", "center center", "out-in");
  var VDialogBottomTransition = createCssTransition("dialog-bottom-transition");
  var VDialogTopTransition = createCssTransition("dialog-top-transition");
  var VFadeTransition = createCssTransition("fade-transition");
  var VScaleTransition = createCssTransition("scale-transition");
  var VScrollXTransition = createCssTransition("scroll-x-transition");
  var VScrollXReverseTransition = createCssTransition("scroll-x-reverse-transition");
  var VScrollYTransition = createCssTransition("scroll-y-transition");
  var VScrollYReverseTransition = createCssTransition("scroll-y-reverse-transition");
  var VSlideXTransition = createCssTransition("slide-x-transition");
  var VSlideXReverseTransition = createCssTransition("slide-x-reverse-transition");
  var VSlideYTransition = createCssTransition("slide-y-transition");
  var VSlideYReverseTransition = createCssTransition("slide-y-reverse-transition");
  var VExpandTransition = createJavascriptTransition("expand-transition", expand_transition_default());
  var VExpandXTransition = createJavascriptTransition("expand-x-transition", expand_transition_default("", true));

  // ../library_management/node_modules/vuetify/lib/components/VDefaultsProvider/VDefaultsProvider.mjs
  var makeVDefaultsProviderProps = propsFactory({
    defaults: Object,
    disabled: Boolean,
    reset: [Number, String],
    root: [Boolean, String],
    scoped: Boolean
  }, "VDefaultsProvider");
  var VDefaultsProvider = genericComponent(false)({
    name: "VDefaultsProvider",
    props: makeVDefaultsProviderProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        defaults: defaults2,
        disabled,
        reset,
        root,
        scoped
      } = toRefs(props);
      provideDefaults(defaults2, {
        reset,
        root,
        scoped,
        disabled
      });
      return () => {
        var _a2;
        return (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/composables/dimensions.mjs
  var makeDimensionProps = propsFactory({
    height: [Number, String],
    maxHeight: [Number, String],
    maxWidth: [Number, String],
    minHeight: [Number, String],
    minWidth: [Number, String],
    width: [Number, String]
  }, "dimension");
  function useDimension(props) {
    const dimensionStyles = computed2(() => ({
      height: convertToUnit(props.height),
      maxHeight: convertToUnit(props.maxHeight),
      maxWidth: convertToUnit(props.maxWidth),
      minHeight: convertToUnit(props.minHeight),
      minWidth: convertToUnit(props.minWidth),
      width: convertToUnit(props.width)
    }));
    return {
      dimensionStyles
    };
  }

  // ../library_management/node_modules/vuetify/lib/components/VResponsive/VResponsive.mjs
  function useAspectStyles(props) {
    return {
      aspectStyles: computed2(() => {
        const ratio = Number(props.aspectRatio);
        return ratio ? {
          paddingBottom: String(1 / ratio * 100) + "%"
        } : void 0;
      })
    };
  }
  var makeVResponsiveProps = propsFactory(__spreadValues(__spreadValues({
    aspectRatio: [String, Number],
    contentClass: String,
    inline: Boolean
  }, makeComponentProps()), makeDimensionProps()), "VResponsive");
  var VResponsive = genericComponent()({
    name: "VResponsive",
    props: makeVResponsiveProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        aspectStyles
      } = useAspectStyles(props);
      const {
        dimensionStyles
      } = useDimension(props);
      useRender(() => {
        var _a2;
        return createVNode("div", {
          "class": ["v-responsive", {
            "v-responsive--inline": props.inline
          }, props.class],
          "style": [dimensionStyles.value, props.style]
        }, [createVNode("div", {
          "class": "v-responsive__sizer",
          "style": aspectStyles.value
        }, null), (_a2 = slots.additional) == null ? void 0 : _a2.call(slots), slots.default && createVNode("div", {
          "class": ["v-responsive__content", props.contentClass]
        }, [slots.default()])]);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/composables/color.mjs
  function useColor(colors) {
    return destructComputed(() => {
      const classes = [];
      const styles = {};
      if (colors.value.background) {
        if (isCssColor(colors.value.background)) {
          styles.backgroundColor = colors.value.background;
          if (!colors.value.text && isParsableColor(colors.value.background)) {
            const backgroundColor = parseColor(colors.value.background);
            if (backgroundColor.a == null || backgroundColor.a === 1) {
              const textColor = getForeground(backgroundColor);
              styles.color = textColor;
              styles.caretColor = textColor;
            }
          }
        } else {
          classes.push(`bg-${colors.value.background}`);
        }
      }
      if (colors.value.text) {
        if (isCssColor(colors.value.text)) {
          styles.color = colors.value.text;
          styles.caretColor = colors.value.text;
        } else {
          classes.push(`text-${colors.value.text}`);
        }
      }
      return {
        colorClasses: classes,
        colorStyles: styles
      };
    });
  }
  function useTextColor(props, name) {
    const colors = computed2(() => ({
      text: isRef(props) ? props.value : name ? props[name] : null
    }));
    const {
      colorClasses: textColorClasses,
      colorStyles: textColorStyles
    } = useColor(colors);
    return {
      textColorClasses,
      textColorStyles
    };
  }
  function useBackgroundColor(props, name) {
    const colors = computed2(() => ({
      background: isRef(props) ? props.value : name ? props[name] : null
    }));
    const {
      colorClasses: backgroundColorClasses,
      colorStyles: backgroundColorStyles
    } = useColor(colors);
    return {
      backgroundColorClasses,
      backgroundColorStyles
    };
  }

  // ../library_management/node_modules/vuetify/lib/composables/rounded.mjs
  var makeRoundedProps = propsFactory({
    rounded: {
      type: [Boolean, Number, String],
      default: void 0
    },
    tile: Boolean
  }, "rounded");
  function useRounded(props) {
    let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    const roundedClasses = computed2(() => {
      const rounded = isRef(props) ? props.value : props.rounded;
      const tile = isRef(props) ? props.value : props.tile;
      const classes = [];
      if (rounded === true || rounded === "") {
        classes.push(`${name}--rounded`);
      } else if (typeof rounded === "string" || rounded === 0) {
        for (const value of String(rounded).split(" ")) {
          classes.push(`rounded-${value}`);
        }
      } else if (tile) {
        classes.push("rounded-0");
      }
      return classes;
    });
    return {
      roundedClasses
    };
  }

  // ../library_management/node_modules/vuetify/lib/composables/transition.mjs
  var makeTransitionProps2 = propsFactory({
    transition: {
      type: [Boolean, String, Object],
      default: "fade-transition",
      validator: (val) => val !== true
    }
  }, "transition");
  var MaybeTransition = (props, _ref) => {
    let {
      slots
    } = _ref;
    const _a2 = props, {
      transition,
      disabled,
      group
    } = _a2, rest = __objRest(_a2, [
      "transition",
      "disabled",
      "group"
    ]);
    const _b = typeof transition === "object" ? transition : {}, {
      component = group ? TransitionGroup : Transition
    } = _b, customProps = __objRest(_b, [
      "component"
    ]);
    return h(component, mergeProps(typeof transition === "string" ? {
      name: disabled ? "" : transition
    } : customProps, typeof transition === "string" ? {} : Object.fromEntries(Object.entries({
      disabled,
      group
    }).filter((_ref2) => {
      let [_, v] = _ref2;
      return v !== void 0;
    })), rest), slots);
  };

  // ../library_management/node_modules/vuetify/lib/directives/intersect/index.mjs
  function mounted(el, binding) {
    if (!SUPPORTS_INTERSECTION)
      return;
    const modifiers = binding.modifiers || {};
    const value = binding.value;
    const {
      handler,
      options
    } = typeof value === "object" ? value : {
      handler: value,
      options: {}
    };
    const observer = new IntersectionObserver(function() {
      var _a2;
      let entries = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      let observer2 = arguments.length > 1 ? arguments[1] : void 0;
      const _observe = (_a2 = el._observe) == null ? void 0 : _a2[binding.instance.$.uid];
      if (!_observe)
        return;
      const isIntersecting = entries.some((entry) => entry.isIntersecting);
      if (handler && (!modifiers.quiet || _observe.init) && (!modifiers.once || isIntersecting || _observe.init)) {
        handler(isIntersecting, entries, observer2);
      }
      if (isIntersecting && modifiers.once)
        unmounted(el, binding);
      else
        _observe.init = true;
    }, options);
    el._observe = Object(el._observe);
    el._observe[binding.instance.$.uid] = {
      init: false,
      observer
    };
    observer.observe(el);
  }
  function unmounted(el, binding) {
    var _a2;
    const observe = (_a2 = el._observe) == null ? void 0 : _a2[binding.instance.$.uid];
    if (!observe)
      return;
    observe.observer.unobserve(el);
    delete el._observe[binding.instance.$.uid];
  }
  var Intersect = {
    mounted,
    unmounted
  };
  var intersect_default = Intersect;

  // ../library_management/node_modules/vuetify/lib/components/VImg/VImg.mjs
  var makeVImgProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    alt: String,
    cover: Boolean,
    color: String,
    draggable: {
      type: [Boolean, String],
      default: void 0
    },
    eager: Boolean,
    gradient: String,
    lazySrc: String,
    options: {
      type: Object,
      default: () => ({
        root: void 0,
        rootMargin: void 0,
        threshold: void 0
      })
    },
    sizes: String,
    src: {
      type: [String, Object],
      default: ""
    },
    crossorigin: String,
    referrerpolicy: String,
    srcset: String,
    position: String
  }, makeVResponsiveProps()), makeComponentProps()), makeRoundedProps()), makeTransitionProps2()), "VImg");
  var VImg = genericComponent()({
    name: "VImg",
    directives: {
      intersect: intersect_default
    },
    props: makeVImgProps(),
    emits: {
      loadstart: (value) => true,
      load: (value) => true,
      error: (value) => true
    },
    setup(props, _ref) {
      let {
        emit: emit2,
        slots
      } = _ref;
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(toRef(props, "color"));
      const {
        roundedClasses
      } = useRounded(props);
      const vm = getCurrentInstance2("VImg");
      const currentSrc = shallowRef("");
      const image = ref();
      const state = shallowRef(props.eager ? "loading" : "idle");
      const naturalWidth = shallowRef();
      const naturalHeight = shallowRef();
      const normalisedSrc = computed2(() => {
        return props.src && typeof props.src === "object" ? {
          src: props.src.src,
          srcset: props.srcset || props.src.srcset,
          lazySrc: props.lazySrc || props.src.lazySrc,
          aspect: Number(props.aspectRatio || props.src.aspect || 0)
        } : {
          src: props.src,
          srcset: props.srcset,
          lazySrc: props.lazySrc,
          aspect: Number(props.aspectRatio || 0)
        };
      });
      const aspectRatio = computed2(() => {
        return normalisedSrc.value.aspect || naturalWidth.value / naturalHeight.value || 0;
      });
      watch(() => props.src, () => {
        init(state.value !== "idle");
      });
      watch(aspectRatio, (val, oldVal) => {
        if (!val && oldVal && image.value) {
          pollForSize(image.value);
        }
      });
      onBeforeMount(() => init());
      function init(isIntersecting) {
        if (props.eager && isIntersecting)
          return;
        if (SUPPORTS_INTERSECTION && !isIntersecting && !props.eager)
          return;
        state.value = "loading";
        if (normalisedSrc.value.lazySrc) {
          const lazyImg = new Image();
          lazyImg.src = normalisedSrc.value.lazySrc;
          pollForSize(lazyImg, null);
        }
        if (!normalisedSrc.value.src)
          return;
        nextTick(() => {
          var _a2;
          emit2("loadstart", ((_a2 = image.value) == null ? void 0 : _a2.currentSrc) || normalisedSrc.value.src);
          setTimeout(() => {
            var _a3;
            if (vm.isUnmounted)
              return;
            if ((_a3 = image.value) == null ? void 0 : _a3.complete) {
              if (!image.value.naturalWidth) {
                onError();
              }
              if (state.value === "error")
                return;
              if (!aspectRatio.value)
                pollForSize(image.value, null);
              if (state.value === "loading")
                onLoad();
            } else {
              if (!aspectRatio.value)
                pollForSize(image.value);
              getSrc();
            }
          });
        });
      }
      function onLoad() {
        var _a2;
        if (vm.isUnmounted)
          return;
        getSrc();
        pollForSize(image.value);
        state.value = "loaded";
        emit2("load", ((_a2 = image.value) == null ? void 0 : _a2.currentSrc) || normalisedSrc.value.src);
      }
      function onError() {
        var _a2;
        if (vm.isUnmounted)
          return;
        state.value = "error";
        emit2("error", ((_a2 = image.value) == null ? void 0 : _a2.currentSrc) || normalisedSrc.value.src);
      }
      function getSrc() {
        const img = image.value;
        if (img)
          currentSrc.value = img.currentSrc || img.src;
      }
      let timer = -1;
      onBeforeUnmount(() => {
        clearTimeout(timer);
      });
      function pollForSize(img) {
        let timeout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;
        const poll = () => {
          clearTimeout(timer);
          if (vm.isUnmounted)
            return;
          const {
            naturalHeight: imgHeight,
            naturalWidth: imgWidth
          } = img;
          if (imgHeight || imgWidth) {
            naturalWidth.value = imgWidth;
            naturalHeight.value = imgHeight;
          } else if (!img.complete && state.value === "loading" && timeout != null) {
            timer = window.setTimeout(poll, timeout);
          } else if (img.currentSrc.endsWith(".svg") || img.currentSrc.startsWith("data:image/svg+xml")) {
            naturalWidth.value = 1;
            naturalHeight.value = 1;
          }
        };
        poll();
      }
      const containClasses = computed2(() => ({
        "v-img__img--cover": props.cover,
        "v-img__img--contain": !props.cover
      }));
      const __image = () => {
        var _a2;
        if (!normalisedSrc.value.src || state.value === "idle")
          return null;
        const img = createVNode("img", {
          "class": ["v-img__img", containClasses.value],
          "style": {
            objectPosition: props.position
          },
          "src": normalisedSrc.value.src,
          "srcset": normalisedSrc.value.srcset,
          "alt": props.alt,
          "crossorigin": props.crossorigin,
          "referrerpolicy": props.referrerpolicy,
          "draggable": props.draggable,
          "sizes": props.sizes,
          "ref": image,
          "onLoad": onLoad,
          "onError": onError
        }, null);
        const sources = (_a2 = slots.sources) == null ? void 0 : _a2.call(slots);
        return createVNode(MaybeTransition, {
          "transition": props.transition,
          "appear": true
        }, {
          default: () => [withDirectives(sources ? createVNode("picture", {
            "class": "v-img__picture"
          }, [sources, img]) : img, [[vShow, state.value === "loaded"]])]
        });
      };
      const __preloadImage = () => createVNode(MaybeTransition, {
        "transition": props.transition
      }, {
        default: () => [normalisedSrc.value.lazySrc && state.value !== "loaded" && createVNode("img", {
          "class": ["v-img__img", "v-img__img--preload", containClasses.value],
          "style": {
            objectPosition: props.position
          },
          "src": normalisedSrc.value.lazySrc,
          "alt": props.alt,
          "crossorigin": props.crossorigin,
          "referrerpolicy": props.referrerpolicy,
          "draggable": props.draggable
        }, null)]
      });
      const __placeholder = () => {
        if (!slots.placeholder)
          return null;
        return createVNode(MaybeTransition, {
          "transition": props.transition,
          "appear": true
        }, {
          default: () => [(state.value === "loading" || state.value === "error" && !slots.error) && createVNode("div", {
            "class": "v-img__placeholder"
          }, [slots.placeholder()])]
        });
      };
      const __error = () => {
        if (!slots.error)
          return null;
        return createVNode(MaybeTransition, {
          "transition": props.transition,
          "appear": true
        }, {
          default: () => [state.value === "error" && createVNode("div", {
            "class": "v-img__error"
          }, [slots.error()])]
        });
      };
      const __gradient = () => {
        if (!props.gradient)
          return null;
        return createVNode("div", {
          "class": "v-img__gradient",
          "style": {
            backgroundImage: `linear-gradient(${props.gradient})`
          }
        }, null);
      };
      const isBooted = shallowRef(false);
      {
        const stop2 = watch(aspectRatio, (val) => {
          if (val) {
            requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                isBooted.value = true;
              });
            });
            stop2();
          }
        });
      }
      useRender(() => {
        const responsiveProps = VResponsive.filterProps(props);
        return withDirectives(createVNode(VResponsive, mergeProps({
          "class": ["v-img", {
            "v-img--booting": !isBooted.value
          }, backgroundColorClasses.value, roundedClasses.value, props.class],
          "style": [{
            width: convertToUnit(props.width === "auto" ? naturalWidth.value : props.width)
          }, backgroundColorStyles.value, props.style]
        }, responsiveProps, {
          "aspectRatio": aspectRatio.value,
          "aria-label": props.alt,
          "role": props.alt ? "img" : void 0
        }), {
          additional: () => createVNode(Fragment, null, [createVNode(__image, null, null), createVNode(__preloadImage, null, null), createVNode(__gradient, null, null), createVNode(__placeholder, null, null), createVNode(__error, null, null)]),
          default: slots.default
        }), [[resolveDirective("intersect"), {
          handler: init,
          options: props.options
        }, null, {
          once: true
        }]]);
      });
      return {
        currentSrc,
        image,
        state,
        naturalWidth,
        naturalHeight
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/composables/border.mjs
  var makeBorderProps = propsFactory({
    border: [Boolean, Number, String]
  }, "border");
  function useBorder(props) {
    let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    const borderClasses = computed2(() => {
      const border = isRef(props) ? props.value : props.border;
      const classes = [];
      if (border === true || border === "") {
        classes.push(`${name}--border`);
      } else if (typeof border === "string" || border === 0) {
        for (const value of String(border).split(" ")) {
          classes.push(`border-${value}`);
        }
      }
      return classes;
    });
    return {
      borderClasses
    };
  }

  // ../library_management/node_modules/vuetify/lib/composables/elevation.mjs
  var makeElevationProps = propsFactory({
    elevation: {
      type: [Number, String],
      validator(v) {
        const value = parseInt(v);
        return !isNaN(value) && value >= 0 && value <= 24;
      }
    }
  }, "elevation");
  function useElevation(props) {
    const elevationClasses = computed2(() => {
      const elevation = isRef(props) ? props.value : props.elevation;
      const classes = [];
      if (elevation == null)
        return classes;
      classes.push(`elevation-${elevation}`);
      return classes;
    });
    return {
      elevationClasses
    };
  }

  // ../library_management/node_modules/vuetify/lib/components/VToolbar/VToolbar.mjs
  var allowedDensities = [null, "prominent", "default", "comfortable", "compact"];
  var makeVToolbarProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    absolute: Boolean,
    collapse: Boolean,
    color: String,
    density: {
      type: String,
      default: "default",
      validator: (v) => allowedDensities.includes(v)
    },
    extended: Boolean,
    extensionHeight: {
      type: [Number, String],
      default: 48
    },
    flat: Boolean,
    floating: Boolean,
    height: {
      type: [Number, String],
      default: 64
    },
    image: String,
    title: String
  }, makeBorderProps()), makeComponentProps()), makeElevationProps()), makeRoundedProps()), makeTagProps({
    tag: "header"
  })), makeThemeProps()), "VToolbar");
  var VToolbar = genericComponent()({
    name: "VToolbar",
    props: makeVToolbarProps(),
    setup(props, _ref) {
      var _a2;
      let {
        slots
      } = _ref;
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(toRef(props, "color"));
      const {
        borderClasses
      } = useBorder(props);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        roundedClasses
      } = useRounded(props);
      const {
        themeClasses
      } = provideTheme(props);
      const {
        rtlClasses
      } = useRtl();
      const isExtended = shallowRef(!!(props.extended || ((_a2 = slots.extension) == null ? void 0 : _a2.call(slots))));
      const contentHeight = computed2(() => parseInt(Number(props.height) + (props.density === "prominent" ? Number(props.height) : 0) - (props.density === "comfortable" ? 8 : 0) - (props.density === "compact" ? 16 : 0), 10));
      const extensionHeight = computed2(() => isExtended.value ? parseInt(Number(props.extensionHeight) + (props.density === "prominent" ? Number(props.extensionHeight) : 0) - (props.density === "comfortable" ? 4 : 0) - (props.density === "compact" ? 8 : 0), 10) : 0);
      provideDefaults({
        VBtn: {
          variant: "text"
        }
      });
      useRender(() => {
        var _a3;
        const hasTitle = !!(props.title || slots.title);
        const hasImage = !!(slots.image || props.image);
        const extension = (_a3 = slots.extension) == null ? void 0 : _a3.call(slots);
        isExtended.value = !!(props.extended || extension);
        return createVNode(props.tag, {
          "class": ["v-toolbar", {
            "v-toolbar--absolute": props.absolute,
            "v-toolbar--collapse": props.collapse,
            "v-toolbar--flat": props.flat,
            "v-toolbar--floating": props.floating,
            [`v-toolbar--density-${props.density}`]: true
          }, backgroundColorClasses.value, borderClasses.value, elevationClasses.value, roundedClasses.value, themeClasses.value, rtlClasses.value, props.class],
          "style": [backgroundColorStyles.value, props.style]
        }, {
          default: () => [hasImage && createVNode("div", {
            "key": "image",
            "class": "v-toolbar__image"
          }, [!slots.image ? createVNode(VImg, {
            "key": "image-img",
            "cover": true,
            "src": props.image
          }, null) : createVNode(VDefaultsProvider, {
            "key": "image-defaults",
            "disabled": !props.image,
            "defaults": {
              VImg: {
                cover: true,
                src: props.image
              }
            }
          }, slots.image)]), createVNode(VDefaultsProvider, {
            "defaults": {
              VTabs: {
                height: convertToUnit(contentHeight.value)
              }
            }
          }, {
            default: () => {
              var _a4, _b, _c;
              return [createVNode("div", {
                "class": "v-toolbar__content",
                "style": {
                  height: convertToUnit(contentHeight.value)
                }
              }, [slots.prepend && createVNode("div", {
                "class": "v-toolbar__prepend"
              }, [(_a4 = slots.prepend) == null ? void 0 : _a4.call(slots)]), hasTitle && createVNode(VToolbarTitle, {
                "key": "title",
                "text": props.title
              }, {
                text: slots.title
              }), (_b = slots.default) == null ? void 0 : _b.call(slots), slots.append && createVNode("div", {
                "class": "v-toolbar__append"
              }, [(_c = slots.append) == null ? void 0 : _c.call(slots)])])];
            }
          }), createVNode(VDefaultsProvider, {
            "defaults": {
              VTabs: {
                height: convertToUnit(extensionHeight.value)
              }
            }
          }, {
            default: () => [createVNode(VExpandTransition, null, {
              default: () => [isExtended.value && createVNode("div", {
                "class": "v-toolbar__extension",
                "style": {
                  height: convertToUnit(extensionHeight.value)
                }
              }, [extension])]
            })]
          })]
        });
      });
      return {
        contentHeight,
        extensionHeight
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/composables/scroll.mjs
  var makeScrollProps = propsFactory({
    scrollTarget: {
      type: String
    },
    scrollThreshold: {
      type: [String, Number],
      default: 300
    }
  }, "scroll");
  function useScroll(props) {
    let args = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      canScroll
    } = args;
    let previousScroll = 0;
    const target = ref(null);
    const currentScroll = shallowRef(0);
    const savedScroll = shallowRef(0);
    const currentThreshold = shallowRef(0);
    const isScrollActive = shallowRef(false);
    const isScrollingUp = shallowRef(false);
    const scrollThreshold = computed2(() => {
      return Number(props.scrollThreshold);
    });
    const scrollRatio = computed2(() => {
      return clamp((scrollThreshold.value - currentScroll.value) / scrollThreshold.value || 0);
    });
    const onScroll = () => {
      const targetEl = target.value;
      if (!targetEl || canScroll && !canScroll.value)
        return;
      previousScroll = currentScroll.value;
      currentScroll.value = "window" in targetEl ? targetEl.pageYOffset : targetEl.scrollTop;
      isScrollingUp.value = currentScroll.value < previousScroll;
      currentThreshold.value = Math.abs(currentScroll.value - scrollThreshold.value);
    };
    watch(isScrollingUp, () => {
      savedScroll.value = savedScroll.value || currentScroll.value;
    });
    watch(isScrollActive, () => {
      savedScroll.value = 0;
    });
    onMounted(() => {
      watch(() => props.scrollTarget, (scrollTarget) => {
        var _a2;
        const newTarget = scrollTarget ? document.querySelector(scrollTarget) : window;
        if (!newTarget) {
          consoleWarn(`Unable to locate element with identifier ${scrollTarget}`);
          return;
        }
        if (newTarget === target.value)
          return;
        (_a2 = target.value) == null ? void 0 : _a2.removeEventListener("scroll", onScroll);
        target.value = newTarget;
        target.value.addEventListener("scroll", onScroll, {
          passive: true
        });
      }, {
        immediate: true
      });
    });
    onBeforeUnmount(() => {
      var _a2;
      (_a2 = target.value) == null ? void 0 : _a2.removeEventListener("scroll", onScroll);
    });
    canScroll && watch(canScroll, onScroll, {
      immediate: true
    });
    return {
      scrollThreshold,
      currentScroll,
      currentThreshold,
      isScrollActive,
      scrollRatio,
      isScrollingUp,
      savedScroll
    };
  }

  // ../library_management/node_modules/vuetify/lib/composables/ssrBoot.mjs
  function useSsrBoot() {
    const isBooted = shallowRef(false);
    onMounted(() => {
      window.requestAnimationFrame(() => {
        isBooted.value = true;
      });
    });
    const ssrBootStyles = computed2(() => !isBooted.value ? {
      transition: "none !important"
    } : void 0);
    return {
      ssrBootStyles,
      isBooted: readonly(isBooted)
    };
  }

  // ../library_management/node_modules/vuetify/lib/components/VAppBar/VAppBar.mjs
  var makeVAppBarProps = propsFactory(__spreadProps(__spreadValues(__spreadValues(__spreadValues({
    scrollBehavior: String,
    modelValue: {
      type: Boolean,
      default: true
    },
    location: {
      type: String,
      default: "top",
      validator: (value) => ["top", "bottom"].includes(value)
    }
  }, makeVToolbarProps()), makeLayoutItemProps()), makeScrollProps()), {
    height: {
      type: [Number, String],
      default: 64
    }
  }), "VAppBar");
  var VAppBar = genericComponent()({
    name: "VAppBar",
    props: makeVAppBarProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const vToolbarRef = ref();
      const isActive = useProxiedModel(props, "modelValue");
      const scrollBehavior = computed2(() => {
        var _a2, _b;
        const behavior = new Set((_b = (_a2 = props.scrollBehavior) == null ? void 0 : _a2.split(" ")) != null ? _b : []);
        return {
          hide: behavior.has("hide"),
          inverted: behavior.has("inverted"),
          collapse: behavior.has("collapse"),
          elevate: behavior.has("elevate"),
          fadeImage: behavior.has("fade-image")
        };
      });
      const canScroll = computed2(() => {
        const behavior = scrollBehavior.value;
        return behavior.hide || behavior.inverted || behavior.collapse || behavior.elevate || behavior.fadeImage || !isActive.value;
      });
      const {
        currentScroll,
        scrollThreshold,
        isScrollingUp,
        scrollRatio
      } = useScroll(props, {
        canScroll
      });
      const isCollapsed = computed2(() => props.collapse || scrollBehavior.value.collapse && (scrollBehavior.value.inverted ? scrollRatio.value > 0 : scrollRatio.value === 0));
      const isFlat = computed2(() => props.flat || scrollBehavior.value.elevate && (scrollBehavior.value.inverted ? currentScroll.value > 0 : currentScroll.value === 0));
      const opacity = computed2(() => scrollBehavior.value.fadeImage ? scrollBehavior.value.inverted ? 1 - scrollRatio.value : scrollRatio.value : void 0);
      const height = computed2(() => {
        var _a2, _b, _c, _d;
        if (scrollBehavior.value.hide && scrollBehavior.value.inverted)
          return 0;
        const height2 = (_b = (_a2 = vToolbarRef.value) == null ? void 0 : _a2.contentHeight) != null ? _b : 0;
        const extensionHeight = (_d = (_c = vToolbarRef.value) == null ? void 0 : _c.extensionHeight) != null ? _d : 0;
        return height2 + extensionHeight;
      });
      useToggleScope(computed2(() => !!props.scrollBehavior), () => {
        watchEffect(() => {
          if (scrollBehavior.value.hide) {
            if (scrollBehavior.value.inverted) {
              isActive.value = currentScroll.value > scrollThreshold.value;
            } else {
              isActive.value = isScrollingUp.value || currentScroll.value < scrollThreshold.value;
            }
          } else {
            isActive.value = true;
          }
        });
      });
      const {
        ssrBootStyles
      } = useSsrBoot();
      const {
        layoutItemStyles
      } = useLayoutItem({
        id: props.name,
        order: computed2(() => parseInt(props.order, 10)),
        position: toRef(props, "location"),
        layoutSize: height,
        elementSize: shallowRef(void 0),
        active: isActive,
        absolute: toRef(props, "absolute")
      });
      useRender(() => {
        const toolbarProps = VToolbar.filterProps(props);
        return createVNode(VToolbar, mergeProps({
          "ref": vToolbarRef,
          "class": ["v-app-bar", {
            "v-app-bar--bottom": props.location === "bottom"
          }, props.class],
          "style": [__spreadValues(__spreadProps(__spreadValues({}, layoutItemStyles.value), {
            "--v-toolbar-image-opacity": opacity.value,
            height: void 0
          }), ssrBootStyles.value), props.style]
        }, toolbarProps, {
          "collapse": isCollapsed.value,
          "flat": isFlat.value
        }), slots);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/composables/density.mjs
  var allowedDensities2 = [null, "default", "comfortable", "compact"];
  var makeDensityProps = propsFactory({
    density: {
      type: String,
      default: "default",
      validator: (v) => allowedDensities2.includes(v)
    }
  }, "density");
  function useDensity(props) {
    let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    const densityClasses = computed2(() => {
      return `${name}--density-${props.density}`;
    });
    return {
      densityClasses
    };
  }

  // ../library_management/node_modules/vuetify/lib/composables/variant.mjs
  var allowedVariants = ["elevated", "flat", "tonal", "outlined", "text", "plain"];
  function genOverlays(isClickable, name) {
    return createVNode(Fragment, null, [isClickable && createVNode("span", {
      "key": "overlay",
      "class": `${name}__overlay`
    }, null), createVNode("span", {
      "key": "underlay",
      "class": `${name}__underlay`
    }, null)]);
  }
  var makeVariantProps = propsFactory({
    color: String,
    variant: {
      type: String,
      default: "elevated",
      validator: (v) => allowedVariants.includes(v)
    }
  }, "variant");
  function useVariant(props) {
    let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    const variantClasses = computed2(() => {
      const {
        variant
      } = unref(props);
      return `${name}--variant-${variant}`;
    });
    const {
      colorClasses,
      colorStyles
    } = useColor(computed2(() => {
      const {
        variant,
        color
      } = unref(props);
      return {
        [["elevated", "flat"].includes(variant) ? "background" : "text"]: color
      };
    }));
    return {
      colorClasses,
      colorStyles,
      variantClasses
    };
  }

  // ../library_management/node_modules/vuetify/lib/components/VBtnGroup/VBtnGroup.mjs
  var makeVBtnGroupProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    divided: Boolean
  }, makeBorderProps()), makeComponentProps()), makeDensityProps()), makeElevationProps()), makeRoundedProps()), makeTagProps()), makeThemeProps()), makeVariantProps()), "VBtnGroup");
  var VBtnGroup = genericComponent()({
    name: "VBtnGroup",
    props: makeVBtnGroupProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      const {
        densityClasses
      } = useDensity(props);
      const {
        borderClasses
      } = useBorder(props);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        roundedClasses
      } = useRounded(props);
      provideDefaults({
        VBtn: {
          height: "auto",
          color: toRef(props, "color"),
          density: toRef(props, "density"),
          flat: true,
          variant: toRef(props, "variant")
        }
      });
      useRender(() => {
        return createVNode(props.tag, {
          "class": ["v-btn-group", {
            "v-btn-group--divided": props.divided
          }, themeClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, roundedClasses.value, props.class],
          "style": props.style
        }, slots);
      });
    }
  });

  // ../library_management/node_modules/vuetify/lib/composables/group.mjs
  var makeGroupProps = propsFactory({
    modelValue: {
      type: null,
      default: void 0
    },
    multiple: Boolean,
    mandatory: [Boolean, String],
    max: Number,
    selectedClass: String,
    disabled: Boolean
  }, "group");
  var makeGroupItemProps = propsFactory({
    value: null,
    disabled: Boolean,
    selectedClass: String
  }, "group-item");
  function useGroupItem(props, injectKey) {
    let required = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    const vm = getCurrentInstance2("useGroupItem");
    if (!vm) {
      throw new Error("[Vuetify] useGroupItem composable must be used inside a component setup function");
    }
    const id = getUid();
    provide(Symbol.for(`${injectKey.description}:id`), id);
    const group = inject(injectKey, null);
    if (!group) {
      if (!required)
        return group;
      throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${injectKey.description}`);
    }
    const value = toRef(props, "value");
    const disabled = computed2(() => !!(group.disabled.value || props.disabled));
    group.register({
      id,
      value,
      disabled
    }, vm);
    onBeforeUnmount(() => {
      group.unregister(id);
    });
    const isSelected = computed2(() => {
      return group.isSelected(id);
    });
    const selectedClass = computed2(() => isSelected.value && [group.selectedClass.value, props.selectedClass]);
    watch(isSelected, (value2) => {
      vm.emit("group:selected", {
        value: value2
      });
    }, {
      flush: "sync"
    });
    return {
      id,
      isSelected,
      toggle: () => group.select(id, !isSelected.value),
      select: (value2) => group.select(id, value2),
      selectedClass,
      value,
      disabled,
      group
    };
  }
  function useGroup(props, injectKey) {
    let isUnmounted = false;
    const items = reactive([]);
    const selected = useProxiedModel(props, "modelValue", [], (v) => {
      if (v == null)
        return [];
      return getIds(items, wrapInArray(v));
    }, (v) => {
      const arr = getValues(items, v);
      return props.multiple ? arr : arr[0];
    });
    const groupVm = getCurrentInstance2("useGroup");
    function register(item, vm) {
      const unwrapped = item;
      const key = Symbol.for(`${injectKey.description}:id`);
      const children = findChildrenWithProvide(key, groupVm == null ? void 0 : groupVm.vnode);
      const index = children.indexOf(vm);
      if (unref(unwrapped.value) == null) {
        unwrapped.value = index;
      }
      if (index > -1) {
        items.splice(index, 0, unwrapped);
      } else {
        items.push(unwrapped);
      }
    }
    function unregister(id) {
      if (isUnmounted)
        return;
      forceMandatoryValue();
      const index = items.findIndex((item) => item.id === id);
      items.splice(index, 1);
    }
    function forceMandatoryValue() {
      const item = items.find((item2) => !item2.disabled);
      if (item && props.mandatory === "force" && !selected.value.length) {
        selected.value = [item.id];
      }
    }
    onMounted(() => {
      forceMandatoryValue();
    });
    onBeforeUnmount(() => {
      isUnmounted = true;
    });
    function select(id, value) {
      const item = items.find((item2) => item2.id === id);
      if (value && (item == null ? void 0 : item.disabled))
        return;
      if (props.multiple) {
        const internalValue = selected.value.slice();
        const index = internalValue.findIndex((v) => v === id);
        const isSelected = ~index;
        value = value != null ? value : !isSelected;
        if (isSelected && props.mandatory && internalValue.length <= 1)
          return;
        if (!isSelected && props.max != null && internalValue.length + 1 > props.max)
          return;
        if (index < 0 && value)
          internalValue.push(id);
        else if (index >= 0 && !value)
          internalValue.splice(index, 1);
        selected.value = internalValue;
      } else {
        const isSelected = selected.value.includes(id);
        if (props.mandatory && isSelected)
          return;
        selected.value = (value != null ? value : !isSelected) ? [id] : [];
      }
    }
    function step(offset) {
      if (props.multiple)
        consoleWarn('This method is not supported when using "multiple" prop');
      if (!selected.value.length) {
        const item = items.find((item2) => !item2.disabled);
        item && (selected.value = [item.id]);
      } else {
        const currentId = selected.value[0];
        const currentIndex = items.findIndex((i) => i.id === currentId);
        let newIndex = (currentIndex + offset) % items.length;
        let newItem = items[newIndex];
        while (newItem.disabled && newIndex !== currentIndex) {
          newIndex = (newIndex + offset) % items.length;
          newItem = items[newIndex];
        }
        if (newItem.disabled)
          return;
        selected.value = [items[newIndex].id];
      }
    }
    const state = {
      register,
      unregister,
      selected,
      select,
      disabled: toRef(props, "disabled"),
      prev: () => step(items.length - 1),
      next: () => step(1),
      isSelected: (id) => selected.value.includes(id),
      selectedClass: computed2(() => props.selectedClass),
      items: computed2(() => items),
      getItemIndex: (value) => getItemIndex(items, value)
    };
    provide(injectKey, state);
    return state;
  }
  function getItemIndex(items, value) {
    const ids = getIds(items, [value]);
    if (!ids.length)
      return -1;
    return items.findIndex((item) => item.id === ids[0]);
  }
  function getIds(items, modelValue) {
    const ids = [];
    modelValue.forEach((value) => {
      const item = items.find((item2) => deepEqual(value, item2.value));
      const itemByIndex = items[value];
      if ((item == null ? void 0 : item.value) != null) {
        ids.push(item.id);
      } else if (itemByIndex != null) {
        ids.push(itemByIndex.id);
      }
    });
    return ids;
  }
  function getValues(items, ids) {
    const values = [];
    ids.forEach((id) => {
      const itemIndex = items.findIndex((item) => item.id === id);
      if (~itemIndex) {
        const item = items[itemIndex];
        values.push(item.value != null ? item.value : itemIndex);
      }
    });
    return values;
  }

  // ../library_management/node_modules/vuetify/lib/components/VBtnToggle/VBtnToggle.mjs
  var VBtnToggleSymbol = Symbol.for("vuetify:v-btn-toggle");
  var makeVBtnToggleProps = propsFactory(__spreadValues(__spreadValues({}, makeVBtnGroupProps()), makeGroupProps()), "VBtnToggle");
  var VBtnToggle = genericComponent()({
    name: "VBtnToggle",
    props: makeVBtnToggleProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        isSelected,
        next,
        prev,
        select,
        selected
      } = useGroup(props, VBtnToggleSymbol);
      useRender(() => {
        const btnGroupProps = VBtnGroup.filterProps(props);
        return createVNode(VBtnGroup, mergeProps({
          "class": ["v-btn-toggle", props.class]
        }, btnGroupProps, {
          "style": props.style
        }), {
          default: () => {
            var _a2;
            return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
              isSelected,
              next,
              prev,
              select,
              selected
            })];
          }
        });
      });
      return {
        next,
        prev,
        select
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/composables/size.mjs
  var predefinedSizes = ["x-small", "small", "default", "large", "x-large"];
  var makeSizeProps = propsFactory({
    size: {
      type: [String, Number],
      default: "default"
    }
  }, "size");
  function useSize(props) {
    let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    return destructComputed(() => {
      let sizeClasses;
      let sizeStyles;
      if (includes(predefinedSizes, props.size)) {
        sizeClasses = `${name}--size-${props.size}`;
      } else if (props.size) {
        sizeStyles = {
          width: convertToUnit(props.size),
          height: convertToUnit(props.size)
        };
      }
      return {
        sizeClasses,
        sizeStyles
      };
    });
  }

  // ../library_management/node_modules/vuetify/lib/components/VIcon/VIcon.mjs
  var makeVIconProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    color: String,
    disabled: Boolean,
    start: Boolean,
    end: Boolean,
    icon: IconValue
  }, makeComponentProps()), makeSizeProps()), makeTagProps({
    tag: "i"
  })), makeThemeProps()), "VIcon");
  var VIcon = genericComponent()({
    name: "VIcon",
    props: makeVIconProps(),
    setup(props, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const slotIcon = ref();
      const {
        themeClasses
      } = provideTheme(props);
      const {
        iconData
      } = useIcon(computed2(() => slotIcon.value || props.icon));
      const {
        sizeClasses
      } = useSize(props);
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(toRef(props, "color"));
      useRender(() => {
        var _a2, _b;
        const slotValue = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
        if (slotValue) {
          slotIcon.value = (_b = flattenFragments(slotValue).filter((node) => node.type === Text && node.children && typeof node.children === "string")[0]) == null ? void 0 : _b.children;
        }
        const hasClick = !!(attrs.onClick || attrs.onClickOnce);
        return createVNode(iconData.value.component, {
          "tag": props.tag,
          "icon": iconData.value.icon,
          "class": ["v-icon", "notranslate", themeClasses.value, sizeClasses.value, textColorClasses.value, {
            "v-icon--clickable": hasClick,
            "v-icon--disabled": props.disabled,
            "v-icon--start": props.start,
            "v-icon--end": props.end
          }, props.class],
          "style": [!sizeClasses.value ? {
            fontSize: convertToUnit(props.size),
            height: convertToUnit(props.size),
            width: convertToUnit(props.size)
          } : void 0, textColorStyles.value, props.style],
          "role": hasClick ? "button" : void 0,
          "aria-hidden": !hasClick,
          "tabindex": hasClick ? props.disabled ? -1 : 0 : void 0
        }, {
          default: () => [slotValue]
        });
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/composables/intersectionObserver.mjs
  function useIntersectionObserver(callback, options) {
    const intersectionRef = ref();
    const isIntersecting = shallowRef(false);
    if (SUPPORTS_INTERSECTION) {
      const observer = new IntersectionObserver((entries) => {
        callback == null ? void 0 : callback(entries, observer);
        isIntersecting.value = !!entries.find((entry) => entry.isIntersecting);
      }, options);
      onBeforeUnmount(() => {
        observer.disconnect();
      });
      watch(intersectionRef, (newValue, oldValue) => {
        if (oldValue) {
          observer.unobserve(oldValue);
          isIntersecting.value = false;
        }
        if (newValue)
          observer.observe(newValue);
      }, {
        flush: "post"
      });
    }
    return {
      intersectionRef,
      isIntersecting
    };
  }

  // ../library_management/node_modules/vuetify/lib/components/VProgressCircular/VProgressCircular.mjs
  var makeVProgressCircularProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    bgColor: String,
    color: String,
    indeterminate: [Boolean, String],
    modelValue: {
      type: [Number, String],
      default: 0
    },
    rotate: {
      type: [Number, String],
      default: 0
    },
    width: {
      type: [Number, String],
      default: 4
    }
  }, makeComponentProps()), makeSizeProps()), makeTagProps({
    tag: "div"
  })), makeThemeProps()), "VProgressCircular");
  var VProgressCircular = genericComponent()({
    name: "VProgressCircular",
    props: makeVProgressCircularProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const MAGIC_RADIUS_CONSTANT = 20;
      const CIRCUMFERENCE = 2 * Math.PI * MAGIC_RADIUS_CONSTANT;
      const root = ref();
      const {
        themeClasses
      } = provideTheme(props);
      const {
        sizeClasses,
        sizeStyles
      } = useSize(props);
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(toRef(props, "color"));
      const {
        textColorClasses: underlayColorClasses,
        textColorStyles: underlayColorStyles
      } = useTextColor(toRef(props, "bgColor"));
      const {
        intersectionRef,
        isIntersecting
      } = useIntersectionObserver();
      const {
        resizeRef,
        contentRect
      } = useResizeObserver();
      const normalizedValue = computed2(() => Math.max(0, Math.min(100, parseFloat(props.modelValue))));
      const width = computed2(() => Number(props.width));
      const size2 = computed2(() => {
        return sizeStyles.value ? Number(props.size) : contentRect.value ? contentRect.value.width : Math.max(width.value, 32);
      });
      const diameter = computed2(() => MAGIC_RADIUS_CONSTANT / (1 - width.value / size2.value) * 2);
      const strokeWidth = computed2(() => width.value / size2.value * diameter.value);
      const strokeDashOffset = computed2(() => convertToUnit((100 - normalizedValue.value) / 100 * CIRCUMFERENCE));
      watchEffect(() => {
        intersectionRef.value = root.value;
        resizeRef.value = root.value;
      });
      useRender(() => createVNode(props.tag, {
        "ref": root,
        "class": ["v-progress-circular", {
          "v-progress-circular--indeterminate": !!props.indeterminate,
          "v-progress-circular--visible": isIntersecting.value,
          "v-progress-circular--disable-shrink": props.indeterminate === "disable-shrink"
        }, themeClasses.value, sizeClasses.value, textColorClasses.value, props.class],
        "style": [sizeStyles.value, textColorStyles.value, props.style],
        "role": "progressbar",
        "aria-valuemin": "0",
        "aria-valuemax": "100",
        "aria-valuenow": props.indeterminate ? void 0 : normalizedValue.value
      }, {
        default: () => [createVNode("svg", {
          "style": {
            transform: `rotate(calc(-90deg + ${Number(props.rotate)}deg))`
          },
          "xmlns": "http://www.w3.org/2000/svg",
          "viewBox": `0 0 ${diameter.value} ${diameter.value}`
        }, [createVNode("circle", {
          "class": ["v-progress-circular__underlay", underlayColorClasses.value],
          "style": underlayColorStyles.value,
          "fill": "transparent",
          "cx": "50%",
          "cy": "50%",
          "r": MAGIC_RADIUS_CONSTANT,
          "stroke-width": strokeWidth.value,
          "stroke-dasharray": CIRCUMFERENCE,
          "stroke-dashoffset": 0
        }, null), createVNode("circle", {
          "class": "v-progress-circular__overlay",
          "fill": "transparent",
          "cx": "50%",
          "cy": "50%",
          "r": MAGIC_RADIUS_CONSTANT,
          "stroke-width": strokeWidth.value,
          "stroke-dasharray": CIRCUMFERENCE,
          "stroke-dashoffset": strokeDashOffset.value
        }, null)]), slots.default && createVNode("div", {
          "class": "v-progress-circular__content"
        }, [slots.default({
          value: normalizedValue.value
        })])]
      }));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/composables/location.mjs
  var oppositeMap = {
    center: "center",
    top: "bottom",
    bottom: "top",
    left: "right",
    right: "left"
  };
  var makeLocationProps = propsFactory({
    location: String
  }, "location");
  function useLocation(props) {
    let opposite = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    let offset = arguments.length > 2 ? arguments[2] : void 0;
    const {
      isRtl
    } = useRtl();
    const locationStyles = computed2(() => {
      if (!props.location)
        return {};
      const {
        side,
        align
      } = parseAnchor(props.location.split(" ").length > 1 ? props.location : `${props.location} center`, isRtl.value);
      function getOffset3(side2) {
        return offset ? offset(side2) : 0;
      }
      const styles = {};
      if (side !== "center") {
        if (opposite)
          styles[oppositeMap[side]] = `calc(100% - ${getOffset3(side)}px)`;
        else
          styles[side] = 0;
      }
      if (align !== "center") {
        if (opposite)
          styles[oppositeMap[align]] = `calc(100% - ${getOffset3(align)}px)`;
        else
          styles[align] = 0;
      } else {
        if (side === "center")
          styles.top = styles.left = "50%";
        else {
          styles[{
            top: "left",
            bottom: "left",
            left: "top",
            right: "top"
          }[side]] = "50%";
        }
        styles.transform = {
          top: "translateX(-50%)",
          bottom: "translateX(-50%)",
          left: "translateY(-50%)",
          right: "translateY(-50%)",
          center: "translate(-50%, -50%)"
        }[side];
      }
      return styles;
    });
    return {
      locationStyles
    };
  }

  // ../library_management/node_modules/vuetify/lib/components/VProgressLinear/VProgressLinear.mjs
  var makeVProgressLinearProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    absolute: Boolean,
    active: {
      type: Boolean,
      default: true
    },
    bgColor: String,
    bgOpacity: [Number, String],
    bufferValue: {
      type: [Number, String],
      default: 0
    },
    clickable: Boolean,
    color: String,
    height: {
      type: [Number, String],
      default: 4
    },
    indeterminate: Boolean,
    max: {
      type: [Number, String],
      default: 100
    },
    modelValue: {
      type: [Number, String],
      default: 0
    },
    reverse: Boolean,
    stream: Boolean,
    striped: Boolean,
    roundedBar: Boolean
  }, makeComponentProps()), makeLocationProps({
    location: "top"
  })), makeRoundedProps()), makeTagProps()), makeThemeProps()), "VProgressLinear");
  var VProgressLinear = genericComponent()({
    name: "VProgressLinear",
    props: makeVProgressLinearProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const progress = useProxiedModel(props, "modelValue");
      const {
        isRtl,
        rtlClasses
      } = useRtl();
      const {
        themeClasses
      } = provideTheme(props);
      const {
        locationStyles
      } = useLocation(props);
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(props, "color");
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(computed2(() => props.bgColor || props.color));
      const {
        backgroundColorClasses: barColorClasses,
        backgroundColorStyles: barColorStyles
      } = useBackgroundColor(props, "color");
      const {
        roundedClasses
      } = useRounded(props);
      const {
        intersectionRef,
        isIntersecting
      } = useIntersectionObserver();
      const max = computed2(() => parseInt(props.max, 10));
      const height = computed2(() => parseInt(props.height, 10));
      const normalizedBuffer = computed2(() => parseFloat(props.bufferValue) / max.value * 100);
      const normalizedValue = computed2(() => parseFloat(progress.value) / max.value * 100);
      const isReversed = computed2(() => isRtl.value !== props.reverse);
      const transition = computed2(() => props.indeterminate ? "fade-transition" : "slide-x-transition");
      const opacity = computed2(() => {
        return props.bgOpacity == null ? props.bgOpacity : parseFloat(props.bgOpacity);
      });
      function handleClick(e) {
        if (!intersectionRef.value)
          return;
        const {
          left,
          right,
          width
        } = intersectionRef.value.getBoundingClientRect();
        const value = isReversed.value ? width - e.clientX + (right - width) : e.clientX - left;
        progress.value = Math.round(value / width * max.value);
      }
      useRender(() => createVNode(props.tag, {
        "ref": intersectionRef,
        "class": ["v-progress-linear", {
          "v-progress-linear--absolute": props.absolute,
          "v-progress-linear--active": props.active && isIntersecting.value,
          "v-progress-linear--reverse": isReversed.value,
          "v-progress-linear--rounded": props.rounded,
          "v-progress-linear--rounded-bar": props.roundedBar,
          "v-progress-linear--striped": props.striped
        }, roundedClasses.value, themeClasses.value, rtlClasses.value, props.class],
        "style": [__spreadValues({
          bottom: props.location === "bottom" ? 0 : void 0,
          top: props.location === "top" ? 0 : void 0,
          height: props.active ? convertToUnit(height.value) : 0,
          "--v-progress-linear-height": convertToUnit(height.value)
        }, locationStyles.value), props.style],
        "role": "progressbar",
        "aria-hidden": props.active ? "false" : "true",
        "aria-valuemin": "0",
        "aria-valuemax": props.max,
        "aria-valuenow": props.indeterminate ? void 0 : normalizedValue.value,
        "onClick": props.clickable && handleClick
      }, {
        default: () => [props.stream && createVNode("div", {
          "key": "stream",
          "class": ["v-progress-linear__stream", textColorClasses.value],
          "style": __spreadProps(__spreadValues({}, textColorStyles.value), {
            [isReversed.value ? "left" : "right"]: convertToUnit(-height.value),
            borderTop: `${convertToUnit(height.value / 2)} dotted`,
            opacity: opacity.value,
            top: `calc(50% - ${convertToUnit(height.value / 4)})`,
            width: convertToUnit(100 - normalizedBuffer.value, "%"),
            "--v-progress-linear-stream-to": convertToUnit(height.value * (isReversed.value ? 1 : -1))
          })
        }, null), createVNode("div", {
          "class": ["v-progress-linear__background", backgroundColorClasses.value],
          "style": [backgroundColorStyles.value, {
            opacity: opacity.value,
            width: convertToUnit(!props.stream ? 100 : normalizedBuffer.value, "%")
          }]
        }, null), createVNode(Transition, {
          "name": transition.value
        }, {
          default: () => [!props.indeterminate ? createVNode("div", {
            "class": ["v-progress-linear__determinate", barColorClasses.value],
            "style": [barColorStyles.value, {
              width: convertToUnit(normalizedValue.value, "%")
            }]
          }, null) : createVNode("div", {
            "class": "v-progress-linear__indeterminate"
          }, [["long", "short"].map((bar) => createVNode("div", {
            "key": bar,
            "class": ["v-progress-linear__indeterminate", bar, barColorClasses.value],
            "style": barColorStyles.value
          }, null))])]
        }), slots.default && createVNode("div", {
          "class": "v-progress-linear__content"
        }, [slots.default({
          value: normalizedValue.value,
          buffer: normalizedBuffer.value
        })])]
      }));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/composables/loader.mjs
  var makeLoaderProps = propsFactory({
    loading: [Boolean, String]
  }, "loader");
  function useLoader(props) {
    let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    const loaderClasses = computed2(() => ({
      [`${name}--loading`]: props.loading
    }));
    return {
      loaderClasses
    };
  }
  function LoaderSlot(props, _ref) {
    var _a2;
    let {
      slots
    } = _ref;
    return createVNode("div", {
      "class": `${props.name}__loader`
    }, [((_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
      color: props.color,
      isActive: props.active
    })) || createVNode(VProgressLinear, {
      "absolute": props.absolute,
      "active": props.active,
      "color": props.color,
      "height": "2",
      "indeterminate": true
    }, null)]);
  }

  // ../library_management/node_modules/vuetify/lib/composables/position.mjs
  var positionValues = ["static", "relative", "fixed", "absolute", "sticky"];
  var makePositionProps = propsFactory({
    position: {
      type: String,
      validator: (v) => positionValues.includes(v)
    }
  }, "position");
  function usePosition(props) {
    let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    const positionClasses = computed2(() => {
      return props.position ? `${name}--${props.position}` : void 0;
    });
    return {
      positionClasses
    };
  }

  // ../library_management/node_modules/vuetify/lib/composables/router.mjs
  function useRoute() {
    const vm = getCurrentInstance2("useRoute");
    return computed2(() => {
      var _a2;
      return (_a2 = vm == null ? void 0 : vm.proxy) == null ? void 0 : _a2.$route;
    });
  }
  function useRouter() {
    var _a2, _b;
    return (_b = (_a2 = getCurrentInstance2("useRouter")) == null ? void 0 : _a2.proxy) == null ? void 0 : _b.$router;
  }
  function useLink(props, attrs) {
    var _a2, _b;
    const RouterLink = resolveDynamicComponent("RouterLink");
    const isLink = computed2(() => !!(props.href || props.to));
    const isClickable = computed2(() => {
      return (isLink == null ? void 0 : isLink.value) || hasEvent(attrs, "click") || hasEvent(props, "click");
    });
    if (typeof RouterLink === "string" || !("useLink" in RouterLink)) {
      return {
        isLink,
        isClickable,
        href: toRef(props, "href")
      };
    }
    const linkProps = computed2(() => __spreadProps(__spreadValues({}, props), {
      to: toRef(() => props.to || {})
    }));
    const routerLink = RouterLink.useLink(linkProps.value);
    const link = computed2(() => props.to ? routerLink : void 0);
    const route = useRoute();
    return {
      isLink,
      isClickable,
      route: (_a2 = link.value) == null ? void 0 : _a2.route,
      navigate: (_b = link.value) == null ? void 0 : _b.navigate,
      isActive: computed2(() => {
        var _a3, _b2, _c, _d, _e;
        if (!link.value)
          return false;
        if (!props.exact)
          return (_b2 = (_a3 = link.value.isActive) == null ? void 0 : _a3.value) != null ? _b2 : false;
        if (!route.value)
          return (_d = (_c = link.value.isExactActive) == null ? void 0 : _c.value) != null ? _d : false;
        return ((_e = link.value.isExactActive) == null ? void 0 : _e.value) && deepEqual(link.value.route.value.query, route.value.query);
      }),
      href: computed2(() => {
        var _a3;
        return props.to ? (_a3 = link.value) == null ? void 0 : _a3.route.value.href : props.href;
      })
    };
  }
  var makeRouterProps = propsFactory({
    href: String,
    replace: Boolean,
    to: [String, Object],
    exact: Boolean
  }, "router");
  var inTransition = false;
  function useBackButton(router, cb) {
    let popped = false;
    let removeBefore;
    let removeAfter;
    if (IN_BROWSER) {
      nextTick(() => {
        window.addEventListener("popstate", onPopstate);
        removeBefore = router == null ? void 0 : router.beforeEach((to, from, next) => {
          if (!inTransition) {
            setTimeout(() => popped ? cb(next) : next());
          } else {
            popped ? cb(next) : next();
          }
          inTransition = true;
        });
        removeAfter = router == null ? void 0 : router.afterEach(() => {
          inTransition = false;
        });
      });
      onScopeDispose(() => {
        window.removeEventListener("popstate", onPopstate);
        removeBefore == null ? void 0 : removeBefore();
        removeAfter == null ? void 0 : removeAfter();
      });
    }
    function onPopstate(e) {
      var _a2;
      if ((_a2 = e.state) == null ? void 0 : _a2.replaced)
        return;
      popped = true;
      setTimeout(() => popped = false);
    }
  }

  // ../library_management/node_modules/vuetify/lib/composables/selectLink.mjs
  function useSelectLink(link, select) {
    watch(() => {
      var _a2;
      return (_a2 = link.isActive) == null ? void 0 : _a2.value;
    }, (isActive) => {
      if (link.isLink.value && isActive && select) {
        nextTick(() => {
          select(true);
        });
      }
    }, {
      immediate: true
    });
  }

  // ../library_management/node_modules/vuetify/lib/directives/ripple/index.mjs
  var stopSymbol = Symbol("rippleStop");
  var DELAY_RIPPLE = 80;
  function transform(el, value) {
    el.style.transform = value;
    el.style.webkitTransform = value;
  }
  function isTouchEvent(e) {
    return e.constructor.name === "TouchEvent";
  }
  function isKeyboardEvent(e) {
    return e.constructor.name === "KeyboardEvent";
  }
  var calculate = function(e, el) {
    var _a2;
    let value = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let localX = 0;
    let localY = 0;
    if (!isKeyboardEvent(e)) {
      const offset = el.getBoundingClientRect();
      const target = isTouchEvent(e) ? e.touches[e.touches.length - 1] : e;
      localX = target.clientX - offset.left;
      localY = target.clientY - offset.top;
    }
    let radius = 0;
    let scale = 0.3;
    if ((_a2 = el._ripple) == null ? void 0 : _a2.circle) {
      scale = 0.15;
      radius = el.clientWidth / 2;
      radius = value.center ? radius : radius + Math.sqrt((localX - radius) ** 2 + (localY - radius) ** 2) / 4;
    } else {
      radius = Math.sqrt(el.clientWidth ** 2 + el.clientHeight ** 2) / 2;
    }
    const centerX = `${(el.clientWidth - radius * 2) / 2}px`;
    const centerY = `${(el.clientHeight - radius * 2) / 2}px`;
    const x = value.center ? centerX : `${localX - radius}px`;
    const y = value.center ? centerY : `${localY - radius}px`;
    return {
      radius,
      scale,
      x,
      y,
      centerX,
      centerY
    };
  };
  var ripples = {
    show(e, el) {
      var _a2;
      let value = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (!((_a2 = el == null ? void 0 : el._ripple) == null ? void 0 : _a2.enabled)) {
        return;
      }
      const container = document.createElement("span");
      const animation = document.createElement("span");
      container.appendChild(animation);
      container.className = "v-ripple__container";
      if (value.class) {
        container.className += ` ${value.class}`;
      }
      const {
        radius,
        scale,
        x,
        y,
        centerX,
        centerY
      } = calculate(e, el, value);
      const size2 = `${radius * 2}px`;
      animation.className = "v-ripple__animation";
      animation.style.width = size2;
      animation.style.height = size2;
      el.appendChild(container);
      const computed3 = window.getComputedStyle(el);
      if (computed3 && computed3.position === "static") {
        el.style.position = "relative";
        el.dataset.previousPosition = "static";
      }
      animation.classList.add("v-ripple__animation--enter");
      animation.classList.add("v-ripple__animation--visible");
      transform(animation, `translate(${x}, ${y}) scale3d(${scale},${scale},${scale})`);
      animation.dataset.activated = String(performance.now());
      setTimeout(() => {
        animation.classList.remove("v-ripple__animation--enter");
        animation.classList.add("v-ripple__animation--in");
        transform(animation, `translate(${centerX}, ${centerY}) scale3d(1,1,1)`);
      }, 0);
    },
    hide(el) {
      var _a2;
      if (!((_a2 = el == null ? void 0 : el._ripple) == null ? void 0 : _a2.enabled))
        return;
      const ripples2 = el.getElementsByClassName("v-ripple__animation");
      if (ripples2.length === 0)
        return;
      const animation = ripples2[ripples2.length - 1];
      if (animation.dataset.isHiding)
        return;
      else
        animation.dataset.isHiding = "true";
      const diff = performance.now() - Number(animation.dataset.activated);
      const delay = Math.max(250 - diff, 0);
      setTimeout(() => {
        animation.classList.remove("v-ripple__animation--in");
        animation.classList.add("v-ripple__animation--out");
        setTimeout(() => {
          var _a3;
          const ripples3 = el.getElementsByClassName("v-ripple__animation");
          if (ripples3.length === 1 && el.dataset.previousPosition) {
            el.style.position = el.dataset.previousPosition;
            delete el.dataset.previousPosition;
          }
          if (((_a3 = animation.parentNode) == null ? void 0 : _a3.parentNode) === el)
            el.removeChild(animation.parentNode);
        }, 300);
      }, delay);
    }
  };
  function isRippleEnabled(value) {
    return typeof value === "undefined" || !!value;
  }
  function rippleShow(e) {
    const value = {};
    const element = e.currentTarget;
    if (!(element == null ? void 0 : element._ripple) || element._ripple.touched || e[stopSymbol])
      return;
    e[stopSymbol] = true;
    if (isTouchEvent(e)) {
      element._ripple.touched = true;
      element._ripple.isTouch = true;
    } else {
      if (element._ripple.isTouch)
        return;
    }
    value.center = element._ripple.centered || isKeyboardEvent(e);
    if (element._ripple.class) {
      value.class = element._ripple.class;
    }
    if (isTouchEvent(e)) {
      if (element._ripple.showTimerCommit)
        return;
      element._ripple.showTimerCommit = () => {
        ripples.show(e, element, value);
      };
      element._ripple.showTimer = window.setTimeout(() => {
        var _a2;
        if ((_a2 = element == null ? void 0 : element._ripple) == null ? void 0 : _a2.showTimerCommit) {
          element._ripple.showTimerCommit();
          element._ripple.showTimerCommit = null;
        }
      }, DELAY_RIPPLE);
    } else {
      ripples.show(e, element, value);
    }
  }
  function rippleStop(e) {
    e[stopSymbol] = true;
  }
  function rippleHide(e) {
    const element = e.currentTarget;
    if (!(element == null ? void 0 : element._ripple))
      return;
    window.clearTimeout(element._ripple.showTimer);
    if (e.type === "touchend" && element._ripple.showTimerCommit) {
      element._ripple.showTimerCommit();
      element._ripple.showTimerCommit = null;
      element._ripple.showTimer = window.setTimeout(() => {
        rippleHide(e);
      });
      return;
    }
    window.setTimeout(() => {
      if (element._ripple) {
        element._ripple.touched = false;
      }
    });
    ripples.hide(element);
  }
  function rippleCancelShow(e) {
    const element = e.currentTarget;
    if (!(element == null ? void 0 : element._ripple))
      return;
    if (element._ripple.showTimerCommit) {
      element._ripple.showTimerCommit = null;
    }
    window.clearTimeout(element._ripple.showTimer);
  }
  var keyboardRipple = false;
  function keyboardRippleShow(e) {
    if (!keyboardRipple && (e.keyCode === keyCodes.enter || e.keyCode === keyCodes.space)) {
      keyboardRipple = true;
      rippleShow(e);
    }
  }
  function keyboardRippleHide(e) {
    keyboardRipple = false;
    rippleHide(e);
  }
  function focusRippleHide(e) {
    if (keyboardRipple) {
      keyboardRipple = false;
      rippleHide(e);
    }
  }
  function updateRipple(el, binding, wasEnabled) {
    var _a2;
    const {
      value,
      modifiers
    } = binding;
    const enabled = isRippleEnabled(value);
    if (!enabled) {
      ripples.hide(el);
    }
    el._ripple = (_a2 = el._ripple) != null ? _a2 : {};
    el._ripple.enabled = enabled;
    el._ripple.centered = modifiers.center;
    el._ripple.circle = modifiers.circle;
    if (isObject2(value) && value.class) {
      el._ripple.class = value.class;
    }
    if (enabled && !wasEnabled) {
      if (modifiers.stop) {
        el.addEventListener("touchstart", rippleStop, {
          passive: true
        });
        el.addEventListener("mousedown", rippleStop);
        return;
      }
      el.addEventListener("touchstart", rippleShow, {
        passive: true
      });
      el.addEventListener("touchend", rippleHide, {
        passive: true
      });
      el.addEventListener("touchmove", rippleCancelShow, {
        passive: true
      });
      el.addEventListener("touchcancel", rippleHide);
      el.addEventListener("mousedown", rippleShow);
      el.addEventListener("mouseup", rippleHide);
      el.addEventListener("mouseleave", rippleHide);
      el.addEventListener("keydown", keyboardRippleShow);
      el.addEventListener("keyup", keyboardRippleHide);
      el.addEventListener("blur", focusRippleHide);
      el.addEventListener("dragstart", rippleHide, {
        passive: true
      });
    } else if (!enabled && wasEnabled) {
      removeListeners(el);
    }
  }
  function removeListeners(el) {
    el.removeEventListener("mousedown", rippleShow);
    el.removeEventListener("touchstart", rippleShow);
    el.removeEventListener("touchend", rippleHide);
    el.removeEventListener("touchmove", rippleCancelShow);
    el.removeEventListener("touchcancel", rippleHide);
    el.removeEventListener("mouseup", rippleHide);
    el.removeEventListener("mouseleave", rippleHide);
    el.removeEventListener("keydown", keyboardRippleShow);
    el.removeEventListener("keyup", keyboardRippleHide);
    el.removeEventListener("dragstart", rippleHide);
    el.removeEventListener("blur", focusRippleHide);
  }
  function mounted2(el, binding) {
    updateRipple(el, binding, false);
  }
  function unmounted2(el) {
    delete el._ripple;
    removeListeners(el);
  }
  function updated(el, binding) {
    if (binding.value === binding.oldValue) {
      return;
    }
    const wasEnabled = isRippleEnabled(binding.oldValue);
    updateRipple(el, binding, wasEnabled);
  }
  var Ripple = {
    mounted: mounted2,
    unmounted: unmounted2,
    updated
  };
  var ripple_default = Ripple;

  // ../library_management/node_modules/vuetify/lib/components/VBtn/VBtn.mjs
  var makeVBtnProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    active: {
      type: Boolean,
      default: void 0
    },
    symbol: {
      type: null,
      default: VBtnToggleSymbol
    },
    flat: Boolean,
    icon: [Boolean, String, Function, Object],
    prependIcon: IconValue,
    appendIcon: IconValue,
    block: Boolean,
    slim: Boolean,
    stacked: Boolean,
    ripple: {
      type: [Boolean, Object],
      default: true
    },
    text: String
  }, makeBorderProps()), makeComponentProps()), makeDensityProps()), makeDimensionProps()), makeElevationProps()), makeGroupItemProps()), makeLoaderProps()), makeLocationProps()), makePositionProps()), makeRoundedProps()), makeRouterProps()), makeSizeProps()), makeTagProps({
    tag: "button"
  })), makeThemeProps()), makeVariantProps({
    variant: "elevated"
  })), "VBtn");
  var VBtn = genericComponent()({
    name: "VBtn",
    directives: {
      Ripple
    },
    props: makeVBtnProps(),
    emits: {
      "group:selected": (val) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      const {
        borderClasses
      } = useBorder(props);
      const {
        colorClasses,
        colorStyles,
        variantClasses
      } = useVariant(props);
      const {
        densityClasses
      } = useDensity(props);
      const {
        dimensionStyles
      } = useDimension(props);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        loaderClasses
      } = useLoader(props);
      const {
        locationStyles
      } = useLocation(props);
      const {
        positionClasses
      } = usePosition(props);
      const {
        roundedClasses
      } = useRounded(props);
      const {
        sizeClasses,
        sizeStyles
      } = useSize(props);
      const group = useGroupItem(props, props.symbol, false);
      const link = useLink(props, attrs);
      const isActive = computed2(() => {
        var _a2;
        if (props.active !== void 0) {
          return props.active;
        }
        if (link.isLink.value) {
          return (_a2 = link.isActive) == null ? void 0 : _a2.value;
        }
        return group == null ? void 0 : group.isSelected.value;
      });
      const isDisabled = computed2(() => (group == null ? void 0 : group.disabled.value) || props.disabled);
      const isElevated = computed2(() => {
        return props.variant === "elevated" && !(props.disabled || props.flat || props.border);
      });
      const valueAttr = computed2(() => {
        if (props.value === void 0 || typeof props.value === "symbol")
          return void 0;
        return Object(props.value) === props.value ? JSON.stringify(props.value, null, 0) : props.value;
      });
      function onClick(e) {
        var _a2;
        if (isDisabled.value || link.isLink.value && (e.metaKey || e.ctrlKey || e.shiftKey || e.button !== 0 || attrs.target === "_blank"))
          return;
        (_a2 = link.navigate) == null ? void 0 : _a2.call(link, e);
        group == null ? void 0 : group.toggle();
      }
      useSelectLink(link, group == null ? void 0 : group.select);
      useRender(() => {
        var _a2, _b;
        const Tag = link.isLink.value ? "a" : props.tag;
        const hasPrepend = !!(props.prependIcon || slots.prepend);
        const hasAppend = !!(props.appendIcon || slots.append);
        const hasIcon = !!(props.icon && props.icon !== true);
        const hasColor = (group == null ? void 0 : group.isSelected.value) && (!link.isLink.value || ((_a2 = link.isActive) == null ? void 0 : _a2.value)) || !group || ((_b = link.isActive) == null ? void 0 : _b.value);
        return withDirectives(createVNode(Tag, {
          "type": Tag === "a" ? void 0 : "button",
          "class": ["v-btn", group == null ? void 0 : group.selectedClass.value, {
            "v-btn--active": isActive.value,
            "v-btn--block": props.block,
            "v-btn--disabled": isDisabled.value,
            "v-btn--elevated": isElevated.value,
            "v-btn--flat": props.flat,
            "v-btn--icon": !!props.icon,
            "v-btn--loading": props.loading,
            "v-btn--slim": props.slim,
            "v-btn--stacked": props.stacked
          }, themeClasses.value, borderClasses.value, hasColor ? colorClasses.value : void 0, densityClasses.value, elevationClasses.value, loaderClasses.value, positionClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value, props.class],
          "style": [hasColor ? colorStyles.value : void 0, dimensionStyles.value, locationStyles.value, sizeStyles.value, props.style],
          "aria-busy": props.loading ? true : void 0,
          "disabled": isDisabled.value || void 0,
          "href": link.href.value,
          "tabindex": props.loading ? -1 : void 0,
          "onClick": onClick,
          "value": valueAttr.value
        }, {
          default: () => {
            var _a3, _b2;
            return [genOverlays(true, "v-btn"), !props.icon && hasPrepend && createVNode("span", {
              "key": "prepend",
              "class": "v-btn__prepend"
            }, [!slots.prepend ? createVNode(VIcon, {
              "key": "prepend-icon",
              "icon": props.prependIcon
            }, null) : createVNode(VDefaultsProvider, {
              "key": "prepend-defaults",
              "disabled": !props.prependIcon,
              "defaults": {
                VIcon: {
                  icon: props.prependIcon
                }
              }
            }, slots.prepend)]), createVNode("span", {
              "class": "v-btn__content",
              "data-no-activator": ""
            }, [!slots.default && hasIcon ? createVNode(VIcon, {
              "key": "content-icon",
              "icon": props.icon
            }, null) : createVNode(VDefaultsProvider, {
              "key": "content-defaults",
              "disabled": !hasIcon,
              "defaults": {
                VIcon: {
                  icon: props.icon
                }
              }
            }, {
              default: () => {
                var _a4, _b3;
                return [(_b3 = (_a4 = slots.default) == null ? void 0 : _a4.call(slots)) != null ? _b3 : props.text];
              }
            })]), !props.icon && hasAppend && createVNode("span", {
              "key": "append",
              "class": "v-btn__append"
            }, [!slots.append ? createVNode(VIcon, {
              "key": "append-icon",
              "icon": props.appendIcon
            }, null) : createVNode(VDefaultsProvider, {
              "key": "append-defaults",
              "disabled": !props.appendIcon,
              "defaults": {
                VIcon: {
                  icon: props.appendIcon
                }
              }
            }, slots.append)]), !!props.loading && createVNode("span", {
              "key": "loader",
              "class": "v-btn__loader"
            }, [(_b2 = (_a3 = slots.loader) == null ? void 0 : _a3.call(slots)) != null ? _b2 : createVNode(VProgressCircular, {
              "color": typeof props.loading === "boolean" ? void 0 : props.loading,
              "indeterminate": true,
              "size": "23",
              "width": "2"
            }, null)])];
          }
        }), [[resolveDirective("ripple"), !isDisabled.value && props.ripple, null]]);
      });
      return {
        group
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VAppBar/VAppBarNavIcon.mjs
  var makeVAppBarNavIconProps = propsFactory(__spreadValues({}, makeVBtnProps({
    icon: "$menu",
    variant: "text"
  })), "VAppBarNavIcon");
  var VAppBarNavIcon = genericComponent()({
    name: "VAppBarNavIcon",
    props: makeVAppBarNavIconProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useRender(() => createVNode(VBtn, mergeProps(props, {
        "class": ["v-app-bar-nav-icon"]
      }), slots));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VAppBar/VAppBarTitle.mjs
  var VAppBarTitle = genericComponent()({
    name: "VAppBarTitle",
    props: makeVToolbarTitleProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useRender(() => createVNode(VToolbarTitle, mergeProps(props, {
        "class": "v-app-bar-title"
      }), slots));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VAlert/VAlertTitle.mjs
  var VAlertTitle = createSimpleFunctional("v-alert-title");

  // ../library_management/node_modules/vuetify/lib/components/VAlert/VAlert.mjs
  var allowedTypes = ["success", "info", "warning", "error"];
  var makeVAlertProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    border: {
      type: [Boolean, String],
      validator: (val) => {
        return typeof val === "boolean" || ["top", "end", "bottom", "start"].includes(val);
      }
    },
    borderColor: String,
    closable: Boolean,
    closeIcon: {
      type: IconValue,
      default: "$close"
    },
    closeLabel: {
      type: String,
      default: "$vuetify.close"
    },
    icon: {
      type: [Boolean, String, Function, Object],
      default: null
    },
    modelValue: {
      type: Boolean,
      default: true
    },
    prominent: Boolean,
    title: String,
    text: String,
    type: {
      type: String,
      validator: (val) => allowedTypes.includes(val)
    }
  }, makeComponentProps()), makeDensityProps()), makeDimensionProps()), makeElevationProps()), makeLocationProps()), makePositionProps()), makeRoundedProps()), makeTagProps()), makeThemeProps()), makeVariantProps({
    variant: "flat"
  })), "VAlert");
  var VAlert = genericComponent()({
    name: "VAlert",
    props: makeVAlertProps(),
    emits: {
      "click:close": (e) => true,
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        emit: emit2,
        slots
      } = _ref;
      const isActive = useProxiedModel(props, "modelValue");
      const icon = computed2(() => {
        var _a2;
        if (props.icon === false)
          return void 0;
        if (!props.type)
          return props.icon;
        return (_a2 = props.icon) != null ? _a2 : `$${props.type}`;
      });
      const variantProps = computed2(() => {
        var _a2;
        return {
          color: (_a2 = props.color) != null ? _a2 : props.type,
          variant: props.variant
        };
      });
      const {
        themeClasses
      } = provideTheme(props);
      const {
        colorClasses,
        colorStyles,
        variantClasses
      } = useVariant(variantProps);
      const {
        densityClasses
      } = useDensity(props);
      const {
        dimensionStyles
      } = useDimension(props);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        locationStyles
      } = useLocation(props);
      const {
        positionClasses
      } = usePosition(props);
      const {
        roundedClasses
      } = useRounded(props);
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(toRef(props, "borderColor"));
      const {
        t
      } = useLocale();
      const closeProps = computed2(() => ({
        "aria-label": t(props.closeLabel),
        onClick(e) {
          isActive.value = false;
          emit2("click:close", e);
        }
      }));
      return () => {
        const hasPrepend = !!(slots.prepend || icon.value);
        const hasTitle = !!(slots.title || props.title);
        const hasClose = !!(slots.close || props.closable);
        return isActive.value && createVNode(props.tag, {
          "class": ["v-alert", props.border && {
            "v-alert--border": !!props.border,
            [`v-alert--border-${props.border === true ? "start" : props.border}`]: true
          }, {
            "v-alert--prominent": props.prominent
          }, themeClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, variantClasses.value, props.class],
          "style": [colorStyles.value, dimensionStyles.value, locationStyles.value, props.style],
          "role": "alert"
        }, {
          default: () => {
            var _a2, _b, _c;
            return [genOverlays(false, "v-alert"), props.border && createVNode("div", {
              "key": "border",
              "class": ["v-alert__border", textColorClasses.value],
              "style": textColorStyles.value
            }, null), hasPrepend && createVNode("div", {
              "key": "prepend",
              "class": "v-alert__prepend"
            }, [!slots.prepend ? createVNode(VIcon, {
              "key": "prepend-icon",
              "density": props.density,
              "icon": icon.value,
              "size": props.prominent ? 44 : 28
            }, null) : createVNode(VDefaultsProvider, {
              "key": "prepend-defaults",
              "disabled": !icon.value,
              "defaults": {
                VIcon: {
                  density: props.density,
                  icon: icon.value,
                  size: props.prominent ? 44 : 28
                }
              }
            }, slots.prepend)]), createVNode("div", {
              "class": "v-alert__content"
            }, [hasTitle && createVNode(VAlertTitle, {
              "key": "title"
            }, {
              default: () => {
                var _a3, _b2;
                return [(_b2 = (_a3 = slots.title) == null ? void 0 : _a3.call(slots)) != null ? _b2 : props.title];
              }
            }), (_b = (_a2 = slots.text) == null ? void 0 : _a2.call(slots)) != null ? _b : props.text, (_c = slots.default) == null ? void 0 : _c.call(slots)]), slots.append && createVNode("div", {
              "key": "append",
              "class": "v-alert__append"
            }, [slots.append()]), hasClose && createVNode("div", {
              "key": "close",
              "class": "v-alert__close"
            }, [!slots.close ? createVNode(VBtn, mergeProps({
              "key": "close-btn",
              "icon": props.closeIcon,
              "size": "x-small",
              "variant": "text"
            }, closeProps.value), null) : createVNode(VDefaultsProvider, {
              "key": "close-defaults",
              "defaults": {
                VBtn: {
                  icon: props.closeIcon,
                  size: "x-small",
                  variant: "text"
                }
              }
            }, {
              default: () => {
                var _a3;
                return [(_a3 = slots.close) == null ? void 0 : _a3.call(slots, {
                  props: closeProps.value
                })];
              }
            })])];
          }
        });
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VAvatar/VAvatar.mjs
  var makeVAvatarProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    start: Boolean,
    end: Boolean,
    icon: IconValue,
    image: String,
    text: String
  }, makeComponentProps()), makeDensityProps()), makeRoundedProps()), makeSizeProps()), makeTagProps()), makeThemeProps()), makeVariantProps({
    variant: "flat"
  })), "VAvatar");
  var VAvatar = genericComponent()({
    name: "VAvatar",
    props: makeVAvatarProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      const {
        colorClasses,
        colorStyles,
        variantClasses
      } = useVariant(props);
      const {
        densityClasses
      } = useDensity(props);
      const {
        roundedClasses
      } = useRounded(props);
      const {
        sizeClasses,
        sizeStyles
      } = useSize(props);
      useRender(() => createVNode(props.tag, {
        "class": ["v-avatar", {
          "v-avatar--start": props.start,
          "v-avatar--end": props.end
        }, themeClasses.value, colorClasses.value, densityClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value, props.class],
        "style": [colorStyles.value, sizeStyles.value, props.style]
      }, {
        default: () => [!slots.default ? props.image ? createVNode(VImg, {
          "key": "image",
          "src": props.image,
          "alt": "",
          "cover": true
        }, null) : props.icon ? createVNode(VIcon, {
          "key": "icon",
          "icon": props.icon
        }, null) : props.text : createVNode(VDefaultsProvider, {
          "key": "content-defaults",
          "defaults": {
            VImg: {
              cover: true,
              image: props.image
            },
            VIcon: {
              icon: props.icon
            }
          }
        }, {
          default: () => [slots.default()]
        }), genOverlays(false, "v-avatar")]
      }));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VLabel/VLabel.mjs
  var makeVLabelProps = propsFactory(__spreadValues(__spreadValues({
    text: String,
    onClick: EventProp()
  }, makeComponentProps()), makeThemeProps()), "VLabel");
  var VLabel = genericComponent()({
    name: "VLabel",
    props: makeVLabelProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useRender(() => {
        var _a2;
        return createVNode("label", {
          "class": ["v-label", {
            "v-label--clickable": !!props.onClick
          }, props.class],
          "style": props.style,
          "onClick": props.onClick
        }, [props.text, (_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VSelectionControlGroup/VSelectionControlGroup.mjs
  var VSelectionControlGroupSymbol = Symbol.for("vuetify:selection-control-group");
  var makeSelectionControlGroupProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({
    color: String,
    disabled: {
      type: Boolean,
      default: null
    },
    defaultsTarget: String,
    error: Boolean,
    id: String,
    inline: Boolean,
    falseIcon: IconValue,
    trueIcon: IconValue,
    ripple: {
      type: [Boolean, Object],
      default: true
    },
    multiple: {
      type: Boolean,
      default: null
    },
    name: String,
    readonly: {
      type: Boolean,
      default: null
    },
    modelValue: null,
    type: String,
    valueComparator: {
      type: Function,
      default: deepEqual
    }
  }, makeComponentProps()), makeDensityProps()), makeThemeProps()), "SelectionControlGroup");
  var makeVSelectionControlGroupProps = propsFactory(__spreadValues({}, makeSelectionControlGroupProps({
    defaultsTarget: "VSelectionControl"
  })), "VSelectionControlGroup");
  var VSelectionControlGroup = genericComponent()({
    name: "VSelectionControlGroup",
    props: makeVSelectionControlGroupProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const modelValue = useProxiedModel(props, "modelValue");
      const uid2 = getUid();
      const id = computed2(() => props.id || `v-selection-control-group-${uid2}`);
      const name = computed2(() => props.name || id.value);
      const updateHandlers = /* @__PURE__ */ new Set();
      provide(VSelectionControlGroupSymbol, {
        modelValue,
        forceUpdate: () => {
          updateHandlers.forEach((fn) => fn());
        },
        onForceUpdate: (cb) => {
          updateHandlers.add(cb);
          onScopeDispose(() => {
            updateHandlers.delete(cb);
          });
        }
      });
      provideDefaults({
        [props.defaultsTarget]: {
          color: toRef(props, "color"),
          disabled: toRef(props, "disabled"),
          density: toRef(props, "density"),
          error: toRef(props, "error"),
          inline: toRef(props, "inline"),
          modelValue,
          multiple: computed2(() => !!props.multiple || props.multiple == null && Array.isArray(modelValue.value)),
          name,
          falseIcon: toRef(props, "falseIcon"),
          trueIcon: toRef(props, "trueIcon"),
          readonly: toRef(props, "readonly"),
          ripple: toRef(props, "ripple"),
          type: toRef(props, "type"),
          valueComparator: toRef(props, "valueComparator")
        }
      });
      useRender(() => {
        var _a2;
        return createVNode("div", {
          "class": ["v-selection-control-group", {
            "v-selection-control-group--inline": props.inline
          }, props.class],
          "style": props.style,
          "role": props.type === "radio" ? "radiogroup" : void 0
        }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VSelectionControl/VSelectionControl.mjs
  var makeVSelectionControlProps = propsFactory(__spreadValues(__spreadValues({
    label: String,
    baseColor: String,
    trueValue: null,
    falseValue: null,
    value: null
  }, makeComponentProps()), makeSelectionControlGroupProps()), "VSelectionControl");
  function useSelectionControl(props) {
    const group = inject(VSelectionControlGroupSymbol, void 0);
    const {
      densityClasses
    } = useDensity(props);
    const modelValue = useProxiedModel(props, "modelValue");
    const trueValue = computed2(() => props.trueValue !== void 0 ? props.trueValue : props.value !== void 0 ? props.value : true);
    const falseValue = computed2(() => props.falseValue !== void 0 ? props.falseValue : false);
    const isMultiple = computed2(() => !!props.multiple || props.multiple == null && Array.isArray(modelValue.value));
    const model = computed2({
      get() {
        const val = group ? group.modelValue.value : modelValue.value;
        return isMultiple.value ? wrapInArray(val).some((v) => props.valueComparator(v, trueValue.value)) : props.valueComparator(val, trueValue.value);
      },
      set(val) {
        if (props.readonly)
          return;
        const currentValue = val ? trueValue.value : falseValue.value;
        let newVal = currentValue;
        if (isMultiple.value) {
          newVal = val ? [...wrapInArray(modelValue.value), currentValue] : wrapInArray(modelValue.value).filter((item) => !props.valueComparator(item, trueValue.value));
        }
        if (group) {
          group.modelValue.value = newVal;
        } else {
          modelValue.value = newVal;
        }
      }
    });
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(computed2(() => {
      if (props.error || props.disabled)
        return void 0;
      return model.value ? props.color : props.baseColor;
    }));
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(computed2(() => {
      return model.value && !props.error && !props.disabled ? props.color : void 0;
    }));
    const icon = computed2(() => model.value ? props.trueIcon : props.falseIcon);
    return {
      group,
      densityClasses,
      trueValue,
      falseValue,
      model,
      textColorClasses,
      textColorStyles,
      backgroundColorClasses,
      backgroundColorStyles,
      icon
    };
  }
  var VSelectionControl = genericComponent()({
    name: "VSelectionControl",
    directives: {
      Ripple
    },
    inheritAttrs: false,
    props: makeVSelectionControlProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const {
        group,
        densityClasses,
        icon,
        model,
        textColorClasses,
        textColorStyles,
        backgroundColorClasses,
        backgroundColorStyles,
        trueValue
      } = useSelectionControl(props);
      const uid2 = getUid();
      const isFocused = shallowRef(false);
      const isFocusVisible = shallowRef(false);
      const input = ref();
      const id = computed2(() => props.id || `input-${uid2}`);
      const isInteractive = computed2(() => !props.disabled && !props.readonly);
      group == null ? void 0 : group.onForceUpdate(() => {
        if (input.value) {
          input.value.checked = model.value;
        }
      });
      function onFocus(e) {
        if (!isInteractive.value)
          return;
        isFocused.value = true;
        if (matchesSelector(e.target, ":focus-visible") !== false) {
          isFocusVisible.value = true;
        }
      }
      function onBlur() {
        isFocused.value = false;
        isFocusVisible.value = false;
      }
      function onClickLabel(e) {
        e.stopPropagation();
      }
      function onInput(e) {
        if (!isInteractive.value)
          return;
        if (props.readonly && group) {
          nextTick(() => group.forceUpdate());
        }
        model.value = e.target.checked;
      }
      useRender(() => {
        var _a2, _b, _c;
        const label = slots.label ? slots.label({
          label: props.label,
          props: {
            for: id.value
          }
        }) : props.label;
        const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
        const inputNode = createVNode("input", mergeProps({
          "ref": input,
          "checked": model.value,
          "disabled": !!props.disabled,
          "id": id.value,
          "onBlur": onBlur,
          "onFocus": onFocus,
          "onInput": onInput,
          "aria-disabled": !!props.disabled,
          "aria-label": props.label,
          "type": props.type,
          "value": trueValue.value,
          "name": props.name,
          "aria-checked": props.type === "checkbox" ? model.value : void 0
        }, inputAttrs), null);
        return createVNode("div", mergeProps({
          "class": ["v-selection-control", {
            "v-selection-control--dirty": model.value,
            "v-selection-control--disabled": props.disabled,
            "v-selection-control--error": props.error,
            "v-selection-control--focused": isFocused.value,
            "v-selection-control--focus-visible": isFocusVisible.value,
            "v-selection-control--inline": props.inline
          }, densityClasses.value, props.class]
        }, rootAttrs, {
          "style": props.style
        }), [createVNode("div", {
          "class": ["v-selection-control__wrapper", textColorClasses.value],
          "style": textColorStyles.value
        }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
          backgroundColorClasses,
          backgroundColorStyles
        }), withDirectives(createVNode("div", {
          "class": ["v-selection-control__input"]
        }, [(_c = (_b = slots.input) == null ? void 0 : _b.call(slots, {
          model,
          textColorClasses,
          textColorStyles,
          backgroundColorClasses,
          backgroundColorStyles,
          inputNode,
          icon: icon.value,
          props: {
            onFocus,
            onBlur,
            id: id.value
          }
        })) != null ? _c : createVNode(Fragment, null, [icon.value && createVNode(VIcon, {
          "key": "icon",
          "icon": icon.value
        }, null), inputNode])]), [[resolveDirective("ripple"), props.ripple && [!props.disabled && !props.readonly, null, ["center", "circle"]]]])]), label && createVNode(VLabel, {
          "for": id.value,
          "onClick": onClickLabel
        }, {
          default: () => [label]
        })]);
      });
      return {
        isFocused,
        input
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VCheckbox/VCheckboxBtn.mjs
  var makeVCheckboxBtnProps = propsFactory(__spreadValues({
    indeterminate: Boolean,
    indeterminateIcon: {
      type: IconValue,
      default: "$checkboxIndeterminate"
    }
  }, makeVSelectionControlProps({
    falseIcon: "$checkboxOff",
    trueIcon: "$checkboxOn"
  })), "VCheckboxBtn");
  var VCheckboxBtn = genericComponent()({
    name: "VCheckboxBtn",
    props: makeVCheckboxBtnProps(),
    emits: {
      "update:modelValue": (value) => true,
      "update:indeterminate": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const indeterminate = useProxiedModel(props, "indeterminate");
      const model = useProxiedModel(props, "modelValue");
      function onChange(v) {
        if (indeterminate.value) {
          indeterminate.value = false;
        }
      }
      const falseIcon = computed2(() => {
        return indeterminate.value ? props.indeterminateIcon : props.falseIcon;
      });
      const trueIcon = computed2(() => {
        return indeterminate.value ? props.indeterminateIcon : props.trueIcon;
      });
      useRender(() => {
        const controlProps = omit(VSelectionControl.filterProps(props), ["modelValue"]);
        return createVNode(VSelectionControl, mergeProps(controlProps, {
          "modelValue": model.value,
          "onUpdate:modelValue": [($event) => model.value = $event, onChange],
          "class": ["v-checkbox-btn", props.class],
          "style": props.style,
          "type": "checkbox",
          "falseIcon": falseIcon.value,
          "trueIcon": trueIcon.value,
          "aria-checked": indeterminate.value ? "mixed" : void 0
        }), slots);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VInput/InputIcon.mjs
  function useInputIcon(props) {
    const {
      t
    } = useLocale();
    function InputIcon(_ref) {
      var _a2;
      let {
        name
      } = _ref;
      const localeKey = {
        prepend: "prependAction",
        prependInner: "prependAction",
        append: "appendAction",
        appendInner: "appendAction",
        clear: "clear"
      }[name];
      const listener = props[`onClick:${name}`];
      const label = listener && localeKey ? t(`$vuetify.input.${localeKey}`, (_a2 = props.label) != null ? _a2 : "") : void 0;
      return createVNode(VIcon, {
        "icon": props[`${name}Icon`],
        "aria-label": label,
        "onClick": listener
      }, null);
    }
    return {
      InputIcon
    };
  }

  // ../library_management/node_modules/vuetify/lib/components/VMessages/VMessages.mjs
  var makeVMessagesProps = propsFactory(__spreadValues(__spreadValues({
    active: Boolean,
    color: String,
    messages: {
      type: [Array, String],
      default: () => []
    }
  }, makeComponentProps()), makeTransitionProps2({
    transition: {
      component: VSlideYTransition,
      leaveAbsolute: true,
      group: true
    }
  })), "VMessages");
  var VMessages = genericComponent()({
    name: "VMessages",
    props: makeVMessagesProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const messages = computed2(() => wrapInArray(props.messages));
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(computed2(() => props.color));
      useRender(() => createVNode(MaybeTransition, {
        "transition": props.transition,
        "tag": "div",
        "class": ["v-messages", textColorClasses.value, props.class],
        "style": [textColorStyles.value, props.style],
        "role": "alert",
        "aria-live": "polite"
      }, {
        default: () => [props.active && messages.value.map((message, i) => createVNode("div", {
          "class": "v-messages__message",
          "key": `${i}-${messages.value}`
        }, [slots.message ? slots.message({
          message
        }) : message]))]
      }));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/composables/focus.mjs
  var makeFocusProps = propsFactory({
    focused: Boolean,
    "onUpdate:focused": EventProp()
  }, "focus");
  function useFocus(props) {
    let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    const isFocused = useProxiedModel(props, "focused");
    const focusClasses = computed2(() => {
      return {
        [`${name}--focused`]: isFocused.value
      };
    });
    function focus() {
      isFocused.value = true;
    }
    function blur() {
      isFocused.value = false;
    }
    return {
      focusClasses,
      isFocused,
      focus,
      blur
    };
  }

  // ../library_management/node_modules/vuetify/lib/composables/form.mjs
  var FormKey = Symbol.for("vuetify:form");
  var makeFormProps = propsFactory({
    disabled: Boolean,
    fastFail: Boolean,
    readonly: Boolean,
    modelValue: {
      type: Boolean,
      default: null
    },
    validateOn: {
      type: String,
      default: "input"
    }
  }, "form");
  function createForm(props) {
    const model = useProxiedModel(props, "modelValue");
    const isDisabled = computed2(() => props.disabled);
    const isReadonly2 = computed2(() => props.readonly);
    const isValidating = shallowRef(false);
    const items = ref([]);
    const errors = ref([]);
    async function validate() {
      const results = [];
      let valid = true;
      errors.value = [];
      isValidating.value = true;
      for (const item of items.value) {
        const itemErrorMessages = await item.validate();
        if (itemErrorMessages.length > 0) {
          valid = false;
          results.push({
            id: item.id,
            errorMessages: itemErrorMessages
          });
        }
        if (!valid && props.fastFail)
          break;
      }
      errors.value = results;
      isValidating.value = false;
      return {
        valid,
        errors: errors.value
      };
    }
    function reset() {
      items.value.forEach((item) => item.reset());
    }
    function resetValidation() {
      items.value.forEach((item) => item.resetValidation());
    }
    watch(items, () => {
      let valid = 0;
      let invalid = 0;
      const results = [];
      for (const item of items.value) {
        if (item.isValid === false) {
          invalid++;
          results.push({
            id: item.id,
            errorMessages: item.errorMessages
          });
        } else if (item.isValid === true)
          valid++;
      }
      errors.value = results;
      model.value = invalid > 0 ? false : valid === items.value.length ? true : null;
    }, {
      deep: true,
      flush: "post"
    });
    provide(FormKey, {
      register: (_ref) => {
        let {
          id,
          validate: validate2,
          reset: reset2,
          resetValidation: resetValidation2
        } = _ref;
        if (items.value.some((item) => item.id === id)) {
          consoleWarn(`Duplicate input name "${id}"`);
        }
        items.value.push({
          id,
          validate: validate2,
          reset: reset2,
          resetValidation: resetValidation2,
          isValid: null,
          errorMessages: []
        });
      },
      unregister: (id) => {
        items.value = items.value.filter((item) => {
          return item.id !== id;
        });
      },
      update: (id, isValid2, errorMessages) => {
        const found = items.value.find((item) => item.id === id);
        if (!found)
          return;
        found.isValid = isValid2;
        found.errorMessages = errorMessages;
      },
      isDisabled,
      isReadonly: isReadonly2,
      isValidating,
      isValid: model,
      items,
      validateOn: toRef(props, "validateOn")
    });
    return {
      errors,
      isDisabled,
      isReadonly: isReadonly2,
      isValidating,
      isValid: model,
      items,
      validate,
      reset,
      resetValidation
    };
  }
  function useForm() {
    return inject(FormKey, null);
  }

  // ../library_management/node_modules/vuetify/lib/composables/validation.mjs
  var makeValidationProps = propsFactory(__spreadValues({
    disabled: {
      type: Boolean,
      default: null
    },
    error: Boolean,
    errorMessages: {
      type: [Array, String],
      default: () => []
    },
    maxErrors: {
      type: [Number, String],
      default: 1
    },
    name: String,
    label: String,
    readonly: {
      type: Boolean,
      default: null
    },
    rules: {
      type: Array,
      default: () => []
    },
    modelValue: null,
    validateOn: String,
    validationValue: null
  }, makeFocusProps()), "validation");
  function useValidation(props) {
    let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    let id = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : getUid();
    const model = useProxiedModel(props, "modelValue");
    const validationModel = computed2(() => props.validationValue === void 0 ? model.value : props.validationValue);
    const form = useForm();
    const internalErrorMessages = ref([]);
    const isPristine = shallowRef(true);
    const isDirty = computed2(() => !!(wrapInArray(model.value === "" ? null : model.value).length || wrapInArray(validationModel.value === "" ? null : validationModel.value).length));
    const isDisabled = computed2(() => {
      var _a2;
      return !!((_a2 = props.disabled) != null ? _a2 : form == null ? void 0 : form.isDisabled.value);
    });
    const isReadonly2 = computed2(() => {
      var _a2;
      return !!((_a2 = props.readonly) != null ? _a2 : form == null ? void 0 : form.isReadonly.value);
    });
    const errorMessages = computed2(() => {
      var _a2;
      return ((_a2 = props.errorMessages) == null ? void 0 : _a2.length) ? wrapInArray(props.errorMessages).concat(internalErrorMessages.value).slice(0, Math.max(0, +props.maxErrors)) : internalErrorMessages.value;
    });
    const validateOn = computed2(() => {
      var _a2, _b;
      let value = ((_a2 = props.validateOn) != null ? _a2 : form == null ? void 0 : form.validateOn.value) || "input";
      if (value === "lazy")
        value = "input lazy";
      const set3 = new Set((_b = value == null ? void 0 : value.split(" ")) != null ? _b : []);
      return {
        blur: set3.has("blur") || set3.has("input"),
        input: set3.has("input"),
        submit: set3.has("submit"),
        lazy: set3.has("lazy")
      };
    });
    const isValid2 = computed2(() => {
      var _a2;
      if (props.error || ((_a2 = props.errorMessages) == null ? void 0 : _a2.length))
        return false;
      if (!props.rules.length)
        return true;
      if (isPristine.value) {
        return internalErrorMessages.value.length || validateOn.value.lazy ? null : true;
      } else {
        return !internalErrorMessages.value.length;
      }
    });
    const isValidating = shallowRef(false);
    const validationClasses = computed2(() => {
      return {
        [`${name}--error`]: isValid2.value === false,
        [`${name}--dirty`]: isDirty.value,
        [`${name}--disabled`]: isDisabled.value,
        [`${name}--readonly`]: isReadonly2.value
      };
    });
    const uid2 = computed2(() => {
      var _a2;
      return (_a2 = props.name) != null ? _a2 : unref(id);
    });
    onBeforeMount(() => {
      form == null ? void 0 : form.register({
        id: uid2.value,
        validate,
        reset,
        resetValidation
      });
    });
    onBeforeUnmount(() => {
      form == null ? void 0 : form.unregister(uid2.value);
    });
    onMounted(async () => {
      if (!validateOn.value.lazy) {
        await validate(true);
      }
      form == null ? void 0 : form.update(uid2.value, isValid2.value, errorMessages.value);
    });
    useToggleScope(() => validateOn.value.input, () => {
      watch(validationModel, () => {
        if (validationModel.value != null) {
          validate();
        } else if (props.focused) {
          const unwatch = watch(() => props.focused, (val) => {
            if (!val)
              validate();
            unwatch();
          });
        }
      });
    });
    useToggleScope(() => validateOn.value.blur, () => {
      watch(() => props.focused, (val) => {
        if (!val)
          validate();
      });
    });
    watch([isValid2, errorMessages], () => {
      form == null ? void 0 : form.update(uid2.value, isValid2.value, errorMessages.value);
    });
    async function reset() {
      model.value = null;
      await nextTick();
      await resetValidation();
    }
    async function resetValidation() {
      isPristine.value = true;
      if (!validateOn.value.lazy) {
        await validate(true);
      } else {
        internalErrorMessages.value = [];
      }
    }
    async function validate() {
      var _a2;
      let silent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      const results = [];
      isValidating.value = true;
      for (const rule of props.rules) {
        if (results.length >= +((_a2 = props.maxErrors) != null ? _a2 : 1)) {
          break;
        }
        const handler = typeof rule === "function" ? rule : () => rule;
        const result = await handler(validationModel.value);
        if (result === true)
          continue;
        if (result !== false && typeof result !== "string") {
          console.warn(`${result} is not a valid value. Rule functions must return boolean true or a string.`);
          continue;
        }
        results.push(result || "");
      }
      internalErrorMessages.value = results;
      isValidating.value = false;
      isPristine.value = silent;
      return internalErrorMessages.value;
    }
    return {
      errorMessages,
      isDirty,
      isDisabled,
      isReadonly: isReadonly2,
      isPristine,
      isValid: isValid2,
      isValidating,
      reset,
      resetValidation,
      validate,
      validationClasses
    };
  }

  // ../library_management/node_modules/vuetify/lib/components/VInput/VInput.mjs
  var makeVInputProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({
    id: String,
    appendIcon: IconValue,
    centerAffix: {
      type: Boolean,
      default: true
    },
    prependIcon: IconValue,
    hideDetails: [Boolean, String],
    hideSpinButtons: Boolean,
    hint: String,
    persistentHint: Boolean,
    messages: {
      type: [Array, String],
      default: () => []
    },
    direction: {
      type: String,
      default: "horizontal",
      validator: (v) => ["horizontal", "vertical"].includes(v)
    },
    "onClick:prepend": EventProp(),
    "onClick:append": EventProp()
  }, makeComponentProps()), makeDensityProps()), makeValidationProps()), "VInput");
  var VInput = genericComponent()({
    name: "VInput",
    props: __spreadValues({}, makeVInputProps()),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        slots,
        emit: emit2
      } = _ref;
      const {
        densityClasses
      } = useDensity(props);
      const {
        rtlClasses
      } = useRtl();
      const {
        InputIcon
      } = useInputIcon(props);
      const uid2 = getUid();
      const id = computed2(() => props.id || `input-${uid2}`);
      const messagesId = computed2(() => `${id.value}-messages`);
      const {
        errorMessages,
        isDirty,
        isDisabled,
        isReadonly: isReadonly2,
        isPristine,
        isValid: isValid2,
        isValidating,
        reset,
        resetValidation,
        validate,
        validationClasses
      } = useValidation(props, "v-input", id);
      const slotProps = computed2(() => ({
        id,
        messagesId,
        isDirty,
        isDisabled,
        isReadonly: isReadonly2,
        isPristine,
        isValid: isValid2,
        isValidating,
        reset,
        resetValidation,
        validate
      }));
      const messages = computed2(() => {
        var _a2;
        if (((_a2 = props.errorMessages) == null ? void 0 : _a2.length) || !isPristine.value && errorMessages.value.length) {
          return errorMessages.value;
        } else if (props.hint && (props.persistentHint || props.focused)) {
          return props.hint;
        } else {
          return props.messages;
        }
      });
      useRender(() => {
        var _a2, _b, _c, _d;
        const hasPrepend = !!(slots.prepend || props.prependIcon);
        const hasAppend = !!(slots.append || props.appendIcon);
        const hasMessages = messages.value.length > 0;
        const hasDetails = !props.hideDetails || props.hideDetails === "auto" && (hasMessages || !!slots.details);
        return createVNode("div", {
          "class": ["v-input", `v-input--${props.direction}`, {
            "v-input--center-affix": props.centerAffix,
            "v-input--hide-spin-buttons": props.hideSpinButtons
          }, densityClasses.value, rtlClasses.value, validationClasses.value, props.class],
          "style": props.style
        }, [hasPrepend && createVNode("div", {
          "key": "prepend",
          "class": "v-input__prepend"
        }, [(_a2 = slots.prepend) == null ? void 0 : _a2.call(slots, slotProps.value), props.prependIcon && createVNode(InputIcon, {
          "key": "prepend-icon",
          "name": "prepend"
        }, null)]), slots.default && createVNode("div", {
          "class": "v-input__control"
        }, [(_b = slots.default) == null ? void 0 : _b.call(slots, slotProps.value)]), hasAppend && createVNode("div", {
          "key": "append",
          "class": "v-input__append"
        }, [props.appendIcon && createVNode(InputIcon, {
          "key": "append-icon",
          "name": "append"
        }, null), (_c = slots.append) == null ? void 0 : _c.call(slots, slotProps.value)]), hasDetails && createVNode("div", {
          "class": "v-input__details"
        }, [createVNode(VMessages, {
          "id": messagesId.value,
          "active": hasMessages,
          "messages": messages.value
        }, {
          message: slots.message
        }), (_d = slots.details) == null ? void 0 : _d.call(slots, slotProps.value)])]);
      });
      return {
        reset,
        resetValidation,
        validate,
        isValid: isValid2,
        errorMessages
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VCheckbox/VCheckbox.mjs
  var makeVCheckboxProps = propsFactory(__spreadValues(__spreadValues({}, makeVInputProps()), omit(makeVCheckboxBtnProps(), ["inline"])), "VCheckbox");
  var VCheckbox = genericComponent()({
    name: "VCheckbox",
    inheritAttrs: false,
    props: makeVCheckboxProps(),
    emits: {
      "update:modelValue": (value) => true,
      "update:focused": (focused) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const model = useProxiedModel(props, "modelValue");
      const {
        isFocused,
        focus,
        blur
      } = useFocus(props);
      const uid2 = getUid();
      const id = computed2(() => props.id || `checkbox-${uid2}`);
      useRender(() => {
        const [rootAttrs, controlAttrs] = filterInputAttrs(attrs);
        const inputProps = VInput.filterProps(props);
        const checkboxProps = VCheckboxBtn.filterProps(props);
        return createVNode(VInput, mergeProps({
          "class": ["v-checkbox", props.class]
        }, rootAttrs, inputProps, {
          "modelValue": model.value,
          "onUpdate:modelValue": ($event) => model.value = $event,
          "id": id.value,
          "focused": isFocused.value,
          "style": props.style
        }), __spreadProps(__spreadValues({}, slots), {
          default: (_ref2) => {
            let {
              id: id2,
              messagesId,
              isDisabled,
              isReadonly: isReadonly2,
              isValid: isValid2
            } = _ref2;
            return createVNode(VCheckboxBtn, mergeProps(checkboxProps, {
              "id": id2.value,
              "aria-describedby": messagesId.value,
              "disabled": isDisabled.value,
              "readonly": isReadonly2.value
            }, controlAttrs, {
              "error": isValid2.value === false,
              "modelValue": model.value,
              "onUpdate:modelValue": ($event) => model.value = $event,
              "onFocus": focus,
              "onBlur": blur
            }), slots);
          }
        }));
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VSlideGroup/helpers.mjs
  function bias(val) {
    const c = 0.501;
    const x = Math.abs(val);
    return Math.sign(val) * (x / ((1 / c - 2) * (1 - x) + 1));
  }
  function calculateUpdatedOffset(_ref) {
    let {
      selectedElement,
      containerSize,
      contentSize,
      isRtl,
      currentScrollOffset,
      isHorizontal
    } = _ref;
    const clientSize = isHorizontal ? selectedElement.clientWidth : selectedElement.clientHeight;
    const offsetStart = isHorizontal ? selectedElement.offsetLeft : selectedElement.offsetTop;
    const adjustedOffsetStart = isRtl && isHorizontal ? contentSize - offsetStart - clientSize : offsetStart;
    const totalSize = containerSize + currentScrollOffset;
    const itemOffset = clientSize + adjustedOffsetStart;
    const additionalOffset = clientSize * 0.4;
    if (adjustedOffsetStart <= currentScrollOffset) {
      currentScrollOffset = Math.max(adjustedOffsetStart - additionalOffset, 0);
    } else if (totalSize <= itemOffset) {
      currentScrollOffset = Math.min(currentScrollOffset - (totalSize - itemOffset - additionalOffset), contentSize - containerSize);
    }
    return currentScrollOffset;
  }
  function calculateCenteredOffset(_ref2) {
    let {
      selectedElement,
      containerSize,
      contentSize,
      isRtl,
      isHorizontal
    } = _ref2;
    const clientSize = isHorizontal ? selectedElement.clientWidth : selectedElement.clientHeight;
    const offsetStart = isHorizontal ? selectedElement.offsetLeft : selectedElement.offsetTop;
    const offsetCentered = isRtl && isHorizontal ? contentSize - offsetStart - clientSize / 2 - containerSize / 2 : offsetStart + clientSize / 2 - containerSize / 2;
    return Math.min(contentSize - containerSize, Math.max(0, offsetCentered));
  }

  // ../library_management/node_modules/vuetify/lib/components/VSlideGroup/VSlideGroup.mjs
  var VSlideGroupSymbol = Symbol.for("vuetify:v-slide-group");
  var makeVSlideGroupProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    centerActive: Boolean,
    direction: {
      type: String,
      default: "horizontal"
    },
    symbol: {
      type: null,
      default: VSlideGroupSymbol
    },
    nextIcon: {
      type: IconValue,
      default: "$next"
    },
    prevIcon: {
      type: IconValue,
      default: "$prev"
    },
    showArrows: {
      type: [Boolean, String],
      validator: (v) => typeof v === "boolean" || ["always", "desktop", "mobile"].includes(v)
    }
  }, makeComponentProps()), makeDisplayProps()), makeTagProps()), makeGroupProps({
    selectedClass: "v-slide-group-item--active"
  })), "VSlideGroup");
  var VSlideGroup = genericComponent()({
    name: "VSlideGroup",
    props: makeVSlideGroupProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        isRtl
      } = useRtl();
      const {
        displayClasses,
        mobile
      } = useDisplay(props);
      const group = useGroup(props, props.symbol);
      const isOverflowing = shallowRef(false);
      const scrollOffset = shallowRef(0);
      const containerSize = shallowRef(0);
      const contentSize = shallowRef(0);
      const isHorizontal = computed2(() => props.direction === "horizontal");
      const {
        resizeRef: containerRef,
        contentRect: containerRect
      } = useResizeObserver();
      const {
        resizeRef: contentRef,
        contentRect
      } = useResizeObserver();
      const firstSelectedIndex = computed2(() => {
        if (!group.selected.value.length)
          return -1;
        return group.items.value.findIndex((item) => item.id === group.selected.value[0]);
      });
      const lastSelectedIndex = computed2(() => {
        if (!group.selected.value.length)
          return -1;
        return group.items.value.findIndex((item) => item.id === group.selected.value[group.selected.value.length - 1]);
      });
      if (IN_BROWSER) {
        let frame = -1;
        watch(() => [group.selected.value, containerRect.value, contentRect.value, isHorizontal.value], () => {
          cancelAnimationFrame(frame);
          frame = requestAnimationFrame(() => {
            if (containerRect.value && contentRect.value) {
              const sizeProperty = isHorizontal.value ? "width" : "height";
              containerSize.value = containerRect.value[sizeProperty];
              contentSize.value = contentRect.value[sizeProperty];
              isOverflowing.value = containerSize.value + 1 < contentSize.value;
            }
            if (firstSelectedIndex.value >= 0 && contentRef.value) {
              const selectedElement = contentRef.value.children[lastSelectedIndex.value];
              if (firstSelectedIndex.value === 0 || !isOverflowing.value) {
                scrollOffset.value = 0;
              } else if (props.centerActive) {
                scrollOffset.value = calculateCenteredOffset({
                  selectedElement,
                  containerSize: containerSize.value,
                  contentSize: contentSize.value,
                  isRtl: isRtl.value,
                  isHorizontal: isHorizontal.value
                });
              } else if (isOverflowing.value) {
                scrollOffset.value = calculateUpdatedOffset({
                  selectedElement,
                  containerSize: containerSize.value,
                  contentSize: contentSize.value,
                  isRtl: isRtl.value,
                  currentScrollOffset: scrollOffset.value,
                  isHorizontal: isHorizontal.value
                });
              }
            }
          });
        });
      }
      const disableTransition = shallowRef(false);
      let startTouch = 0;
      let startOffset = 0;
      function onTouchstart(e) {
        const sizeProperty = isHorizontal.value ? "clientX" : "clientY";
        const sign = isRtl.value && isHorizontal.value ? -1 : 1;
        startOffset = sign * scrollOffset.value;
        startTouch = e.touches[0][sizeProperty];
        disableTransition.value = true;
      }
      function onTouchmove(e) {
        if (!isOverflowing.value)
          return;
        const sizeProperty = isHorizontal.value ? "clientX" : "clientY";
        const sign = isRtl.value && isHorizontal.value ? -1 : 1;
        scrollOffset.value = sign * (startOffset + startTouch - e.touches[0][sizeProperty]);
      }
      function onTouchend(e) {
        const maxScrollOffset = contentSize.value - containerSize.value;
        if (scrollOffset.value < 0 || !isOverflowing.value) {
          scrollOffset.value = 0;
        } else if (scrollOffset.value >= maxScrollOffset) {
          scrollOffset.value = maxScrollOffset;
        }
        disableTransition.value = false;
      }
      function onScroll() {
        if (!containerRef.value)
          return;
        containerRef.value[isHorizontal.value ? "scrollLeft" : "scrollTop"] = 0;
      }
      const isFocused = shallowRef(false);
      function onFocusin(e) {
        isFocused.value = true;
        if (!isOverflowing.value || !contentRef.value)
          return;
        for (const el of e.composedPath()) {
          for (const item of contentRef.value.children) {
            if (item === el) {
              scrollOffset.value = calculateUpdatedOffset({
                selectedElement: item,
                containerSize: containerSize.value,
                contentSize: contentSize.value,
                isRtl: isRtl.value,
                currentScrollOffset: scrollOffset.value,
                isHorizontal: isHorizontal.value
              });
              return;
            }
          }
        }
      }
      function onFocusout(e) {
        isFocused.value = false;
      }
      function onFocus(e) {
        var _a2;
        if (!isFocused.value && !(e.relatedTarget && ((_a2 = contentRef.value) == null ? void 0 : _a2.contains(e.relatedTarget))))
          focus();
      }
      function onKeydown(e) {
        if (!contentRef.value)
          return;
        if (isHorizontal.value) {
          if (e.key === "ArrowRight") {
            focus(isRtl.value ? "prev" : "next");
          } else if (e.key === "ArrowLeft") {
            focus(isRtl.value ? "next" : "prev");
          }
        } else {
          if (e.key === "ArrowDown") {
            focus("next");
          } else if (e.key === "ArrowUp") {
            focus("prev");
          }
        }
        if (e.key === "Home") {
          focus("first");
        } else if (e.key === "End") {
          focus("last");
        }
      }
      function focus(location2) {
        var _a2, _b, _c, _d, _e;
        if (!contentRef.value)
          return;
        if (!location2) {
          const focusable = focusableChildren(contentRef.value);
          (_a2 = focusable[0]) == null ? void 0 : _a2.focus();
        } else if (location2 === "next") {
          const el = (_b = contentRef.value.querySelector(":focus")) == null ? void 0 : _b.nextElementSibling;
          if (el)
            el.focus();
          else
            focus("first");
        } else if (location2 === "prev") {
          const el = (_c = contentRef.value.querySelector(":focus")) == null ? void 0 : _c.previousElementSibling;
          if (el)
            el.focus();
          else
            focus("last");
        } else if (location2 === "first") {
          (_d = contentRef.value.firstElementChild) == null ? void 0 : _d.focus();
        } else if (location2 === "last") {
          (_e = contentRef.value.lastElementChild) == null ? void 0 : _e.focus();
        }
      }
      function scrollTo(location2) {
        const newAbsoluteOffset = scrollOffset.value + (location2 === "prev" ? -1 : 1) * containerSize.value;
        scrollOffset.value = clamp(newAbsoluteOffset, 0, contentSize.value - containerSize.value);
      }
      const contentStyles = computed2(() => {
        let scrollAmount = scrollOffset.value > contentSize.value - containerSize.value ? -(contentSize.value - containerSize.value) + bias(contentSize.value - containerSize.value - scrollOffset.value) : -scrollOffset.value;
        if (scrollOffset.value <= 0) {
          scrollAmount = bias(-scrollOffset.value);
        }
        const sign = isRtl.value && isHorizontal.value ? -1 : 1;
        return {
          transform: `translate${isHorizontal.value ? "X" : "Y"}(${sign * scrollAmount}px)`,
          transition: disableTransition.value ? "none" : "",
          willChange: disableTransition.value ? "transform" : ""
        };
      });
      const slotProps = computed2(() => ({
        next: group.next,
        prev: group.prev,
        select: group.select,
        isSelected: group.isSelected
      }));
      const hasAffixes = computed2(() => {
        switch (props.showArrows) {
          case "always":
            return true;
          case "desktop":
            return !mobile.value;
          case true:
            return isOverflowing.value || Math.abs(scrollOffset.value) > 0;
          case "mobile":
            return mobile.value || isOverflowing.value || Math.abs(scrollOffset.value) > 0;
          default:
            return !mobile.value && (isOverflowing.value || Math.abs(scrollOffset.value) > 0);
        }
      });
      const hasPrev = computed2(() => {
        return Math.abs(scrollOffset.value) > 0;
      });
      const hasNext = computed2(() => {
        return contentSize.value > Math.abs(scrollOffset.value) + containerSize.value;
      });
      useRender(() => createVNode(props.tag, {
        "class": ["v-slide-group", {
          "v-slide-group--vertical": !isHorizontal.value,
          "v-slide-group--has-affixes": hasAffixes.value,
          "v-slide-group--is-overflowing": isOverflowing.value
        }, displayClasses.value, props.class],
        "style": props.style,
        "tabindex": isFocused.value || group.selected.value.length ? -1 : 0,
        "onFocus": onFocus
      }, {
        default: () => {
          var _a2, _b, _c, _d, _e;
          return [hasAffixes.value && createVNode("div", {
            "key": "prev",
            "class": ["v-slide-group__prev", {
              "v-slide-group__prev--disabled": !hasPrev.value
            }],
            "onClick": () => hasPrev.value && scrollTo("prev")
          }, [(_b = (_a2 = slots.prev) == null ? void 0 : _a2.call(slots, slotProps.value)) != null ? _b : createVNode(VFadeTransition, null, {
            default: () => [createVNode(VIcon, {
              "icon": isRtl.value ? props.nextIcon : props.prevIcon
            }, null)]
          })]), createVNode("div", {
            "key": "container",
            "ref": containerRef,
            "class": "v-slide-group__container",
            "onScroll": onScroll
          }, [createVNode("div", {
            "ref": contentRef,
            "class": "v-slide-group__content",
            "style": contentStyles.value,
            "onTouchstartPassive": onTouchstart,
            "onTouchmovePassive": onTouchmove,
            "onTouchendPassive": onTouchend,
            "onFocusin": onFocusin,
            "onFocusout": onFocusout,
            "onKeydown": onKeydown
          }, [(_c = slots.default) == null ? void 0 : _c.call(slots, slotProps.value)])]), hasAffixes.value && createVNode("div", {
            "key": "next",
            "class": ["v-slide-group__next", {
              "v-slide-group__next--disabled": !hasNext.value
            }],
            "onClick": () => hasNext.value && scrollTo("next")
          }, [(_e = (_d = slots.next) == null ? void 0 : _d.call(slots, slotProps.value)) != null ? _e : createVNode(VFadeTransition, null, {
            default: () => [createVNode(VIcon, {
              "icon": isRtl.value ? props.prevIcon : props.nextIcon
            }, null)]
          })])];
        }
      }));
      return {
        selected: group.selected,
        scrollTo,
        scrollOffset,
        focus
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VChipGroup/VChipGroup.mjs
  var VChipGroupSymbol = Symbol.for("vuetify:v-chip-group");
  var makeVChipGroupProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    column: Boolean,
    filter: Boolean,
    valueComparator: {
      type: Function,
      default: deepEqual
    }
  }, makeVSlideGroupProps()), makeComponentProps()), makeGroupProps({
    selectedClass: "v-chip--selected"
  })), makeTagProps()), makeThemeProps()), makeVariantProps({
    variant: "tonal"
  })), "VChipGroup");
  var VChipGroup = genericComponent()({
    name: "VChipGroup",
    props: makeVChipGroupProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      const {
        isSelected,
        select,
        next,
        prev,
        selected
      } = useGroup(props, VChipGroupSymbol);
      provideDefaults({
        VChip: {
          color: toRef(props, "color"),
          disabled: toRef(props, "disabled"),
          filter: toRef(props, "filter"),
          variant: toRef(props, "variant")
        }
      });
      useRender(() => {
        const slideGroupProps = VSlideGroup.filterProps(props);
        return createVNode(VSlideGroup, mergeProps(slideGroupProps, {
          "class": ["v-chip-group", {
            "v-chip-group--column": props.column
          }, themeClasses.value, props.class],
          "style": props.style
        }), {
          default: () => {
            var _a2;
            return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
              isSelected,
              select,
              next,
              prev,
              selected: selected.value
            })];
          }
        });
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VChip/VChip.mjs
  var makeVChipProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    activeClass: String,
    appendAvatar: String,
    appendIcon: IconValue,
    closable: Boolean,
    closeIcon: {
      type: IconValue,
      default: "$delete"
    },
    closeLabel: {
      type: String,
      default: "$vuetify.close"
    },
    draggable: Boolean,
    filter: Boolean,
    filterIcon: {
      type: String,
      default: "$complete"
    },
    label: Boolean,
    link: {
      type: Boolean,
      default: void 0
    },
    pill: Boolean,
    prependAvatar: String,
    prependIcon: IconValue,
    ripple: {
      type: [Boolean, Object],
      default: true
    },
    text: String,
    modelValue: {
      type: Boolean,
      default: true
    },
    onClick: EventProp(),
    onClickOnce: EventProp()
  }, makeBorderProps()), makeComponentProps()), makeDensityProps()), makeElevationProps()), makeGroupItemProps()), makeRoundedProps()), makeRouterProps()), makeSizeProps()), makeTagProps({
    tag: "span"
  })), makeThemeProps()), makeVariantProps({
    variant: "tonal"
  })), "VChip");
  var VChip = genericComponent()({
    name: "VChip",
    directives: {
      Ripple
    },
    props: makeVChipProps(),
    emits: {
      "click:close": (e) => true,
      "update:modelValue": (value) => true,
      "group:selected": (val) => true,
      click: (e) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        emit: emit2,
        slots
      } = _ref;
      const {
        t
      } = useLocale();
      const {
        borderClasses
      } = useBorder(props);
      const {
        colorClasses,
        colorStyles,
        variantClasses
      } = useVariant(props);
      const {
        densityClasses
      } = useDensity(props);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        roundedClasses
      } = useRounded(props);
      const {
        sizeClasses
      } = useSize(props);
      const {
        themeClasses
      } = provideTheme(props);
      const isActive = useProxiedModel(props, "modelValue");
      const group = useGroupItem(props, VChipGroupSymbol, false);
      const link = useLink(props, attrs);
      const isLink = computed2(() => props.link !== false && link.isLink.value);
      const isClickable = computed2(() => !props.disabled && props.link !== false && (!!group || props.link || link.isClickable.value));
      const closeProps = computed2(() => ({
        "aria-label": t(props.closeLabel),
        onClick(e) {
          e.preventDefault();
          e.stopPropagation();
          isActive.value = false;
          emit2("click:close", e);
        }
      }));
      function onClick(e) {
        var _a2;
        emit2("click", e);
        if (!isClickable.value)
          return;
        (_a2 = link.navigate) == null ? void 0 : _a2.call(link, e);
        group == null ? void 0 : group.toggle();
      }
      function onKeyDown(e) {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          onClick(e);
        }
      }
      return () => {
        const Tag = link.isLink.value ? "a" : props.tag;
        const hasAppendMedia = !!(props.appendIcon || props.appendAvatar);
        const hasAppend = !!(hasAppendMedia || slots.append);
        const hasClose = !!(slots.close || props.closable);
        const hasFilter = !!(slots.filter || props.filter) && group;
        const hasPrependMedia = !!(props.prependIcon || props.prependAvatar);
        const hasPrepend = !!(hasPrependMedia || slots.prepend);
        const hasColor = !group || group.isSelected.value;
        return isActive.value && withDirectives(createVNode(Tag, {
          "class": ["v-chip", {
            "v-chip--disabled": props.disabled,
            "v-chip--label": props.label,
            "v-chip--link": isClickable.value,
            "v-chip--filter": hasFilter,
            "v-chip--pill": props.pill
          }, themeClasses.value, borderClasses.value, hasColor ? colorClasses.value : void 0, densityClasses.value, elevationClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value, group == null ? void 0 : group.selectedClass.value, props.class],
          "style": [hasColor ? colorStyles.value : void 0, props.style],
          "disabled": props.disabled || void 0,
          "draggable": props.draggable,
          "href": link.href.value,
          "tabindex": isClickable.value ? 0 : void 0,
          "onClick": onClick,
          "onKeydown": isClickable.value && !isLink.value && onKeyDown
        }, {
          default: () => {
            var _a2, _b;
            return [genOverlays(isClickable.value, "v-chip"), hasFilter && createVNode(VExpandXTransition, {
              "key": "filter"
            }, {
              default: () => [withDirectives(createVNode("div", {
                "class": "v-chip__filter"
              }, [!slots.filter ? createVNode(VIcon, {
                "key": "filter-icon",
                "icon": props.filterIcon
              }, null) : createVNode(VDefaultsProvider, {
                "key": "filter-defaults",
                "disabled": !props.filterIcon,
                "defaults": {
                  VIcon: {
                    icon: props.filterIcon
                  }
                }
              }, slots.filter)]), [[vShow, group.isSelected.value]])]
            }), hasPrepend && createVNode("div", {
              "key": "prepend",
              "class": "v-chip__prepend"
            }, [!slots.prepend ? createVNode(Fragment, null, [props.prependIcon && createVNode(VIcon, {
              "key": "prepend-icon",
              "icon": props.prependIcon,
              "start": true
            }, null), props.prependAvatar && createVNode(VAvatar, {
              "key": "prepend-avatar",
              "image": props.prependAvatar,
              "start": true
            }, null)]) : createVNode(VDefaultsProvider, {
              "key": "prepend-defaults",
              "disabled": !hasPrependMedia,
              "defaults": {
                VAvatar: {
                  image: props.prependAvatar,
                  start: true
                },
                VIcon: {
                  icon: props.prependIcon,
                  start: true
                }
              }
            }, slots.prepend)]), createVNode("div", {
              "class": "v-chip__content",
              "data-no-activator": ""
            }, [(_b = (_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
              isSelected: group == null ? void 0 : group.isSelected.value,
              selectedClass: group == null ? void 0 : group.selectedClass.value,
              select: group == null ? void 0 : group.select,
              toggle: group == null ? void 0 : group.toggle,
              value: group == null ? void 0 : group.value.value,
              disabled: props.disabled
            })) != null ? _b : props.text]), hasAppend && createVNode("div", {
              "key": "append",
              "class": "v-chip__append"
            }, [!slots.append ? createVNode(Fragment, null, [props.appendIcon && createVNode(VIcon, {
              "key": "append-icon",
              "end": true,
              "icon": props.appendIcon
            }, null), props.appendAvatar && createVNode(VAvatar, {
              "key": "append-avatar",
              "end": true,
              "image": props.appendAvatar
            }, null)]) : createVNode(VDefaultsProvider, {
              "key": "append-defaults",
              "disabled": !hasAppendMedia,
              "defaults": {
                VAvatar: {
                  end: true,
                  image: props.appendAvatar
                },
                VIcon: {
                  end: true,
                  icon: props.appendIcon
                }
              }
            }, slots.append)]), hasClose && createVNode("button", mergeProps({
              "key": "close",
              "class": "v-chip__close",
              "type": "button"
            }, closeProps.value), [!slots.close ? createVNode(VIcon, {
              "key": "close-icon",
              "icon": props.closeIcon,
              "size": "x-small"
            }, null) : createVNode(VDefaultsProvider, {
              "key": "close-defaults",
              "defaults": {
                VIcon: {
                  icon: props.closeIcon,
                  size: "x-small"
                }
              }
            }, slots.close)])];
          }
        }), [[resolveDirective("ripple"), isClickable.value && props.ripple, null]]);
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VList/list.mjs
  var DepthKey = Symbol.for("vuetify:depth");
  var ListKey = Symbol.for("vuetify:list");
  function createList() {
    const parent2 = inject(ListKey, {
      hasPrepend: shallowRef(false),
      updateHasPrepend: () => null
    });
    const data = {
      hasPrepend: shallowRef(false),
      updateHasPrepend: (value) => {
        if (value)
          data.hasPrepend.value = value;
      }
    };
    provide(ListKey, data);
    return parent2;
  }
  function useList() {
    return inject(ListKey, null);
  }

  // ../library_management/node_modules/vuetify/lib/composables/nested/activeStrategies.mjs
  var independentActiveStrategy = (mandatory) => {
    const strategy = {
      activate: (_ref) => {
        let {
          id,
          value,
          activated
        } = _ref;
        id = toRaw(id);
        if (mandatory && !value && activated.size === 1 && activated.has(id))
          return activated;
        if (value) {
          activated.add(id);
        } else {
          activated.delete(id);
        }
        return activated;
      },
      in: (v, children, parents2) => {
        let set3 = /* @__PURE__ */ new Set();
        for (const id of v || []) {
          set3 = strategy.activate({
            id,
            value: true,
            activated: new Set(set3),
            children,
            parents: parents2
          });
        }
        return set3;
      },
      out: (v) => {
        return Array.from(v);
      }
    };
    return strategy;
  };
  var independentSingleActiveStrategy = (mandatory) => {
    const parentStrategy = independentActiveStrategy(mandatory);
    const strategy = {
      activate: (_ref2) => {
        let _a2 = _ref2, {
          activated,
          id
        } = _a2, rest = __objRest(_a2, [
          "activated",
          "id"
        ]);
        id = toRaw(id);
        const singleSelected = activated.has(id) ? /* @__PURE__ */ new Set([id]) : /* @__PURE__ */ new Set();
        return parentStrategy.activate(__spreadProps(__spreadValues({}, rest), {
          id,
          activated: singleSelected
        }));
      },
      in: (v, children, parents2) => {
        let set3 = /* @__PURE__ */ new Set();
        if (v == null ? void 0 : v.length) {
          set3 = parentStrategy.in(v.slice(0, 1), children, parents2);
        }
        return set3;
      },
      out: (v, children, parents2) => {
        return parentStrategy.out(v, children, parents2);
      }
    };
    return strategy;
  };
  var leafActiveStrategy = (mandatory) => {
    const parentStrategy = independentActiveStrategy(mandatory);
    const strategy = {
      activate: (_ref3) => {
        let _a2 = _ref3, {
          id,
          activated,
          children
        } = _a2, rest = __objRest(_a2, [
          "id",
          "activated",
          "children"
        ]);
        id = toRaw(id);
        if (children.has(id))
          return activated;
        return parentStrategy.activate(__spreadValues({
          id,
          activated,
          children
        }, rest));
      },
      in: parentStrategy.in,
      out: parentStrategy.out
    };
    return strategy;
  };
  var leafSingleActiveStrategy = (mandatory) => {
    const parentStrategy = independentSingleActiveStrategy(mandatory);
    const strategy = {
      activate: (_ref4) => {
        let _a2 = _ref4, {
          id,
          activated,
          children
        } = _a2, rest = __objRest(_a2, [
          "id",
          "activated",
          "children"
        ]);
        id = toRaw(id);
        if (children.has(id))
          return activated;
        return parentStrategy.activate(__spreadValues({
          id,
          activated,
          children
        }, rest));
      },
      in: parentStrategy.in,
      out: parentStrategy.out
    };
    return strategy;
  };

  // ../library_management/node_modules/vuetify/lib/composables/nested/openStrategies.mjs
  var singleOpenStrategy = {
    open: (_ref) => {
      let {
        id,
        value,
        opened,
        parents: parents2
      } = _ref;
      if (value) {
        const newOpened = /* @__PURE__ */ new Set();
        newOpened.add(id);
        let parent2 = parents2.get(id);
        while (parent2 != null) {
          newOpened.add(parent2);
          parent2 = parents2.get(parent2);
        }
        return newOpened;
      } else {
        opened.delete(id);
        return opened;
      }
    },
    select: () => null
  };
  var multipleOpenStrategy = {
    open: (_ref2) => {
      let {
        id,
        value,
        opened,
        parents: parents2
      } = _ref2;
      if (value) {
        let parent2 = parents2.get(id);
        opened.add(id);
        while (parent2 != null && parent2 !== id) {
          opened.add(parent2);
          parent2 = parents2.get(parent2);
        }
        return opened;
      } else {
        opened.delete(id);
      }
      return opened;
    },
    select: () => null
  };
  var listOpenStrategy = {
    open: multipleOpenStrategy.open,
    select: (_ref3) => {
      let {
        id,
        value,
        opened,
        parents: parents2
      } = _ref3;
      if (!value)
        return opened;
      const path5 = [];
      let parent2 = parents2.get(id);
      while (parent2 != null) {
        path5.push(parent2);
        parent2 = parents2.get(parent2);
      }
      return new Set(path5);
    }
  };

  // ../library_management/node_modules/vuetify/lib/composables/nested/selectStrategies.mjs
  var independentSelectStrategy = (mandatory) => {
    const strategy = {
      select: (_ref) => {
        let {
          id,
          value,
          selected
        } = _ref;
        id = toRaw(id);
        if (mandatory && !value) {
          const on = Array.from(selected.entries()).reduce((arr, _ref2) => {
            let [key, value2] = _ref2;
            if (value2 === "on")
              arr.push(key);
            return arr;
          }, []);
          if (on.length === 1 && on[0] === id)
            return selected;
        }
        selected.set(id, value ? "on" : "off");
        return selected;
      },
      in: (v, children, parents2) => {
        let map2 = /* @__PURE__ */ new Map();
        for (const id of v || []) {
          map2 = strategy.select({
            id,
            value: true,
            selected: new Map(map2),
            children,
            parents: parents2
          });
        }
        return map2;
      },
      out: (v) => {
        const arr = [];
        for (const [key, value] of v.entries()) {
          if (value === "on")
            arr.push(key);
        }
        return arr;
      }
    };
    return strategy;
  };
  var independentSingleSelectStrategy = (mandatory) => {
    const parentStrategy = independentSelectStrategy(mandatory);
    const strategy = {
      select: (_ref3) => {
        let _a2 = _ref3, {
          selected,
          id
        } = _a2, rest = __objRest(_a2, [
          "selected",
          "id"
        ]);
        id = toRaw(id);
        const singleSelected = selected.has(id) ? /* @__PURE__ */ new Map([[id, selected.get(id)]]) : /* @__PURE__ */ new Map();
        return parentStrategy.select(__spreadProps(__spreadValues({}, rest), {
          id,
          selected: singleSelected
        }));
      },
      in: (v, children, parents2) => {
        let map2 = /* @__PURE__ */ new Map();
        if (v == null ? void 0 : v.length) {
          map2 = parentStrategy.in(v.slice(0, 1), children, parents2);
        }
        return map2;
      },
      out: (v, children, parents2) => {
        return parentStrategy.out(v, children, parents2);
      }
    };
    return strategy;
  };
  var leafSelectStrategy = (mandatory) => {
    const parentStrategy = independentSelectStrategy(mandatory);
    const strategy = {
      select: (_ref4) => {
        let _a2 = _ref4, {
          id,
          selected,
          children
        } = _a2, rest = __objRest(_a2, [
          "id",
          "selected",
          "children"
        ]);
        id = toRaw(id);
        if (children.has(id))
          return selected;
        return parentStrategy.select(__spreadValues({
          id,
          selected,
          children
        }, rest));
      },
      in: parentStrategy.in,
      out: parentStrategy.out
    };
    return strategy;
  };
  var leafSingleSelectStrategy = (mandatory) => {
    const parentStrategy = independentSingleSelectStrategy(mandatory);
    const strategy = {
      select: (_ref5) => {
        let _a2 = _ref5, {
          id,
          selected,
          children
        } = _a2, rest = __objRest(_a2, [
          "id",
          "selected",
          "children"
        ]);
        id = toRaw(id);
        if (children.has(id))
          return selected;
        return parentStrategy.select(__spreadValues({
          id,
          selected,
          children
        }, rest));
      },
      in: parentStrategy.in,
      out: parentStrategy.out
    };
    return strategy;
  };
  var classicSelectStrategy = (mandatory) => {
    const strategy = {
      select: (_ref6) => {
        let {
          id,
          value,
          selected,
          children,
          parents: parents2
        } = _ref6;
        id = toRaw(id);
        const original = new Map(selected);
        const items = [id];
        while (items.length) {
          const item = items.shift();
          selected.set(item, value ? "on" : "off");
          if (children.has(item)) {
            items.push(...children.get(item));
          }
        }
        let parent2 = parents2.get(id);
        while (parent2) {
          const childrenIds = children.get(parent2);
          const everySelected = childrenIds.every((cid) => selected.get(cid) === "on");
          const noneSelected = childrenIds.every((cid) => !selected.has(cid) || selected.get(cid) === "off");
          selected.set(parent2, everySelected ? "on" : noneSelected ? "off" : "indeterminate");
          parent2 = parents2.get(parent2);
        }
        if (mandatory && !value) {
          const on = Array.from(selected.entries()).reduce((arr, _ref7) => {
            let [key, value2] = _ref7;
            if (value2 === "on")
              arr.push(key);
            return arr;
          }, []);
          if (on.length === 0)
            return original;
        }
        return selected;
      },
      in: (v, children, parents2) => {
        let map2 = /* @__PURE__ */ new Map();
        for (const id of v || []) {
          map2 = strategy.select({
            id,
            value: true,
            selected: new Map(map2),
            children,
            parents: parents2
          });
        }
        return map2;
      },
      out: (v, children) => {
        const arr = [];
        for (const [key, value] of v.entries()) {
          if (value === "on" && !children.has(key))
            arr.push(key);
        }
        return arr;
      }
    };
    return strategy;
  };

  // ../library_management/node_modules/vuetify/lib/composables/nested/nested.mjs
  var VNestedSymbol = Symbol.for("vuetify:nested");
  var emptyNested = {
    id: shallowRef(),
    root: {
      register: () => null,
      unregister: () => null,
      parents: ref(/* @__PURE__ */ new Map()),
      children: ref(/* @__PURE__ */ new Map()),
      open: () => null,
      openOnSelect: () => null,
      activate: () => null,
      select: () => null,
      activatable: ref(false),
      selectable: ref(false),
      opened: ref(/* @__PURE__ */ new Set()),
      activated: ref(/* @__PURE__ */ new Set()),
      selected: ref(/* @__PURE__ */ new Map()),
      selectedValues: ref([])
    }
  };
  var makeNestedProps = propsFactory({
    activatable: Boolean,
    selectable: Boolean,
    activeStrategy: [String, Function],
    selectStrategy: [String, Function],
    openStrategy: [String, Object],
    opened: Array,
    activated: Array,
    selected: Array,
    mandatory: Boolean
  }, "nested");
  var useNested = (props) => {
    let isUnmounted = false;
    const children = ref(/* @__PURE__ */ new Map());
    const parents2 = ref(/* @__PURE__ */ new Map());
    const opened = useProxiedModel(props, "opened", props.opened, (v) => new Set(v), (v) => [...v.values()]);
    const activeStrategy = computed2(() => {
      if (typeof props.activeStrategy === "object")
        return props.activeStrategy;
      switch (props.activeStrategy) {
        case "leaf":
          return leafActiveStrategy(props.mandatory);
        case "single-leaf":
          return leafSingleActiveStrategy(props.mandatory);
        case "independent":
          return independentActiveStrategy(props.mandatory);
        case "single-independent":
        default:
          return independentSingleActiveStrategy(props.mandatory);
      }
    });
    const selectStrategy = computed2(() => {
      if (typeof props.selectStrategy === "object")
        return props.selectStrategy;
      switch (props.selectStrategy) {
        case "single-leaf":
          return leafSingleSelectStrategy(props.mandatory);
        case "leaf":
          return leafSelectStrategy(props.mandatory);
        case "independent":
          return independentSelectStrategy(props.mandatory);
        case "single-independent":
          return independentSingleSelectStrategy(props.mandatory);
        case "classic":
        default:
          return classicSelectStrategy(props.mandatory);
      }
    });
    const openStrategy = computed2(() => {
      if (typeof props.openStrategy === "object")
        return props.openStrategy;
      switch (props.openStrategy) {
        case "list":
          return listOpenStrategy;
        case "single":
          return singleOpenStrategy;
        case "multiple":
        default:
          return multipleOpenStrategy;
      }
    });
    const activated = useProxiedModel(props, "activated", props.activated, (v) => activeStrategy.value.in(v, children.value, parents2.value), (v) => activeStrategy.value.out(v, children.value, parents2.value));
    const selected = useProxiedModel(props, "selected", props.selected, (v) => selectStrategy.value.in(v, children.value, parents2.value), (v) => selectStrategy.value.out(v, children.value, parents2.value));
    onBeforeUnmount(() => {
      isUnmounted = true;
    });
    function getPath(id) {
      const path5 = [];
      let parent2 = id;
      while (parent2 != null) {
        path5.unshift(parent2);
        parent2 = parents2.value.get(parent2);
      }
      return path5;
    }
    const vm = getCurrentInstance2("nested");
    const nested = {
      id: shallowRef(),
      root: {
        opened,
        activatable: toRef(props, "activatable"),
        selectable: toRef(props, "selectable"),
        activated,
        selected,
        selectedValues: computed2(() => {
          const arr = [];
          for (const [key, value] of selected.value.entries()) {
            if (value === "on")
              arr.push(key);
          }
          return arr;
        }),
        register: (id, parentId, isGroup) => {
          parentId && id !== parentId && parents2.value.set(id, parentId);
          isGroup && children.value.set(id, []);
          if (parentId != null) {
            children.value.set(parentId, [...children.value.get(parentId) || [], id]);
          }
        },
        unregister: (id) => {
          var _a2;
          if (isUnmounted)
            return;
          children.value.delete(id);
          const parent2 = parents2.value.get(id);
          if (parent2) {
            const list = (_a2 = children.value.get(parent2)) != null ? _a2 : [];
            children.value.set(parent2, list.filter((child) => child !== id));
          }
          parents2.value.delete(id);
          opened.value.delete(id);
        },
        open: (id, value, event) => {
          vm.emit("click:open", {
            id,
            value,
            path: getPath(id),
            event
          });
          const newOpened = openStrategy.value.open({
            id,
            value,
            opened: new Set(opened.value),
            children: children.value,
            parents: parents2.value,
            event
          });
          newOpened && (opened.value = newOpened);
        },
        openOnSelect: (id, value, event) => {
          const newOpened = openStrategy.value.select({
            id,
            value,
            selected: new Map(selected.value),
            opened: new Set(opened.value),
            children: children.value,
            parents: parents2.value,
            event
          });
          newOpened && (opened.value = newOpened);
        },
        select: (id, value, event) => {
          vm.emit("click:select", {
            id,
            value,
            path: getPath(id),
            event
          });
          const newSelected = selectStrategy.value.select({
            id,
            value,
            selected: new Map(selected.value),
            children: children.value,
            parents: parents2.value,
            event
          });
          newSelected && (selected.value = newSelected);
          nested.root.openOnSelect(id, value, event);
        },
        activate: (id, value, event) => {
          if (!props.activatable) {
            return nested.root.select(id, true, event);
          }
          vm.emit("click:activate", {
            id,
            value,
            path: getPath(id),
            event
          });
          const newActivated = activeStrategy.value.activate({
            id,
            value,
            activated: new Set(activated.value),
            children: children.value,
            parents: parents2.value,
            event
          });
          newActivated && (activated.value = newActivated);
        },
        children,
        parents: parents2
      }
    };
    provide(VNestedSymbol, nested);
    return nested.root;
  };
  var useNestedItem = (id, isGroup) => {
    const parent2 = inject(VNestedSymbol, emptyNested);
    const uidSymbol = Symbol(getUid());
    const computedId = computed2(() => id.value !== void 0 ? id.value : uidSymbol);
    const item = __spreadProps(__spreadValues({}, parent2), {
      id: computedId,
      open: (open2, e) => parent2.root.open(computedId.value, open2, e),
      openOnSelect: (open2, e) => parent2.root.openOnSelect(computedId.value, open2, e),
      isOpen: computed2(() => parent2.root.opened.value.has(computedId.value)),
      parent: computed2(() => parent2.root.parents.value.get(computedId.value)),
      activate: (activated, e) => parent2.root.activate(computedId.value, activated, e),
      isActivated: computed2(() => parent2.root.activated.value.has(toRaw(computedId.value))),
      select: (selected, e) => parent2.root.select(computedId.value, selected, e),
      isSelected: computed2(() => parent2.root.selected.value.get(toRaw(computedId.value)) === "on"),
      isIndeterminate: computed2(() => parent2.root.selected.value.get(computedId.value) === "indeterminate"),
      isLeaf: computed2(() => !parent2.root.children.value.get(computedId.value)),
      isGroupActivator: parent2.isGroupActivator
    });
    !parent2.isGroupActivator && parent2.root.register(computedId.value, parent2.id.value, isGroup);
    onBeforeUnmount(() => {
      !parent2.isGroupActivator && parent2.root.unregister(computedId.value);
    });
    isGroup && provide(VNestedSymbol, item);
    return item;
  };
  var useNestedGroupActivator = () => {
    const parent2 = inject(VNestedSymbol, emptyNested);
    provide(VNestedSymbol, __spreadProps(__spreadValues({}, parent2), {
      isGroupActivator: true
    }));
  };

  // ../library_management/node_modules/vuetify/lib/components/VList/VListGroup.mjs
  var VListGroupActivator = defineComponent2({
    name: "VListGroupActivator",
    setup(_, _ref) {
      let {
        slots
      } = _ref;
      useNestedGroupActivator();
      return () => {
        var _a2;
        return (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
      };
    }
  });
  var makeVListGroupProps = propsFactory(__spreadValues(__spreadValues({
    activeColor: String,
    baseColor: String,
    color: String,
    collapseIcon: {
      type: IconValue,
      default: "$collapse"
    },
    expandIcon: {
      type: IconValue,
      default: "$expand"
    },
    prependIcon: IconValue,
    appendIcon: IconValue,
    fluid: Boolean,
    subgroup: Boolean,
    title: String,
    value: null
  }, makeComponentProps()), makeTagProps()), "VListGroup");
  var VListGroup = genericComponent()({
    name: "VListGroup",
    props: makeVListGroupProps(),
    setup(props, _ref2) {
      let {
        slots
      } = _ref2;
      const {
        isOpen,
        open: open2,
        id: _id
      } = useNestedItem(toRef(props, "value"), true);
      const id = computed2(() => `v-list-group--id-${String(_id.value)}`);
      const list = useList();
      const {
        isBooted
      } = useSsrBoot();
      function onClick(e) {
        open2(!isOpen.value, e);
      }
      const activatorProps = computed2(() => ({
        onClick,
        class: "v-list-group__header",
        id: id.value
      }));
      const toggleIcon = computed2(() => isOpen.value ? props.collapseIcon : props.expandIcon);
      const activatorDefaults = computed2(() => ({
        VListItem: {
          active: isOpen.value,
          activeColor: props.activeColor,
          baseColor: props.baseColor,
          color: props.color,
          prependIcon: props.prependIcon || props.subgroup && toggleIcon.value,
          appendIcon: props.appendIcon || !props.subgroup && toggleIcon.value,
          title: props.title,
          value: props.value
        }
      }));
      useRender(() => createVNode(props.tag, {
        "class": ["v-list-group", {
          "v-list-group--prepend": list == null ? void 0 : list.hasPrepend.value,
          "v-list-group--fluid": props.fluid,
          "v-list-group--subgroup": props.subgroup,
          "v-list-group--open": isOpen.value
        }, props.class],
        "style": props.style
      }, {
        default: () => [slots.activator && createVNode(VDefaultsProvider, {
          "defaults": activatorDefaults.value
        }, {
          default: () => [createVNode(VListGroupActivator, null, {
            default: () => [slots.activator({
              props: activatorProps.value,
              isOpen: isOpen.value
            })]
          })]
        }), createVNode(MaybeTransition, {
          "transition": {
            component: VExpandTransition
          },
          "disabled": !isBooted.value
        }, {
          default: () => {
            var _a2;
            return [withDirectives(createVNode("div", {
              "class": "v-list-group__items",
              "role": "group",
              "aria-labelledby": id.value
            }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]), [[vShow, isOpen.value]])];
          }
        })]
      }));
      return {
        isOpen
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VList/VListItemSubtitle.mjs
  var VListItemSubtitle = createSimpleFunctional("v-list-item-subtitle");

  // ../library_management/node_modules/vuetify/lib/components/VList/VListItemTitle.mjs
  var VListItemTitle = createSimpleFunctional("v-list-item-title");

  // ../library_management/node_modules/vuetify/lib/components/VList/VListItem.mjs
  var makeVListItemProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    active: {
      type: Boolean,
      default: void 0
    },
    activeClass: String,
    activeColor: String,
    appendAvatar: String,
    appendIcon: IconValue,
    baseColor: String,
    disabled: Boolean,
    lines: String,
    link: {
      type: Boolean,
      default: void 0
    },
    nav: Boolean,
    prependAvatar: String,
    prependIcon: IconValue,
    ripple: {
      type: [Boolean, Object],
      default: true
    },
    slim: Boolean,
    subtitle: [String, Number],
    title: [String, Number],
    value: null,
    onClick: EventProp(),
    onClickOnce: EventProp()
  }, makeBorderProps()), makeComponentProps()), makeDensityProps()), makeDimensionProps()), makeElevationProps()), makeRoundedProps()), makeRouterProps()), makeTagProps()), makeThemeProps()), makeVariantProps({
    variant: "text"
  })), "VListItem");
  var VListItem = genericComponent()({
    name: "VListItem",
    directives: {
      Ripple
    },
    props: makeVListItemProps(),
    emits: {
      click: (e) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        slots,
        emit: emit2
      } = _ref;
      const link = useLink(props, attrs);
      const id = computed2(() => props.value === void 0 ? link.href.value : props.value);
      const {
        activate,
        isActivated,
        select,
        isSelected,
        isIndeterminate,
        isGroupActivator,
        root,
        parent: parent2,
        openOnSelect
      } = useNestedItem(id, false);
      const list = useList();
      const isActive = computed2(() => {
        var _a2;
        return props.active !== false && (props.active || ((_a2 = link.isActive) == null ? void 0 : _a2.value) || (root.activatable.value ? isActivated.value : isSelected.value));
      });
      const isLink = computed2(() => props.link !== false && link.isLink.value);
      const isClickable = computed2(() => !props.disabled && props.link !== false && (props.link || link.isClickable.value || !!list && (root.selectable.value || root.activatable.value || props.value != null)));
      const roundedProps = computed2(() => props.rounded || props.nav);
      const color = computed2(() => {
        var _a2;
        return (_a2 = props.color) != null ? _a2 : props.activeColor;
      });
      const variantProps = computed2(() => {
        var _a2;
        return {
          color: isActive.value ? (_a2 = color.value) != null ? _a2 : props.baseColor : props.baseColor,
          variant: props.variant
        };
      });
      watch(() => {
        var _a2;
        return (_a2 = link.isActive) == null ? void 0 : _a2.value;
      }, (val) => {
        if (val && parent2.value != null) {
          root.open(parent2.value, true);
        }
        if (val) {
          openOnSelect(val);
        }
      }, {
        immediate: true
      });
      const {
        themeClasses
      } = provideTheme(props);
      const {
        borderClasses
      } = useBorder(props);
      const {
        colorClasses,
        colorStyles,
        variantClasses
      } = useVariant(variantProps);
      const {
        densityClasses
      } = useDensity(props);
      const {
        dimensionStyles
      } = useDimension(props);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        roundedClasses
      } = useRounded(roundedProps);
      const lineClasses = computed2(() => props.lines ? `v-list-item--${props.lines}-line` : void 0);
      const slotProps = computed2(() => ({
        isActive: isActive.value,
        select,
        isSelected: isSelected.value,
        isIndeterminate: isIndeterminate.value
      }));
      function onClick(e) {
        var _a2;
        emit2("click", e);
        if (isGroupActivator || !isClickable.value)
          return;
        (_a2 = link.navigate) == null ? void 0 : _a2.call(link, e);
        if (root.activatable.value) {
          activate(!isActivated.value, e);
        } else if (root.selectable.value) {
          select(!isSelected.value, e);
        } else if (props.value != null) {
          select(!isSelected.value, e);
        }
      }
      function onKeyDown(e) {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          onClick(e);
        }
      }
      useRender(() => {
        const Tag = isLink.value ? "a" : props.tag;
        const hasTitle = slots.title || props.title != null;
        const hasSubtitle = slots.subtitle || props.subtitle != null;
        const hasAppendMedia = !!(props.appendAvatar || props.appendIcon);
        const hasAppend = !!(hasAppendMedia || slots.append);
        const hasPrependMedia = !!(props.prependAvatar || props.prependIcon);
        const hasPrepend = !!(hasPrependMedia || slots.prepend);
        list == null ? void 0 : list.updateHasPrepend(hasPrepend);
        if (props.activeColor) {
          deprecate("active-color", ["color", "base-color"]);
        }
        return withDirectives(createVNode(Tag, {
          "class": ["v-list-item", {
            "v-list-item--active": isActive.value,
            "v-list-item--disabled": props.disabled,
            "v-list-item--link": isClickable.value,
            "v-list-item--nav": props.nav,
            "v-list-item--prepend": !hasPrepend && (list == null ? void 0 : list.hasPrepend.value),
            "v-list-item--slim": props.slim,
            [`${props.activeClass}`]: props.activeClass && isActive.value
          }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, lineClasses.value, roundedClasses.value, variantClasses.value, props.class],
          "style": [colorStyles.value, dimensionStyles.value, props.style],
          "href": link.href.value,
          "tabindex": isClickable.value ? list ? -2 : 0 : void 0,
          "onClick": onClick,
          "onKeydown": isClickable.value && !isLink.value && onKeyDown
        }, {
          default: () => {
            var _a2;
            return [genOverlays(isClickable.value || isActive.value, "v-list-item"), hasPrepend && createVNode("div", {
              "key": "prepend",
              "class": "v-list-item__prepend"
            }, [!slots.prepend ? createVNode(Fragment, null, [props.prependAvatar && createVNode(VAvatar, {
              "key": "prepend-avatar",
              "density": props.density,
              "image": props.prependAvatar
            }, null), props.prependIcon && createVNode(VIcon, {
              "key": "prepend-icon",
              "density": props.density,
              "icon": props.prependIcon
            }, null)]) : createVNode(VDefaultsProvider, {
              "key": "prepend-defaults",
              "disabled": !hasPrependMedia,
              "defaults": {
                VAvatar: {
                  density: props.density,
                  image: props.prependAvatar
                },
                VIcon: {
                  density: props.density,
                  icon: props.prependIcon
                },
                VListItemAction: {
                  start: true
                }
              }
            }, {
              default: () => {
                var _a3;
                return [(_a3 = slots.prepend) == null ? void 0 : _a3.call(slots, slotProps.value)];
              }
            }), createVNode("div", {
              "class": "v-list-item__spacer"
            }, null)]), createVNode("div", {
              "class": "v-list-item__content",
              "data-no-activator": ""
            }, [hasTitle && createVNode(VListItemTitle, {
              "key": "title"
            }, {
              default: () => {
                var _a3, _b;
                return [(_b = (_a3 = slots.title) == null ? void 0 : _a3.call(slots, {
                  title: props.title
                })) != null ? _b : props.title];
              }
            }), hasSubtitle && createVNode(VListItemSubtitle, {
              "key": "subtitle"
            }, {
              default: () => {
                var _a3, _b;
                return [(_b = (_a3 = slots.subtitle) == null ? void 0 : _a3.call(slots, {
                  subtitle: props.subtitle
                })) != null ? _b : props.subtitle];
              }
            }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots, slotProps.value)]), hasAppend && createVNode("div", {
              "key": "append",
              "class": "v-list-item__append"
            }, [!slots.append ? createVNode(Fragment, null, [props.appendIcon && createVNode(VIcon, {
              "key": "append-icon",
              "density": props.density,
              "icon": props.appendIcon
            }, null), props.appendAvatar && createVNode(VAvatar, {
              "key": "append-avatar",
              "density": props.density,
              "image": props.appendAvatar
            }, null)]) : createVNode(VDefaultsProvider, {
              "key": "append-defaults",
              "disabled": !hasAppendMedia,
              "defaults": {
                VAvatar: {
                  density: props.density,
                  image: props.appendAvatar
                },
                VIcon: {
                  density: props.density,
                  icon: props.appendIcon
                },
                VListItemAction: {
                  end: true
                }
              }
            }, {
              default: () => {
                var _a3;
                return [(_a3 = slots.append) == null ? void 0 : _a3.call(slots, slotProps.value)];
              }
            }), createVNode("div", {
              "class": "v-list-item__spacer"
            }, null)])];
          }
        }), [[resolveDirective("ripple"), isClickable.value && props.ripple]]);
      });
      return {
        isGroupActivator,
        isSelected,
        list,
        select
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VList/VListSubheader.mjs
  var makeVListSubheaderProps = propsFactory(__spreadValues(__spreadValues({
    color: String,
    inset: Boolean,
    sticky: Boolean,
    title: String
  }, makeComponentProps()), makeTagProps()), "VListSubheader");
  var VListSubheader = genericComponent()({
    name: "VListSubheader",
    props: makeVListSubheaderProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(toRef(props, "color"));
      useRender(() => {
        const hasText = !!(slots.default || props.title);
        return createVNode(props.tag, {
          "class": ["v-list-subheader", {
            "v-list-subheader--inset": props.inset,
            "v-list-subheader--sticky": props.sticky
          }, textColorClasses.value, props.class],
          "style": [{
            textColorStyles
          }, props.style]
        }, {
          default: () => {
            var _a2, _b;
            return [hasText && createVNode("div", {
              "class": "v-list-subheader__text"
            }, [(_b = (_a2 = slots.default) == null ? void 0 : _a2.call(slots)) != null ? _b : props.title])];
          }
        });
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VDivider/VDivider.mjs
  var makeVDividerProps = propsFactory(__spreadValues(__spreadValues({
    color: String,
    inset: Boolean,
    length: [Number, String],
    thickness: [Number, String],
    vertical: Boolean
  }, makeComponentProps()), makeThemeProps()), "VDivider");
  var VDivider = genericComponent()({
    name: "VDivider",
    props: makeVDividerProps(),
    setup(props, _ref) {
      let {
        attrs
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(toRef(props, "color"));
      const dividerStyles = computed2(() => {
        const styles = {};
        if (props.length) {
          styles[props.vertical ? "maxHeight" : "maxWidth"] = convertToUnit(props.length);
        }
        if (props.thickness) {
          styles[props.vertical ? "borderRightWidth" : "borderTopWidth"] = convertToUnit(props.thickness);
        }
        return styles;
      });
      useRender(() => createVNode("hr", {
        "class": [{
          "v-divider": true,
          "v-divider--inset": props.inset,
          "v-divider--vertical": props.vertical
        }, themeClasses.value, textColorClasses.value, props.class],
        "style": [dividerStyles.value, textColorStyles.value, props.style],
        "aria-orientation": !attrs.role || attrs.role === "separator" ? props.vertical ? "vertical" : "horizontal" : void 0,
        "role": `${attrs.role || "separator"}`
      }, null));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VList/VListChildren.mjs
  var makeVListChildrenProps = propsFactory({
    items: Array,
    returnObject: Boolean
  }, "VListChildren");
  var VListChildren = genericComponent()({
    name: "VListChildren",
    props: makeVListChildrenProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      createList();
      return () => {
        var _a2, _b, _c;
        return (_c = (_a2 = slots.default) == null ? void 0 : _a2.call(slots)) != null ? _c : (_b = props.items) == null ? void 0 : _b.map((_ref2) => {
          var _a3, _b2, _c2, _d;
          let {
            children,
            props: itemProps,
            type: type2,
            raw: item
          } = _ref2;
          if (type2 === "divider") {
            return (_b2 = (_a3 = slots.divider) == null ? void 0 : _a3.call(slots, {
              props: itemProps
            })) != null ? _b2 : createVNode(VDivider, itemProps, null);
          }
          if (type2 === "subheader") {
            return (_d = (_c2 = slots.subheader) == null ? void 0 : _c2.call(slots, {
              props: itemProps
            })) != null ? _d : createVNode(VListSubheader, itemProps, null);
          }
          const slotsWithItem = {
            subtitle: slots.subtitle ? (slotProps) => {
              var _a4;
              return (_a4 = slots.subtitle) == null ? void 0 : _a4.call(slots, __spreadProps(__spreadValues({}, slotProps), {
                item
              }));
            } : void 0,
            prepend: slots.prepend ? (slotProps) => {
              var _a4;
              return (_a4 = slots.prepend) == null ? void 0 : _a4.call(slots, __spreadProps(__spreadValues({}, slotProps), {
                item
              }));
            } : void 0,
            append: slots.append ? (slotProps) => {
              var _a4;
              return (_a4 = slots.append) == null ? void 0 : _a4.call(slots, __spreadProps(__spreadValues({}, slotProps), {
                item
              }));
            } : void 0,
            title: slots.title ? (slotProps) => {
              var _a4;
              return (_a4 = slots.title) == null ? void 0 : _a4.call(slots, __spreadProps(__spreadValues({}, slotProps), {
                item
              }));
            } : void 0
          };
          const listGroupProps = VListGroup.filterProps(itemProps);
          return children ? createVNode(VListGroup, mergeProps({
            "value": itemProps == null ? void 0 : itemProps.value
          }, listGroupProps), {
            activator: (_ref3) => {
              let {
                props: activatorProps
              } = _ref3;
              const listItemProps = __spreadProps(__spreadValues(__spreadValues({}, itemProps), activatorProps), {
                value: props.returnObject ? item : itemProps.value
              });
              return slots.header ? slots.header({
                props: listItemProps
              }) : createVNode(VListItem, listItemProps, slotsWithItem);
            },
            default: () => createVNode(VListChildren, {
              "items": children
            }, slots)
          }) : slots.item ? slots.item({
            props: itemProps
          }) : createVNode(VListItem, mergeProps(itemProps, {
            "value": props.returnObject ? item : itemProps.value
          }), slotsWithItem);
        });
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/composables/list-items.mjs
  var makeItemsProps = propsFactory({
    items: {
      type: Array,
      default: () => []
    },
    itemTitle: {
      type: [String, Array, Function],
      default: "title"
    },
    itemValue: {
      type: [String, Array, Function],
      default: "value"
    },
    itemChildren: {
      type: [Boolean, String, Array, Function],
      default: "children"
    },
    itemProps: {
      type: [Boolean, String, Array, Function],
      default: "props"
    },
    returnObject: Boolean,
    valueComparator: {
      type: Function,
      default: deepEqual
    }
  }, "list-items");
  function transformItem(props, item) {
    var _a2;
    const title = getPropertyFromItem(item, props.itemTitle, item);
    const value = getPropertyFromItem(item, props.itemValue, title);
    const children = getPropertyFromItem(item, props.itemChildren);
    const itemProps = props.itemProps === true ? typeof item === "object" && item != null && !Array.isArray(item) ? "children" in item ? omit(item, ["children"]) : item : void 0 : getPropertyFromItem(item, props.itemProps);
    const _props = __spreadValues({
      title,
      value
    }, itemProps);
    return {
      title: String((_a2 = _props.title) != null ? _a2 : ""),
      value: _props.value,
      props: _props,
      children: Array.isArray(children) ? transformItems(props, children) : void 0,
      raw: item
    };
  }
  function transformItems(props, items) {
    const array = [];
    for (const item of items) {
      array.push(transformItem(props, item));
    }
    return array;
  }
  function useItems(props) {
    const items = computed2(() => transformItems(props, props.items));
    const hasNullItem = computed2(() => items.value.some((item) => item.value === null));
    function transformIn(value) {
      if (!hasNullItem.value) {
        value = value.filter((v) => v !== null);
      }
      return value.map((v) => {
        if (props.returnObject && typeof v === "string") {
          return transformItem(props, v);
        }
        return items.value.find((item) => props.valueComparator(v, item.value)) || transformItem(props, v);
      });
    }
    function transformOut(value) {
      return props.returnObject ? value.map((_ref) => {
        let {
          raw
        } = _ref;
        return raw;
      }) : value.map((_ref2) => {
        let {
          value: value2
        } = _ref2;
        return value2;
      });
    }
    return {
      items,
      transformIn,
      transformOut
    };
  }

  // ../library_management/node_modules/vuetify/lib/components/VList/VList.mjs
  function isPrimitive(value) {
    return typeof value === "string" || typeof value === "number" || typeof value === "boolean";
  }
  function transformItem2(props, item) {
    const type2 = getPropertyFromItem(item, props.itemType, "item");
    const title = isPrimitive(item) ? item : getPropertyFromItem(item, props.itemTitle);
    const value = getPropertyFromItem(item, props.itemValue, void 0);
    const children = getPropertyFromItem(item, props.itemChildren);
    const itemProps = props.itemProps === true ? omit(item, ["children"]) : getPropertyFromItem(item, props.itemProps);
    const _props = __spreadValues({
      title,
      value
    }, itemProps);
    return {
      type: type2,
      title: _props.title,
      value: _props.value,
      props: _props,
      children: type2 === "item" && children ? transformItems2(props, children) : void 0,
      raw: item
    };
  }
  function transformItems2(props, items) {
    const array = [];
    for (const item of items) {
      array.push(transformItem2(props, item));
    }
    return array;
  }
  function useListItems(props) {
    const items = computed2(() => transformItems2(props, props.items));
    return {
      items
    };
  }
  var makeVListProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    baseColor: String,
    activeColor: String,
    activeClass: String,
    bgColor: String,
    disabled: Boolean,
    expandIcon: String,
    collapseIcon: String,
    lines: {
      type: [Boolean, String],
      default: "one"
    },
    slim: Boolean,
    nav: Boolean
  }, makeNestedProps({
    selectStrategy: "single-leaf",
    openStrategy: "list"
  })), makeBorderProps()), makeComponentProps()), makeDensityProps()), makeDimensionProps()), makeElevationProps()), {
    itemType: {
      type: String,
      default: "type"
    }
  }), makeItemsProps()), makeRoundedProps()), makeTagProps()), makeThemeProps()), makeVariantProps({
    variant: "text"
  })), "VList");
  var VList = genericComponent()({
    name: "VList",
    props: makeVListProps(),
    emits: {
      "update:selected": (value) => true,
      "update:activated": (value) => true,
      "update:opened": (value) => true,
      "click:open": (value) => true,
      "click:activate": (value) => true,
      "click:select": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        items
      } = useListItems(props);
      const {
        themeClasses
      } = provideTheme(props);
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(toRef(props, "bgColor"));
      const {
        borderClasses
      } = useBorder(props);
      const {
        densityClasses
      } = useDensity(props);
      const {
        dimensionStyles
      } = useDimension(props);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        roundedClasses
      } = useRounded(props);
      const {
        children,
        open: open2,
        parents: parents2,
        select
      } = useNested(props);
      const lineClasses = computed2(() => props.lines ? `v-list--${props.lines}-line` : void 0);
      const activeColor = toRef(props, "activeColor");
      const baseColor = toRef(props, "baseColor");
      const color = toRef(props, "color");
      createList();
      provideDefaults({
        VListGroup: {
          activeColor,
          baseColor,
          color,
          expandIcon: toRef(props, "expandIcon"),
          collapseIcon: toRef(props, "collapseIcon")
        },
        VListItem: {
          activeClass: toRef(props, "activeClass"),
          activeColor,
          baseColor,
          color,
          density: toRef(props, "density"),
          disabled: toRef(props, "disabled"),
          lines: toRef(props, "lines"),
          nav: toRef(props, "nav"),
          slim: toRef(props, "slim"),
          variant: toRef(props, "variant")
        }
      });
      const isFocused = shallowRef(false);
      const contentRef = ref();
      function onFocusin(e) {
        isFocused.value = true;
      }
      function onFocusout(e) {
        isFocused.value = false;
      }
      function onFocus(e) {
        var _a2;
        if (!isFocused.value && !(e.relatedTarget && ((_a2 = contentRef.value) == null ? void 0 : _a2.contains(e.relatedTarget))))
          focus();
      }
      function onKeydown(e) {
        if (!contentRef.value)
          return;
        if (e.key === "ArrowDown") {
          focus("next");
        } else if (e.key === "ArrowUp") {
          focus("prev");
        } else if (e.key === "Home") {
          focus("first");
        } else if (e.key === "End") {
          focus("last");
        } else {
          return;
        }
        e.preventDefault();
      }
      function onMousedown(e) {
        isFocused.value = true;
      }
      function focus(location2) {
        if (contentRef.value) {
          return focusChild(contentRef.value, location2);
        }
      }
      useRender(() => {
        return createVNode(props.tag, {
          "ref": contentRef,
          "class": ["v-list", {
            "v-list--disabled": props.disabled,
            "v-list--nav": props.nav,
            "v-list--slim": props.slim
          }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, lineClasses.value, roundedClasses.value, props.class],
          "style": [backgroundColorStyles.value, dimensionStyles.value, props.style],
          "tabindex": props.disabled || isFocused.value ? -1 : 0,
          "role": "listbox",
          "aria-activedescendant": void 0,
          "onFocusin": onFocusin,
          "onFocusout": onFocusout,
          "onFocus": onFocus,
          "onKeydown": onKeydown,
          "onMousedown": onMousedown
        }, {
          default: () => [createVNode(VListChildren, {
            "items": items.value,
            "returnObject": props.returnObject
          }, slots)]
        });
      });
      return {
        open: open2,
        select,
        focus,
        children,
        parents: parents2
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VList/VListImg.mjs
  var VListImg = createSimpleFunctional("v-list-img");

  // ../library_management/node_modules/vuetify/lib/components/VList/VListItemAction.mjs
  var makeVListItemActionProps = propsFactory(__spreadValues(__spreadValues({
    start: Boolean,
    end: Boolean
  }, makeComponentProps()), makeTagProps()), "VListItemAction");
  var VListItemAction = genericComponent()({
    name: "VListItemAction",
    props: makeVListItemActionProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useRender(() => createVNode(props.tag, {
        "class": ["v-list-item-action", {
          "v-list-item-action--start": props.start,
          "v-list-item-action--end": props.end
        }, props.class],
        "style": props.style
      }, slots));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VList/VListItemMedia.mjs
  var makeVListItemMediaProps = propsFactory(__spreadValues(__spreadValues({
    start: Boolean,
    end: Boolean
  }, makeComponentProps()), makeTagProps()), "VListItemMedia");
  var VListItemMedia = genericComponent()({
    name: "VListItemMedia",
    props: makeVListItemMediaProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useRender(() => {
        return createVNode(props.tag, {
          "class": ["v-list-item-media", {
            "v-list-item-media--start": props.start,
            "v-list-item-media--end": props.end
          }, props.class],
          "style": props.style
        }, slots);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VOverlay/util/point.mjs
  function elementToViewport(point, offset) {
    return {
      x: point.x + offset.x,
      y: point.y + offset.y
    };
  }
  function getOffset(a, b) {
    return {
      x: a.x - b.x,
      y: a.y - b.y
    };
  }
  function anchorToPoint(anchor, box) {
    if (anchor.side === "top" || anchor.side === "bottom") {
      const {
        side,
        align
      } = anchor;
      const x = align === "left" ? 0 : align === "center" ? box.width / 2 : align === "right" ? box.width : align;
      const y = side === "top" ? 0 : side === "bottom" ? box.height : side;
      return elementToViewport({
        x,
        y
      }, box);
    } else if (anchor.side === "left" || anchor.side === "right") {
      const {
        side,
        align
      } = anchor;
      const x = side === "left" ? 0 : side === "right" ? box.width : side;
      const y = align === "top" ? 0 : align === "center" ? box.height / 2 : align === "bottom" ? box.height : align;
      return elementToViewport({
        x,
        y
      }, box);
    }
    return elementToViewport({
      x: box.width / 2,
      y: box.height / 2
    }, box);
  }

  // ../library_management/node_modules/vuetify/lib/components/VOverlay/locationStrategies.mjs
  var locationStrategies = {
    static: staticLocationStrategy,
    connected: connectedLocationStrategy
  };
  var makeLocationStrategyProps = propsFactory({
    locationStrategy: {
      type: [String, Function],
      default: "static",
      validator: (val) => typeof val === "function" || val in locationStrategies
    },
    location: {
      type: String,
      default: "bottom"
    },
    origin: {
      type: String,
      default: "auto"
    },
    offset: [Number, String, Array]
  }, "VOverlay-location-strategies");
  function useLocationStrategies(props, data) {
    const contentStyles = ref({});
    const updateLocation = ref();
    if (IN_BROWSER) {
      useToggleScope(() => !!(data.isActive.value && props.locationStrategy), (reset) => {
        var _a2, _b;
        watch(() => props.locationStrategy, reset);
        onScopeDispose(() => {
          window.removeEventListener("resize", onResize);
          updateLocation.value = void 0;
        });
        window.addEventListener("resize", onResize, {
          passive: true
        });
        if (typeof props.locationStrategy === "function") {
          updateLocation.value = (_a2 = props.locationStrategy(data, props, contentStyles)) == null ? void 0 : _a2.updateLocation;
        } else {
          updateLocation.value = (_b = locationStrategies[props.locationStrategy](data, props, contentStyles)) == null ? void 0 : _b.updateLocation;
        }
      });
    }
    function onResize(e) {
      var _a2;
      (_a2 = updateLocation.value) == null ? void 0 : _a2.call(updateLocation, e);
    }
    return {
      contentStyles,
      updateLocation
    };
  }
  function staticLocationStrategy() {
  }
  function getIntrinsicSize(el, isRtl) {
    if (isRtl) {
      el.style.removeProperty("left");
    } else {
      el.style.removeProperty("right");
    }
    const contentBox = nullifyTransforms(el);
    if (isRtl) {
      contentBox.x += parseFloat(el.style.right || 0);
    } else {
      contentBox.x -= parseFloat(el.style.left || 0);
    }
    contentBox.y -= parseFloat(el.style.top || 0);
    return contentBox;
  }
  function connectedLocationStrategy(data, props, contentStyles) {
    const activatorFixed = Array.isArray(data.target.value) || isFixedPosition(data.target.value);
    if (activatorFixed) {
      Object.assign(contentStyles.value, {
        position: "fixed",
        top: 0,
        [data.isRtl.value ? "right" : "left"]: 0
      });
    }
    const {
      preferredAnchor,
      preferredOrigin
    } = destructComputed(() => {
      const parsedAnchor = parseAnchor(props.location, data.isRtl.value);
      const parsedOrigin = props.origin === "overlap" ? parsedAnchor : props.origin === "auto" ? flipSide(parsedAnchor) : parseAnchor(props.origin, data.isRtl.value);
      if (parsedAnchor.side === parsedOrigin.side && parsedAnchor.align === flipAlign(parsedOrigin).align) {
        return {
          preferredAnchor: flipCorner(parsedAnchor),
          preferredOrigin: flipCorner(parsedOrigin)
        };
      } else {
        return {
          preferredAnchor: parsedAnchor,
          preferredOrigin: parsedOrigin
        };
      }
    });
    const [minWidth, minHeight, maxWidth, maxHeight] = ["minWidth", "minHeight", "maxWidth", "maxHeight"].map((key) => {
      return computed2(() => {
        const val = parseFloat(props[key]);
        return isNaN(val) ? Infinity : val;
      });
    });
    const offset = computed2(() => {
      if (Array.isArray(props.offset)) {
        return props.offset;
      }
      if (typeof props.offset === "string") {
        const offset2 = props.offset.split(" ").map(parseFloat);
        if (offset2.length < 2)
          offset2.push(0);
        return offset2;
      }
      return typeof props.offset === "number" ? [props.offset, 0] : [0, 0];
    });
    let observe = false;
    const observer = new ResizeObserver(() => {
      if (observe)
        updateLocation();
    });
    watch([data.target, data.contentEl], (_ref, _ref2) => {
      let [newTarget, newContentEl] = _ref;
      let [oldTarget, oldContentEl] = _ref2;
      if (oldTarget && !Array.isArray(oldTarget))
        observer.unobserve(oldTarget);
      if (newTarget && !Array.isArray(newTarget))
        observer.observe(newTarget);
      if (oldContentEl)
        observer.unobserve(oldContentEl);
      if (newContentEl)
        observer.observe(newContentEl);
    }, {
      immediate: true
    });
    onScopeDispose(() => {
      observer.disconnect();
    });
    function updateLocation() {
      observe = false;
      requestAnimationFrame(() => observe = true);
      if (!data.target.value || !data.contentEl.value)
        return;
      const targetBox = getTargetBox(data.target.value);
      const contentBox = getIntrinsicSize(data.contentEl.value, data.isRtl.value);
      const scrollParents = getScrollParents(data.contentEl.value);
      const viewportMargin = 12;
      if (!scrollParents.length) {
        scrollParents.push(document.documentElement);
        if (!(data.contentEl.value.style.top && data.contentEl.value.style.left)) {
          contentBox.x -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-x") || 0);
          contentBox.y -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-y") || 0);
        }
      }
      const viewport = scrollParents.reduce((box, el) => {
        const rect = el.getBoundingClientRect();
        const scrollBox = new Box({
          x: el === document.documentElement ? 0 : rect.x,
          y: el === document.documentElement ? 0 : rect.y,
          width: el.clientWidth,
          height: el.clientHeight
        });
        if (box) {
          return new Box({
            x: Math.max(box.left, scrollBox.left),
            y: Math.max(box.top, scrollBox.top),
            width: Math.min(box.right, scrollBox.right) - Math.max(box.left, scrollBox.left),
            height: Math.min(box.bottom, scrollBox.bottom) - Math.max(box.top, scrollBox.top)
          });
        }
        return scrollBox;
      }, void 0);
      viewport.x += viewportMargin;
      viewport.y += viewportMargin;
      viewport.width -= viewportMargin * 2;
      viewport.height -= viewportMargin * 2;
      let placement = {
        anchor: preferredAnchor.value,
        origin: preferredOrigin.value
      };
      function checkOverflow(_placement) {
        const box = new Box(contentBox);
        const targetPoint = anchorToPoint(_placement.anchor, targetBox);
        const contentPoint = anchorToPoint(_placement.origin, box);
        let {
          x: x2,
          y: y2
        } = getOffset(targetPoint, contentPoint);
        switch (_placement.anchor.side) {
          case "top":
            y2 -= offset.value[0];
            break;
          case "bottom":
            y2 += offset.value[0];
            break;
          case "left":
            x2 -= offset.value[0];
            break;
          case "right":
            x2 += offset.value[0];
            break;
        }
        switch (_placement.anchor.align) {
          case "top":
            y2 -= offset.value[1];
            break;
          case "bottom":
            y2 += offset.value[1];
            break;
          case "left":
            x2 -= offset.value[1];
            break;
          case "right":
            x2 += offset.value[1];
            break;
        }
        box.x += x2;
        box.y += y2;
        box.width = Math.min(box.width, maxWidth.value);
        box.height = Math.min(box.height, maxHeight.value);
        const overflows = getOverflow(box, viewport);
        return {
          overflows,
          x: x2,
          y: y2
        };
      }
      let x = 0;
      let y = 0;
      const available = {
        x: 0,
        y: 0
      };
      const flipped = {
        x: false,
        y: false
      };
      let resets = -1;
      while (true) {
        if (resets++ > 10) {
          consoleError("Infinite loop detected in connectedLocationStrategy");
          break;
        }
        const {
          x: _x,
          y: _y,
          overflows
        } = checkOverflow(placement);
        x += _x;
        y += _y;
        contentBox.x += _x;
        contentBox.y += _y;
        {
          const axis2 = getAxis(placement.anchor);
          const hasOverflowX = overflows.x.before || overflows.x.after;
          const hasOverflowY = overflows.y.before || overflows.y.after;
          let reset = false;
          ["x", "y"].forEach((key) => {
            if (key === "x" && hasOverflowX && !flipped.x || key === "y" && hasOverflowY && !flipped.y) {
              const newPlacement = {
                anchor: __spreadValues({}, placement.anchor),
                origin: __spreadValues({}, placement.origin)
              };
              const flip = key === "x" ? axis2 === "y" ? flipAlign : flipSide : axis2 === "y" ? flipSide : flipAlign;
              newPlacement.anchor = flip(newPlacement.anchor);
              newPlacement.origin = flip(newPlacement.origin);
              const {
                overflows: newOverflows
              } = checkOverflow(newPlacement);
              if (newOverflows[key].before <= overflows[key].before && newOverflows[key].after <= overflows[key].after || newOverflows[key].before + newOverflows[key].after < (overflows[key].before + overflows[key].after) / 2) {
                placement = newPlacement;
                reset = flipped[key] = true;
              }
            }
          });
          if (reset)
            continue;
        }
        if (overflows.x.before) {
          x += overflows.x.before;
          contentBox.x += overflows.x.before;
        }
        if (overflows.x.after) {
          x -= overflows.x.after;
          contentBox.x -= overflows.x.after;
        }
        if (overflows.y.before) {
          y += overflows.y.before;
          contentBox.y += overflows.y.before;
        }
        if (overflows.y.after) {
          y -= overflows.y.after;
          contentBox.y -= overflows.y.after;
        }
        {
          const overflows2 = getOverflow(contentBox, viewport);
          available.x = viewport.width - overflows2.x.before - overflows2.x.after;
          available.y = viewport.height - overflows2.y.before - overflows2.y.after;
          x += overflows2.x.before;
          contentBox.x += overflows2.x.before;
          y += overflows2.y.before;
          contentBox.y += overflows2.y.before;
        }
        break;
      }
      const axis = getAxis(placement.anchor);
      Object.assign(contentStyles.value, {
        "--v-overlay-anchor-origin": `${placement.anchor.side} ${placement.anchor.align}`,
        transformOrigin: `${placement.origin.side} ${placement.origin.align}`,
        top: convertToUnit(pixelRound(y)),
        left: data.isRtl.value ? void 0 : convertToUnit(pixelRound(x)),
        right: data.isRtl.value ? convertToUnit(pixelRound(-x)) : void 0,
        minWidth: convertToUnit(axis === "y" ? Math.min(minWidth.value, targetBox.width) : minWidth.value),
        maxWidth: convertToUnit(pixelCeil(clamp(available.x, minWidth.value === Infinity ? 0 : minWidth.value, maxWidth.value))),
        maxHeight: convertToUnit(pixelCeil(clamp(available.y, minHeight.value === Infinity ? 0 : minHeight.value, maxHeight.value)))
      });
      return {
        available,
        contentBox
      };
    }
    watch(() => [preferredAnchor.value, preferredOrigin.value, props.offset, props.minWidth, props.minHeight, props.maxWidth, props.maxHeight], () => updateLocation());
    nextTick(() => {
      const result = updateLocation();
      if (!result)
        return;
      const {
        available,
        contentBox
      } = result;
      if (contentBox.height > available.y) {
        requestAnimationFrame(() => {
          updateLocation();
          requestAnimationFrame(() => {
            updateLocation();
          });
        });
      }
    });
    return {
      updateLocation
    };
  }
  function pixelRound(val) {
    return Math.round(val * devicePixelRatio) / devicePixelRatio;
  }
  function pixelCeil(val) {
    return Math.ceil(val * devicePixelRatio) / devicePixelRatio;
  }

  // ../library_management/node_modules/vuetify/lib/components/VOverlay/requestNewFrame.mjs
  var clean = true;
  var frames = [];
  function requestNewFrame(cb) {
    if (!clean || frames.length) {
      frames.push(cb);
      run();
    } else {
      clean = false;
      cb();
      run();
    }
  }
  var raf = -1;
  function run() {
    cancelAnimationFrame(raf);
    raf = requestAnimationFrame(() => {
      const frame = frames.shift();
      if (frame)
        frame();
      if (frames.length)
        run();
      else
        clean = true;
    });
  }

  // ../library_management/node_modules/vuetify/lib/components/VOverlay/scrollStrategies.mjs
  var scrollStrategies = {
    none: null,
    close: closeScrollStrategy,
    block: blockScrollStrategy,
    reposition: repositionScrollStrategy
  };
  var makeScrollStrategyProps = propsFactory({
    scrollStrategy: {
      type: [String, Function],
      default: "block",
      validator: (val) => typeof val === "function" || val in scrollStrategies
    }
  }, "VOverlay-scroll-strategies");
  function useScrollStrategies(props, data) {
    if (!IN_BROWSER)
      return;
    let scope;
    watchEffect(async () => {
      scope == null ? void 0 : scope.stop();
      if (!(data.isActive.value && props.scrollStrategy))
        return;
      scope = effectScope();
      await new Promise((resolve2) => setTimeout(resolve2));
      scope.active && scope.run(() => {
        var _a2;
        if (typeof props.scrollStrategy === "function") {
          props.scrollStrategy(data, props, scope);
        } else {
          (_a2 = scrollStrategies[props.scrollStrategy]) == null ? void 0 : _a2.call(scrollStrategies, data, props, scope);
        }
      });
    });
    onScopeDispose(() => {
      scope == null ? void 0 : scope.stop();
    });
  }
  function closeScrollStrategy(data) {
    var _a2;
    function onScroll(e) {
      data.isActive.value = false;
    }
    bindScroll((_a2 = data.targetEl.value) != null ? _a2 : data.contentEl.value, onScroll);
  }
  function blockScrollStrategy(data, props) {
    var _a2;
    const offsetParent = (_a2 = data.root.value) == null ? void 0 : _a2.offsetParent;
    const scrollElements = [.../* @__PURE__ */ new Set([...getScrollParents(data.targetEl.value, props.contained ? offsetParent : void 0), ...getScrollParents(data.contentEl.value, props.contained ? offsetParent : void 0)])].filter((el) => !el.classList.contains("v-overlay-scroll-blocked"));
    const scrollbarWidth = window.innerWidth - document.documentElement.offsetWidth;
    const scrollableParent = ((el) => hasScrollbar(el) && el)(offsetParent || document.documentElement);
    if (scrollableParent) {
      data.root.value.classList.add("v-overlay--scroll-blocked");
    }
    scrollElements.forEach((el, i) => {
      el.style.setProperty("--v-body-scroll-x", convertToUnit(-el.scrollLeft));
      el.style.setProperty("--v-body-scroll-y", convertToUnit(-el.scrollTop));
      if (el !== document.documentElement) {
        el.style.setProperty("--v-scrollbar-offset", convertToUnit(scrollbarWidth));
      }
      el.classList.add("v-overlay-scroll-blocked");
    });
    onScopeDispose(() => {
      scrollElements.forEach((el, i) => {
        const x = parseFloat(el.style.getPropertyValue("--v-body-scroll-x"));
        const y = parseFloat(el.style.getPropertyValue("--v-body-scroll-y"));
        const scrollBehavior = el.style.scrollBehavior;
        el.style.scrollBehavior = "auto";
        el.style.removeProperty("--v-body-scroll-x");
        el.style.removeProperty("--v-body-scroll-y");
        el.style.removeProperty("--v-scrollbar-offset");
        el.classList.remove("v-overlay-scroll-blocked");
        el.scrollLeft = -x;
        el.scrollTop = -y;
        el.style.scrollBehavior = scrollBehavior;
      });
      if (scrollableParent) {
        data.root.value.classList.remove("v-overlay--scroll-blocked");
      }
    });
  }
  function repositionScrollStrategy(data, props, scope) {
    let slow = false;
    let raf2 = -1;
    let ric = -1;
    function update(e) {
      requestNewFrame(() => {
        var _a2, _b;
        const start = performance.now();
        (_b = (_a2 = data.updateLocation).value) == null ? void 0 : _b.call(_a2, e);
        const time = performance.now() - start;
        slow = time / (1e3 / 60) > 2;
      });
    }
    ric = (typeof requestIdleCallback === "undefined" ? (cb) => cb() : requestIdleCallback)(() => {
      scope.run(() => {
        var _a2;
        bindScroll((_a2 = data.targetEl.value) != null ? _a2 : data.contentEl.value, (e) => {
          if (slow) {
            cancelAnimationFrame(raf2);
            raf2 = requestAnimationFrame(() => {
              raf2 = requestAnimationFrame(() => {
                update(e);
              });
            });
          } else {
            update(e);
          }
        });
      });
    });
    onScopeDispose(() => {
      typeof cancelIdleCallback !== "undefined" && cancelIdleCallback(ric);
      cancelAnimationFrame(raf2);
    });
  }
  function bindScroll(el, onScroll) {
    const scrollElements = [document, ...getScrollParents(el)];
    scrollElements.forEach((el2) => {
      el2.addEventListener("scroll", onScroll, {
        passive: true
      });
    });
    onScopeDispose(() => {
      scrollElements.forEach((el2) => {
        el2.removeEventListener("scroll", onScroll);
      });
    });
  }

  // ../library_management/node_modules/vuetify/lib/components/VMenu/shared.mjs
  var VMenuSymbol = Symbol.for("vuetify:v-menu");

  // ../library_management/node_modules/vuetify/lib/composables/delay.mjs
  var makeDelayProps = propsFactory({
    closeDelay: [Number, String],
    openDelay: [Number, String]
  }, "delay");
  function useDelay(props, cb) {
    let clearDelay = () => {
    };
    function runDelay(isOpening) {
      clearDelay == null ? void 0 : clearDelay();
      const delay = Number(isOpening ? props.openDelay : props.closeDelay);
      return new Promise((resolve2) => {
        clearDelay = defer2(delay, () => {
          cb == null ? void 0 : cb(isOpening);
          resolve2(isOpening);
        });
      });
    }
    function runOpenDelay() {
      return runDelay(true);
    }
    function runCloseDelay() {
      return runDelay(false);
    }
    return {
      clearDelay,
      runOpenDelay,
      runCloseDelay
    };
  }

  // ../library_management/node_modules/vuetify/lib/components/VOverlay/useActivator.mjs
  var makeActivatorProps = propsFactory(__spreadValues({
    target: [String, Object],
    activator: [String, Object],
    activatorProps: {
      type: Object,
      default: () => ({})
    },
    openOnClick: {
      type: Boolean,
      default: void 0
    },
    openOnHover: Boolean,
    openOnFocus: {
      type: Boolean,
      default: void 0
    },
    closeOnContentClick: Boolean
  }, makeDelayProps()), "VOverlay-activator");
  function useActivator(props, _ref) {
    let {
      isActive,
      isTop
    } = _ref;
    const vm = getCurrentInstance2("useActivator");
    const activatorEl = ref();
    let isHovered = false;
    let isFocused = false;
    let firstEnter = true;
    const openOnFocus = computed2(() => props.openOnFocus || props.openOnFocus == null && props.openOnHover);
    const openOnClick = computed2(() => props.openOnClick || props.openOnClick == null && !props.openOnHover && !openOnFocus.value);
    const {
      runOpenDelay,
      runCloseDelay
    } = useDelay(props, (value) => {
      if (value === (props.openOnHover && isHovered || openOnFocus.value && isFocused) && !(props.openOnHover && isActive.value && !isTop.value)) {
        if (isActive.value !== value) {
          firstEnter = true;
        }
        isActive.value = value;
      }
    });
    const cursorTarget = ref();
    const availableEvents = {
      onClick: (e) => {
        e.stopPropagation();
        activatorEl.value = e.currentTarget || e.target;
        if (!isActive.value) {
          cursorTarget.value = [e.clientX, e.clientY];
        }
        isActive.value = !isActive.value;
      },
      onMouseenter: (e) => {
        var _a2;
        if ((_a2 = e.sourceCapabilities) == null ? void 0 : _a2.firesTouchEvents)
          return;
        isHovered = true;
        activatorEl.value = e.currentTarget || e.target;
        runOpenDelay();
      },
      onMouseleave: (e) => {
        isHovered = false;
        runCloseDelay();
      },
      onFocus: (e) => {
        if (matchesSelector(e.target, ":focus-visible") === false)
          return;
        isFocused = true;
        e.stopPropagation();
        activatorEl.value = e.currentTarget || e.target;
        runOpenDelay();
      },
      onBlur: (e) => {
        isFocused = false;
        e.stopPropagation();
        runCloseDelay();
      }
    };
    const activatorEvents = computed2(() => {
      const events = {};
      if (openOnClick.value) {
        events.onClick = availableEvents.onClick;
      }
      if (props.openOnHover) {
        events.onMouseenter = availableEvents.onMouseenter;
        events.onMouseleave = availableEvents.onMouseleave;
      }
      if (openOnFocus.value) {
        events.onFocus = availableEvents.onFocus;
        events.onBlur = availableEvents.onBlur;
      }
      return events;
    });
    const contentEvents = computed2(() => {
      const events = {};
      if (props.openOnHover) {
        events.onMouseenter = () => {
          isHovered = true;
          runOpenDelay();
        };
        events.onMouseleave = () => {
          isHovered = false;
          runCloseDelay();
        };
      }
      if (openOnFocus.value) {
        events.onFocusin = () => {
          isFocused = true;
          runOpenDelay();
        };
        events.onFocusout = () => {
          isFocused = false;
          runCloseDelay();
        };
      }
      if (props.closeOnContentClick) {
        const menu = inject(VMenuSymbol, null);
        events.onClick = () => {
          isActive.value = false;
          menu == null ? void 0 : menu.closeParents();
        };
      }
      return events;
    });
    const scrimEvents = computed2(() => {
      const events = {};
      if (props.openOnHover) {
        events.onMouseenter = () => {
          if (firstEnter) {
            isHovered = true;
            firstEnter = false;
            runOpenDelay();
          }
        };
        events.onMouseleave = () => {
          isHovered = false;
          runCloseDelay();
        };
      }
      return events;
    });
    watch(isTop, (val) => {
      if (val && (props.openOnHover && !isHovered && (!openOnFocus.value || !isFocused) || openOnFocus.value && !isFocused && (!props.openOnHover || !isHovered))) {
        isActive.value = false;
      }
    });
    watch(isActive, (val) => {
      if (!val) {
        setTimeout(() => {
          cursorTarget.value = void 0;
        });
      }
    }, {
      flush: "post"
    });
    const activatorRef = ref();
    watchEffect(() => {
      if (!activatorRef.value)
        return;
      nextTick(() => {
        activatorEl.value = refElement(activatorRef.value);
      });
    });
    const targetRef = ref();
    const target = computed2(() => {
      if (props.target === "cursor" && cursorTarget.value)
        return cursorTarget.value;
      if (targetRef.value)
        return refElement(targetRef.value);
      return getTarget2(props.target, vm) || activatorEl.value;
    });
    const targetEl = computed2(() => {
      return Array.isArray(target.value) ? void 0 : target.value;
    });
    let scope;
    watch(() => !!props.activator, (val) => {
      if (val && IN_BROWSER) {
        scope = effectScope();
        scope.run(() => {
          _useActivator(props, vm, {
            activatorEl,
            activatorEvents
          });
        });
      } else if (scope) {
        scope.stop();
      }
    }, {
      flush: "post",
      immediate: true
    });
    onScopeDispose(() => {
      scope == null ? void 0 : scope.stop();
    });
    return {
      activatorEl,
      activatorRef,
      target,
      targetEl,
      targetRef,
      activatorEvents,
      contentEvents,
      scrimEvents
    };
  }
  function _useActivator(props, vm, _ref2) {
    let {
      activatorEl,
      activatorEvents
    } = _ref2;
    watch(() => props.activator, (val, oldVal) => {
      if (oldVal && val !== oldVal) {
        const activator = getActivator(oldVal);
        activator && unbindActivatorProps(activator);
      }
      if (val) {
        nextTick(() => bindActivatorProps());
      }
    }, {
      immediate: true
    });
    watch(() => props.activatorProps, () => {
      bindActivatorProps();
    });
    onScopeDispose(() => {
      unbindActivatorProps();
    });
    function bindActivatorProps() {
      let el = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getActivator();
      let _props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : props.activatorProps;
      if (!el)
        return;
      bindProps(el, mergeProps(activatorEvents.value, _props));
    }
    function unbindActivatorProps() {
      let el = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getActivator();
      let _props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : props.activatorProps;
      if (!el)
        return;
      unbindProps(el, mergeProps(activatorEvents.value, _props));
    }
    function getActivator() {
      let selector = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : props.activator;
      const activator = getTarget2(selector, vm);
      activatorEl.value = (activator == null ? void 0 : activator.nodeType) === Node.ELEMENT_NODE ? activator : void 0;
      return activatorEl.value;
    }
  }
  function getTarget2(selector, vm) {
    var _a2, _b;
    if (!selector)
      return;
    let target;
    if (selector === "parent") {
      let el = (_b = (_a2 = vm == null ? void 0 : vm.proxy) == null ? void 0 : _a2.$el) == null ? void 0 : _b.parentNode;
      while (el == null ? void 0 : el.hasAttribute("data-no-activator")) {
        el = el.parentNode;
      }
      target = el;
    } else if (typeof selector === "string") {
      target = document.querySelector(selector);
    } else if ("$el" in selector) {
      target = selector.$el;
    } else {
      target = selector;
    }
    return target;
  }

  // ../library_management/node_modules/vuetify/lib/composables/hydration.mjs
  function useHydration() {
    if (!IN_BROWSER)
      return shallowRef(false);
    const {
      ssr
    } = useDisplay();
    if (ssr) {
      const isMounted = shallowRef(false);
      onMounted(() => {
        isMounted.value = true;
      });
      return isMounted;
    } else {
      return shallowRef(true);
    }
  }

  // ../library_management/node_modules/vuetify/lib/composables/lazy.mjs
  var makeLazyProps = propsFactory({
    eager: Boolean
  }, "lazy");
  function useLazy(props, active) {
    const isBooted = shallowRef(false);
    const hasContent = computed2(() => isBooted.value || props.eager || active.value);
    watch(active, () => isBooted.value = true);
    function onAfterLeave() {
      if (!props.eager)
        isBooted.value = false;
    }
    return {
      isBooted,
      hasContent,
      onAfterLeave
    };
  }

  // ../library_management/node_modules/vuetify/lib/composables/scopeId.mjs
  function useScopeId() {
    const vm = getCurrentInstance2("useScopeId");
    const scopeId = vm.vnode.scopeId;
    return {
      scopeId: scopeId ? {
        [scopeId]: ""
      } : void 0
    };
  }

  // ../library_management/node_modules/vuetify/lib/composables/stack.mjs
  var StackSymbol = Symbol.for("vuetify:stack");
  var globalStack = reactive([]);
  function useStack(isActive, zIndex, disableGlobalStack) {
    const vm = getCurrentInstance2("useStack");
    const createStackEntry = !disableGlobalStack;
    const parent2 = inject(StackSymbol, void 0);
    const stack2 = reactive({
      activeChildren: /* @__PURE__ */ new Set()
    });
    provide(StackSymbol, stack2);
    const _zIndex = shallowRef(+zIndex.value);
    useToggleScope(isActive, () => {
      var _a2;
      const lastZIndex = (_a2 = globalStack.at(-1)) == null ? void 0 : _a2[1];
      _zIndex.value = lastZIndex ? lastZIndex + 10 : +zIndex.value;
      if (createStackEntry) {
        globalStack.push([vm.uid, _zIndex.value]);
      }
      parent2 == null ? void 0 : parent2.activeChildren.add(vm.uid);
      onScopeDispose(() => {
        if (createStackEntry) {
          const idx = toRaw(globalStack).findIndex((v) => v[0] === vm.uid);
          globalStack.splice(idx, 1);
        }
        parent2 == null ? void 0 : parent2.activeChildren.delete(vm.uid);
      });
    });
    const globalTop = shallowRef(true);
    if (createStackEntry) {
      watchEffect(() => {
        var _a2;
        const _isTop = ((_a2 = globalStack.at(-1)) == null ? void 0 : _a2[0]) === vm.uid;
        setTimeout(() => globalTop.value = _isTop);
      });
    }
    const localTop = computed2(() => !stack2.activeChildren.size);
    return {
      globalTop: readonly(globalTop),
      localTop,
      stackStyles: computed2(() => ({
        zIndex: _zIndex.value
      }))
    };
  }

  // ../library_management/node_modules/vuetify/lib/composables/teleport.mjs
  function useTeleport(target) {
    const teleportTarget = computed2(() => {
      const _target = target.value;
      if (_target === true || !IN_BROWSER)
        return void 0;
      const targetElement = _target === false ? document.body : typeof _target === "string" ? document.querySelector(_target) : _target;
      if (targetElement == null) {
        warn2(`Unable to locate target ${_target}`);
        return void 0;
      }
      let container = targetElement.querySelector(":scope > .v-overlay-container");
      if (!container) {
        container = document.createElement("div");
        container.className = "v-overlay-container";
        targetElement.appendChild(container);
      }
      return container;
    });
    return {
      teleportTarget
    };
  }

  // ../library_management/node_modules/vuetify/lib/directives/click-outside/index.mjs
  function defaultConditional() {
    return true;
  }
  function checkEvent(e, el, binding) {
    if (!e || checkIsActive(e, binding) === false)
      return false;
    const root = attachedRoot(el);
    if (typeof ShadowRoot !== "undefined" && root instanceof ShadowRoot && root.host === e.target)
      return false;
    const elements = (typeof binding.value === "object" && binding.value.include || (() => []))();
    elements.push(el);
    return !elements.some((el2) => el2 == null ? void 0 : el2.contains(e.target));
  }
  function checkIsActive(e, binding) {
    const isActive = typeof binding.value === "object" && binding.value.closeConditional || defaultConditional;
    return isActive(e);
  }
  function directive(e, el, binding) {
    const handler = typeof binding.value === "function" ? binding.value : binding.value.handler;
    el._clickOutside.lastMousedownWasOutside && checkEvent(e, el, binding) && setTimeout(() => {
      checkIsActive(e, binding) && handler && handler(e);
    }, 0);
  }
  function handleShadow(el, callback) {
    const root = attachedRoot(el);
    callback(document);
    if (typeof ShadowRoot !== "undefined" && root instanceof ShadowRoot) {
      callback(root);
    }
  }
  var ClickOutside = {
    mounted(el, binding) {
      const onClick = (e) => directive(e, el, binding);
      const onMousedown = (e) => {
        el._clickOutside.lastMousedownWasOutside = checkEvent(e, el, binding);
      };
      handleShadow(el, (app) => {
        app.addEventListener("click", onClick, true);
        app.addEventListener("mousedown", onMousedown, true);
      });
      if (!el._clickOutside) {
        el._clickOutside = {
          lastMousedownWasOutside: false
        };
      }
      el._clickOutside[binding.instance.$.uid] = {
        onClick,
        onMousedown
      };
    },
    unmounted(el, binding) {
      if (!el._clickOutside)
        return;
      handleShadow(el, (app) => {
        var _a2;
        if (!app || !((_a2 = el._clickOutside) == null ? void 0 : _a2[binding.instance.$.uid]))
          return;
        const {
          onClick,
          onMousedown
        } = el._clickOutside[binding.instance.$.uid];
        app.removeEventListener("click", onClick, true);
        app.removeEventListener("mousedown", onMousedown, true);
      });
      delete el._clickOutside[binding.instance.$.uid];
    }
  };

  // ../library_management/node_modules/vuetify/lib/components/VOverlay/VOverlay.mjs
  function Scrim(props) {
    const _a2 = props, {
      modelValue,
      color
    } = _a2, rest = __objRest(_a2, [
      "modelValue",
      "color"
    ]);
    return createVNode(Transition, {
      "name": "fade-transition",
      "appear": true
    }, {
      default: () => [props.modelValue && createVNode("div", mergeProps({
        "class": ["v-overlay__scrim", props.color.backgroundColorClasses.value],
        "style": props.color.backgroundColorStyles.value
      }, rest), null)]
    });
  }
  var makeVOverlayProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    absolute: Boolean,
    attach: [Boolean, String, Object],
    closeOnBack: {
      type: Boolean,
      default: true
    },
    contained: Boolean,
    contentClass: null,
    contentProps: null,
    disabled: Boolean,
    opacity: [Number, String],
    noClickAnimation: Boolean,
    modelValue: Boolean,
    persistent: Boolean,
    scrim: {
      type: [Boolean, String],
      default: true
    },
    zIndex: {
      type: [Number, String],
      default: 2e3
    }
  }, makeActivatorProps()), makeComponentProps()), makeDimensionProps()), makeLazyProps()), makeLocationStrategyProps()), makeScrollStrategyProps()), makeThemeProps()), makeTransitionProps2()), "VOverlay");
  var VOverlay = genericComponent()({
    name: "VOverlay",
    directives: {
      ClickOutside
    },
    inheritAttrs: false,
    props: __spreadValues({
      _disableGlobalStack: Boolean
    }, makeVOverlayProps()),
    emits: {
      "click:outside": (e) => true,
      "update:modelValue": (value) => true,
      afterLeave: () => true
    },
    setup(props, _ref) {
      let {
        slots,
        attrs,
        emit: emit2
      } = _ref;
      const model = useProxiedModel(props, "modelValue");
      const isActive = computed2({
        get: () => model.value,
        set: (v) => {
          if (!(v && props.disabled))
            model.value = v;
        }
      });
      const {
        teleportTarget
      } = useTeleport(computed2(() => props.attach || props.contained));
      const {
        themeClasses
      } = provideTheme(props);
      const {
        rtlClasses,
        isRtl
      } = useRtl();
      const {
        hasContent,
        onAfterLeave: _onAfterLeave
      } = useLazy(props, isActive);
      const scrimColor = useBackgroundColor(computed2(() => {
        return typeof props.scrim === "string" ? props.scrim : null;
      }));
      const {
        globalTop,
        localTop,
        stackStyles
      } = useStack(isActive, toRef(props, "zIndex"), props._disableGlobalStack);
      const {
        activatorEl,
        activatorRef,
        target,
        targetEl,
        targetRef,
        activatorEvents,
        contentEvents,
        scrimEvents
      } = useActivator(props, {
        isActive,
        isTop: localTop
      });
      const {
        dimensionStyles
      } = useDimension(props);
      const isMounted = useHydration();
      const {
        scopeId
      } = useScopeId();
      watch(() => props.disabled, (v) => {
        if (v)
          isActive.value = false;
      });
      const root = ref();
      const scrimEl = ref();
      const contentEl = ref();
      const {
        contentStyles,
        updateLocation
      } = useLocationStrategies(props, {
        isRtl,
        contentEl,
        target,
        isActive
      });
      useScrollStrategies(props, {
        root,
        contentEl,
        targetEl,
        isActive,
        updateLocation
      });
      function onClickOutside(e) {
        emit2("click:outside", e);
        if (!props.persistent)
          isActive.value = false;
        else
          animateClick();
      }
      function closeConditional(e) {
        return isActive.value && globalTop.value && (!props.scrim || e.target === scrimEl.value);
      }
      IN_BROWSER && watch(isActive, (val) => {
        if (val) {
          window.addEventListener("keydown", onKeydown);
        } else {
          window.removeEventListener("keydown", onKeydown);
        }
      }, {
        immediate: true
      });
      onBeforeUnmount(() => {
        if (!IN_BROWSER)
          return;
        window.removeEventListener("keydown", onKeydown);
      });
      function onKeydown(e) {
        var _a2, _b;
        if (e.key === "Escape" && globalTop.value) {
          if (!props.persistent) {
            isActive.value = false;
            if ((_a2 = contentEl.value) == null ? void 0 : _a2.contains(document.activeElement)) {
              (_b = activatorEl.value) == null ? void 0 : _b.focus();
            }
          } else
            animateClick();
        }
      }
      const router = useRouter();
      useToggleScope(() => props.closeOnBack, () => {
        useBackButton(router, (next) => {
          if (globalTop.value && isActive.value) {
            next(false);
            if (!props.persistent)
              isActive.value = false;
            else
              animateClick();
          } else {
            next();
          }
        });
      });
      const top = ref();
      watch(() => isActive.value && (props.absolute || props.contained) && teleportTarget.value == null, (val) => {
        if (val) {
          const scrollParent = getScrollParent(root.value);
          if (scrollParent && scrollParent !== document.scrollingElement) {
            top.value = scrollParent.scrollTop;
          }
        }
      });
      function animateClick() {
        if (props.noClickAnimation)
          return;
        contentEl.value && animate(contentEl.value, [{
          transformOrigin: "center"
        }, {
          transform: "scale(1.03)"
        }, {
          transformOrigin: "center"
        }], {
          duration: 150,
          easing: standardEasing
        });
      }
      function onAfterLeave() {
        _onAfterLeave();
        emit2("afterLeave");
      }
      useRender(() => {
        var _a2;
        return createVNode(Fragment, null, [(_a2 = slots.activator) == null ? void 0 : _a2.call(slots, {
          isActive: isActive.value,
          props: mergeProps({
            ref: activatorRef,
            targetRef
          }, activatorEvents.value, props.activatorProps)
        }), isMounted.value && hasContent.value && createVNode(Teleport, {
          "disabled": !teleportTarget.value,
          "to": teleportTarget.value
        }, {
          default: () => [createVNode("div", mergeProps({
            "class": ["v-overlay", {
              "v-overlay--absolute": props.absolute || props.contained,
              "v-overlay--active": isActive.value,
              "v-overlay--contained": props.contained
            }, themeClasses.value, rtlClasses.value, props.class],
            "style": [stackStyles.value, {
              "--v-overlay-opacity": props.opacity,
              top: convertToUnit(top.value)
            }, props.style],
            "ref": root
          }, scopeId, attrs), [createVNode(Scrim, mergeProps({
            "color": scrimColor,
            "modelValue": isActive.value && !!props.scrim,
            "ref": scrimEl
          }, scrimEvents.value), null), createVNode(MaybeTransition, {
            "appear": true,
            "persisted": true,
            "transition": props.transition,
            "target": target.value,
            "onAfterLeave": onAfterLeave
          }, {
            default: () => {
              var _a3;
              return [withDirectives(createVNode("div", mergeProps({
                "ref": contentEl,
                "class": ["v-overlay__content", props.contentClass],
                "style": [dimensionStyles.value, contentStyles.value]
              }, contentEvents.value, props.contentProps), [(_a3 = slots.default) == null ? void 0 : _a3.call(slots, {
                isActive
              })]), [[vShow, isActive.value], [resolveDirective("click-outside"), {
                handler: onClickOutside,
                closeConditional,
                include: () => [activatorEl.value]
              }]])];
            }
          })])]
        })]);
      });
      return {
        activatorEl,
        scrimEl,
        target,
        animateClick,
        contentEl,
        globalTop,
        localTop,
        updateLocation
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/composables/forwardRefs.mjs
  var Refs = Symbol("Forwarded refs");
  function getDescriptor(obj, key) {
    let currentObj = obj;
    while (currentObj) {
      const descriptor = Reflect.getOwnPropertyDescriptor(currentObj, key);
      if (descriptor)
        return descriptor;
      currentObj = Object.getPrototypeOf(currentObj);
    }
    return void 0;
  }
  function forwardRefs(target) {
    for (var _len = arguments.length, refs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      refs[_key - 1] = arguments[_key];
    }
    target[Refs] = refs;
    return new Proxy(target, {
      get(target2, key) {
        if (Reflect.has(target2, key)) {
          return Reflect.get(target2, key);
        }
        if (typeof key === "symbol" || key.startsWith("$") || key.startsWith("__"))
          return;
        for (const ref2 of refs) {
          if (ref2.value && Reflect.has(ref2.value, key)) {
            const val = Reflect.get(ref2.value, key);
            return typeof val === "function" ? val.bind(ref2.value) : val;
          }
        }
      },
      has(target2, key) {
        if (Reflect.has(target2, key)) {
          return true;
        }
        if (typeof key === "symbol" || key.startsWith("$") || key.startsWith("__"))
          return false;
        for (const ref2 of refs) {
          if (ref2.value && Reflect.has(ref2.value, key)) {
            return true;
          }
        }
        return false;
      },
      set(target2, key, value) {
        if (Reflect.has(target2, key)) {
          return Reflect.set(target2, key, value);
        }
        if (typeof key === "symbol" || key.startsWith("$") || key.startsWith("__"))
          return false;
        for (const ref2 of refs) {
          if (ref2.value && Reflect.has(ref2.value, key)) {
            return Reflect.set(ref2.value, key, value);
          }
        }
        return false;
      },
      getOwnPropertyDescriptor(target2, key) {
        var _a2, _b;
        const descriptor = Reflect.getOwnPropertyDescriptor(target2, key);
        if (descriptor)
          return descriptor;
        if (typeof key === "symbol" || key.startsWith("$") || key.startsWith("__"))
          return;
        for (const ref2 of refs) {
          if (!ref2.value)
            continue;
          const descriptor2 = (_b = getDescriptor(ref2.value, key)) != null ? _b : "_" in ref2.value ? getDescriptor((_a2 = ref2.value._) == null ? void 0 : _a2.setupState, key) : void 0;
          if (descriptor2)
            return descriptor2;
        }
        for (const ref2 of refs) {
          const childRefs = ref2.value && ref2.value[Refs];
          if (!childRefs)
            continue;
          const queue2 = childRefs.slice();
          while (queue2.length) {
            const ref3 = queue2.shift();
            const descriptor2 = getDescriptor(ref3.value, key);
            if (descriptor2)
              return descriptor2;
            const childRefs2 = ref3.value && ref3.value[Refs];
            if (childRefs2)
              queue2.push(...childRefs2);
          }
        }
        return void 0;
      }
    });
  }

  // ../library_management/node_modules/vuetify/lib/components/VMenu/VMenu.mjs
  var makeVMenuProps = propsFactory(__spreadValues({
    id: String
  }, omit(makeVOverlayProps({
    closeDelay: 250,
    closeOnContentClick: true,
    locationStrategy: "connected",
    openDelay: 300,
    scrim: false,
    scrollStrategy: "reposition",
    transition: {
      component: VDialogTransition
    }
  }), ["absolute"])), "VMenu");
  var VMenu = genericComponent()({
    name: "VMenu",
    props: makeVMenuProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const isActive = useProxiedModel(props, "modelValue");
      const {
        scopeId
      } = useScopeId();
      const uid2 = getUid();
      const id = computed2(() => props.id || `v-menu-${uid2}`);
      const overlay = ref();
      const parent2 = inject(VMenuSymbol, null);
      const openChildren = shallowRef(0);
      provide(VMenuSymbol, {
        register() {
          ++openChildren.value;
        },
        unregister() {
          --openChildren.value;
        },
        closeParents(e) {
          setTimeout(() => {
            if (!openChildren.value && (e == null || e && !isClickInsideElement(e, overlay.value.contentEl))) {
              isActive.value = false;
              parent2 == null ? void 0 : parent2.closeParents();
            }
          }, 40);
        }
      });
      async function onFocusIn(e) {
        var _a2, _b, _c;
        const before = e.relatedTarget;
        const after = e.target;
        await nextTick();
        if (isActive.value && before !== after && ((_a2 = overlay.value) == null ? void 0 : _a2.contentEl) && ((_b = overlay.value) == null ? void 0 : _b.globalTop) && ![document, overlay.value.contentEl].includes(after) && !overlay.value.contentEl.contains(after)) {
          const focusable = focusableChildren(overlay.value.contentEl);
          (_c = focusable[0]) == null ? void 0 : _c.focus();
        }
      }
      watch(isActive, (val) => {
        if (val) {
          parent2 == null ? void 0 : parent2.register();
          document.addEventListener("focusin", onFocusIn, {
            once: true
          });
        } else {
          parent2 == null ? void 0 : parent2.unregister();
          document.removeEventListener("focusin", onFocusIn);
        }
      });
      function onClickOutside(e) {
        parent2 == null ? void 0 : parent2.closeParents(e);
      }
      function onKeydown(e) {
        var _a2, _b, _c;
        if (props.disabled)
          return;
        if (e.key === "Tab") {
          const nextElement = getNextElement(focusableChildren((_a2 = overlay.value) == null ? void 0 : _a2.contentEl, false), e.shiftKey ? "prev" : "next", (el) => el.tabIndex >= 0);
          if (!nextElement) {
            isActive.value = false;
            (_c = (_b = overlay.value) == null ? void 0 : _b.activatorEl) == null ? void 0 : _c.focus();
          }
        } else if (["Enter", " "].includes(e.key) && props.closeOnContentClick) {
          isActive.value = false;
          parent2 == null ? void 0 : parent2.closeParents();
        }
      }
      function onActivatorKeydown(e) {
        var _a2;
        if (props.disabled)
          return;
        const el = (_a2 = overlay.value) == null ? void 0 : _a2.contentEl;
        if (el && isActive.value) {
          if (e.key === "ArrowDown") {
            e.preventDefault();
            focusChild(el, "next");
          } else if (e.key === "ArrowUp") {
            e.preventDefault();
            focusChild(el, "prev");
          }
        } else if (["ArrowDown", "ArrowUp"].includes(e.key)) {
          isActive.value = true;
          e.preventDefault();
          setTimeout(() => setTimeout(() => onActivatorKeydown(e)));
        }
      }
      const activatorProps = computed2(() => mergeProps({
        "aria-haspopup": "menu",
        "aria-expanded": String(isActive.value),
        "aria-owns": id.value,
        onKeydown: onActivatorKeydown
      }, props.activatorProps));
      useRender(() => {
        const overlayProps = VOverlay.filterProps(props);
        return createVNode(VOverlay, mergeProps({
          "ref": overlay,
          "id": id.value,
          "class": ["v-menu", props.class],
          "style": props.style
        }, overlayProps, {
          "modelValue": isActive.value,
          "onUpdate:modelValue": ($event) => isActive.value = $event,
          "absolute": true,
          "activatorProps": activatorProps.value,
          "onClick:outside": onClickOutside,
          "onKeydown": onKeydown
        }, scopeId), {
          activator: slots.activator,
          default: function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return createVNode(VDefaultsProvider, {
              "root": "VMenu"
            }, {
              default: () => {
                var _a2;
                return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, ...args)];
              }
            });
          }
        });
      });
      return forwardRefs({
        id,
        \u03A8openChildren: openChildren
      }, overlay);
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VCounter/VCounter.mjs
  var makeVCounterProps = propsFactory(__spreadValues(__spreadValues({
    active: Boolean,
    max: [Number, String],
    value: {
      type: [Number, String],
      default: 0
    }
  }, makeComponentProps()), makeTransitionProps2({
    transition: {
      component: VSlideYTransition
    }
  })), "VCounter");
  var VCounter = genericComponent()({
    name: "VCounter",
    functional: true,
    props: makeVCounterProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const counter = computed2(() => {
        return props.max ? `${props.value} / ${props.max}` : String(props.value);
      });
      useRender(() => createVNode(MaybeTransition, {
        "transition": props.transition
      }, {
        default: () => [withDirectives(createVNode("div", {
          "class": ["v-counter", props.class],
          "style": props.style
        }, [slots.default ? slots.default({
          counter: counter.value,
          max: props.max,
          value: props.value
        }) : counter.value]), [[vShow, props.active]])]
      }));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VField/VFieldLabel.mjs
  var makeVFieldLabelProps = propsFactory(__spreadValues({
    floating: Boolean
  }, makeComponentProps()), "VFieldLabel");
  var VFieldLabel = genericComponent()({
    name: "VFieldLabel",
    props: makeVFieldLabelProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useRender(() => createVNode(VLabel, {
        "class": ["v-field-label", {
          "v-field-label--floating": props.floating
        }, props.class],
        "style": props.style,
        "aria-hidden": props.floating || void 0
      }, slots));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VField/VField.mjs
  var allowedVariants2 = ["underlined", "outlined", "filled", "solo", "solo-inverted", "solo-filled", "plain"];
  var makeVFieldProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    appendInnerIcon: IconValue,
    bgColor: String,
    clearable: Boolean,
    clearIcon: {
      type: IconValue,
      default: "$clear"
    },
    active: Boolean,
    centerAffix: {
      type: Boolean,
      default: void 0
    },
    color: String,
    baseColor: String,
    dirty: Boolean,
    disabled: {
      type: Boolean,
      default: null
    },
    error: Boolean,
    flat: Boolean,
    label: String,
    persistentClear: Boolean,
    prependInnerIcon: IconValue,
    reverse: Boolean,
    singleLine: Boolean,
    variant: {
      type: String,
      default: "filled",
      validator: (v) => allowedVariants2.includes(v)
    },
    "onClick:clear": EventProp(),
    "onClick:appendInner": EventProp(),
    "onClick:prependInner": EventProp()
  }, makeComponentProps()), makeLoaderProps()), makeRoundedProps()), makeThemeProps()), "VField");
  var VField = genericComponent()({
    name: "VField",
    inheritAttrs: false,
    props: __spreadValues(__spreadValues({
      id: String
    }, makeFocusProps()), makeVFieldProps()),
    emits: {
      "update:focused": (focused) => true,
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        emit: emit2,
        slots
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      const {
        loaderClasses
      } = useLoader(props);
      const {
        focusClasses,
        isFocused,
        focus,
        blur
      } = useFocus(props);
      const {
        InputIcon
      } = useInputIcon(props);
      const {
        roundedClasses
      } = useRounded(props);
      const {
        rtlClasses
      } = useRtl();
      const isActive = computed2(() => props.dirty || props.active);
      const hasLabel = computed2(() => !props.singleLine && !!(props.label || slots.label));
      const uid2 = getUid();
      const id = computed2(() => props.id || `input-${uid2}`);
      const messagesId = computed2(() => `${id.value}-messages`);
      const labelRef = ref();
      const floatingLabelRef = ref();
      const controlRef = ref();
      const isPlainOrUnderlined = computed2(() => ["plain", "underlined"].includes(props.variant));
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(toRef(props, "bgColor"));
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(computed2(() => {
        return props.error || props.disabled ? void 0 : isActive.value && isFocused.value ? props.color : props.baseColor;
      }));
      watch(isActive, (val) => {
        if (hasLabel.value) {
          const el = labelRef.value.$el;
          const targetEl = floatingLabelRef.value.$el;
          requestAnimationFrame(() => {
            const rect = nullifyTransforms(el);
            const targetRect = targetEl.getBoundingClientRect();
            const x = targetRect.x - rect.x;
            const y = targetRect.y - rect.y - (rect.height / 2 - targetRect.height / 2);
            const targetWidth = targetRect.width / 0.75;
            const width = Math.abs(targetWidth - rect.width) > 1 ? {
              maxWidth: convertToUnit(targetWidth)
            } : void 0;
            const style = getComputedStyle(el);
            const targetStyle = getComputedStyle(targetEl);
            const duration = parseFloat(style.transitionDuration) * 1e3 || 150;
            const scale = parseFloat(targetStyle.getPropertyValue("--v-field-label-scale"));
            const color = targetStyle.getPropertyValue("color");
            el.style.visibility = "visible";
            targetEl.style.visibility = "hidden";
            animate(el, __spreadValues({
              transform: `translate(${x}px, ${y}px) scale(${scale})`,
              color
            }, width), {
              duration,
              easing: standardEasing,
              direction: val ? "normal" : "reverse"
            }).finished.then(() => {
              el.style.removeProperty("visibility");
              targetEl.style.removeProperty("visibility");
            });
          });
        }
      }, {
        flush: "post"
      });
      const slotProps = computed2(() => ({
        isActive,
        isFocused,
        controlRef,
        blur,
        focus
      }));
      function onClick(e) {
        if (e.target !== document.activeElement) {
          e.preventDefault();
        }
      }
      function onKeydownClear(e) {
        var _a2;
        if (e.key !== "Enter" && e.key !== " ")
          return;
        e.preventDefault();
        e.stopPropagation();
        (_a2 = props["onClick:clear"]) == null ? void 0 : _a2.call(props, new MouseEvent("click"));
      }
      useRender(() => {
        var _a2, _b, _c, _d;
        const isOutlined = props.variant === "outlined";
        const hasPrepend = !!(slots["prepend-inner"] || props.prependInnerIcon);
        const hasClear = !!(props.clearable || slots.clear);
        const hasAppend = !!(slots["append-inner"] || props.appendInnerIcon || hasClear);
        const label = () => slots.label ? slots.label(__spreadProps(__spreadValues({}, slotProps.value), {
          label: props.label,
          props: {
            for: id.value
          }
        })) : props.label;
        return createVNode("div", mergeProps({
          "class": ["v-field", {
            "v-field--active": isActive.value,
            "v-field--appended": hasAppend,
            "v-field--center-affix": (_a2 = props.centerAffix) != null ? _a2 : !isPlainOrUnderlined.value,
            "v-field--disabled": props.disabled,
            "v-field--dirty": props.dirty,
            "v-field--error": props.error,
            "v-field--flat": props.flat,
            "v-field--has-background": !!props.bgColor,
            "v-field--persistent-clear": props.persistentClear,
            "v-field--prepended": hasPrepend,
            "v-field--reverse": props.reverse,
            "v-field--single-line": props.singleLine,
            "v-field--no-label": !label(),
            [`v-field--variant-${props.variant}`]: true
          }, themeClasses.value, backgroundColorClasses.value, focusClasses.value, loaderClasses.value, roundedClasses.value, rtlClasses.value, props.class],
          "style": [backgroundColorStyles.value, props.style],
          "onClick": onClick
        }, attrs), [createVNode("div", {
          "class": "v-field__overlay"
        }, null), createVNode(LoaderSlot, {
          "name": "v-field",
          "active": !!props.loading,
          "color": props.error ? "error" : typeof props.loading === "string" ? props.loading : props.color
        }, {
          default: slots.loader
        }), hasPrepend && createVNode("div", {
          "key": "prepend",
          "class": "v-field__prepend-inner"
        }, [props.prependInnerIcon && createVNode(InputIcon, {
          "key": "prepend-icon",
          "name": "prependInner"
        }, null), (_b = slots["prepend-inner"]) == null ? void 0 : _b.call(slots, slotProps.value)]), createVNode("div", {
          "class": "v-field__field",
          "data-no-activator": ""
        }, [["filled", "solo", "solo-inverted", "solo-filled"].includes(props.variant) && hasLabel.value && createVNode(VFieldLabel, {
          "key": "floating-label",
          "ref": floatingLabelRef,
          "class": [textColorClasses.value],
          "floating": true,
          "for": id.value,
          "style": textColorStyles.value
        }, {
          default: () => [label()]
        }), createVNode(VFieldLabel, {
          "ref": labelRef,
          "for": id.value
        }, {
          default: () => [label()]
        }), (_c = slots.default) == null ? void 0 : _c.call(slots, __spreadProps(__spreadValues({}, slotProps.value), {
          props: {
            id: id.value,
            class: "v-field__input",
            "aria-describedby": messagesId.value
          },
          focus,
          blur
        }))]), hasClear && createVNode(VExpandXTransition, {
          "key": "clear"
        }, {
          default: () => [withDirectives(createVNode("div", {
            "class": "v-field__clearable",
            "onMousedown": (e) => {
              e.preventDefault();
              e.stopPropagation();
            }
          }, [createVNode(VDefaultsProvider, {
            "defaults": {
              VIcon: {
                icon: props.clearIcon
              }
            }
          }, {
            default: () => [slots.clear ? slots.clear(__spreadProps(__spreadValues({}, slotProps.value), {
              props: {
                onKeydown: onKeydownClear,
                onFocus: focus,
                onBlur: blur,
                onClick: props["onClick:clear"]
              }
            })) : createVNode(InputIcon, {
              "name": "clear",
              "onKeydown": onKeydownClear,
              "onFocus": focus,
              "onBlur": blur
            }, null)]
          })]), [[vShow, props.dirty]])]
        }), hasAppend && createVNode("div", {
          "key": "append",
          "class": "v-field__append-inner"
        }, [(_d = slots["append-inner"]) == null ? void 0 : _d.call(slots, slotProps.value), props.appendInnerIcon && createVNode(InputIcon, {
          "key": "append-icon",
          "name": "appendInner"
        }, null)]), createVNode("div", {
          "class": ["v-field__outline", textColorClasses.value],
          "style": textColorStyles.value
        }, [isOutlined && createVNode(Fragment, null, [createVNode("div", {
          "class": "v-field__outline__start"
        }, null), hasLabel.value && createVNode("div", {
          "class": "v-field__outline__notch"
        }, [createVNode(VFieldLabel, {
          "ref": floatingLabelRef,
          "floating": true,
          "for": id.value
        }, {
          default: () => [label()]
        })]), createVNode("div", {
          "class": "v-field__outline__end"
        }, null)]), isPlainOrUnderlined.value && hasLabel.value && createVNode(VFieldLabel, {
          "ref": floatingLabelRef,
          "floating": true,
          "for": id.value
        }, {
          default: () => [label()]
        })])]);
      });
      return {
        controlRef
      };
    }
  });
  function filterFieldProps(attrs) {
    const keys2 = Object.keys(VField.props).filter((k) => !isOn2(k) && k !== "class" && k !== "style");
    return pick(attrs, keys2);
  }

  // ../library_management/node_modules/vuetify/lib/components/VTextField/VTextField.mjs
  var activeTypes = ["color", "file", "time", "date", "datetime-local", "week", "month"];
  var makeVTextFieldProps = propsFactory(__spreadValues(__spreadValues({
    autofocus: Boolean,
    counter: [Boolean, Number, String],
    counterValue: [Number, Function],
    prefix: String,
    placeholder: String,
    persistentPlaceholder: Boolean,
    persistentCounter: Boolean,
    suffix: String,
    role: String,
    type: {
      type: String,
      default: "text"
    },
    modelModifiers: Object
  }, makeVInputProps()), makeVFieldProps()), "VTextField");
  var VTextField = genericComponent()({
    name: "VTextField",
    directives: {
      Intersect: intersect_default
    },
    inheritAttrs: false,
    props: makeVTextFieldProps(),
    emits: {
      "click:control": (e) => true,
      "mousedown:control": (e) => true,
      "update:focused": (focused) => true,
      "update:modelValue": (val) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        emit: emit2,
        slots
      } = _ref;
      const model = useProxiedModel(props, "modelValue");
      const {
        isFocused,
        focus,
        blur
      } = useFocus(props);
      const counterValue = computed2(() => {
        var _a2;
        return typeof props.counterValue === "function" ? props.counterValue(model.value) : typeof props.counterValue === "number" ? props.counterValue : ((_a2 = model.value) != null ? _a2 : "").toString().length;
      });
      const max = computed2(() => {
        if (attrs.maxlength)
          return attrs.maxlength;
        if (!props.counter || typeof props.counter !== "number" && typeof props.counter !== "string")
          return void 0;
        return props.counter;
      });
      const isPlainOrUnderlined = computed2(() => ["plain", "underlined"].includes(props.variant));
      function onIntersect(isIntersecting, entries) {
        var _a2, _b;
        if (!props.autofocus || !isIntersecting)
          return;
        (_b = (_a2 = entries[0].target) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
      }
      const vInputRef = ref();
      const vFieldRef = ref();
      const inputRef = ref();
      const isActive = computed2(() => activeTypes.includes(props.type) || props.persistentPlaceholder || isFocused.value || props.active);
      function onFocus() {
        var _a2;
        if (inputRef.value !== document.activeElement) {
          (_a2 = inputRef.value) == null ? void 0 : _a2.focus();
        }
        if (!isFocused.value)
          focus();
      }
      function onControlMousedown(e) {
        emit2("mousedown:control", e);
        if (e.target === inputRef.value)
          return;
        onFocus();
        e.preventDefault();
      }
      function onControlClick(e) {
        onFocus();
        emit2("click:control", e);
      }
      function onClear(e) {
        e.stopPropagation();
        onFocus();
        nextTick(() => {
          model.value = null;
          callEvent(props["onClick:clear"], e);
        });
      }
      function onInput(e) {
        var _a2;
        const el = e.target;
        model.value = el.value;
        if (((_a2 = props.modelModifiers) == null ? void 0 : _a2.trim) && ["text", "search", "password", "tel", "url"].includes(props.type)) {
          const caretPosition = [el.selectionStart, el.selectionEnd];
          nextTick(() => {
            el.selectionStart = caretPosition[0];
            el.selectionEnd = caretPosition[1];
          });
        }
      }
      useRender(() => {
        const hasCounter = !!(slots.counter || props.counter !== false && props.counter != null);
        const hasDetails = !!(hasCounter || slots.details);
        const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
        const _a2 = VInput.filterProps(props), {
          modelValue: _
        } = _a2, inputProps = __objRest(_a2, [
          "modelValue"
        ]);
        const fieldProps = filterFieldProps(props);
        return createVNode(VInput, mergeProps({
          "ref": vInputRef,
          "modelValue": model.value,
          "onUpdate:modelValue": ($event) => model.value = $event,
          "class": ["v-text-field", {
            "v-text-field--prefixed": props.prefix,
            "v-text-field--suffixed": props.suffix,
            "v-input--plain-underlined": isPlainOrUnderlined.value
          }, props.class],
          "style": props.style
        }, rootAttrs, inputProps, {
          "centerAffix": !isPlainOrUnderlined.value,
          "focused": isFocused.value
        }), __spreadProps(__spreadValues({}, slots), {
          default: (_ref2) => {
            let {
              id,
              isDisabled,
              isDirty,
              isReadonly: isReadonly2,
              isValid: isValid2
            } = _ref2;
            return createVNode(VField, mergeProps({
              "ref": vFieldRef,
              "onMousedown": onControlMousedown,
              "onClick": onControlClick,
              "onClick:clear": onClear,
              "onClick:prependInner": props["onClick:prependInner"],
              "onClick:appendInner": props["onClick:appendInner"],
              "role": props.role
            }, fieldProps, {
              "id": id.value,
              "active": isActive.value || isDirty.value,
              "dirty": isDirty.value || props.dirty,
              "disabled": isDisabled.value,
              "focused": isFocused.value,
              "error": isValid2.value === false
            }), __spreadProps(__spreadValues({}, slots), {
              default: (_ref3) => {
                let {
                  props: _a3
                } = _ref3, _b = _a3, {
                  class: fieldClass
                } = _b, slotProps = __objRest(_b, [
                  "class"
                ]);
                const inputNode = withDirectives(createVNode("input", mergeProps({
                  "ref": inputRef,
                  "value": model.value,
                  "onInput": onInput,
                  "autofocus": props.autofocus,
                  "readonly": isReadonly2.value,
                  "disabled": isDisabled.value,
                  "name": props.name,
                  "placeholder": props.placeholder,
                  "size": 1,
                  "type": props.type,
                  "onFocus": onFocus,
                  "onBlur": blur
                }, slotProps, inputAttrs), null), [[resolveDirective("intersect"), {
                  handler: onIntersect
                }, null, {
                  once: true
                }]]);
                return createVNode(Fragment, null, [props.prefix && createVNode("span", {
                  "class": "v-text-field__prefix"
                }, [createVNode("span", {
                  "class": "v-text-field__prefix__text"
                }, [props.prefix])]), slots.default ? createVNode("div", {
                  "class": fieldClass,
                  "data-no-activator": ""
                }, [slots.default(), inputNode]) : cloneVNode(inputNode, {
                  class: fieldClass
                }), props.suffix && createVNode("span", {
                  "class": "v-text-field__suffix"
                }, [createVNode("span", {
                  "class": "v-text-field__suffix__text"
                }, [props.suffix])])]);
              }
            }));
          },
          details: hasDetails ? (slotProps) => {
            var _a3;
            return createVNode(Fragment, null, [(_a3 = slots.details) == null ? void 0 : _a3.call(slots, slotProps), hasCounter && createVNode(Fragment, null, [createVNode("span", null, null), createVNode(VCounter, {
              "active": props.persistentCounter || isFocused.value,
              "value": counterValue.value,
              "max": max.value
            }, slots.counter)])]);
          } : void 0
        }));
      });
      return forwardRefs({}, vInputRef, vFieldRef, inputRef);
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VVirtualScroll/VVirtualScrollItem.mjs
  var makeVVirtualScrollItemProps = propsFactory(__spreadValues({
    renderless: Boolean
  }, makeComponentProps()), "VVirtualScrollItem");
  var VVirtualScrollItem = genericComponent()({
    name: "VVirtualScrollItem",
    inheritAttrs: false,
    props: makeVVirtualScrollItemProps(),
    emits: {
      "update:height": (height) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        emit: emit2,
        slots
      } = _ref;
      const {
        resizeRef,
        contentRect
      } = useResizeObserver(void 0, "border");
      watch(() => {
        var _a2;
        return (_a2 = contentRect.value) == null ? void 0 : _a2.height;
      }, (height) => {
        if (height != null)
          emit2("update:height", height);
      });
      useRender(() => {
        var _a2, _b;
        return props.renderless ? createVNode(Fragment, null, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
          itemRef: resizeRef
        })]) : createVNode("div", mergeProps({
          "ref": resizeRef,
          "class": ["v-virtual-scroll__item", props.class],
          "style": props.style
        }, attrs), [(_b = slots.default) == null ? void 0 : _b.call(slots)]);
      });
    }
  });

  // ../library_management/node_modules/vuetify/lib/composables/virtual.mjs
  var UP = -1;
  var DOWN = 1;
  var BUFFER_PX = 100;
  var makeVirtualProps = propsFactory({
    itemHeight: {
      type: [Number, String],
      default: null
    },
    height: [Number, String]
  }, "virtual");
  function useVirtual(props, items) {
    const display = useDisplay();
    const itemHeight = shallowRef(0);
    watchEffect(() => {
      itemHeight.value = parseFloat(props.itemHeight || 0);
    });
    const first = shallowRef(0);
    const last = shallowRef(Math.ceil(
      (parseInt(props.height) || display.height.value) / (itemHeight.value || 16)
    ) || 1);
    const paddingTop = shallowRef(0);
    const paddingBottom = shallowRef(0);
    const containerRef = ref();
    const markerRef = ref();
    let markerOffset = 0;
    const {
      resizeRef,
      contentRect
    } = useResizeObserver();
    watchEffect(() => {
      resizeRef.value = containerRef.value;
    });
    const viewportHeight = computed2(() => {
      var _a2;
      return containerRef.value === document.documentElement ? display.height.value : ((_a2 = contentRect.value) == null ? void 0 : _a2.height) || parseInt(props.height) || 0;
    });
    const hasInitialRender = computed2(() => {
      return !!(containerRef.value && markerRef.value && viewportHeight.value && itemHeight.value);
    });
    let sizes = Array.from({
      length: items.value.length
    });
    let offsets = Array.from({
      length: items.value.length
    });
    const updateTime = shallowRef(0);
    let targetScrollIndex = -1;
    function getSize(index) {
      return sizes[index] || itemHeight.value;
    }
    const updateOffsets = debounce2(() => {
      const start = performance.now();
      offsets[0] = 0;
      const length = items.value.length;
      for (let i = 1; i <= length - 1; i++) {
        offsets[i] = (offsets[i - 1] || 0) + getSize(i - 1);
      }
      updateTime.value = Math.max(updateTime.value, performance.now() - start);
    }, updateTime);
    const unwatch = watch(hasInitialRender, (v) => {
      if (!v)
        return;
      unwatch();
      markerOffset = markerRef.value.offsetTop;
      updateOffsets.immediate();
      calculateVisibleItems();
      if (!~targetScrollIndex)
        return;
      nextTick(() => {
        IN_BROWSER && window.requestAnimationFrame(() => {
          scrollToIndex(targetScrollIndex);
          targetScrollIndex = -1;
        });
      });
    });
    onScopeDispose(() => {
      updateOffsets.clear();
    });
    function handleItemResize(index, height) {
      const prevHeight = sizes[index];
      const prevMinHeight = itemHeight.value;
      itemHeight.value = prevMinHeight ? Math.min(itemHeight.value, height) : height;
      if (prevHeight !== height || prevMinHeight !== itemHeight.value) {
        sizes[index] = height;
        updateOffsets();
      }
    }
    function calculateOffset(index) {
      index = clamp(index, 0, items.value.length - 1);
      return offsets[index] || 0;
    }
    function calculateIndex(scrollTop) {
      return binaryClosest(offsets, scrollTop);
    }
    let lastScrollTop = 0;
    let scrollVelocity = 0;
    let lastScrollTime = 0;
    watch(viewportHeight, (val, oldVal) => {
      if (oldVal) {
        calculateVisibleItems();
        if (val < oldVal) {
          requestAnimationFrame(() => {
            scrollVelocity = 0;
            calculateVisibleItems();
          });
        }
      }
    });
    function handleScroll() {
      if (!containerRef.value || !markerRef.value)
        return;
      const scrollTop = containerRef.value.scrollTop;
      const scrollTime = performance.now();
      const scrollDeltaT = scrollTime - lastScrollTime;
      if (scrollDeltaT > 500) {
        scrollVelocity = Math.sign(scrollTop - lastScrollTop);
        markerOffset = markerRef.value.offsetTop;
      } else {
        scrollVelocity = scrollTop - lastScrollTop;
      }
      lastScrollTop = scrollTop;
      lastScrollTime = scrollTime;
      calculateVisibleItems();
    }
    function handleScrollend() {
      if (!containerRef.value || !markerRef.value)
        return;
      scrollVelocity = 0;
      lastScrollTime = 0;
      calculateVisibleItems();
    }
    let raf2 = -1;
    function calculateVisibleItems() {
      cancelAnimationFrame(raf2);
      raf2 = requestAnimationFrame(_calculateVisibleItems);
    }
    function _calculateVisibleItems() {
      if (!containerRef.value || !viewportHeight.value)
        return;
      const scrollTop = lastScrollTop - markerOffset;
      const direction = Math.sign(scrollVelocity);
      const startPx = Math.max(0, scrollTop - BUFFER_PX);
      const start = clamp(calculateIndex(startPx), 0, items.value.length);
      const endPx = scrollTop + viewportHeight.value + BUFFER_PX;
      const end = clamp(calculateIndex(endPx) + 1, start + 1, items.value.length);
      if ((direction !== UP || start < first.value) && (direction !== DOWN || end > last.value)) {
        const topOverflow = calculateOffset(first.value) - calculateOffset(start);
        const bottomOverflow = calculateOffset(end) - calculateOffset(last.value);
        const bufferOverflow = Math.max(topOverflow, bottomOverflow);
        if (bufferOverflow > BUFFER_PX) {
          first.value = start;
          last.value = end;
        } else {
          if (start <= 0)
            first.value = start;
          if (end >= items.value.length)
            last.value = end;
        }
      }
      paddingTop.value = calculateOffset(first.value);
      paddingBottom.value = calculateOffset(items.value.length) - calculateOffset(last.value);
    }
    function scrollToIndex(index) {
      const offset = calculateOffset(index);
      if (!containerRef.value || index && !offset) {
        targetScrollIndex = index;
      } else {
        containerRef.value.scrollTop = offset;
      }
    }
    const computedItems = computed2(() => {
      return items.value.slice(first.value, last.value).map((item, index) => ({
        raw: item,
        index: index + first.value
      }));
    });
    watch(items, () => {
      sizes = Array.from({
        length: items.value.length
      });
      offsets = Array.from({
        length: items.value.length
      });
      updateOffsets.immediate();
      calculateVisibleItems();
    }, {
      deep: true
    });
    return {
      containerRef,
      markerRef,
      computedItems,
      paddingTop,
      paddingBottom,
      scrollToIndex,
      handleScroll,
      handleScrollend,
      handleItemResize
    };
  }
  function binaryClosest(arr, val) {
    let high = arr.length - 1;
    let low = 0;
    let mid = 0;
    let item = null;
    let target = -1;
    if (arr[high] < val) {
      return high;
    }
    while (low <= high) {
      mid = low + high >> 1;
      item = arr[mid];
      if (item > val) {
        high = mid - 1;
      } else if (item < val) {
        target = mid;
        low = mid + 1;
      } else if (item === val) {
        return mid;
      } else {
        return low;
      }
    }
    return target;
  }

  // ../library_management/node_modules/vuetify/lib/components/VVirtualScroll/VVirtualScroll.mjs
  var makeVVirtualScrollProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({
    items: {
      type: Array,
      default: () => []
    },
    renderless: Boolean
  }, makeVirtualProps()), makeComponentProps()), makeDimensionProps()), "VVirtualScroll");
  var VVirtualScroll = genericComponent()({
    name: "VVirtualScroll",
    props: makeVVirtualScrollProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const vm = getCurrentInstance2("VVirtualScroll");
      const {
        dimensionStyles
      } = useDimension(props);
      const {
        containerRef,
        markerRef,
        handleScroll,
        handleScrollend,
        handleItemResize,
        scrollToIndex,
        paddingTop,
        paddingBottom,
        computedItems
      } = useVirtual(props, toRef(props, "items"));
      useToggleScope(() => props.renderless, () => {
        function handleListeners() {
          var _a2, _b;
          let add2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
          const method = add2 ? "addEventListener" : "removeEventListener";
          if (containerRef.value === document.documentElement) {
            document[method]("scroll", handleScroll, {
              passive: true
            });
            document[method]("scrollend", handleScrollend);
          } else {
            (_a2 = containerRef.value) == null ? void 0 : _a2[method]("scroll", handleScroll, {
              passive: true
            });
            (_b = containerRef.value) == null ? void 0 : _b[method]("scrollend", handleScrollend);
          }
        }
        onMounted(() => {
          containerRef.value = getScrollParent(vm.vnode.el, true);
          handleListeners(true);
        });
        onScopeDispose(handleListeners);
      });
      useRender(() => {
        const children = computedItems.value.map((item) => createVNode(VVirtualScrollItem, {
          "key": item.index,
          "renderless": props.renderless,
          "onUpdate:height": (height) => handleItemResize(item.index, height)
        }, {
          default: (slotProps) => {
            var _a2;
            return (_a2 = slots.default) == null ? void 0 : _a2.call(slots, __spreadValues({
              item: item.raw,
              index: item.index
            }, slotProps));
          }
        }));
        return props.renderless ? createVNode(Fragment, null, [createVNode("div", {
          "ref": markerRef,
          "class": "v-virtual-scroll__spacer",
          "style": {
            paddingTop: convertToUnit(paddingTop.value)
          }
        }, null), children, createVNode("div", {
          "class": "v-virtual-scroll__spacer",
          "style": {
            paddingBottom: convertToUnit(paddingBottom.value)
          }
        }, null)]) : createVNode("div", {
          "ref": containerRef,
          "class": ["v-virtual-scroll", props.class],
          "onScrollPassive": handleScroll,
          "onScrollend": handleScrollend,
          "style": [dimensionStyles.value, props.style]
        }, [createVNode("div", {
          "ref": markerRef,
          "class": "v-virtual-scroll__container",
          "style": {
            paddingTop: convertToUnit(paddingTop.value),
            paddingBottom: convertToUnit(paddingBottom.value)
          }
        }, [children])]);
      });
      return {
        scrollToIndex
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VSelect/useScrolling.mjs
  function useScrolling(listRef, textFieldRef) {
    const isScrolling = shallowRef(false);
    let scrollTimeout;
    function onListScroll(e) {
      cancelAnimationFrame(scrollTimeout);
      isScrolling.value = true;
      scrollTimeout = requestAnimationFrame(() => {
        scrollTimeout = requestAnimationFrame(() => {
          isScrolling.value = false;
        });
      });
    }
    async function finishScrolling() {
      await new Promise((resolve2) => requestAnimationFrame(resolve2));
      await new Promise((resolve2) => requestAnimationFrame(resolve2));
      await new Promise((resolve2) => requestAnimationFrame(resolve2));
      await new Promise((resolve2) => {
        if (isScrolling.value) {
          const stop2 = watch(isScrolling, () => {
            stop2();
            resolve2();
          });
        } else
          resolve2();
      });
    }
    async function onListKeydown(e) {
      var _a2, _b;
      if (e.key === "Tab") {
        (_a2 = textFieldRef.value) == null ? void 0 : _a2.focus();
      }
      if (!["PageDown", "PageUp", "Home", "End"].includes(e.key))
        return;
      const el = (_b = listRef.value) == null ? void 0 : _b.$el;
      if (!el)
        return;
      if (e.key === "Home" || e.key === "End") {
        el.scrollTo({
          top: e.key === "Home" ? 0 : el.scrollHeight,
          behavior: "smooth"
        });
      }
      await finishScrolling();
      const children = el.querySelectorAll(":scope > :not(.v-virtual-scroll__spacer)");
      if (e.key === "PageDown" || e.key === "Home") {
        const top = el.getBoundingClientRect().top;
        for (const child of children) {
          if (child.getBoundingClientRect().top >= top) {
            child.focus();
            break;
          }
        }
      } else {
        const bottom = el.getBoundingClientRect().bottom;
        for (const child of [...children].reverse()) {
          if (child.getBoundingClientRect().bottom <= bottom) {
            child.focus();
            break;
          }
        }
      }
    }
    return {
      onListScroll,
      onListKeydown
    };
  }

  // ../library_management/node_modules/vuetify/lib/components/VSelect/VSelect.mjs
  var makeSelectProps = propsFactory(__spreadValues({
    chips: Boolean,
    closableChips: Boolean,
    closeText: {
      type: String,
      default: "$vuetify.close"
    },
    openText: {
      type: String,
      default: "$vuetify.open"
    },
    eager: Boolean,
    hideNoData: Boolean,
    hideSelected: Boolean,
    listProps: {
      type: Object
    },
    menu: Boolean,
    menuIcon: {
      type: IconValue,
      default: "$dropdown"
    },
    menuProps: {
      type: Object
    },
    multiple: Boolean,
    noDataText: {
      type: String,
      default: "$vuetify.noDataText"
    },
    openOnClear: Boolean,
    itemColor: String
  }, makeItemsProps({
    itemChildren: false
  })), "Select");
  var makeVSelectProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({}, makeSelectProps()), omit(makeVTextFieldProps({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"])), makeTransitionProps2({
    transition: {
      component: VDialogTransition
    }
  })), "VSelect");
  var VSelect = genericComponent()({
    name: "VSelect",
    props: makeVSelectProps(),
    emits: {
      "update:focused": (focused) => true,
      "update:modelValue": (value) => true,
      "update:menu": (ue) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        t
      } = useLocale();
      const vTextFieldRef = ref();
      const vMenuRef = ref();
      const vVirtualScrollRef = ref();
      const _menu = useProxiedModel(props, "menu");
      const menu = computed2({
        get: () => _menu.value,
        set: (v) => {
          var _a2;
          if (_menu.value && !v && ((_a2 = vMenuRef.value) == null ? void 0 : _a2.\u03A8openChildren))
            return;
          _menu.value = v;
        }
      });
      const {
        items,
        transformIn,
        transformOut
      } = useItems(props);
      const model = useProxiedModel(props, "modelValue", [], (v) => transformIn(v === null ? [null] : wrapInArray(v)), (v) => {
        var _a2;
        const transformed = transformOut(v);
        return props.multiple ? transformed : (_a2 = transformed[0]) != null ? _a2 : null;
      });
      const counterValue = computed2(() => {
        return typeof props.counterValue === "function" ? props.counterValue(model.value) : typeof props.counterValue === "number" ? props.counterValue : model.value.length;
      });
      const form = useForm();
      const selectedValues = computed2(() => model.value.map((selection) => selection.value));
      const isFocused = shallowRef(false);
      const label = computed2(() => menu.value ? props.closeText : props.openText);
      let keyboardLookupPrefix = "";
      let keyboardLookupLastTime;
      const displayItems = computed2(() => {
        if (props.hideSelected) {
          return items.value.filter((item) => !model.value.some((s) => s === item));
        }
        return items.value;
      });
      const menuDisabled = computed2(() => props.hideNoData && !displayItems.value.length || props.readonly || (form == null ? void 0 : form.isReadonly.value));
      const computedMenuProps = computed2(() => {
        var _a2;
        return __spreadProps(__spreadValues({}, props.menuProps), {
          activatorProps: __spreadProps(__spreadValues({}, ((_a2 = props.menuProps) == null ? void 0 : _a2.activatorProps) || {}), {
            "aria-haspopup": "listbox"
          })
        });
      });
      const listRef = ref();
      const {
        onListScroll,
        onListKeydown
      } = useScrolling(listRef, vTextFieldRef);
      function onClear(e) {
        if (props.openOnClear) {
          menu.value = true;
        }
      }
      function onMousedownControl() {
        if (menuDisabled.value)
          return;
        menu.value = !menu.value;
      }
      function onKeydown(e) {
        var _a2, _b;
        if (!e.key || props.readonly || (form == null ? void 0 : form.isReadonly.value))
          return;
        if (["Enter", " ", "ArrowDown", "ArrowUp", "Home", "End"].includes(e.key)) {
          e.preventDefault();
        }
        if (["Enter", "ArrowDown", " "].includes(e.key)) {
          menu.value = true;
        }
        if (["Escape", "Tab"].includes(e.key)) {
          menu.value = false;
        }
        if (e.key === "Home") {
          (_a2 = listRef.value) == null ? void 0 : _a2.focus("first");
        } else if (e.key === "End") {
          (_b = listRef.value) == null ? void 0 : _b.focus("last");
        }
        const KEYBOARD_LOOKUP_THRESHOLD = 1e3;
        function checkPrintable(e2) {
          const isPrintableChar = e2.key.length === 1;
          const noModifier = !e2.ctrlKey && !e2.metaKey && !e2.altKey;
          return isPrintableChar && noModifier;
        }
        if (props.multiple || !checkPrintable(e))
          return;
        const now2 = performance.now();
        if (now2 - keyboardLookupLastTime > KEYBOARD_LOOKUP_THRESHOLD) {
          keyboardLookupPrefix = "";
        }
        keyboardLookupPrefix += e.key.toLowerCase();
        keyboardLookupLastTime = now2;
        const item = items.value.find((item2) => item2.title.toLowerCase().startsWith(keyboardLookupPrefix));
        if (item !== void 0) {
          model.value = [item];
        }
      }
      function select(item) {
        let set3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        if (item.props.disabled)
          return;
        if (props.multiple) {
          const index = model.value.findIndex((selection) => props.valueComparator(selection.value, item.value));
          const add2 = set3 == null ? !~index : set3;
          if (~index) {
            const value = add2 ? [...model.value, item] : [...model.value];
            value.splice(index, 1);
            model.value = value;
          } else if (add2) {
            model.value = [...model.value, item];
          }
        } else {
          const add2 = set3 !== false;
          model.value = add2 ? [item] : [];
          nextTick(() => {
            menu.value = false;
          });
        }
      }
      function onBlur(e) {
        var _a2;
        if (!((_a2 = listRef.value) == null ? void 0 : _a2.$el.contains(e.relatedTarget))) {
          menu.value = false;
        }
      }
      function onAfterLeave() {
        var _a2;
        if (isFocused.value) {
          (_a2 = vTextFieldRef.value) == null ? void 0 : _a2.focus();
        }
      }
      function onFocusin(e) {
        isFocused.value = true;
      }
      function onModelUpdate(v) {
        if (v == null)
          model.value = [];
        else if (matchesSelector(vTextFieldRef.value, ":autofill") || matchesSelector(vTextFieldRef.value, ":-webkit-autofill")) {
          const item = items.value.find((item2) => item2.title === v);
          if (item) {
            select(item);
          }
        } else if (vTextFieldRef.value) {
          vTextFieldRef.value.value = "";
        }
      }
      watch(menu, () => {
        if (!props.hideSelected && menu.value && model.value.length) {
          const index = displayItems.value.findIndex((item) => model.value.some((s) => props.valueComparator(s.value, item.value)));
          IN_BROWSER && window.requestAnimationFrame(() => {
            var _a2;
            index >= 0 && ((_a2 = vVirtualScrollRef.value) == null ? void 0 : _a2.scrollToIndex(index));
          });
        }
      });
      watch(() => props.items, (newVal, oldVal) => {
        if (menu.value)
          return;
        if (isFocused.value && !oldVal.length && newVal.length) {
          menu.value = true;
        }
      });
      useRender(() => {
        const hasChips = !!(props.chips || slots.chip);
        const hasList = !!(!props.hideNoData || displayItems.value.length || slots["prepend-item"] || slots["append-item"] || slots["no-data"]);
        const isDirty = model.value.length > 0;
        const textFieldProps = VTextField.filterProps(props);
        const placeholder = isDirty || !isFocused.value && props.label && !props.persistentPlaceholder ? void 0 : props.placeholder;
        return createVNode(VTextField, mergeProps({
          "ref": vTextFieldRef
        }, textFieldProps, {
          "modelValue": model.value.map((v) => v.props.value).join(", "),
          "onUpdate:modelValue": onModelUpdate,
          "focused": isFocused.value,
          "onUpdate:focused": ($event) => isFocused.value = $event,
          "validationValue": model.externalValue,
          "counterValue": counterValue.value,
          "dirty": isDirty,
          "class": ["v-select", {
            "v-select--active-menu": menu.value,
            "v-select--chips": !!props.chips,
            [`v-select--${props.multiple ? "multiple" : "single"}`]: true,
            "v-select--selected": model.value.length,
            "v-select--selection-slot": !!slots.selection
          }, props.class],
          "style": props.style,
          "inputmode": "none",
          "placeholder": placeholder,
          "onClick:clear": onClear,
          "onMousedown:control": onMousedownControl,
          "onBlur": onBlur,
          "onKeydown": onKeydown,
          "aria-label": t(label.value),
          "title": t(label.value)
        }), __spreadProps(__spreadValues({}, slots), {
          default: () => createVNode(Fragment, null, [createVNode(VMenu, mergeProps({
            "ref": vMenuRef,
            "modelValue": menu.value,
            "onUpdate:modelValue": ($event) => menu.value = $event,
            "activator": "parent",
            "contentClass": "v-select__content",
            "disabled": menuDisabled.value,
            "eager": props.eager,
            "maxHeight": 310,
            "openOnClick": false,
            "closeOnContentClick": false,
            "transition": props.transition,
            "onAfterLeave": onAfterLeave
          }, computedMenuProps.value), {
            default: () => {
              var _a2;
              return [hasList && createVNode(VList, mergeProps({
                "ref": listRef,
                "selected": selectedValues.value,
                "selectStrategy": props.multiple ? "independent" : "single-independent",
                "onMousedown": (e) => e.preventDefault(),
                "onKeydown": onListKeydown,
                "onFocusin": onFocusin,
                "onScrollPassive": onListScroll,
                "tabindex": "-1",
                "aria-live": "polite",
                "color": (_a2 = props.itemColor) != null ? _a2 : props.color
              }, props.listProps), {
                default: () => {
                  var _a3, _b, _c, _d;
                  return [(_a3 = slots["prepend-item"]) == null ? void 0 : _a3.call(slots), !displayItems.value.length && !props.hideNoData && ((_c = (_b = slots["no-data"]) == null ? void 0 : _b.call(slots)) != null ? _c : createVNode(VListItem, {
                    "title": t(props.noDataText)
                  }, null)), createVNode(VVirtualScroll, {
                    "ref": vVirtualScrollRef,
                    "renderless": true,
                    "items": displayItems.value
                  }, {
                    default: (_ref2) => {
                      var _a4, _b2;
                      let {
                        item,
                        index,
                        itemRef
                      } = _ref2;
                      const itemProps = mergeProps(item.props, {
                        ref: itemRef,
                        key: index,
                        onClick: () => select(item, null)
                      });
                      return (_b2 = (_a4 = slots.item) == null ? void 0 : _a4.call(slots, {
                        item,
                        index,
                        props: itemProps
                      })) != null ? _b2 : createVNode(VListItem, mergeProps(itemProps, {
                        "role": "option"
                      }), {
                        prepend: (_ref3) => {
                          let {
                            isSelected
                          } = _ref3;
                          return createVNode(Fragment, null, [props.multiple && !props.hideSelected ? createVNode(VCheckboxBtn, {
                            "key": item.value,
                            "modelValue": isSelected,
                            "ripple": false,
                            "tabindex": "-1"
                          }, null) : void 0, item.props.prependAvatar && createVNode(VAvatar, {
                            "image": item.props.prependAvatar
                          }, null), item.props.prependIcon && createVNode(VIcon, {
                            "icon": item.props.prependIcon
                          }, null)]);
                        }
                      });
                    }
                  }), (_d = slots["append-item"]) == null ? void 0 : _d.call(slots)];
                }
              })];
            }
          }), model.value.map((item, index) => {
            function onChipClose(e) {
              e.stopPropagation();
              e.preventDefault();
              select(item, false);
            }
            const slotProps = {
              "onClick:close": onChipClose,
              onKeydown(e) {
                if (e.key !== "Enter" && e.key !== " ")
                  return;
                e.preventDefault();
                e.stopPropagation();
                onChipClose(e);
              },
              onMousedown(e) {
                e.preventDefault();
                e.stopPropagation();
              },
              modelValue: true,
              "onUpdate:modelValue": void 0
            };
            const hasSlot = hasChips ? !!slots.chip : !!slots.selection;
            const slotContent = hasSlot ? ensureValidVNode(hasChips ? slots.chip({
              item,
              index,
              props: slotProps
            }) : slots.selection({
              item,
              index
            })) : void 0;
            if (hasSlot && !slotContent)
              return void 0;
            return createVNode("div", {
              "key": item.value,
              "class": "v-select__selection"
            }, [hasChips ? !slots.chip ? createVNode(VChip, mergeProps({
              "key": "chip",
              "closable": props.closableChips,
              "size": "small",
              "text": item.title,
              "disabled": item.props.disabled
            }, slotProps), null) : createVNode(VDefaultsProvider, {
              "key": "chip-defaults",
              "defaults": {
                VChip: {
                  closable: props.closableChips,
                  size: "small",
                  text: item.title
                }
              }
            }, {
              default: () => [slotContent]
            }) : slotContent != null ? slotContent : createVNode("span", {
              "class": "v-select__selection-text"
            }, [item.title, props.multiple && index < model.value.length - 1 && createVNode("span", {
              "class": "v-select__selection-comma"
            }, [createTextVNode(",")])])]);
          })]),
          "append-inner": function() {
            var _a2;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return createVNode(Fragment, null, [(_a2 = slots["append-inner"]) == null ? void 0 : _a2.call(slots, ...args), props.menuIcon ? createVNode(VIcon, {
              "class": "v-select__menu-icon",
              "icon": props.menuIcon
            }, null) : void 0]);
          }
        }));
      });
      return forwardRefs({
        isFocused,
        menu,
        select
      }, vTextFieldRef);
    }
  });

  // ../library_management/node_modules/vuetify/lib/composables/filter.mjs
  var defaultFilter = (value, query, item) => {
    if (value == null || query == null)
      return -1;
    return value.toString().toLocaleLowerCase().indexOf(query.toString().toLocaleLowerCase());
  };
  var makeFilterProps = propsFactory({
    customFilter: Function,
    customKeyFilter: Object,
    filterKeys: [Array, String],
    filterMode: {
      type: String,
      default: "intersection"
    },
    noFilter: Boolean
  }, "filter");
  function filterItems(items, query, options) {
    var _a2, _b, _c;
    const array = [];
    const filter = (_a2 = options == null ? void 0 : options.default) != null ? _a2 : defaultFilter;
    const keys2 = (options == null ? void 0 : options.filterKeys) ? wrapInArray(options.filterKeys) : false;
    const customFiltersLength = Object.keys((_b = options == null ? void 0 : options.customKeyFilter) != null ? _b : {}).length;
    if (!(items == null ? void 0 : items.length))
      return array;
    loop:
      for (let i = 0; i < items.length; i++) {
        const [item, transformed = item] = wrapInArray(items[i]);
        const customMatches = {};
        const defaultMatches = {};
        let match = -1;
        if (query && !(options == null ? void 0 : options.noFilter)) {
          if (typeof item === "object") {
            const filterKeys = keys2 || Object.keys(transformed);
            for (const key of filterKeys) {
              const value = getPropertyFromItem(transformed, key);
              const keyFilter = (_c = options == null ? void 0 : options.customKeyFilter) == null ? void 0 : _c[key];
              match = keyFilter ? keyFilter(value, query, item) : filter(value, query, item);
              if (match !== -1 && match !== false) {
                if (keyFilter)
                  customMatches[key] = match;
                else
                  defaultMatches[key] = match;
              } else if ((options == null ? void 0 : options.filterMode) === "every") {
                continue loop;
              }
            }
          } else {
            match = filter(item, query, item);
            if (match !== -1 && match !== false) {
              defaultMatches.title = match;
            }
          }
          const defaultMatchesLength = Object.keys(defaultMatches).length;
          const customMatchesLength = Object.keys(customMatches).length;
          if (!defaultMatchesLength && !customMatchesLength)
            continue;
          if ((options == null ? void 0 : options.filterMode) === "union" && customMatchesLength !== customFiltersLength && !defaultMatchesLength)
            continue;
          if ((options == null ? void 0 : options.filterMode) === "intersection" && (customMatchesLength !== customFiltersLength || !defaultMatchesLength))
            continue;
        }
        array.push({
          index: i,
          matches: __spreadValues(__spreadValues({}, defaultMatches), customMatches)
        });
      }
    return array;
  }
  function useFilter(props, items, query, options) {
    const filteredItems = ref([]);
    const filteredMatches = ref(/* @__PURE__ */ new Map());
    const transformedItems = computed2(() => (options == null ? void 0 : options.transform) ? unref(items).map((item) => [item, options.transform(item)]) : unref(items));
    watchEffect(() => {
      const _query = typeof query === "function" ? query() : unref(query);
      const strQuery = typeof _query !== "string" && typeof _query !== "number" ? "" : String(_query);
      const results = filterItems(transformedItems.value, strQuery, {
        customKeyFilter: __spreadValues(__spreadValues({}, props.customKeyFilter), unref(options == null ? void 0 : options.customKeyFilter)),
        default: props.customFilter,
        filterKeys: props.filterKeys,
        filterMode: props.filterMode,
        noFilter: props.noFilter
      });
      const originalItems = unref(items);
      const _filteredItems = [];
      const _filteredMatches = /* @__PURE__ */ new Map();
      results.forEach((_ref) => {
        let {
          index,
          matches
        } = _ref;
        const item = originalItems[index];
        _filteredItems.push(item);
        _filteredMatches.set(item.value, matches);
      });
      filteredItems.value = _filteredItems;
      filteredMatches.value = _filteredMatches;
    });
    function getMatches(item) {
      return filteredMatches.value.get(item.value);
    }
    return {
      filteredItems,
      filteredMatches,
      getMatches
    };
  }

  // ../library_management/node_modules/vuetify/lib/components/VAutocomplete/VAutocomplete.mjs
  function highlightResult(text, matches, length) {
    if (matches == null)
      return text;
    if (Array.isArray(matches))
      throw new Error("Multiple matches is not implemented");
    return typeof matches === "number" && ~matches ? createVNode(Fragment, null, [createVNode("span", {
      "class": "v-autocomplete__unmask"
    }, [text.substr(0, matches)]), createVNode("span", {
      "class": "v-autocomplete__mask"
    }, [text.substr(matches, length)]), createVNode("span", {
      "class": "v-autocomplete__unmask"
    }, [text.substr(matches + length)])]) : text;
  }
  var makeVAutocompleteProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    autoSelectFirst: {
      type: [Boolean, String]
    },
    clearOnSelect: Boolean,
    search: String
  }, makeFilterProps({
    filterKeys: ["title"]
  })), makeSelectProps()), omit(makeVTextFieldProps({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"])), makeTransitionProps2({
    transition: false
  })), "VAutocomplete");
  var VAutocomplete = genericComponent()({
    name: "VAutocomplete",
    props: makeVAutocompleteProps(),
    emits: {
      "update:focused": (focused) => true,
      "update:search": (value) => true,
      "update:modelValue": (value) => true,
      "update:menu": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        t
      } = useLocale();
      const vTextFieldRef = ref();
      const isFocused = shallowRef(false);
      const isPristine = shallowRef(true);
      const listHasFocus = shallowRef(false);
      const vMenuRef = ref();
      const vVirtualScrollRef = ref();
      const _menu = useProxiedModel(props, "menu");
      const menu = computed2({
        get: () => _menu.value,
        set: (v) => {
          var _a2;
          if (_menu.value && !v && ((_a2 = vMenuRef.value) == null ? void 0 : _a2.\u03A8openChildren))
            return;
          _menu.value = v;
        }
      });
      const selectionIndex = shallowRef(-1);
      const color = computed2(() => {
        var _a2;
        return (_a2 = vTextFieldRef.value) == null ? void 0 : _a2.color;
      });
      const label = computed2(() => menu.value ? props.closeText : props.openText);
      const {
        items,
        transformIn,
        transformOut
      } = useItems(props);
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(color);
      const search = useProxiedModel(props, "search", "");
      const model = useProxiedModel(props, "modelValue", [], (v) => transformIn(v === null ? [null] : wrapInArray(v)), (v) => {
        var _a2;
        const transformed = transformOut(v);
        return props.multiple ? transformed : (_a2 = transformed[0]) != null ? _a2 : null;
      });
      const counterValue = computed2(() => {
        return typeof props.counterValue === "function" ? props.counterValue(model.value) : typeof props.counterValue === "number" ? props.counterValue : model.value.length;
      });
      const form = useForm();
      const {
        filteredItems,
        getMatches
      } = useFilter(props, items, () => isPristine.value ? "" : search.value);
      const displayItems = computed2(() => {
        if (props.hideSelected) {
          return filteredItems.value.filter((filteredItem) => !model.value.some((s) => s.value === filteredItem.value));
        }
        return filteredItems.value;
      });
      const hasChips = computed2(() => !!(props.chips || slots.chip));
      const hasSelectionSlot = computed2(() => hasChips.value || !!slots.selection);
      const selectedValues = computed2(() => model.value.map((selection) => selection.props.value));
      const highlightFirst = computed2(() => {
        var _a2;
        const selectFirst = props.autoSelectFirst === true || props.autoSelectFirst === "exact" && search.value === ((_a2 = displayItems.value[0]) == null ? void 0 : _a2.title);
        return selectFirst && displayItems.value.length > 0 && !isPristine.value && !listHasFocus.value;
      });
      const menuDisabled = computed2(() => props.hideNoData && !displayItems.value.length || props.readonly || (form == null ? void 0 : form.isReadonly.value));
      const listRef = ref();
      const {
        onListScroll,
        onListKeydown
      } = useScrolling(listRef, vTextFieldRef);
      function onClear(e) {
        if (props.openOnClear) {
          menu.value = true;
        }
        search.value = "";
      }
      function onMousedownControl() {
        if (menuDisabled.value)
          return;
        menu.value = true;
      }
      function onMousedownMenuIcon(e) {
        if (menuDisabled.value)
          return;
        if (isFocused.value) {
          e.preventDefault();
          e.stopPropagation();
        }
        menu.value = !menu.value;
      }
      function onKeydown(e) {
        var _a2, _b, _c;
        if (props.readonly || (form == null ? void 0 : form.isReadonly.value))
          return;
        const selectionStart = vTextFieldRef.value.selectionStart;
        const length = model.value.length;
        if (selectionIndex.value > -1 || ["Enter", "ArrowDown", "ArrowUp"].includes(e.key)) {
          e.preventDefault();
        }
        if (["Enter", "ArrowDown"].includes(e.key)) {
          menu.value = true;
        }
        if (["Escape"].includes(e.key)) {
          menu.value = false;
        }
        if (highlightFirst.value && ["Enter", "Tab"].includes(e.key)) {
          select(displayItems.value[0]);
        }
        if (e.key === "ArrowDown" && highlightFirst.value) {
          (_a2 = listRef.value) == null ? void 0 : _a2.focus("next");
        }
        if (["Backspace", "Delete"].includes(e.key)) {
          if (!props.multiple && hasSelectionSlot.value && model.value.length > 0)
            return select(model.value[0], false);
          if (selectionIndex.value < 0) {
            if (e.key === "Backspace" && !search.value) {
              selectionIndex.value = length - 1;
            }
            return;
          }
          const originalSelectionIndex = selectionIndex.value;
          select(model.value[selectionIndex.value], false);
          selectionIndex.value = originalSelectionIndex >= length - 1 ? length - 2 : originalSelectionIndex;
        }
        if (!props.multiple)
          return;
        if (e.key === "ArrowLeft") {
          if (selectionIndex.value < 0 && selectionStart > 0)
            return;
          const prev = selectionIndex.value > -1 ? selectionIndex.value - 1 : length - 1;
          if (model.value[prev]) {
            selectionIndex.value = prev;
          } else {
            selectionIndex.value = -1;
            vTextFieldRef.value.setSelectionRange((_b = search.value) == null ? void 0 : _b.length, (_c = search.value) == null ? void 0 : _c.length);
          }
        }
        if (e.key === "ArrowRight") {
          if (selectionIndex.value < 0)
            return;
          const next = selectionIndex.value + 1;
          if (model.value[next]) {
            selectionIndex.value = next;
          } else {
            selectionIndex.value = -1;
            vTextFieldRef.value.setSelectionRange(0, 0);
          }
        }
      }
      function onChange(e) {
        if (matchesSelector(vTextFieldRef.value, ":autofill") || matchesSelector(vTextFieldRef.value, ":-webkit-autofill")) {
          const item = items.value.find((item2) => item2.title === e.target.value);
          if (item) {
            select(item);
          }
        }
      }
      function onAfterLeave() {
        var _a2;
        if (isFocused.value) {
          isPristine.value = true;
          (_a2 = vTextFieldRef.value) == null ? void 0 : _a2.focus();
        }
      }
      function onFocusin(e) {
        isFocused.value = true;
        setTimeout(() => {
          listHasFocus.value = true;
        });
      }
      function onFocusout(e) {
        listHasFocus.value = false;
      }
      function onUpdateModelValue(v) {
        if (v == null || v === "" && !props.multiple)
          model.value = [];
      }
      const isSelecting = shallowRef(false);
      function select(item) {
        let set3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        if (!item || item.props.disabled)
          return;
        if (props.multiple) {
          const index = model.value.findIndex((selection) => props.valueComparator(selection.value, item.value));
          const add2 = set3 == null ? !~index : set3;
          if (~index) {
            const value = add2 ? [...model.value, item] : [...model.value];
            value.splice(index, 1);
            model.value = value;
          } else if (add2) {
            model.value = [...model.value, item];
          }
          if (props.clearOnSelect) {
            search.value = "";
          }
        } else {
          const add2 = set3 !== false;
          model.value = add2 ? [item] : [];
          search.value = add2 && !hasSelectionSlot.value ? item.title : "";
          nextTick(() => {
            menu.value = false;
            isPristine.value = true;
          });
        }
      }
      watch(isFocused, (val, oldVal) => {
        var _a2, _b;
        if (val === oldVal)
          return;
        if (val) {
          isSelecting.value = true;
          search.value = props.multiple || hasSelectionSlot.value ? "" : String((_b = (_a2 = model.value.at(-1)) == null ? void 0 : _a2.props.title) != null ? _b : "");
          isPristine.value = true;
          nextTick(() => isSelecting.value = false);
        } else {
          if (!props.multiple && search.value == null)
            model.value = [];
          else if (highlightFirst.value && !listHasFocus.value && !model.value.some((_ref2) => {
            let {
              value
            } = _ref2;
            return value === displayItems.value[0].value;
          })) {
            select(displayItems.value[0]);
          }
          menu.value = false;
          search.value = "";
          selectionIndex.value = -1;
        }
      });
      watch(search, (val) => {
        if (!isFocused.value || isSelecting.value)
          return;
        if (val)
          menu.value = true;
        isPristine.value = !val;
      });
      watch(menu, () => {
        if (!props.hideSelected && menu.value && model.value.length) {
          const index = displayItems.value.findIndex((item) => model.value.some((s) => item.value === s.value));
          IN_BROWSER && window.requestAnimationFrame(() => {
            var _a2;
            index >= 0 && ((_a2 = vVirtualScrollRef.value) == null ? void 0 : _a2.scrollToIndex(index));
          });
        }
      });
      watch(() => props.items, (newVal, oldVal) => {
        if (menu.value)
          return;
        if (isFocused.value && !oldVal.length && newVal.length) {
          menu.value = true;
        }
      });
      useRender(() => {
        const hasList = !!(!props.hideNoData || displayItems.value.length || slots["prepend-item"] || slots["append-item"] || slots["no-data"]);
        const isDirty = model.value.length > 0;
        const textFieldProps = VTextField.filterProps(props);
        return createVNode(VTextField, mergeProps({
          "ref": vTextFieldRef
        }, textFieldProps, {
          "modelValue": search.value,
          "onUpdate:modelValue": [($event) => search.value = $event, onUpdateModelValue],
          "focused": isFocused.value,
          "onUpdate:focused": ($event) => isFocused.value = $event,
          "validationValue": model.externalValue,
          "counterValue": counterValue.value,
          "dirty": isDirty,
          "onChange": onChange,
          "class": ["v-autocomplete", `v-autocomplete--${props.multiple ? "multiple" : "single"}`, {
            "v-autocomplete--active-menu": menu.value,
            "v-autocomplete--chips": !!props.chips,
            "v-autocomplete--selection-slot": !!hasSelectionSlot.value,
            "v-autocomplete--selecting-index": selectionIndex.value > -1
          }, props.class],
          "style": props.style,
          "readonly": props.readonly,
          "placeholder": isDirty ? void 0 : props.placeholder,
          "onClick:clear": onClear,
          "onMousedown:control": onMousedownControl,
          "onKeydown": onKeydown
        }), __spreadProps(__spreadValues({}, slots), {
          default: () => createVNode(Fragment, null, [createVNode(VMenu, mergeProps({
            "ref": vMenuRef,
            "modelValue": menu.value,
            "onUpdate:modelValue": ($event) => menu.value = $event,
            "activator": "parent",
            "contentClass": "v-autocomplete__content",
            "disabled": menuDisabled.value,
            "eager": props.eager,
            "maxHeight": 310,
            "openOnClick": false,
            "closeOnContentClick": false,
            "transition": props.transition,
            "onAfterLeave": onAfterLeave
          }, props.menuProps), {
            default: () => {
              var _a2;
              return [hasList && createVNode(VList, mergeProps({
                "ref": listRef,
                "selected": selectedValues.value,
                "selectStrategy": props.multiple ? "independent" : "single-independent",
                "onMousedown": (e) => e.preventDefault(),
                "onKeydown": onListKeydown,
                "onFocusin": onFocusin,
                "onFocusout": onFocusout,
                "onScrollPassive": onListScroll,
                "tabindex": "-1",
                "aria-live": "polite",
                "color": (_a2 = props.itemColor) != null ? _a2 : props.color
              }, props.listProps), {
                default: () => {
                  var _a3, _b, _c, _d;
                  return [(_a3 = slots["prepend-item"]) == null ? void 0 : _a3.call(slots), !displayItems.value.length && !props.hideNoData && ((_c = (_b = slots["no-data"]) == null ? void 0 : _b.call(slots)) != null ? _c : createVNode(VListItem, {
                    "title": t(props.noDataText)
                  }, null)), createVNode(VVirtualScroll, {
                    "ref": vVirtualScrollRef,
                    "renderless": true,
                    "items": displayItems.value
                  }, {
                    default: (_ref3) => {
                      var _a4, _b2;
                      let {
                        item,
                        index,
                        itemRef
                      } = _ref3;
                      const itemProps = mergeProps(item.props, {
                        ref: itemRef,
                        key: index,
                        active: highlightFirst.value && index === 0 ? true : void 0,
                        onClick: () => select(item, null)
                      });
                      return (_b2 = (_a4 = slots.item) == null ? void 0 : _a4.call(slots, {
                        item,
                        index,
                        props: itemProps
                      })) != null ? _b2 : createVNode(VListItem, mergeProps(itemProps, {
                        "role": "option"
                      }), {
                        prepend: (_ref4) => {
                          let {
                            isSelected
                          } = _ref4;
                          return createVNode(Fragment, null, [props.multiple && !props.hideSelected ? createVNode(VCheckboxBtn, {
                            "key": item.value,
                            "modelValue": isSelected,
                            "ripple": false,
                            "tabindex": "-1"
                          }, null) : void 0, item.props.prependAvatar && createVNode(VAvatar, {
                            "image": item.props.prependAvatar
                          }, null), item.props.prependIcon && createVNode(VIcon, {
                            "icon": item.props.prependIcon
                          }, null)]);
                        },
                        title: () => {
                          var _a5, _b3, _c2;
                          return isPristine.value ? item.title : highlightResult(item.title, (_a5 = getMatches(item)) == null ? void 0 : _a5.title, (_c2 = (_b3 = search.value) == null ? void 0 : _b3.length) != null ? _c2 : 0);
                        }
                      });
                    }
                  }), (_d = slots["append-item"]) == null ? void 0 : _d.call(slots)];
                }
              })];
            }
          }), model.value.map((item, index) => {
            function onChipClose(e) {
              e.stopPropagation();
              e.preventDefault();
              select(item, false);
            }
            const slotProps = {
              "onClick:close": onChipClose,
              onKeydown(e) {
                if (e.key !== "Enter" && e.key !== " ")
                  return;
                e.preventDefault();
                e.stopPropagation();
                onChipClose(e);
              },
              onMousedown(e) {
                e.preventDefault();
                e.stopPropagation();
              },
              modelValue: true,
              "onUpdate:modelValue": void 0
            };
            const hasSlot = hasChips.value ? !!slots.chip : !!slots.selection;
            const slotContent = hasSlot ? ensureValidVNode(hasChips.value ? slots.chip({
              item,
              index,
              props: slotProps
            }) : slots.selection({
              item,
              index
            })) : void 0;
            if (hasSlot && !slotContent)
              return void 0;
            return createVNode("div", {
              "key": item.value,
              "class": ["v-autocomplete__selection", index === selectionIndex.value && ["v-autocomplete__selection--selected", textColorClasses.value]],
              "style": index === selectionIndex.value ? textColorStyles.value : {}
            }, [hasChips.value ? !slots.chip ? createVNode(VChip, mergeProps({
              "key": "chip",
              "closable": props.closableChips,
              "size": "small",
              "text": item.title,
              "disabled": item.props.disabled
            }, slotProps), null) : createVNode(VDefaultsProvider, {
              "key": "chip-defaults",
              "defaults": {
                VChip: {
                  closable: props.closableChips,
                  size: "small",
                  text: item.title
                }
              }
            }, {
              default: () => [slotContent]
            }) : slotContent != null ? slotContent : createVNode("span", {
              "class": "v-autocomplete__selection-text"
            }, [item.title, props.multiple && index < model.value.length - 1 && createVNode("span", {
              "class": "v-autocomplete__selection-comma"
            }, [createTextVNode(",")])])]);
          })]),
          "append-inner": function() {
            var _a2;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return createVNode(Fragment, null, [(_a2 = slots["append-inner"]) == null ? void 0 : _a2.call(slots, ...args), props.menuIcon ? createVNode(VIcon, {
              "class": "v-autocomplete__menu-icon",
              "icon": props.menuIcon,
              "onMousedown": onMousedownMenuIcon,
              "onClick": noop2,
              "aria-label": t(label.value),
              "title": t(label.value)
            }, null) : void 0]);
          }
        }));
      });
      return forwardRefs({
        isFocused,
        isPristine,
        menu,
        search,
        filteredItems,
        select
      }, vTextFieldRef);
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VBadge/VBadge.mjs
  var makeVBadgeProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    bordered: Boolean,
    color: String,
    content: [Number, String],
    dot: Boolean,
    floating: Boolean,
    icon: IconValue,
    inline: Boolean,
    label: {
      type: String,
      default: "$vuetify.badge"
    },
    max: [Number, String],
    modelValue: {
      type: Boolean,
      default: true
    },
    offsetX: [Number, String],
    offsetY: [Number, String],
    textColor: String
  }, makeComponentProps()), makeLocationProps({
    location: "top end"
  })), makeRoundedProps()), makeTagProps()), makeThemeProps()), makeTransitionProps2({
    transition: "scale-rotate-transition"
  })), "VBadge");
  var VBadge = genericComponent()({
    name: "VBadge",
    inheritAttrs: false,
    props: makeVBadgeProps(),
    setup(props, ctx) {
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(toRef(props, "color"));
      const {
        roundedClasses
      } = useRounded(props);
      const {
        t
      } = useLocale();
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(toRef(props, "textColor"));
      const {
        themeClasses
      } = useTheme();
      const {
        locationStyles
      } = useLocation(props, true, (side) => {
        var _a2, _b;
        const base = props.floating ? props.dot ? 2 : 4 : props.dot ? 8 : 12;
        return base + (["top", "bottom"].includes(side) ? +((_a2 = props.offsetY) != null ? _a2 : 0) : ["left", "right"].includes(side) ? +((_b = props.offsetX) != null ? _b : 0) : 0);
      });
      useRender(() => {
        const value = Number(props.content);
        const content = !props.max || isNaN(value) ? props.content : value <= +props.max ? value : `${props.max}+`;
        const [badgeAttrs, attrs] = pickWithRest(ctx.attrs, ["aria-atomic", "aria-label", "aria-live", "role", "title"]);
        return createVNode(props.tag, mergeProps({
          "class": ["v-badge", {
            "v-badge--bordered": props.bordered,
            "v-badge--dot": props.dot,
            "v-badge--floating": props.floating,
            "v-badge--inline": props.inline
          }, props.class]
        }, attrs, {
          "style": props.style
        }), {
          default: () => {
            var _a2, _b;
            return [createVNode("div", {
              "class": "v-badge__wrapper"
            }, [(_b = (_a2 = ctx.slots).default) == null ? void 0 : _b.call(_a2), createVNode(MaybeTransition, {
              "transition": props.transition
            }, {
              default: () => {
                var _a3, _b2;
                return [withDirectives(createVNode("span", mergeProps({
                  "class": ["v-badge__badge", themeClasses.value, backgroundColorClasses.value, roundedClasses.value, textColorClasses.value],
                  "style": [backgroundColorStyles.value, textColorStyles.value, props.inline ? {} : locationStyles.value],
                  "aria-atomic": "true",
                  "aria-label": t(props.label, value),
                  "aria-live": "polite",
                  "role": "status"
                }, badgeAttrs), [props.dot ? void 0 : ctx.slots.badge ? (_b2 = (_a3 = ctx.slots).badge) == null ? void 0 : _b2.call(_a3) : props.icon ? createVNode(VIcon, {
                  "icon": props.icon
                }, null) : content]), [[vShow, props.modelValue]])];
              }
            })])];
          }
        });
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VBanner/VBannerActions.mjs
  var makeVBannerActionsProps = propsFactory(__spreadValues({
    color: String,
    density: String
  }, makeComponentProps()), "VBannerActions");
  var VBannerActions = genericComponent()({
    name: "VBannerActions",
    props: makeVBannerActionsProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      provideDefaults({
        VBtn: {
          color: props.color,
          density: props.density,
          slim: true,
          variant: "text"
        }
      });
      useRender(() => {
        var _a2;
        return createVNode("div", {
          "class": ["v-banner-actions", props.class],
          "style": props.style
        }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VBanner/VBannerText.mjs
  var VBannerText = createSimpleFunctional("v-banner-text");

  // ../library_management/node_modules/vuetify/lib/components/VBanner/VBanner.mjs
  var makeVBannerProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    avatar: String,
    bgColor: String,
    color: String,
    icon: IconValue,
    lines: String,
    stacked: Boolean,
    sticky: Boolean,
    text: String
  }, makeBorderProps()), makeComponentProps()), makeDensityProps()), makeDimensionProps()), makeDisplayProps()), makeElevationProps()), makeLocationProps()), makePositionProps()), makeRoundedProps()), makeTagProps()), makeThemeProps()), "VBanner");
  var VBanner = genericComponent()({
    name: "VBanner",
    props: makeVBannerProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(props, "bgColor");
      const {
        borderClasses
      } = useBorder(props);
      const {
        densityClasses
      } = useDensity(props);
      const {
        displayClasses,
        mobile
      } = useDisplay(props);
      const {
        dimensionStyles
      } = useDimension(props);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        locationStyles
      } = useLocation(props);
      const {
        positionClasses
      } = usePosition(props);
      const {
        roundedClasses
      } = useRounded(props);
      const {
        themeClasses
      } = provideTheme(props);
      const color = toRef(props, "color");
      const density = toRef(props, "density");
      provideDefaults({
        VBannerActions: {
          color,
          density
        }
      });
      useRender(() => {
        const hasText = !!(props.text || slots.text);
        const hasPrependMedia = !!(props.avatar || props.icon);
        const hasPrepend = !!(hasPrependMedia || slots.prepend);
        return createVNode(props.tag, {
          "class": ["v-banner", {
            "v-banner--stacked": props.stacked || mobile.value,
            "v-banner--sticky": props.sticky,
            [`v-banner--${props.lines}-line`]: !!props.lines
          }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, densityClasses.value, displayClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, props.class],
          "style": [backgroundColorStyles.value, dimensionStyles.value, locationStyles.value, props.style],
          "role": "banner"
        }, {
          default: () => {
            var _a2;
            return [hasPrepend && createVNode("div", {
              "key": "prepend",
              "class": "v-banner__prepend"
            }, [!slots.prepend ? createVNode(VAvatar, {
              "key": "prepend-avatar",
              "color": color.value,
              "density": density.value,
              "icon": props.icon,
              "image": props.avatar
            }, null) : createVNode(VDefaultsProvider, {
              "key": "prepend-defaults",
              "disabled": !hasPrependMedia,
              "defaults": {
                VAvatar: {
                  color: color.value,
                  density: density.value,
                  icon: props.icon,
                  image: props.avatar
                }
              }
            }, slots.prepend)]), createVNode("div", {
              "class": "v-banner__content"
            }, [hasText && createVNode(VBannerText, {
              "key": "text"
            }, {
              default: () => {
                var _a3, _b;
                return [(_b = (_a3 = slots.text) == null ? void 0 : _a3.call(slots)) != null ? _b : props.text];
              }
            }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots)]), slots.actions && createVNode(VBannerActions, {
              "key": "actions"
            }, slots.actions)];
          }
        });
      });
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VBottomNavigation/VBottomNavigation.mjs
  var makeVBottomNavigationProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    bgColor: String,
    color: String,
    grow: Boolean,
    mode: {
      type: String,
      validator: (v) => !v || ["horizontal", "shift"].includes(v)
    },
    height: {
      type: [Number, String],
      default: 56
    },
    active: {
      type: Boolean,
      default: true
    }
  }, makeBorderProps()), makeComponentProps()), makeDensityProps()), makeElevationProps()), makeRoundedProps()), makeLayoutItemProps({
    name: "bottom-navigation"
  })), makeTagProps({
    tag: "header"
  })), makeGroupProps({
    modelValue: true,
    selectedClass: "v-btn--selected"
  })), makeThemeProps()), "VBottomNavigation");
  var VBottomNavigation = genericComponent()({
    name: "VBottomNavigation",
    props: makeVBottomNavigationProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        themeClasses
      } = useTheme();
      const {
        borderClasses
      } = useBorder(props);
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(toRef(props, "bgColor"));
      const {
        densityClasses
      } = useDensity(props);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        roundedClasses
      } = useRounded(props);
      const {
        ssrBootStyles
      } = useSsrBoot();
      const height = computed2(() => Number(props.height) - (props.density === "comfortable" ? 8 : 0) - (props.density === "compact" ? 16 : 0));
      const isActive = toRef(props, "active");
      const {
        layoutItemStyles
      } = useLayoutItem({
        id: props.name,
        order: computed2(() => parseInt(props.order, 10)),
        position: computed2(() => "bottom"),
        layoutSize: computed2(() => isActive.value ? height.value : 0),
        elementSize: height,
        active: isActive,
        absolute: toRef(props, "absolute")
      });
      useGroup(props, VBtnToggleSymbol);
      provideDefaults({
        VBtn: {
          color: toRef(props, "color"),
          density: toRef(props, "density"),
          stacked: computed2(() => props.mode !== "horizontal"),
          variant: "text"
        }
      }, {
        scoped: true
      });
      useRender(() => {
        return createVNode(props.tag, {
          "class": ["v-bottom-navigation", {
            "v-bottom-navigation--active": isActive.value,
            "v-bottom-navigation--grow": props.grow,
            "v-bottom-navigation--shift": props.mode === "shift"
          }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, roundedClasses.value, props.class],
          "style": [backgroundColorStyles.value, layoutItemStyles.value, {
            height: convertToUnit(height.value),
            transform: `translateY(${convertToUnit(!isActive.value ? 100 : 0, "%")})`
          }, ssrBootStyles.value, props.style]
        }, {
          default: () => [slots.default && createVNode("div", {
            "class": "v-bottom-navigation__content"
          }, [slots.default()])]
        });
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VDialog/VDialog.mjs
  var makeVDialogProps = propsFactory(__spreadValues({
    fullscreen: Boolean,
    retainFocus: {
      type: Boolean,
      default: true
    },
    scrollable: Boolean
  }, makeVOverlayProps({
    origin: "center center",
    scrollStrategy: "block",
    transition: {
      component: VDialogTransition
    },
    zIndex: 2400
  })), "VDialog");
  var VDialog = genericComponent()({
    name: "VDialog",
    props: makeVDialogProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const isActive = useProxiedModel(props, "modelValue");
      const {
        scopeId
      } = useScopeId();
      const overlay = ref();
      function onFocusin(e) {
        var _a2, _b;
        const before = e.relatedTarget;
        const after = e.target;
        if (before !== after && ((_a2 = overlay.value) == null ? void 0 : _a2.contentEl) && ((_b = overlay.value) == null ? void 0 : _b.globalTop) && ![document, overlay.value.contentEl].includes(after) && !overlay.value.contentEl.contains(after)) {
          const focusable = focusableChildren(overlay.value.contentEl);
          if (!focusable.length)
            return;
          const firstElement = focusable[0];
          const lastElement = focusable[focusable.length - 1];
          if (before === firstElement) {
            lastElement.focus();
          } else {
            firstElement.focus();
          }
        }
      }
      if (IN_BROWSER) {
        watch(() => isActive.value && props.retainFocus, (val) => {
          val ? document.addEventListener("focusin", onFocusin) : document.removeEventListener("focusin", onFocusin);
        }, {
          immediate: true
        });
      }
      watch(isActive, async (val) => {
        var _a2, _b;
        await nextTick();
        if (val) {
          (_a2 = overlay.value.contentEl) == null ? void 0 : _a2.focus({
            preventScroll: true
          });
        } else {
          (_b = overlay.value.activatorEl) == null ? void 0 : _b.focus({
            preventScroll: true
          });
        }
      });
      const activatorProps = computed2(() => mergeProps({
        "aria-haspopup": "dialog",
        "aria-expanded": String(isActive.value)
      }, props.activatorProps));
      useRender(() => {
        const overlayProps = VOverlay.filterProps(props);
        return createVNode(VOverlay, mergeProps({
          "ref": overlay,
          "class": ["v-dialog", {
            "v-dialog--fullscreen": props.fullscreen,
            "v-dialog--scrollable": props.scrollable
          }, props.class],
          "style": props.style
        }, overlayProps, {
          "modelValue": isActive.value,
          "onUpdate:modelValue": ($event) => isActive.value = $event,
          "aria-modal": "true",
          "activatorProps": activatorProps.value,
          "role": "dialog"
        }, scopeId), {
          activator: slots.activator,
          default: function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return createVNode(VDefaultsProvider, {
              "root": "VDialog"
            }, {
              default: () => {
                var _a2;
                return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, ...args)];
              }
            });
          }
        });
      });
      return forwardRefs({}, overlay);
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VBottomSheet/VBottomSheet.mjs
  var makeVBottomSheetProps = propsFactory(__spreadValues({
    inset: Boolean
  }, makeVDialogProps({
    transition: "bottom-sheet-transition"
  })), "VBottomSheet");
  var VBottomSheet = genericComponent()({
    name: "VBottomSheet",
    props: makeVBottomSheetProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const isActive = useProxiedModel(props, "modelValue");
      useRender(() => {
        const dialogProps = VDialog.filterProps(props);
        return createVNode(VDialog, mergeProps(dialogProps, {
          "contentClass": ["v-bottom-sheet__content", props.contentClass],
          "modelValue": isActive.value,
          "onUpdate:modelValue": ($event) => isActive.value = $event,
          "class": ["v-bottom-sheet", {
            "v-bottom-sheet--inset": props.inset
          }, props.class],
          "style": props.style
        }), slots);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VBreadcrumbs/VBreadcrumbsDivider.mjs
  var makeVBreadcrumbsDividerProps = propsFactory(__spreadValues({
    divider: [Number, String]
  }, makeComponentProps()), "VBreadcrumbsDivider");
  var VBreadcrumbsDivider = genericComponent()({
    name: "VBreadcrumbsDivider",
    props: makeVBreadcrumbsDividerProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useRender(() => {
        var _a2, _b;
        return createVNode("li", {
          "class": ["v-breadcrumbs-divider", props.class],
          "style": props.style
        }, [(_b = (_a2 = slots == null ? void 0 : slots.default) == null ? void 0 : _a2.call(slots)) != null ? _b : props.divider]);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VBreadcrumbs/VBreadcrumbsItem.mjs
  var makeVBreadcrumbsItemProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({
    active: Boolean,
    activeClass: String,
    activeColor: String,
    color: String,
    disabled: Boolean,
    title: String
  }, makeComponentProps()), makeRouterProps()), makeTagProps({
    tag: "li"
  })), "VBreadcrumbsItem");
  var VBreadcrumbsItem = genericComponent()({
    name: "VBreadcrumbsItem",
    props: makeVBreadcrumbsItemProps(),
    setup(props, _ref) {
      let {
        slots,
        attrs
      } = _ref;
      const link = useLink(props, attrs);
      const isActive = computed2(() => {
        var _a2;
        return props.active || ((_a2 = link.isActive) == null ? void 0 : _a2.value);
      });
      const color = computed2(() => isActive.value ? props.activeColor : props.color);
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(color);
      useRender(() => {
        return createVNode(props.tag, {
          "class": ["v-breadcrumbs-item", {
            "v-breadcrumbs-item--active": isActive.value,
            "v-breadcrumbs-item--disabled": props.disabled,
            [`${props.activeClass}`]: isActive.value && props.activeClass
          }, textColorClasses.value, props.class],
          "style": [textColorStyles.value, props.style],
          "aria-current": isActive.value ? "page" : void 0
        }, {
          default: () => {
            var _a2, _b, _c, _d;
            return [!link.isLink.value ? (_b = (_a2 = slots.default) == null ? void 0 : _a2.call(slots)) != null ? _b : props.title : createVNode("a", {
              "class": "v-breadcrumbs-item--link",
              "href": link.href.value,
              "aria-current": isActive.value ? "page" : void 0,
              "onClick": link.navigate
            }, [(_d = (_c = slots.default) == null ? void 0 : _c.call(slots)) != null ? _d : props.title])];
          }
        });
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VBreadcrumbs/VBreadcrumbs.mjs
  var makeVBreadcrumbsProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    activeClass: String,
    activeColor: String,
    bgColor: String,
    color: String,
    disabled: Boolean,
    divider: {
      type: String,
      default: "/"
    },
    icon: IconValue,
    items: {
      type: Array,
      default: () => []
    }
  }, makeComponentProps()), makeDensityProps()), makeRoundedProps()), makeTagProps({
    tag: "ul"
  })), "VBreadcrumbs");
  var VBreadcrumbs = genericComponent()({
    name: "VBreadcrumbs",
    props: makeVBreadcrumbsProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(toRef(props, "bgColor"));
      const {
        densityClasses
      } = useDensity(props);
      const {
        roundedClasses
      } = useRounded(props);
      provideDefaults({
        VBreadcrumbsDivider: {
          divider: toRef(props, "divider")
        },
        VBreadcrumbsItem: {
          activeClass: toRef(props, "activeClass"),
          activeColor: toRef(props, "activeColor"),
          color: toRef(props, "color"),
          disabled: toRef(props, "disabled")
        }
      });
      const items = computed2(() => props.items.map((item) => {
        return typeof item === "string" ? {
          item: {
            title: item
          },
          raw: item
        } : {
          item,
          raw: item
        };
      }));
      useRender(() => {
        const hasPrepend = !!(slots.prepend || props.icon);
        return createVNode(props.tag, {
          "class": ["v-breadcrumbs", backgroundColorClasses.value, densityClasses.value, roundedClasses.value, props.class],
          "style": [backgroundColorStyles.value, props.style]
        }, {
          default: () => {
            var _a2;
            return [hasPrepend && createVNode("li", {
              "key": "prepend",
              "class": "v-breadcrumbs__prepend"
            }, [!slots.prepend ? createVNode(VIcon, {
              "key": "prepend-icon",
              "start": true,
              "icon": props.icon
            }, null) : createVNode(VDefaultsProvider, {
              "key": "prepend-defaults",
              "disabled": !props.icon,
              "defaults": {
                VIcon: {
                  icon: props.icon,
                  start: true
                }
              }
            }, slots.prepend)]), items.value.map((_ref2, index, array) => {
              var _a3, _b;
              let {
                item,
                raw
              } = _ref2;
              return createVNode(Fragment, null, [(_b = (_a3 = slots.item) == null ? void 0 : _a3.call(slots, {
                item,
                index
              })) != null ? _b : createVNode(VBreadcrumbsItem, mergeProps({
                "key": index,
                "disabled": index >= array.length - 1
              }, typeof item === "string" ? {
                title: item
              } : item), {
                default: slots.title ? () => {
                  var _a4;
                  return (_a4 = slots.title) == null ? void 0 : _a4.call(slots, {
                    item,
                    index
                  });
                } : void 0
              }), index < array.length - 1 && createVNode(VBreadcrumbsDivider, null, {
                default: slots.divider ? () => {
                  var _a4;
                  return (_a4 = slots.divider) == null ? void 0 : _a4.call(slots, {
                    item: raw,
                    index
                  });
                } : void 0
              })]);
            }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots)];
          }
        });
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VCard/VCardActions.mjs
  var VCardActions = genericComponent()({
    name: "VCardActions",
    props: makeComponentProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      provideDefaults({
        VBtn: {
          slim: true,
          variant: "text"
        }
      });
      useRender(() => {
        var _a2;
        return createVNode("div", {
          "class": ["v-card-actions", props.class],
          "style": props.style
        }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VCard/VCardSubtitle.mjs
  var VCardSubtitle = createSimpleFunctional("v-card-subtitle");

  // ../library_management/node_modules/vuetify/lib/components/VCard/VCardTitle.mjs
  var VCardTitle = createSimpleFunctional("v-card-title");

  // ../library_management/node_modules/vuetify/lib/components/VCard/VCardItem.mjs
  var makeCardItemProps = propsFactory(__spreadValues(__spreadValues({
    appendAvatar: String,
    appendIcon: IconValue,
    prependAvatar: String,
    prependIcon: IconValue,
    subtitle: [String, Number],
    title: [String, Number]
  }, makeComponentProps()), makeDensityProps()), "VCardItem");
  var VCardItem = genericComponent()({
    name: "VCardItem",
    props: makeCardItemProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useRender(() => {
        var _a2;
        const hasPrependMedia = !!(props.prependAvatar || props.prependIcon);
        const hasPrepend = !!(hasPrependMedia || slots.prepend);
        const hasAppendMedia = !!(props.appendAvatar || props.appendIcon);
        const hasAppend = !!(hasAppendMedia || slots.append);
        const hasTitle = !!(props.title != null || slots.title);
        const hasSubtitle = !!(props.subtitle != null || slots.subtitle);
        return createVNode("div", {
          "class": ["v-card-item", props.class],
          "style": props.style
        }, [hasPrepend && createVNode("div", {
          "key": "prepend",
          "class": "v-card-item__prepend"
        }, [!slots.prepend ? createVNode(Fragment, null, [props.prependAvatar && createVNode(VAvatar, {
          "key": "prepend-avatar",
          "density": props.density,
          "image": props.prependAvatar
        }, null), props.prependIcon && createVNode(VIcon, {
          "key": "prepend-icon",
          "density": props.density,
          "icon": props.prependIcon
        }, null)]) : createVNode(VDefaultsProvider, {
          "key": "prepend-defaults",
          "disabled": !hasPrependMedia,
          "defaults": {
            VAvatar: {
              density: props.density,
              image: props.prependAvatar
            },
            VIcon: {
              density: props.density,
              icon: props.prependIcon
            }
          }
        }, slots.prepend)]), createVNode("div", {
          "class": "v-card-item__content"
        }, [hasTitle && createVNode(VCardTitle, {
          "key": "title"
        }, {
          default: () => {
            var _a3, _b;
            return [(_b = (_a3 = slots.title) == null ? void 0 : _a3.call(slots)) != null ? _b : props.title];
          }
        }), hasSubtitle && createVNode(VCardSubtitle, {
          "key": "subtitle"
        }, {
          default: () => {
            var _a3, _b;
            return [(_b = (_a3 = slots.subtitle) == null ? void 0 : _a3.call(slots)) != null ? _b : props.subtitle];
          }
        }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots)]), hasAppend && createVNode("div", {
          "key": "append",
          "class": "v-card-item__append"
        }, [!slots.append ? createVNode(Fragment, null, [props.appendIcon && createVNode(VIcon, {
          "key": "append-icon",
          "density": props.density,
          "icon": props.appendIcon
        }, null), props.appendAvatar && createVNode(VAvatar, {
          "key": "append-avatar",
          "density": props.density,
          "image": props.appendAvatar
        }, null)]) : createVNode(VDefaultsProvider, {
          "key": "append-defaults",
          "disabled": !hasAppendMedia,
          "defaults": {
            VAvatar: {
              density: props.density,
              image: props.appendAvatar
            },
            VIcon: {
              density: props.density,
              icon: props.appendIcon
            }
          }
        }, slots.append)])]);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VCard/VCardText.mjs
  var VCardText = createSimpleFunctional("v-card-text");

  // ../library_management/node_modules/vuetify/lib/components/VCard/VCard.mjs
  var makeVCardProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    appendAvatar: String,
    appendIcon: IconValue,
    disabled: Boolean,
    flat: Boolean,
    hover: Boolean,
    image: String,
    link: {
      type: Boolean,
      default: void 0
    },
    prependAvatar: String,
    prependIcon: IconValue,
    ripple: {
      type: [Boolean, Object],
      default: true
    },
    subtitle: [String, Number],
    text: [String, Number],
    title: [String, Number]
  }, makeBorderProps()), makeComponentProps()), makeDensityProps()), makeDimensionProps()), makeElevationProps()), makeLoaderProps()), makeLocationProps()), makePositionProps()), makeRoundedProps()), makeRouterProps()), makeTagProps()), makeThemeProps()), makeVariantProps({
    variant: "elevated"
  })), "VCard");
  var VCard = genericComponent()({
    name: "VCard",
    directives: {
      Ripple
    },
    props: makeVCardProps(),
    setup(props, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      const {
        borderClasses
      } = useBorder(props);
      const {
        colorClasses,
        colorStyles,
        variantClasses
      } = useVariant(props);
      const {
        densityClasses
      } = useDensity(props);
      const {
        dimensionStyles
      } = useDimension(props);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        loaderClasses
      } = useLoader(props);
      const {
        locationStyles
      } = useLocation(props);
      const {
        positionClasses
      } = usePosition(props);
      const {
        roundedClasses
      } = useRounded(props);
      const link = useLink(props, attrs);
      const isLink = computed2(() => props.link !== false && link.isLink.value);
      const isClickable = computed2(() => !props.disabled && props.link !== false && (props.link || link.isClickable.value));
      useRender(() => {
        const Tag = isLink.value ? "a" : props.tag;
        const hasTitle = !!(slots.title || props.title != null);
        const hasSubtitle = !!(slots.subtitle || props.subtitle != null);
        const hasHeader = hasTitle || hasSubtitle;
        const hasAppend = !!(slots.append || props.appendAvatar || props.appendIcon);
        const hasPrepend = !!(slots.prepend || props.prependAvatar || props.prependIcon);
        const hasImage = !!(slots.image || props.image);
        const hasCardItem = hasHeader || hasPrepend || hasAppend;
        const hasText = !!(slots.text || props.text != null);
        return withDirectives(createVNode(Tag, {
          "class": ["v-card", {
            "v-card--disabled": props.disabled,
            "v-card--flat": props.flat,
            "v-card--hover": props.hover && !(props.disabled || props.flat),
            "v-card--link": isClickable.value
          }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, loaderClasses.value, positionClasses.value, roundedClasses.value, variantClasses.value, props.class],
          "style": [colorStyles.value, dimensionStyles.value, locationStyles.value, props.style],
          "href": link.href.value,
          "onClick": isClickable.value && link.navigate,
          "tabindex": props.disabled ? -1 : void 0
        }, {
          default: () => {
            var _a2;
            return [hasImage && createVNode("div", {
              "key": "image",
              "class": "v-card__image"
            }, [!slots.image ? createVNode(VImg, {
              "key": "image-img",
              "cover": true,
              "src": props.image
            }, null) : createVNode(VDefaultsProvider, {
              "key": "image-defaults",
              "disabled": !props.image,
              "defaults": {
                VImg: {
                  cover: true,
                  src: props.image
                }
              }
            }, slots.image)]), createVNode(LoaderSlot, {
              "name": "v-card",
              "active": !!props.loading,
              "color": typeof props.loading === "boolean" ? void 0 : props.loading
            }, {
              default: slots.loader
            }), hasCardItem && createVNode(VCardItem, {
              "key": "item",
              "prependAvatar": props.prependAvatar,
              "prependIcon": props.prependIcon,
              "title": props.title,
              "subtitle": props.subtitle,
              "appendAvatar": props.appendAvatar,
              "appendIcon": props.appendIcon
            }, {
              default: slots.item,
              prepend: slots.prepend,
              title: slots.title,
              subtitle: slots.subtitle,
              append: slots.append
            }), hasText && createVNode(VCardText, {
              "key": "text"
            }, {
              default: () => {
                var _a3, _b;
                return [(_b = (_a3 = slots.text) == null ? void 0 : _a3.call(slots)) != null ? _b : props.text];
              }
            }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots), slots.actions && createVNode(VCardActions, null, {
              default: slots.actions
            }), genOverlays(isClickable.value, "v-card")];
          }
        }), [[resolveDirective("ripple"), isClickable.value && props.ripple]]);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/directives/touch/index.mjs
  var handleGesture = (wrapper) => {
    const {
      touchstartX,
      touchendX,
      touchstartY,
      touchendY
    } = wrapper;
    const dirRatio = 0.5;
    const minDistance = 16;
    wrapper.offsetX = touchendX - touchstartX;
    wrapper.offsetY = touchendY - touchstartY;
    if (Math.abs(wrapper.offsetY) < dirRatio * Math.abs(wrapper.offsetX)) {
      wrapper.left && touchendX < touchstartX - minDistance && wrapper.left(wrapper);
      wrapper.right && touchendX > touchstartX + minDistance && wrapper.right(wrapper);
    }
    if (Math.abs(wrapper.offsetX) < dirRatio * Math.abs(wrapper.offsetY)) {
      wrapper.up && touchendY < touchstartY - minDistance && wrapper.up(wrapper);
      wrapper.down && touchendY > touchstartY + minDistance && wrapper.down(wrapper);
    }
  };
  function touchstart(event, wrapper) {
    var _a2;
    const touch = event.changedTouches[0];
    wrapper.touchstartX = touch.clientX;
    wrapper.touchstartY = touch.clientY;
    (_a2 = wrapper.start) == null ? void 0 : _a2.call(wrapper, __spreadValues({
      originalEvent: event
    }, wrapper));
  }
  function touchend(event, wrapper) {
    var _a2;
    const touch = event.changedTouches[0];
    wrapper.touchendX = touch.clientX;
    wrapper.touchendY = touch.clientY;
    (_a2 = wrapper.end) == null ? void 0 : _a2.call(wrapper, __spreadValues({
      originalEvent: event
    }, wrapper));
    handleGesture(wrapper);
  }
  function touchmove(event, wrapper) {
    var _a2;
    const touch = event.changedTouches[0];
    wrapper.touchmoveX = touch.clientX;
    wrapper.touchmoveY = touch.clientY;
    (_a2 = wrapper.move) == null ? void 0 : _a2.call(wrapper, __spreadValues({
      originalEvent: event
    }, wrapper));
  }
  function createHandlers() {
    let value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const wrapper = {
      touchstartX: 0,
      touchstartY: 0,
      touchendX: 0,
      touchendY: 0,
      touchmoveX: 0,
      touchmoveY: 0,
      offsetX: 0,
      offsetY: 0,
      left: value.left,
      right: value.right,
      up: value.up,
      down: value.down,
      start: value.start,
      move: value.move,
      end: value.end
    };
    return {
      touchstart: (e) => touchstart(e, wrapper),
      touchend: (e) => touchend(e, wrapper),
      touchmove: (e) => touchmove(e, wrapper)
    };
  }
  function mounted3(el, binding) {
    var _a2, _b, _c;
    const value = binding.value;
    const target = (value == null ? void 0 : value.parent) ? el.parentElement : el;
    const options = (_a2 = value == null ? void 0 : value.options) != null ? _a2 : {
      passive: true
    };
    const uid2 = (_b = binding.instance) == null ? void 0 : _b.$.uid;
    if (!target || !uid2)
      return;
    const handlers2 = createHandlers(binding.value);
    target._touchHandlers = (_c = target._touchHandlers) != null ? _c : /* @__PURE__ */ Object.create(null);
    target._touchHandlers[uid2] = handlers2;
    keys(handlers2).forEach((eventName2) => {
      target.addEventListener(eventName2, handlers2[eventName2], options);
    });
  }
  function unmounted3(el, binding) {
    var _a2, _b;
    const target = ((_a2 = binding.value) == null ? void 0 : _a2.parent) ? el.parentElement : el;
    const uid2 = (_b = binding.instance) == null ? void 0 : _b.$.uid;
    if (!(target == null ? void 0 : target._touchHandlers) || !uid2)
      return;
    const handlers2 = target._touchHandlers[uid2];
    keys(handlers2).forEach((eventName2) => {
      target.removeEventListener(eventName2, handlers2[eventName2]);
    });
    delete target._touchHandlers[uid2];
  }
  var Touch = {
    mounted: mounted3,
    unmounted: unmounted3
  };
  var touch_default = Touch;

  // ../library_management/node_modules/vuetify/lib/components/VWindow/VWindow.mjs
  var VWindowSymbol = Symbol.for("vuetify:v-window");
  var VWindowGroupSymbol = Symbol.for("vuetify:v-window-group");
  var makeVWindowProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({
    continuous: Boolean,
    nextIcon: {
      type: [Boolean, String, Function, Object],
      default: "$next"
    },
    prevIcon: {
      type: [Boolean, String, Function, Object],
      default: "$prev"
    },
    reverse: Boolean,
    showArrows: {
      type: [Boolean, String],
      validator: (v) => typeof v === "boolean" || v === "hover"
    },
    touch: {
      type: [Object, Boolean],
      default: void 0
    },
    direction: {
      type: String,
      default: "horizontal"
    },
    modelValue: null,
    disabled: Boolean,
    selectedClass: {
      type: String,
      default: "v-window-item--active"
    },
    mandatory: {
      type: [Boolean, String],
      default: "force"
    }
  }, makeComponentProps()), makeTagProps()), makeThemeProps()), "VWindow");
  var VWindow = genericComponent()({
    name: "VWindow",
    directives: {
      Touch
    },
    props: makeVWindowProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      const {
        isRtl
      } = useRtl();
      const {
        t
      } = useLocale();
      const group = useGroup(props, VWindowGroupSymbol);
      const rootRef = ref();
      const isRtlReverse = computed2(() => isRtl.value ? !props.reverse : props.reverse);
      const isReversed = shallowRef(false);
      const transition = computed2(() => {
        const axis = props.direction === "vertical" ? "y" : "x";
        const reverse = isRtlReverse.value ? !isReversed.value : isReversed.value;
        const direction = reverse ? "-reverse" : "";
        return `v-window-${axis}${direction}-transition`;
      });
      const transitionCount = shallowRef(0);
      const transitionHeight = ref(void 0);
      const activeIndex = computed2(() => {
        return group.items.value.findIndex((item) => group.selected.value.includes(item.id));
      });
      watch(activeIndex, (newVal, oldVal) => {
        const itemsLength = group.items.value.length;
        const lastIndex = itemsLength - 1;
        if (itemsLength <= 2) {
          isReversed.value = newVal < oldVal;
        } else if (newVal === lastIndex && oldVal === 0) {
          isReversed.value = true;
        } else if (newVal === 0 && oldVal === lastIndex) {
          isReversed.value = false;
        } else {
          isReversed.value = newVal < oldVal;
        }
      });
      provide(VWindowSymbol, {
        transition,
        isReversed,
        transitionCount,
        transitionHeight,
        rootRef
      });
      const canMoveBack = computed2(() => props.continuous || activeIndex.value !== 0);
      const canMoveForward = computed2(() => props.continuous || activeIndex.value !== group.items.value.length - 1);
      function prev() {
        canMoveBack.value && group.prev();
      }
      function next() {
        canMoveForward.value && group.next();
      }
      const arrows = computed2(() => {
        const arrows2 = [];
        const prevProps = {
          icon: isRtl.value ? props.nextIcon : props.prevIcon,
          class: `v-window__${isRtlReverse.value ? "right" : "left"}`,
          onClick: group.prev,
          "aria-label": t("$vuetify.carousel.prev")
        };
        arrows2.push(canMoveBack.value ? slots.prev ? slots.prev({
          props: prevProps
        }) : createVNode(VBtn, prevProps, null) : createVNode("div", null, null));
        const nextProps = {
          icon: isRtl.value ? props.prevIcon : props.nextIcon,
          class: `v-window__${isRtlReverse.value ? "left" : "right"}`,
          onClick: group.next,
          "aria-label": t("$vuetify.carousel.next")
        };
        arrows2.push(canMoveForward.value ? slots.next ? slots.next({
          props: nextProps
        }) : createVNode(VBtn, nextProps, null) : createVNode("div", null, null));
        return arrows2;
      });
      const touchOptions = computed2(() => {
        if (props.touch === false)
          return props.touch;
        const options = {
          left: () => {
            isRtlReverse.value ? prev() : next();
          },
          right: () => {
            isRtlReverse.value ? next() : prev();
          },
          start: (_ref2) => {
            let {
              originalEvent
            } = _ref2;
            originalEvent.stopPropagation();
          }
        };
        return __spreadValues(__spreadValues({}, options), props.touch === true ? {} : props.touch);
      });
      useRender(() => withDirectives(createVNode(props.tag, {
        "ref": rootRef,
        "class": ["v-window", {
          "v-window--show-arrows-on-hover": props.showArrows === "hover"
        }, themeClasses.value, props.class],
        "style": props.style
      }, {
        default: () => {
          var _a2, _b;
          return [createVNode("div", {
            "class": "v-window__container",
            "style": {
              height: transitionHeight.value
            }
          }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
            group
          }), props.showArrows !== false && createVNode("div", {
            "class": "v-window__controls"
          }, [arrows.value])]), (_b = slots.additional) == null ? void 0 : _b.call(slots, {
            group
          })];
        }
      }), [[resolveDirective("touch"), touchOptions.value]]));
      return {
        group
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VCarousel/VCarousel.mjs
  var makeVCarouselProps = propsFactory(__spreadValues({
    color: String,
    cycle: Boolean,
    delimiterIcon: {
      type: IconValue,
      default: "$delimiter"
    },
    height: {
      type: [Number, String],
      default: 500
    },
    hideDelimiters: Boolean,
    hideDelimiterBackground: Boolean,
    interval: {
      type: [Number, String],
      default: 6e3,
      validator: (value) => Number(value) > 0
    },
    progress: [Boolean, String],
    verticalDelimiters: [Boolean, String]
  }, makeVWindowProps({
    continuous: true,
    mandatory: "force",
    showArrows: true
  })), "VCarousel");
  var VCarousel = genericComponent()({
    name: "VCarousel",
    props: makeVCarouselProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const model = useProxiedModel(props, "modelValue");
      const {
        t
      } = useLocale();
      const windowRef = ref();
      let slideTimeout = -1;
      watch(model, restartTimeout);
      watch(() => props.interval, restartTimeout);
      watch(() => props.cycle, (val) => {
        if (val)
          restartTimeout();
        else
          window.clearTimeout(slideTimeout);
      });
      onMounted(startTimeout);
      function startTimeout() {
        if (!props.cycle || !windowRef.value)
          return;
        slideTimeout = window.setTimeout(windowRef.value.group.next, +props.interval > 0 ? +props.interval : 6e3);
      }
      function restartTimeout() {
        window.clearTimeout(slideTimeout);
        window.requestAnimationFrame(startTimeout);
      }
      useRender(() => {
        const windowProps = VWindow.filterProps(props);
        return createVNode(VWindow, mergeProps({
          "ref": windowRef
        }, windowProps, {
          "modelValue": model.value,
          "onUpdate:modelValue": ($event) => model.value = $event,
          "class": ["v-carousel", {
            "v-carousel--hide-delimiter-background": props.hideDelimiterBackground,
            "v-carousel--vertical-delimiters": props.verticalDelimiters
          }, props.class],
          "style": [{
            height: convertToUnit(props.height)
          }, props.style]
        }), {
          default: slots.default,
          additional: (_ref2) => {
            let {
              group
            } = _ref2;
            return createVNode(Fragment, null, [!props.hideDelimiters && createVNode("div", {
              "class": "v-carousel__controls",
              "style": {
                left: props.verticalDelimiters === "left" && props.verticalDelimiters ? 0 : "auto",
                right: props.verticalDelimiters === "right" ? 0 : "auto"
              }
            }, [group.items.value.length > 0 && createVNode(VDefaultsProvider, {
              "defaults": {
                VBtn: {
                  color: props.color,
                  icon: props.delimiterIcon,
                  size: "x-small",
                  variant: "text"
                }
              },
              "scoped": true
            }, {
              default: () => [group.items.value.map((item, index) => {
                const props2 = {
                  id: `carousel-item-${item.id}`,
                  "aria-label": t("$vuetify.carousel.ariaLabel.delimiter", index + 1, group.items.value.length),
                  class: ["v-carousel__controls__item", group.isSelected(item.id) && "v-btn--active"],
                  onClick: () => group.select(item.id, true)
                };
                return slots.item ? slots.item({
                  props: props2,
                  item
                }) : createVNode(VBtn, mergeProps(item, props2), null);
              })]
            })]), props.progress && createVNode(VProgressLinear, {
              "class": "v-carousel__progress",
              "color": typeof props.progress === "string" ? props.progress : void 0,
              "modelValue": (group.getItemIndex(model.value) + 1) / group.items.value.length * 100
            }, null)]);
          },
          prev: slots.prev,
          next: slots.next
        });
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VWindow/VWindowItem.mjs
  var makeVWindowItemProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({
    reverseTransition: {
      type: [Boolean, String],
      default: void 0
    },
    transition: {
      type: [Boolean, String],
      default: void 0
    }
  }, makeComponentProps()), makeGroupItemProps()), makeLazyProps()), "VWindowItem");
  var VWindowItem = genericComponent()({
    name: "VWindowItem",
    directives: {
      Touch: touch_default
    },
    props: makeVWindowItemProps(),
    emits: {
      "group:selected": (val) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const window2 = inject(VWindowSymbol);
      const groupItem = useGroupItem(props, VWindowGroupSymbol);
      const {
        isBooted
      } = useSsrBoot();
      if (!window2 || !groupItem)
        throw new Error("[Vuetify] VWindowItem must be used inside VWindow");
      const isTransitioning = shallowRef(false);
      const hasTransition = computed2(() => isBooted.value && (window2.isReversed.value ? props.reverseTransition !== false : props.transition !== false));
      function onAfterTransition() {
        if (!isTransitioning.value || !window2) {
          return;
        }
        isTransitioning.value = false;
        if (window2.transitionCount.value > 0) {
          window2.transitionCount.value -= 1;
          if (window2.transitionCount.value === 0) {
            window2.transitionHeight.value = void 0;
          }
        }
      }
      function onBeforeTransition() {
        var _a2;
        if (isTransitioning.value || !window2) {
          return;
        }
        isTransitioning.value = true;
        if (window2.transitionCount.value === 0) {
          window2.transitionHeight.value = convertToUnit((_a2 = window2.rootRef.value) == null ? void 0 : _a2.clientHeight);
        }
        window2.transitionCount.value += 1;
      }
      function onTransitionCancelled() {
        onAfterTransition();
      }
      function onEnterTransition(el) {
        if (!isTransitioning.value) {
          return;
        }
        nextTick(() => {
          if (!hasTransition.value || !isTransitioning.value || !window2) {
            return;
          }
          window2.transitionHeight.value = convertToUnit(el.clientHeight);
        });
      }
      const transition = computed2(() => {
        const name = window2.isReversed.value ? props.reverseTransition : props.transition;
        return !hasTransition.value ? false : {
          name: typeof name !== "string" ? window2.transition.value : name,
          onBeforeEnter: onBeforeTransition,
          onAfterEnter: onAfterTransition,
          onEnterCancelled: onTransitionCancelled,
          onBeforeLeave: onBeforeTransition,
          onAfterLeave: onAfterTransition,
          onLeaveCancelled: onTransitionCancelled,
          onEnter: onEnterTransition
        };
      });
      const {
        hasContent
      } = useLazy(props, groupItem.isSelected);
      useRender(() => createVNode(MaybeTransition, {
        "transition": transition.value,
        "disabled": !isBooted.value
      }, {
        default: () => {
          var _a2;
          return [withDirectives(createVNode("div", {
            "class": ["v-window-item", groupItem.selectedClass.value, props.class],
            "style": props.style
          }, [hasContent.value && ((_a2 = slots.default) == null ? void 0 : _a2.call(slots))]), [[vShow, groupItem.isSelected.value]])];
        }
      }));
      return {
        groupItem
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VCarousel/VCarouselItem.mjs
  var makeVCarouselItemProps = propsFactory(__spreadValues(__spreadValues({}, makeVImgProps()), makeVWindowItemProps()), "VCarouselItem");
  var VCarouselItem = genericComponent()({
    name: "VCarouselItem",
    inheritAttrs: false,
    props: makeVCarouselItemProps(),
    setup(props, _ref) {
      let {
        slots,
        attrs
      } = _ref;
      useRender(() => {
        const imgProps = VImg.filterProps(props);
        const windowItemProps = VWindowItem.filterProps(props);
        return createVNode(VWindowItem, mergeProps({
          "class": "v-carousel-item"
        }, windowItemProps), {
          default: () => [createVNode(VImg, mergeProps(attrs, imgProps), slots)]
        });
      });
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VCode/index.mjs
  var VCode = createSimpleFunctional("v-code");

  // ../library_management/node_modules/vuetify/lib/components/VColorPicker/VColorPickerCanvas.mjs
  var makeVColorPickerCanvasProps = propsFactory(__spreadValues({
    color: {
      type: Object
    },
    disabled: Boolean,
    dotSize: {
      type: [Number, String],
      default: 10
    },
    height: {
      type: [Number, String],
      default: 150
    },
    width: {
      type: [Number, String],
      default: 300
    }
  }, makeComponentProps()), "VColorPickerCanvas");
  var VColorPickerCanvas = defineComponent2({
    name: "VColorPickerCanvas",
    props: makeVColorPickerCanvasProps(),
    emits: {
      "update:color": (color) => true,
      "update:position": (hue) => true
    },
    setup(props, _ref) {
      let {
        emit: emit2
      } = _ref;
      const isInteracting = shallowRef(false);
      const canvasRef = ref();
      const canvasWidth = shallowRef(parseFloat(props.width));
      const canvasHeight = shallowRef(parseFloat(props.height));
      const _dotPosition = ref({
        x: 0,
        y: 0
      });
      const dotPosition = computed2({
        get: () => _dotPosition.value,
        set(val) {
          var _a2, _b, _c, _d;
          if (!canvasRef.value)
            return;
          const {
            x,
            y
          } = val;
          _dotPosition.value = val;
          emit2("update:color", {
            h: (_b = (_a2 = props.color) == null ? void 0 : _a2.h) != null ? _b : 0,
            s: clamp(x, 0, canvasWidth.value) / canvasWidth.value,
            v: 1 - clamp(y, 0, canvasHeight.value) / canvasHeight.value,
            a: (_d = (_c = props.color) == null ? void 0 : _c.a) != null ? _d : 1
          });
        }
      });
      const dotStyles = computed2(() => {
        const {
          x,
          y
        } = dotPosition.value;
        const radius = parseInt(props.dotSize, 10) / 2;
        return {
          width: convertToUnit(props.dotSize),
          height: convertToUnit(props.dotSize),
          transform: `translate(${convertToUnit(x - radius)}, ${convertToUnit(y - radius)})`
        };
      });
      const {
        resizeRef
      } = useResizeObserver((entries) => {
        var _a2;
        if (!((_a2 = resizeRef.value) == null ? void 0 : _a2.offsetParent))
          return;
        const {
          width,
          height
        } = entries[0].contentRect;
        canvasWidth.value = width;
        canvasHeight.value = height;
      });
      function updateDotPosition(x, y, rect) {
        const {
          left,
          top,
          width,
          height
        } = rect;
        dotPosition.value = {
          x: clamp(x - left, 0, width),
          y: clamp(y - top, 0, height)
        };
      }
      function handleMouseDown(e) {
        if (e.type === "mousedown") {
          e.preventDefault();
        }
        if (props.disabled)
          return;
        handleMouseMove(e);
        window.addEventListener("mousemove", handleMouseMove);
        window.addEventListener("mouseup", handleMouseUp);
        window.addEventListener("touchmove", handleMouseMove);
        window.addEventListener("touchend", handleMouseUp);
      }
      function handleMouseMove(e) {
        if (props.disabled || !canvasRef.value)
          return;
        isInteracting.value = true;
        const coords = getEventCoordinates(e);
        updateDotPosition(coords.clientX, coords.clientY, canvasRef.value.getBoundingClientRect());
      }
      function handleMouseUp() {
        window.removeEventListener("mousemove", handleMouseMove);
        window.removeEventListener("mouseup", handleMouseUp);
        window.removeEventListener("touchmove", handleMouseMove);
        window.removeEventListener("touchend", handleMouseUp);
      }
      function updateCanvas() {
        var _a2, _b;
        if (!canvasRef.value)
          return;
        const canvas = canvasRef.value;
        const ctx = canvas.getContext("2d");
        if (!ctx)
          return;
        const saturationGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
        saturationGradient.addColorStop(0, "hsla(0, 0%, 100%, 1)");
        saturationGradient.addColorStop(1, `hsla(${(_b = (_a2 = props.color) == null ? void 0 : _a2.h) != null ? _b : 0}, 100%, 50%, 1)`);
        ctx.fillStyle = saturationGradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        const valueGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        valueGradient.addColorStop(0, "hsla(0, 0%, 0%, 0)");
        valueGradient.addColorStop(1, "hsla(0, 0%, 0%, 1)");
        ctx.fillStyle = valueGradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
      watch(() => {
        var _a2;
        return (_a2 = props.color) == null ? void 0 : _a2.h;
      }, updateCanvas, {
        immediate: true
      });
      watch(() => [canvasWidth.value, canvasHeight.value], (newVal, oldVal) => {
        updateCanvas();
        _dotPosition.value = {
          x: dotPosition.value.x * newVal[0] / oldVal[0],
          y: dotPosition.value.y * newVal[1] / oldVal[1]
        };
      }, {
        flush: "post"
      });
      watch(() => props.color, () => {
        if (isInteracting.value) {
          isInteracting.value = false;
          return;
        }
        _dotPosition.value = props.color ? {
          x: props.color.s * canvasWidth.value,
          y: (1 - props.color.v) * canvasHeight.value
        } : {
          x: 0,
          y: 0
        };
      }, {
        deep: true,
        immediate: true
      });
      onMounted(() => updateCanvas());
      useRender(() => createVNode("div", {
        "ref": resizeRef,
        "class": ["v-color-picker-canvas", props.class],
        "style": props.style,
        "onMousedown": handleMouseDown,
        "onTouchstartPassive": handleMouseDown
      }, [createVNode("canvas", {
        "ref": canvasRef,
        "width": canvasWidth.value,
        "height": canvasHeight.value
      }, null), props.color && createVNode("div", {
        "class": ["v-color-picker-canvas__dot", {
          "v-color-picker-canvas__dot--disabled": props.disabled
        }],
        "style": dotStyles.value
      }, null)]));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VColorPicker/util/index.mjs
  function stripAlpha(color, stripAlpha2) {
    if (stripAlpha2) {
      const _a2 = color, {
        a
      } = _a2, rest = __objRest(_a2, [
        "a"
      ]);
      return rest;
    }
    return color;
  }
  function extractColor(color, input) {
    if (input == null || typeof input === "string") {
      const hex2 = HSVtoHex(color);
      if (color.a === 1)
        return hex2.slice(0, 7);
      else
        return hex2;
    }
    if (typeof input === "object") {
      let converted;
      if (has2(input, ["r", "g", "b"]))
        converted = HSVtoRGB(color);
      else if (has2(input, ["h", "s", "l"]))
        converted = HSVtoHSL(color);
      else if (has2(input, ["h", "s", "v"]))
        converted = color;
      return stripAlpha(converted, !has2(input, ["a"]) && color.a === 1);
    }
    return color;
  }
  var nullColor = {
    h: 0,
    s: 0,
    v: 0,
    a: 1
  };
  var rgba = {
    inputProps: {
      type: "number",
      min: 0
    },
    inputs: [{
      label: "R",
      max: 255,
      step: 1,
      getValue: (c) => Math.round(c.r),
      getColor: (c, v) => __spreadProps(__spreadValues({}, c), {
        r: Number(v)
      })
    }, {
      label: "G",
      max: 255,
      step: 1,
      getValue: (c) => Math.round(c.g),
      getColor: (c, v) => __spreadProps(__spreadValues({}, c), {
        g: Number(v)
      })
    }, {
      label: "B",
      max: 255,
      step: 1,
      getValue: (c) => Math.round(c.b),
      getColor: (c, v) => __spreadProps(__spreadValues({}, c), {
        b: Number(v)
      })
    }, {
      label: "A",
      max: 1,
      step: 0.01,
      getValue: (_ref) => {
        let {
          a
        } = _ref;
        return a != null ? Math.round(a * 100) / 100 : 1;
      },
      getColor: (c, v) => __spreadProps(__spreadValues({}, c), {
        a: Number(v)
      })
    }],
    to: HSVtoRGB,
    from: RGBtoHSV
  };
  var _a;
  var rgb = __spreadProps(__spreadValues({}, rgba), {
    inputs: (_a = rgba.inputs) == null ? void 0 : _a.slice(0, 3)
  });
  var hsla = {
    inputProps: {
      type: "number",
      min: 0
    },
    inputs: [{
      label: "H",
      max: 360,
      step: 1,
      getValue: (c) => Math.round(c.h),
      getColor: (c, v) => __spreadProps(__spreadValues({}, c), {
        h: Number(v)
      })
    }, {
      label: "S",
      max: 1,
      step: 0.01,
      getValue: (c) => Math.round(c.s * 100) / 100,
      getColor: (c, v) => __spreadProps(__spreadValues({}, c), {
        s: Number(v)
      })
    }, {
      label: "L",
      max: 1,
      step: 0.01,
      getValue: (c) => Math.round(c.l * 100) / 100,
      getColor: (c, v) => __spreadProps(__spreadValues({}, c), {
        l: Number(v)
      })
    }, {
      label: "A",
      max: 1,
      step: 0.01,
      getValue: (_ref2) => {
        let {
          a
        } = _ref2;
        return a != null ? Math.round(a * 100) / 100 : 1;
      },
      getColor: (c, v) => __spreadProps(__spreadValues({}, c), {
        a: Number(v)
      })
    }],
    to: HSVtoHSL,
    from: HSLtoHSV
  };
  var hsl = __spreadProps(__spreadValues({}, hsla), {
    inputs: hsla.inputs.slice(0, 3)
  });
  var hexa = {
    inputProps: {
      type: "text"
    },
    inputs: [{
      label: "HEXA",
      getValue: (c) => c,
      getColor: (c, v) => v
    }],
    to: HSVtoHex,
    from: HexToHSV
  };
  var hex = __spreadProps(__spreadValues({}, hexa), {
    inputs: [{
      label: "HEX",
      getValue: (c) => c.slice(0, 7),
      getColor: (c, v) => v
    }]
  });
  var modes = {
    rgb,
    rgba,
    hsl,
    hsla,
    hex,
    hexa
  };

  // ../library_management/node_modules/vuetify/lib/components/VColorPicker/VColorPickerEdit.mjs
  var VColorPickerInput = (_ref) => {
    let _a2 = _ref, {
      label
    } = _a2, rest = __objRest(_a2, [
      "label"
    ]);
    return createVNode("div", {
      "class": "v-color-picker-edit__input"
    }, [createVNode("input", rest, null), createVNode("span", null, [label])]);
  };
  var makeVColorPickerEditProps = propsFactory(__spreadValues({
    color: Object,
    disabled: Boolean,
    mode: {
      type: String,
      default: "rgba",
      validator: (v) => Object.keys(modes).includes(v)
    },
    modes: {
      type: Array,
      default: () => Object.keys(modes),
      validator: (v) => Array.isArray(v) && v.every((m) => Object.keys(modes).includes(m))
    }
  }, makeComponentProps()), "VColorPickerEdit");
  var VColorPickerEdit = defineComponent2({
    name: "VColorPickerEdit",
    props: makeVColorPickerEditProps(),
    emits: {
      "update:color": (color) => true,
      "update:mode": (mode) => true
    },
    setup(props, _ref2) {
      let {
        emit: emit2
      } = _ref2;
      const enabledModes = computed2(() => {
        return props.modes.map((key) => __spreadProps(__spreadValues({}, modes[key]), {
          name: key
        }));
      });
      const inputs = computed2(() => {
        var _a2;
        const mode = enabledModes.value.find((m) => m.name === props.mode);
        if (!mode)
          return [];
        const color = props.color ? mode.to(props.color) : null;
        return (_a2 = mode.inputs) == null ? void 0 : _a2.map((_ref3) => {
          let _a3 = _ref3, {
            getValue,
            getColor
          } = _a3, inputProps = __objRest(_a3, [
            "getValue",
            "getColor"
          ]);
          return __spreadProps(__spreadValues(__spreadValues({}, mode.inputProps), inputProps), {
            disabled: props.disabled,
            value: color && getValue(color),
            onChange: (e) => {
              const target = e.target;
              if (!target)
                return;
              emit2("update:color", mode.from(getColor(color != null ? color : mode.to(nullColor), target.value)));
            }
          });
        });
      });
      useRender(() => {
        var _a2;
        return createVNode("div", {
          "class": ["v-color-picker-edit", props.class],
          "style": props.style
        }, [(_a2 = inputs.value) == null ? void 0 : _a2.map((props2) => createVNode(VColorPickerInput, props2, null)), enabledModes.value.length > 1 && createVNode(VBtn, {
          "icon": "$unfold",
          "size": "x-small",
          "variant": "plain",
          "onClick": () => {
            const mi = enabledModes.value.findIndex((m) => m.name === props.mode);
            emit2("update:mode", enabledModes.value[(mi + 1) % enabledModes.value.length].name);
          }
        }, null)]);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VSlider/slider.mjs
  var VSliderSymbol = Symbol.for("vuetify:v-slider");
  function getOffset2(e, el, direction) {
    const vertical = direction === "vertical";
    const rect = el.getBoundingClientRect();
    const touch = "touches" in e ? e.touches[0] : e;
    return vertical ? touch.clientY - (rect.top + rect.height / 2) : touch.clientX - (rect.left + rect.width / 2);
  }
  function getPosition(e, position) {
    if ("touches" in e && e.touches.length)
      return e.touches[0][position];
    else if ("changedTouches" in e && e.changedTouches.length)
      return e.changedTouches[0][position];
    else
      return e[position];
  }
  var makeSliderProps = propsFactory(__spreadProps(__spreadValues(__spreadValues({
    disabled: {
      type: Boolean,
      default: null
    },
    error: Boolean,
    readonly: {
      type: Boolean,
      default: null
    },
    max: {
      type: [Number, String],
      default: 100
    },
    min: {
      type: [Number, String],
      default: 0
    },
    step: {
      type: [Number, String],
      default: 0
    },
    thumbColor: String,
    thumbLabel: {
      type: [Boolean, String],
      default: void 0,
      validator: (v) => typeof v === "boolean" || v === "always"
    },
    thumbSize: {
      type: [Number, String],
      default: 20
    },
    showTicks: {
      type: [Boolean, String],
      default: false,
      validator: (v) => typeof v === "boolean" || v === "always"
    },
    ticks: {
      type: [Array, Object]
    },
    tickSize: {
      type: [Number, String],
      default: 2
    },
    color: String,
    trackColor: String,
    trackFillColor: String,
    trackSize: {
      type: [Number, String],
      default: 4
    },
    direction: {
      type: String,
      default: "horizontal",
      validator: (v) => ["vertical", "horizontal"].includes(v)
    },
    reverse: Boolean
  }, makeRoundedProps()), makeElevationProps({
    elevation: 2
  })), {
    ripple: {
      type: Boolean,
      default: true
    }
  }), "Slider");
  var useSteps = (props) => {
    const min = computed2(() => parseFloat(props.min));
    const max = computed2(() => parseFloat(props.max));
    const step = computed2(() => +props.step > 0 ? parseFloat(props.step) : 0);
    const decimals = computed2(() => Math.max(getDecimals(step.value), getDecimals(min.value)));
    function roundValue(value) {
      value = parseFloat(value);
      if (step.value <= 0)
        return value;
      const clamped = clamp(value, min.value, max.value);
      const offset = min.value % step.value;
      const newValue = Math.round((clamped - offset) / step.value) * step.value + offset;
      return parseFloat(Math.min(newValue, max.value).toFixed(decimals.value));
    }
    return {
      min,
      max,
      step,
      decimals,
      roundValue
    };
  };
  var useSlider = (_ref) => {
    let {
      props,
      steps,
      onSliderStart,
      onSliderMove,
      onSliderEnd,
      getActiveThumb
    } = _ref;
    const {
      isRtl
    } = useRtl();
    const isReversed = toRef(props, "reverse");
    const vertical = computed2(() => props.direction === "vertical");
    const indexFromEnd = computed2(() => vertical.value !== isReversed.value);
    const {
      min,
      max,
      step,
      decimals,
      roundValue
    } = steps;
    const thumbSize = computed2(() => parseInt(props.thumbSize, 10));
    const tickSize = computed2(() => parseInt(props.tickSize, 10));
    const trackSize = computed2(() => parseInt(props.trackSize, 10));
    const numTicks = computed2(() => (max.value - min.value) / step.value);
    const disabled = toRef(props, "disabled");
    const thumbColor = computed2(() => {
      var _a2;
      return props.error || props.disabled ? void 0 : (_a2 = props.thumbColor) != null ? _a2 : props.color;
    });
    const trackColor = computed2(() => {
      var _a2;
      return props.error || props.disabled ? void 0 : (_a2 = props.trackColor) != null ? _a2 : props.color;
    });
    const trackFillColor = computed2(() => {
      var _a2;
      return props.error || props.disabled ? void 0 : (_a2 = props.trackFillColor) != null ? _a2 : props.color;
    });
    const mousePressed = shallowRef(false);
    const startOffset = shallowRef(0);
    const trackContainerRef = ref();
    const activeThumbRef = ref();
    function parseMouseMove(e) {
      var _a2;
      const vertical2 = props.direction === "vertical";
      const start = vertical2 ? "top" : "left";
      const length = vertical2 ? "height" : "width";
      const position2 = vertical2 ? "clientY" : "clientX";
      const {
        [start]: trackStart,
        [length]: trackLength
      } = (_a2 = trackContainerRef.value) == null ? void 0 : _a2.$el.getBoundingClientRect();
      const clickOffset = getPosition(e, position2);
      let clickPos = Math.min(Math.max((clickOffset - trackStart - startOffset.value) / trackLength, 0), 1) || 0;
      if (vertical2 ? indexFromEnd.value : indexFromEnd.value !== isRtl.value)
        clickPos = 1 - clickPos;
      return roundValue(min.value + clickPos * (max.value - min.value));
    }
    const handleStop = (e) => {
      onSliderEnd({
        value: parseMouseMove(e)
      });
      mousePressed.value = false;
      startOffset.value = 0;
    };
    const handleStart = (e) => {
      activeThumbRef.value = getActiveThumb(e);
      if (!activeThumbRef.value)
        return;
      activeThumbRef.value.focus();
      mousePressed.value = true;
      if (activeThumbRef.value.contains(e.target)) {
        startOffset.value = getOffset2(e, activeThumbRef.value, props.direction);
      } else {
        startOffset.value = 0;
        onSliderMove({
          value: parseMouseMove(e)
        });
      }
      onSliderStart({
        value: parseMouseMove(e)
      });
    };
    const moveListenerOptions = {
      passive: true,
      capture: true
    };
    function onMouseMove(e) {
      onSliderMove({
        value: parseMouseMove(e)
      });
    }
    function onSliderMouseUp(e) {
      e.stopPropagation();
      e.preventDefault();
      handleStop(e);
      window.removeEventListener("mousemove", onMouseMove, moveListenerOptions);
      window.removeEventListener("mouseup", onSliderMouseUp);
    }
    function onSliderTouchend(e) {
      var _a2;
      handleStop(e);
      window.removeEventListener("touchmove", onMouseMove, moveListenerOptions);
      (_a2 = e.target) == null ? void 0 : _a2.removeEventListener("touchend", onSliderTouchend);
    }
    function onSliderTouchstart(e) {
      var _a2;
      handleStart(e);
      window.addEventListener("touchmove", onMouseMove, moveListenerOptions);
      (_a2 = e.target) == null ? void 0 : _a2.addEventListener("touchend", onSliderTouchend, {
        passive: false
      });
    }
    function onSliderMousedown(e) {
      e.preventDefault();
      handleStart(e);
      window.addEventListener("mousemove", onMouseMove, moveListenerOptions);
      window.addEventListener("mouseup", onSliderMouseUp, {
        passive: false
      });
    }
    const position = (val) => {
      const percentage = (val - min.value) / (max.value - min.value) * 100;
      return clamp(isNaN(percentage) ? 0 : percentage, 0, 100);
    };
    const showTicks = toRef(props, "showTicks");
    const parsedTicks = computed2(() => {
      if (!showTicks.value)
        return [];
      if (!props.ticks) {
        return numTicks.value !== Infinity ? createRange(numTicks.value + 1).map((t) => {
          const value = min.value + t * step.value;
          return {
            value,
            position: position(value)
          };
        }) : [];
      }
      if (Array.isArray(props.ticks))
        return props.ticks.map((t) => ({
          value: t,
          position: position(t),
          label: t.toString()
        }));
      return Object.keys(props.ticks).map((key) => ({
        value: parseFloat(key),
        position: position(parseFloat(key)),
        label: props.ticks[key]
      }));
    });
    const hasLabels = computed2(() => parsedTicks.value.some((_ref2) => {
      let {
        label
      } = _ref2;
      return !!label;
    }));
    const data = {
      activeThumbRef,
      color: toRef(props, "color"),
      decimals,
      disabled,
      direction: toRef(props, "direction"),
      elevation: toRef(props, "elevation"),
      hasLabels,
      isReversed,
      indexFromEnd,
      min,
      max,
      mousePressed,
      numTicks,
      onSliderMousedown,
      onSliderTouchstart,
      parsedTicks,
      parseMouseMove,
      position,
      readonly: toRef(props, "readonly"),
      rounded: toRef(props, "rounded"),
      roundValue,
      showTicks,
      startOffset,
      step,
      thumbSize,
      thumbColor,
      thumbLabel: toRef(props, "thumbLabel"),
      ticks: toRef(props, "ticks"),
      tickSize,
      trackColor,
      trackContainerRef,
      trackFillColor,
      trackSize,
      vertical
    };
    provide(VSliderSymbol, data);
    return data;
  };

  // ../library_management/node_modules/vuetify/lib/components/VSlider/VSliderThumb.mjs
  var makeVSliderThumbProps = propsFactory(__spreadValues({
    focused: Boolean,
    max: {
      type: Number,
      required: true
    },
    min: {
      type: Number,
      required: true
    },
    modelValue: {
      type: Number,
      required: true
    },
    position: {
      type: Number,
      required: true
    },
    ripple: {
      type: [Boolean, Object],
      default: true
    }
  }, makeComponentProps()), "VSliderThumb");
  var VSliderThumb = genericComponent()({
    name: "VSliderThumb",
    directives: {
      Ripple: ripple_default
    },
    props: makeVSliderThumbProps(),
    emits: {
      "update:modelValue": (v) => true
    },
    setup(props, _ref) {
      let {
        slots,
        emit: emit2
      } = _ref;
      const slider = inject(VSliderSymbol);
      const {
        isRtl,
        rtlClasses
      } = useRtl();
      if (!slider)
        throw new Error("[Vuetify] v-slider-thumb must be used inside v-slider or v-range-slider");
      const {
        thumbColor,
        step,
        disabled,
        thumbSize,
        thumbLabel,
        direction,
        isReversed,
        vertical,
        readonly: readonly2,
        elevation,
        mousePressed,
        decimals,
        indexFromEnd
      } = slider;
      const elevationProps = computed2(() => !disabled.value ? elevation.value : void 0);
      const {
        elevationClasses
      } = useElevation(elevationProps);
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(thumbColor);
      const {
        pageup,
        pagedown,
        end,
        home,
        left,
        right,
        down,
        up
      } = keyValues;
      const relevantKeys = [pageup, pagedown, end, home, left, right, down, up];
      const multipliers = computed2(() => {
        if (step.value)
          return [1, 2, 3];
        else
          return [1, 5, 10];
      });
      function parseKeydown(e, value) {
        if (!relevantKeys.includes(e.key))
          return;
        e.preventDefault();
        const _step = step.value || 0.1;
        const steps = (props.max - props.min) / _step;
        if ([left, right, down, up].includes(e.key)) {
          const increase = vertical.value ? [isRtl.value ? left : right, isReversed.value ? down : up] : indexFromEnd.value !== isRtl.value ? [left, up] : [right, up];
          const direction2 = increase.includes(e.key) ? 1 : -1;
          const multiplier = e.shiftKey ? 2 : e.ctrlKey ? 1 : 0;
          value = value + direction2 * _step * multipliers.value[multiplier];
        } else if (e.key === home) {
          value = props.min;
        } else if (e.key === end) {
          value = props.max;
        } else {
          const direction2 = e.key === pagedown ? 1 : -1;
          value = value - direction2 * _step * (steps > 100 ? steps / 10 : 10);
        }
        return Math.max(props.min, Math.min(props.max, value));
      }
      function onKeydown(e) {
        const newValue = parseKeydown(e, props.modelValue);
        newValue != null && emit2("update:modelValue", newValue);
      }
      useRender(() => {
        const positionPercentage = convertToUnit(indexFromEnd.value ? 100 - props.position : props.position, "%");
        return createVNode("div", {
          "class": ["v-slider-thumb", {
            "v-slider-thumb--focused": props.focused,
            "v-slider-thumb--pressed": props.focused && mousePressed.value
          }, props.class, rtlClasses.value],
          "style": [{
            "--v-slider-thumb-position": positionPercentage,
            "--v-slider-thumb-size": convertToUnit(thumbSize.value)
          }, props.style],
          "role": "slider",
          "tabindex": disabled.value ? -1 : 0,
          "aria-valuemin": props.min,
          "aria-valuemax": props.max,
          "aria-valuenow": props.modelValue,
          "aria-readonly": !!readonly2.value,
          "aria-orientation": direction.value,
          "onKeydown": !readonly2.value ? onKeydown : void 0
        }, [createVNode("div", {
          "class": ["v-slider-thumb__surface", textColorClasses.value, elevationClasses.value],
          "style": __spreadValues({}, textColorStyles.value)
        }, null), withDirectives(createVNode("div", {
          "class": ["v-slider-thumb__ripple", textColorClasses.value],
          "style": textColorStyles.value
        }, null), [[resolveDirective("ripple"), props.ripple, null, {
          circle: true,
          center: true
        }]]), createVNode(VScaleTransition, {
          "origin": "bottom center"
        }, {
          default: () => {
            var _a2, _b;
            return [withDirectives(createVNode("div", {
              "class": "v-slider-thumb__label-container"
            }, [createVNode("div", {
              "class": ["v-slider-thumb__label"]
            }, [createVNode("div", null, [(_b = (_a2 = slots["thumb-label"]) == null ? void 0 : _a2.call(slots, {
              modelValue: props.modelValue
            })) != null ? _b : props.modelValue.toFixed(step.value ? decimals.value : 1)])])]), [[vShow, thumbLabel.value && props.focused || thumbLabel.value === "always"]])];
          }
        })]);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VSlider/VSliderTrack.mjs
  var makeVSliderTrackProps = propsFactory(__spreadValues({
    start: {
      type: Number,
      required: true
    },
    stop: {
      type: Number,
      required: true
    }
  }, makeComponentProps()), "VSliderTrack");
  var VSliderTrack = genericComponent()({
    name: "VSliderTrack",
    props: makeVSliderTrackProps(),
    emits: {},
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const slider = inject(VSliderSymbol);
      if (!slider)
        throw new Error("[Vuetify] v-slider-track must be inside v-slider or v-range-slider");
      const {
        color,
        parsedTicks,
        rounded,
        showTicks,
        tickSize,
        trackColor,
        trackFillColor,
        trackSize,
        vertical,
        min,
        max,
        indexFromEnd
      } = slider;
      const {
        roundedClasses
      } = useRounded(rounded);
      const {
        backgroundColorClasses: trackFillColorClasses,
        backgroundColorStyles: trackFillColorStyles
      } = useBackgroundColor(trackFillColor);
      const {
        backgroundColorClasses: trackColorClasses,
        backgroundColorStyles: trackColorStyles
      } = useBackgroundColor(trackColor);
      const startDir = computed2(() => `inset-${vertical.value ? "block" : "inline"}-${indexFromEnd.value ? "end" : "start"}`);
      const endDir = computed2(() => vertical.value ? "height" : "width");
      const backgroundStyles = computed2(() => {
        return {
          [startDir.value]: "0%",
          [endDir.value]: "100%"
        };
      });
      const trackFillWidth = computed2(() => props.stop - props.start);
      const trackFillStyles = computed2(() => {
        return {
          [startDir.value]: convertToUnit(props.start, "%"),
          [endDir.value]: convertToUnit(trackFillWidth.value, "%")
        };
      });
      const computedTicks = computed2(() => {
        if (!showTicks.value)
          return [];
        const ticks = vertical.value ? parsedTicks.value.slice().reverse() : parsedTicks.value;
        return ticks.map((tick, index) => {
          var _a2, _b;
          const directionValue = tick.value !== min.value && tick.value !== max.value ? convertToUnit(tick.position, "%") : void 0;
          return createVNode("div", {
            "key": tick.value,
            "class": ["v-slider-track__tick", {
              "v-slider-track__tick--filled": tick.position >= props.start && tick.position <= props.stop,
              "v-slider-track__tick--first": tick.value === min.value,
              "v-slider-track__tick--last": tick.value === max.value
            }],
            "style": {
              [startDir.value]: directionValue
            }
          }, [(tick.label || slots["tick-label"]) && createVNode("div", {
            "class": "v-slider-track__tick-label"
          }, [(_b = (_a2 = slots["tick-label"]) == null ? void 0 : _a2.call(slots, {
            tick,
            index
          })) != null ? _b : tick.label])]);
        });
      });
      useRender(() => {
        return createVNode("div", {
          "class": ["v-slider-track", roundedClasses.value, props.class],
          "style": [{
            "--v-slider-track-size": convertToUnit(trackSize.value),
            "--v-slider-tick-size": convertToUnit(tickSize.value)
          }, props.style]
        }, [createVNode("div", {
          "class": ["v-slider-track__background", trackColorClasses.value, {
            "v-slider-track__background--opacity": !!color.value || !trackFillColor.value
          }],
          "style": __spreadValues(__spreadValues({}, backgroundStyles.value), trackColorStyles.value)
        }, null), createVNode("div", {
          "class": ["v-slider-track__fill", trackFillColorClasses.value],
          "style": __spreadValues(__spreadValues({}, trackFillStyles.value), trackFillColorStyles.value)
        }, null), showTicks.value && createVNode("div", {
          "class": ["v-slider-track__ticks", {
            "v-slider-track__ticks--always-show": showTicks.value === "always"
          }]
        }, [computedTicks.value])]);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VSlider/VSlider.mjs
  var makeVSliderProps = propsFactory(__spreadProps(__spreadValues(__spreadValues(__spreadValues({}, makeFocusProps()), makeSliderProps()), makeVInputProps()), {
    modelValue: {
      type: [Number, String],
      default: 0
    }
  }), "VSlider");
  var VSlider = genericComponent()({
    name: "VSlider",
    props: makeVSliderProps(),
    emits: {
      "update:focused": (value) => true,
      "update:modelValue": (v) => true,
      start: (value) => true,
      end: (value) => true
    },
    setup(props, _ref) {
      let {
        slots,
        emit: emit2
      } = _ref;
      const thumbContainerRef = ref();
      const {
        rtlClasses
      } = useRtl();
      const steps = useSteps(props);
      const model = useProxiedModel(props, "modelValue", void 0, (value) => {
        return steps.roundValue(value == null ? steps.min.value : value);
      });
      const {
        min,
        max,
        mousePressed,
        roundValue,
        onSliderMousedown,
        onSliderTouchstart,
        trackContainerRef,
        position,
        hasLabels,
        readonly: readonly2
      } = useSlider({
        props,
        steps,
        onSliderStart: () => {
          emit2("start", model.value);
        },
        onSliderEnd: (_ref2) => {
          let {
            value
          } = _ref2;
          const roundedValue = roundValue(value);
          model.value = roundedValue;
          emit2("end", roundedValue);
        },
        onSliderMove: (_ref3) => {
          let {
            value
          } = _ref3;
          return model.value = roundValue(value);
        },
        getActiveThumb: () => {
          var _a2;
          return (_a2 = thumbContainerRef.value) == null ? void 0 : _a2.$el;
        }
      });
      const {
        isFocused,
        focus,
        blur
      } = useFocus(props);
      const trackStop = computed2(() => position(model.value));
      useRender(() => {
        const inputProps = VInput.filterProps(props);
        const hasPrepend = !!(props.label || slots.label || slots.prepend);
        return createVNode(VInput, mergeProps({
          "class": ["v-slider", {
            "v-slider--has-labels": !!slots["tick-label"] || hasLabels.value,
            "v-slider--focused": isFocused.value,
            "v-slider--pressed": mousePressed.value,
            "v-slider--disabled": props.disabled
          }, rtlClasses.value, props.class],
          "style": props.style
        }, inputProps, {
          "focused": isFocused.value
        }), __spreadProps(__spreadValues({}, slots), {
          prepend: hasPrepend ? (slotProps) => {
            var _a2, _b, _c;
            return createVNode(Fragment, null, [(_b = (_a2 = slots.label) == null ? void 0 : _a2.call(slots, slotProps)) != null ? _b : props.label ? createVNode(VLabel, {
              "id": slotProps.id.value,
              "class": "v-slider__label",
              "text": props.label
            }, null) : void 0, (_c = slots.prepend) == null ? void 0 : _c.call(slots, slotProps)]);
          } : void 0,
          default: (_ref4) => {
            let {
              id,
              messagesId
            } = _ref4;
            return createVNode("div", {
              "class": "v-slider__container",
              "onMousedown": !readonly2.value ? onSliderMousedown : void 0,
              "onTouchstartPassive": !readonly2.value ? onSliderTouchstart : void 0
            }, [createVNode("input", {
              "id": id.value,
              "name": props.name || id.value,
              "disabled": !!props.disabled,
              "readonly": !!props.readonly,
              "tabindex": "-1",
              "value": model.value
            }, null), createVNode(VSliderTrack, {
              "ref": trackContainerRef,
              "start": 0,
              "stop": trackStop.value
            }, {
              "tick-label": slots["tick-label"]
            }), createVNode(VSliderThumb, {
              "ref": thumbContainerRef,
              "aria-describedby": messagesId.value,
              "focused": isFocused.value,
              "min": min.value,
              "max": max.value,
              "modelValue": model.value,
              "onUpdate:modelValue": (v) => model.value = v,
              "position": trackStop.value,
              "elevation": props.elevation,
              "onFocus": focus,
              "onBlur": blur,
              "ripple": props.ripple
            }, {
              "thumb-label": slots["thumb-label"]
            })]);
          }
        }));
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VColorPicker/VColorPickerPreview.mjs
  var makeVColorPickerPreviewProps = propsFactory(__spreadValues({
    color: {
      type: Object
    },
    disabled: Boolean,
    hideAlpha: Boolean
  }, makeComponentProps()), "VColorPickerPreview");
  var VColorPickerPreview = defineComponent2({
    name: "VColorPickerPreview",
    props: makeVColorPickerPreviewProps(),
    emits: {
      "update:color": (color) => true
    },
    setup(props, _ref) {
      let {
        emit: emit2
      } = _ref;
      const abortController = new AbortController();
      onUnmounted(() => abortController.abort());
      async function openEyeDropper() {
        var _a2;
        if (!SUPPORTS_EYE_DROPPER)
          return;
        const eyeDropper = new window.EyeDropper();
        try {
          const result = await eyeDropper.open({
            signal: abortController.signal
          });
          const colorHexValue = HexToHSV(result.sRGBHex);
          emit2("update:color", __spreadValues(__spreadValues({}, (_a2 = props.color) != null ? _a2 : nullColor), colorHexValue));
        } catch (e) {
        }
      }
      useRender(() => {
        var _a2, _b, _c, _d;
        return createVNode("div", {
          "class": ["v-color-picker-preview", {
            "v-color-picker-preview--hide-alpha": props.hideAlpha
          }, props.class],
          "style": props.style
        }, [SUPPORTS_EYE_DROPPER && createVNode("div", {
          "class": "v-color-picker-preview__eye-dropper",
          "key": "eyeDropper"
        }, [createVNode(VBtn, {
          "onClick": openEyeDropper,
          "icon": "$eyeDropper",
          "variant": "plain",
          "density": "comfortable"
        }, null)]), createVNode("div", {
          "class": "v-color-picker-preview__dot"
        }, [createVNode("div", {
          "style": {
            background: HSVtoCSS((_a2 = props.color) != null ? _a2 : nullColor)
          }
        }, null)]), createVNode("div", {
          "class": "v-color-picker-preview__sliders"
        }, [createVNode(VSlider, {
          "class": "v-color-picker-preview__track v-color-picker-preview__hue",
          "modelValue": (_b = props.color) == null ? void 0 : _b.h,
          "onUpdate:modelValue": (h2) => {
            var _a3;
            return emit2("update:color", __spreadProps(__spreadValues({}, (_a3 = props.color) != null ? _a3 : nullColor), {
              h: h2
            }));
          },
          "step": 0,
          "min": 0,
          "max": 360,
          "disabled": props.disabled,
          "thumbSize": 14,
          "trackSize": 8,
          "trackFillColor": "white",
          "hideDetails": true
        }, null), !props.hideAlpha && createVNode(VSlider, {
          "class": "v-color-picker-preview__track v-color-picker-preview__alpha",
          "modelValue": (_d = (_c = props.color) == null ? void 0 : _c.a) != null ? _d : 1,
          "onUpdate:modelValue": (a) => {
            var _a3;
            return emit2("update:color", __spreadProps(__spreadValues({}, (_a3 = props.color) != null ? _a3 : nullColor), {
              a
            }));
          },
          "step": 1 / 256,
          "min": 0,
          "max": 1,
          "disabled": props.disabled,
          "thumbSize": 14,
          "trackSize": 8,
          "trackFillColor": "white",
          "hideDetails": true
        }, null)])]);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/util/colors.mjs
  var red = {
    base: "#f44336",
    lighten5: "#ffebee",
    lighten4: "#ffcdd2",
    lighten3: "#ef9a9a",
    lighten2: "#e57373",
    lighten1: "#ef5350",
    darken1: "#e53935",
    darken2: "#d32f2f",
    darken3: "#c62828",
    darken4: "#b71c1c",
    accent1: "#ff8a80",
    accent2: "#ff5252",
    accent3: "#ff1744",
    accent4: "#d50000"
  };
  var pink = {
    base: "#e91e63",
    lighten5: "#fce4ec",
    lighten4: "#f8bbd0",
    lighten3: "#f48fb1",
    lighten2: "#f06292",
    lighten1: "#ec407a",
    darken1: "#d81b60",
    darken2: "#c2185b",
    darken3: "#ad1457",
    darken4: "#880e4f",
    accent1: "#ff80ab",
    accent2: "#ff4081",
    accent3: "#f50057",
    accent4: "#c51162"
  };
  var purple = {
    base: "#9c27b0",
    lighten5: "#f3e5f5",
    lighten4: "#e1bee7",
    lighten3: "#ce93d8",
    lighten2: "#ba68c8",
    lighten1: "#ab47bc",
    darken1: "#8e24aa",
    darken2: "#7b1fa2",
    darken3: "#6a1b9a",
    darken4: "#4a148c",
    accent1: "#ea80fc",
    accent2: "#e040fb",
    accent3: "#d500f9",
    accent4: "#aa00ff"
  };
  var deepPurple = {
    base: "#673ab7",
    lighten5: "#ede7f6",
    lighten4: "#d1c4e9",
    lighten3: "#b39ddb",
    lighten2: "#9575cd",
    lighten1: "#7e57c2",
    darken1: "#5e35b1",
    darken2: "#512da8",
    darken3: "#4527a0",
    darken4: "#311b92",
    accent1: "#b388ff",
    accent2: "#7c4dff",
    accent3: "#651fff",
    accent4: "#6200ea"
  };
  var indigo = {
    base: "#3f51b5",
    lighten5: "#e8eaf6",
    lighten4: "#c5cae9",
    lighten3: "#9fa8da",
    lighten2: "#7986cb",
    lighten1: "#5c6bc0",
    darken1: "#3949ab",
    darken2: "#303f9f",
    darken3: "#283593",
    darken4: "#1a237e",
    accent1: "#8c9eff",
    accent2: "#536dfe",
    accent3: "#3d5afe",
    accent4: "#304ffe"
  };
  var blue = {
    base: "#2196f3",
    lighten5: "#e3f2fd",
    lighten4: "#bbdefb",
    lighten3: "#90caf9",
    lighten2: "#64b5f6",
    lighten1: "#42a5f5",
    darken1: "#1e88e5",
    darken2: "#1976d2",
    darken3: "#1565c0",
    darken4: "#0d47a1",
    accent1: "#82b1ff",
    accent2: "#448aff",
    accent3: "#2979ff",
    accent4: "#2962ff"
  };
  var lightBlue = {
    base: "#03a9f4",
    lighten5: "#e1f5fe",
    lighten4: "#b3e5fc",
    lighten3: "#81d4fa",
    lighten2: "#4fc3f7",
    lighten1: "#29b6f6",
    darken1: "#039be5",
    darken2: "#0288d1",
    darken3: "#0277bd",
    darken4: "#01579b",
    accent1: "#80d8ff",
    accent2: "#40c4ff",
    accent3: "#00b0ff",
    accent4: "#0091ea"
  };
  var cyan = {
    base: "#00bcd4",
    lighten5: "#e0f7fa",
    lighten4: "#b2ebf2",
    lighten3: "#80deea",
    lighten2: "#4dd0e1",
    lighten1: "#26c6da",
    darken1: "#00acc1",
    darken2: "#0097a7",
    darken3: "#00838f",
    darken4: "#006064",
    accent1: "#84ffff",
    accent2: "#18ffff",
    accent3: "#00e5ff",
    accent4: "#00b8d4"
  };
  var teal = {
    base: "#009688",
    lighten5: "#e0f2f1",
    lighten4: "#b2dfdb",
    lighten3: "#80cbc4",
    lighten2: "#4db6ac",
    lighten1: "#26a69a",
    darken1: "#00897b",
    darken2: "#00796b",
    darken3: "#00695c",
    darken4: "#004d40",
    accent1: "#a7ffeb",
    accent2: "#64ffda",
    accent3: "#1de9b6",
    accent4: "#00bfa5"
  };
  var green = {
    base: "#4caf50",
    lighten5: "#e8f5e9",
    lighten4: "#c8e6c9",
    lighten3: "#a5d6a7",
    lighten2: "#81c784",
    lighten1: "#66bb6a",
    darken1: "#43a047",
    darken2: "#388e3c",
    darken3: "#2e7d32",
    darken4: "#1b5e20",
    accent1: "#b9f6ca",
    accent2: "#69f0ae",
    accent3: "#00e676",
    accent4: "#00c853"
  };
  var lightGreen = {
    base: "#8bc34a",
    lighten5: "#f1f8e9",
    lighten4: "#dcedc8",
    lighten3: "#c5e1a5",
    lighten2: "#aed581",
    lighten1: "#9ccc65",
    darken1: "#7cb342",
    darken2: "#689f38",
    darken3: "#558b2f",
    darken4: "#33691e",
    accent1: "#ccff90",
    accent2: "#b2ff59",
    accent3: "#76ff03",
    accent4: "#64dd17"
  };
  var lime = {
    base: "#cddc39",
    lighten5: "#f9fbe7",
    lighten4: "#f0f4c3",
    lighten3: "#e6ee9c",
    lighten2: "#dce775",
    lighten1: "#d4e157",
    darken1: "#c0ca33",
    darken2: "#afb42b",
    darken3: "#9e9d24",
    darken4: "#827717",
    accent1: "#f4ff81",
    accent2: "#eeff41",
    accent3: "#c6ff00",
    accent4: "#aeea00"
  };
  var yellow = {
    base: "#ffeb3b",
    lighten5: "#fffde7",
    lighten4: "#fff9c4",
    lighten3: "#fff59d",
    lighten2: "#fff176",
    lighten1: "#ffee58",
    darken1: "#fdd835",
    darken2: "#fbc02d",
    darken3: "#f9a825",
    darken4: "#f57f17",
    accent1: "#ffff8d",
    accent2: "#ffff00",
    accent3: "#ffea00",
    accent4: "#ffd600"
  };
  var amber = {
    base: "#ffc107",
    lighten5: "#fff8e1",
    lighten4: "#ffecb3",
    lighten3: "#ffe082",
    lighten2: "#ffd54f",
    lighten1: "#ffca28",
    darken1: "#ffb300",
    darken2: "#ffa000",
    darken3: "#ff8f00",
    darken4: "#ff6f00",
    accent1: "#ffe57f",
    accent2: "#ffd740",
    accent3: "#ffc400",
    accent4: "#ffab00"
  };
  var orange = {
    base: "#ff9800",
    lighten5: "#fff3e0",
    lighten4: "#ffe0b2",
    lighten3: "#ffcc80",
    lighten2: "#ffb74d",
    lighten1: "#ffa726",
    darken1: "#fb8c00",
    darken2: "#f57c00",
    darken3: "#ef6c00",
    darken4: "#e65100",
    accent1: "#ffd180",
    accent2: "#ffab40",
    accent3: "#ff9100",
    accent4: "#ff6d00"
  };
  var deepOrange = {
    base: "#ff5722",
    lighten5: "#fbe9e7",
    lighten4: "#ffccbc",
    lighten3: "#ffab91",
    lighten2: "#ff8a65",
    lighten1: "#ff7043",
    darken1: "#f4511e",
    darken2: "#e64a19",
    darken3: "#d84315",
    darken4: "#bf360c",
    accent1: "#ff9e80",
    accent2: "#ff6e40",
    accent3: "#ff3d00",
    accent4: "#dd2c00"
  };
  var brown = {
    base: "#795548",
    lighten5: "#efebe9",
    lighten4: "#d7ccc8",
    lighten3: "#bcaaa4",
    lighten2: "#a1887f",
    lighten1: "#8d6e63",
    darken1: "#6d4c41",
    darken2: "#5d4037",
    darken3: "#4e342e",
    darken4: "#3e2723"
  };
  var blueGrey = {
    base: "#607d8b",
    lighten5: "#eceff1",
    lighten4: "#cfd8dc",
    lighten3: "#b0bec5",
    lighten2: "#90a4ae",
    lighten1: "#78909c",
    darken1: "#546e7a",
    darken2: "#455a64",
    darken3: "#37474f",
    darken4: "#263238"
  };
  var grey = {
    base: "#9e9e9e",
    lighten5: "#fafafa",
    lighten4: "#f5f5f5",
    lighten3: "#eeeeee",
    lighten2: "#e0e0e0",
    lighten1: "#bdbdbd",
    darken1: "#757575",
    darken2: "#616161",
    darken3: "#424242",
    darken4: "#212121"
  };
  var shades = {
    black: "#000000",
    white: "#ffffff",
    transparent: "#ffffff00"
  };
  var colors_default = {
    red,
    pink,
    purple,
    deepPurple,
    indigo,
    blue,
    lightBlue,
    cyan,
    teal,
    green,
    lightGreen,
    lime,
    yellow,
    amber,
    orange,
    deepOrange,
    brown,
    blueGrey,
    grey,
    shades
  };

  // ../library_management/node_modules/vuetify/lib/components/VColorPicker/VColorPickerSwatches.mjs
  var makeVColorPickerSwatchesProps = propsFactory(__spreadValues({
    swatches: {
      type: Array,
      default: () => parseDefaultColors(colors_default)
    },
    disabled: Boolean,
    color: Object,
    maxHeight: [Number, String]
  }, makeComponentProps()), "VColorPickerSwatches");
  function parseDefaultColors(colors) {
    return Object.keys(colors).map((key) => {
      const color = colors[key];
      return color.base ? [color.base, color.darken4, color.darken3, color.darken2, color.darken1, color.lighten1, color.lighten2, color.lighten3, color.lighten4, color.lighten5] : [color.black, color.white, color.transparent];
    });
  }
  var VColorPickerSwatches = defineComponent2({
    name: "VColorPickerSwatches",
    props: makeVColorPickerSwatchesProps(),
    emits: {
      "update:color": (color) => true
    },
    setup(props, _ref) {
      let {
        emit: emit2
      } = _ref;
      useRender(() => createVNode("div", {
        "class": ["v-color-picker-swatches", props.class],
        "style": [{
          maxHeight: convertToUnit(props.maxHeight)
        }, props.style]
      }, [createVNode("div", null, [props.swatches.map((swatch) => createVNode("div", {
        "class": "v-color-picker-swatches__swatch"
      }, [swatch.map((color) => {
        const rgba2 = parseColor(color);
        const hsva = RGBtoHSV(rgba2);
        const background = RGBtoCSS(rgba2);
        return createVNode("div", {
          "class": "v-color-picker-swatches__color",
          "onClick": () => hsva && emit2("update:color", hsva)
        }, [createVNode("div", {
          "style": {
            background
          }
        }, [props.color && deepEqual(props.color, hsva) ? createVNode(VIcon, {
          "size": "x-small",
          "icon": "$success",
          "color": getContrast(color, "#FFFFFF") > 2 ? "white" : "black"
        }, null) : void 0])]);
      })]))])]));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VSheet/VSheet.mjs
  var makeVSheetProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    color: String
  }, makeBorderProps()), makeComponentProps()), makeDimensionProps()), makeElevationProps()), makeLocationProps()), makePositionProps()), makeRoundedProps()), makeTagProps()), makeThemeProps()), "VSheet");
  var VSheet = genericComponent()({
    name: "VSheet",
    props: makeVSheetProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(toRef(props, "color"));
      const {
        borderClasses
      } = useBorder(props);
      const {
        dimensionStyles
      } = useDimension(props);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        locationStyles
      } = useLocation(props);
      const {
        positionClasses
      } = usePosition(props);
      const {
        roundedClasses
      } = useRounded(props);
      useRender(() => createVNode(props.tag, {
        "class": ["v-sheet", themeClasses.value, backgroundColorClasses.value, borderClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, props.class],
        "style": [backgroundColorStyles.value, dimensionStyles.value, locationStyles.value, props.style]
      }, slots));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VColorPicker/VColorPicker.mjs
  var makeVColorPickerProps = propsFactory(__spreadValues({
    canvasHeight: {
      type: [String, Number],
      default: 150
    },
    disabled: Boolean,
    dotSize: {
      type: [Number, String],
      default: 10
    },
    hideCanvas: Boolean,
    hideSliders: Boolean,
    hideInputs: Boolean,
    mode: {
      type: String,
      default: "rgba",
      validator: (v) => Object.keys(modes).includes(v)
    },
    modes: {
      type: Array,
      default: () => Object.keys(modes),
      validator: (v) => Array.isArray(v) && v.every((m) => Object.keys(modes).includes(m))
    },
    showSwatches: Boolean,
    swatches: Array,
    swatchesMaxHeight: {
      type: [Number, String],
      default: 150
    },
    modelValue: {
      type: [Object, String]
    }
  }, omit(makeVSheetProps({
    width: 300
  }), ["height", "location", "minHeight", "maxHeight", "minWidth", "maxWidth"])), "VColorPicker");
  var VColorPicker = defineComponent2({
    name: "VColorPicker",
    props: makeVColorPickerProps(),
    emits: {
      "update:modelValue": (color) => true,
      "update:mode": (mode) => true
    },
    setup(props) {
      const mode = useProxiedModel(props, "mode");
      const hue = ref(null);
      const model = useProxiedModel(props, "modelValue", void 0, (v) => {
        if (v == null || v === "")
          return null;
        let c;
        try {
          c = RGBtoHSV(parseColor(v));
        } catch (err) {
          consoleWarn(err);
          return null;
        }
        return c;
      }, (v) => {
        if (!v)
          return null;
        return extractColor(v, props.modelValue);
      });
      const currentColor = computed2(() => {
        var _a2;
        return model.value ? __spreadProps(__spreadValues({}, model.value), {
          h: (_a2 = hue.value) != null ? _a2 : model.value.h
        }) : null;
      });
      const {
        rtlClasses
      } = useRtl();
      let externalChange = true;
      watch(model, (v) => {
        if (!externalChange) {
          externalChange = true;
          return;
        }
        if (!v)
          return;
        hue.value = v.h;
      }, {
        immediate: true
      });
      const updateColor = (hsva) => {
        externalChange = false;
        hue.value = hsva.h;
        model.value = hsva;
      };
      onMounted(() => {
        if (!props.modes.includes(mode.value))
          mode.value = props.modes[0];
      });
      provideDefaults({
        VSlider: {
          color: void 0,
          trackColor: void 0,
          trackFillColor: void 0
        }
      });
      useRender(() => {
        var _a2;
        const sheetProps = VSheet.filterProps(props);
        return createVNode(VSheet, mergeProps({
          "rounded": props.rounded,
          "elevation": props.elevation,
          "theme": props.theme,
          "class": ["v-color-picker", rtlClasses.value, props.class],
          "style": [{
            "--v-color-picker-color-hsv": HSVtoCSS(__spreadProps(__spreadValues({}, (_a2 = currentColor.value) != null ? _a2 : nullColor), {
              a: 1
            }))
          }, props.style]
        }, sheetProps, {
          "maxWidth": props.width
        }), {
          default: () => [!props.hideCanvas && createVNode(VColorPickerCanvas, {
            "key": "canvas",
            "color": currentColor.value,
            "onUpdate:color": updateColor,
            "disabled": props.disabled,
            "dotSize": props.dotSize,
            "width": props.width,
            "height": props.canvasHeight
          }, null), (!props.hideSliders || !props.hideInputs) && createVNode("div", {
            "key": "controls",
            "class": "v-color-picker__controls"
          }, [!props.hideSliders && createVNode(VColorPickerPreview, {
            "key": "preview",
            "color": currentColor.value,
            "onUpdate:color": updateColor,
            "hideAlpha": !mode.value.endsWith("a"),
            "disabled": props.disabled
          }, null), !props.hideInputs && createVNode(VColorPickerEdit, {
            "key": "edit",
            "modes": props.modes,
            "mode": mode.value,
            "onUpdate:mode": (m) => mode.value = m,
            "color": currentColor.value,
            "onUpdate:color": updateColor,
            "disabled": props.disabled
          }, null)]), props.showSwatches && createVNode(VColorPickerSwatches, {
            "key": "swatches",
            "color": currentColor.value,
            "onUpdate:color": updateColor,
            "maxHeight": props.swatchesMaxHeight,
            "swatches": props.swatches,
            "disabled": props.disabled
          }, null)]
        });
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VCombobox/VCombobox.mjs
  function highlightResult2(text, matches, length) {
    if (matches == null)
      return text;
    if (Array.isArray(matches))
      throw new Error("Multiple matches is not implemented");
    return typeof matches === "number" && ~matches ? createVNode(Fragment, null, [createVNode("span", {
      "class": "v-combobox__unmask"
    }, [text.substr(0, matches)]), createVNode("span", {
      "class": "v-combobox__mask"
    }, [text.substr(matches, length)]), createVNode("span", {
      "class": "v-combobox__unmask"
    }, [text.substr(matches + length)])]) : text;
  }
  var makeVComboboxProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    autoSelectFirst: {
      type: [Boolean, String]
    },
    clearOnSelect: {
      type: Boolean,
      default: true
    },
    delimiters: Array
  }, makeFilterProps({
    filterKeys: ["title"]
  })), makeSelectProps({
    hideNoData: true,
    returnObject: true
  })), omit(makeVTextFieldProps({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"])), makeTransitionProps2({
    transition: false
  })), "VCombobox");
  var VCombobox = genericComponent()({
    name: "VCombobox",
    props: makeVComboboxProps(),
    emits: {
      "update:focused": (focused) => true,
      "update:modelValue": (value) => true,
      "update:search": (value) => true,
      "update:menu": (value) => true
    },
    setup(props, _ref) {
      var _a2, _b;
      let {
        emit: emit2,
        slots
      } = _ref;
      const {
        t
      } = useLocale();
      const vTextFieldRef = ref();
      const isFocused = shallowRef(false);
      const isPristine = shallowRef(true);
      const listHasFocus = shallowRef(false);
      const vMenuRef = ref();
      const vVirtualScrollRef = ref();
      const _menu = useProxiedModel(props, "menu");
      const menu = computed2({
        get: () => _menu.value,
        set: (v) => {
          var _a3;
          if (_menu.value && !v && ((_a3 = vMenuRef.value) == null ? void 0 : _a3.\u03A8openChildren))
            return;
          _menu.value = v;
        }
      });
      const selectionIndex = shallowRef(-1);
      let cleared = false;
      const color = computed2(() => {
        var _a3;
        return (_a3 = vTextFieldRef.value) == null ? void 0 : _a3.color;
      });
      const label = computed2(() => menu.value ? props.closeText : props.openText);
      const {
        items,
        transformIn,
        transformOut
      } = useItems(props);
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(color);
      const model = useProxiedModel(props, "modelValue", [], (v) => transformIn(wrapInArray(v)), (v) => {
        var _a3;
        const transformed = transformOut(v);
        return props.multiple ? transformed : (_a3 = transformed[0]) != null ? _a3 : null;
      });
      const form = useForm();
      const hasChips = computed2(() => !!(props.chips || slots.chip));
      const hasSelectionSlot = computed2(() => hasChips.value || !!slots.selection);
      const _search = shallowRef(!props.multiple && !hasSelectionSlot.value ? (_b = (_a2 = model.value[0]) == null ? void 0 : _a2.title) != null ? _b : "" : "");
      const search = computed2({
        get: () => {
          return _search.value;
        },
        set: (val) => {
          var _a3;
          _search.value = val != null ? val : "";
          if (!props.multiple && !hasSelectionSlot.value) {
            model.value = [transformItem(props, val)];
          }
          if (val && props.multiple && ((_a3 = props.delimiters) == null ? void 0 : _a3.length)) {
            const values = val.split(new RegExp(`(?:${props.delimiters.join("|")})+`));
            if (values.length > 1) {
              values.forEach((v) => {
                v = v.trim();
                if (v)
                  select(transformItem(props, v));
              });
              _search.value = "";
            }
          }
          if (!val)
            selectionIndex.value = -1;
          isPristine.value = !val;
        }
      });
      const counterValue = computed2(() => {
        return typeof props.counterValue === "function" ? props.counterValue(model.value) : typeof props.counterValue === "number" ? props.counterValue : props.multiple ? model.value.length : search.value.length;
      });
      watch(_search, (value) => {
        if (cleared) {
          nextTick(() => cleared = false);
        } else if (isFocused.value && !menu.value) {
          menu.value = true;
        }
        emit2("update:search", value);
      });
      watch(model, (value) => {
        var _a3, _b2;
        if (!props.multiple && !hasSelectionSlot.value) {
          _search.value = (_b2 = (_a3 = value[0]) == null ? void 0 : _a3.title) != null ? _b2 : "";
        }
      });
      const {
        filteredItems,
        getMatches
      } = useFilter(props, items, () => isPristine.value ? "" : search.value);
      const displayItems = computed2(() => {
        if (props.hideSelected) {
          return filteredItems.value.filter((filteredItem) => !model.value.some((s) => s.value === filteredItem.value));
        }
        return filteredItems.value;
      });
      const selectedValues = computed2(() => model.value.map((selection) => selection.value));
      const highlightFirst = computed2(() => {
        var _a3;
        const selectFirst = props.autoSelectFirst === true || props.autoSelectFirst === "exact" && search.value === ((_a3 = displayItems.value[0]) == null ? void 0 : _a3.title);
        return selectFirst && displayItems.value.length > 0 && !isPristine.value && !listHasFocus.value;
      });
      const menuDisabled = computed2(() => props.hideNoData && !displayItems.value.length || props.readonly || (form == null ? void 0 : form.isReadonly.value));
      const listRef = ref();
      const {
        onListScroll,
        onListKeydown
      } = useScrolling(listRef, vTextFieldRef);
      function onClear(e) {
        cleared = true;
        if (props.openOnClear) {
          menu.value = true;
        }
      }
      function onMousedownControl() {
        if (menuDisabled.value)
          return;
        menu.value = true;
      }
      function onMousedownMenuIcon(e) {
        if (menuDisabled.value)
          return;
        if (isFocused.value) {
          e.preventDefault();
          e.stopPropagation();
        }
        menu.value = !menu.value;
      }
      function onKeydown(e) {
        var _a3;
        if (isComposingIgnoreKey(e) || props.readonly || (form == null ? void 0 : form.isReadonly.value))
          return;
        const selectionStart = vTextFieldRef.value.selectionStart;
        const length = model.value.length;
        if (selectionIndex.value > -1 || ["Enter", "ArrowDown", "ArrowUp"].includes(e.key)) {
          e.preventDefault();
        }
        if (["Enter", "ArrowDown"].includes(e.key)) {
          menu.value = true;
        }
        if (["Escape"].includes(e.key)) {
          menu.value = false;
        }
        if (["Enter", "Escape", "Tab"].includes(e.key)) {
          if (highlightFirst.value && ["Enter", "Tab"].includes(e.key)) {
            select(filteredItems.value[0]);
          }
          isPristine.value = true;
        }
        if (e.key === "ArrowDown" && highlightFirst.value) {
          (_a3 = listRef.value) == null ? void 0 : _a3.focus("next");
        }
        if (e.key === "Enter" && search.value) {
          select(transformItem(props, search.value));
          if (hasSelectionSlot.value)
            _search.value = "";
        }
        if (["Backspace", "Delete"].includes(e.key)) {
          if (!props.multiple && hasSelectionSlot.value && model.value.length > 0)
            return select(model.value[0], false);
          if (selectionIndex.value < 0) {
            if (e.key === "Backspace" && !search.value) {
              selectionIndex.value = length - 1;
            }
            return;
          }
          const originalSelectionIndex = selectionIndex.value;
          select(model.value[selectionIndex.value], false);
          selectionIndex.value = originalSelectionIndex >= length - 1 ? length - 2 : originalSelectionIndex;
        }
        if (!props.multiple)
          return;
        if (e.key === "ArrowLeft") {
          if (selectionIndex.value < 0 && selectionStart > 0)
            return;
          const prev = selectionIndex.value > -1 ? selectionIndex.value - 1 : length - 1;
          if (model.value[prev]) {
            selectionIndex.value = prev;
          } else {
            selectionIndex.value = -1;
            vTextFieldRef.value.setSelectionRange(search.value.length, search.value.length);
          }
        }
        if (e.key === "ArrowRight") {
          if (selectionIndex.value < 0)
            return;
          const next = selectionIndex.value + 1;
          if (model.value[next]) {
            selectionIndex.value = next;
          } else {
            selectionIndex.value = -1;
            vTextFieldRef.value.setSelectionRange(0, 0);
          }
        }
      }
      function onAfterLeave() {
        var _a3;
        if (isFocused.value) {
          isPristine.value = true;
          (_a3 = vTextFieldRef.value) == null ? void 0 : _a3.focus();
        }
      }
      function select(item) {
        let set3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        if (!item || item.props.disabled)
          return;
        if (props.multiple) {
          const index = model.value.findIndex((selection) => props.valueComparator(selection.value, item.value));
          const add2 = set3 == null ? !~index : set3;
          if (~index) {
            const value = add2 ? [...model.value, item] : [...model.value];
            value.splice(index, 1);
            model.value = value;
          } else if (add2) {
            model.value = [...model.value, item];
          }
          if (props.clearOnSelect) {
            search.value = "";
          }
        } else {
          const add2 = set3 !== false;
          model.value = add2 ? [item] : [];
          _search.value = add2 && !hasSelectionSlot.value ? item.title : "";
          nextTick(() => {
            menu.value = false;
            isPristine.value = true;
          });
        }
      }
      function onFocusin(e) {
        isFocused.value = true;
        setTimeout(() => {
          listHasFocus.value = true;
        });
      }
      function onFocusout(e) {
        listHasFocus.value = false;
      }
      function onUpdateModelValue(v) {
        if (v == null || v === "" && !props.multiple)
          model.value = [];
      }
      watch(isFocused, (val, oldVal) => {
        if (val || val === oldVal)
          return;
        selectionIndex.value = -1;
        menu.value = false;
        if (highlightFirst.value && !listHasFocus.value && !model.value.some((_ref2) => {
          let {
            value
          } = _ref2;
          return value === displayItems.value[0].value;
        })) {
          select(displayItems.value[0]);
          return;
        }
        if (search.value) {
          if (props.multiple) {
            select(transformItem(props, search.value));
            return;
          }
          if (!hasSelectionSlot.value)
            return;
          if (model.value.some((_ref3) => {
            let {
              title
            } = _ref3;
            return title === search.value;
          })) {
            _search.value = "";
          } else {
            select(transformItem(props, search.value));
          }
        }
      });
      watch(menu, () => {
        if (!props.hideSelected && menu.value && model.value.length) {
          const index = displayItems.value.findIndex((item) => model.value.some((s) => props.valueComparator(s.value, item.value)));
          IN_BROWSER && window.requestAnimationFrame(() => {
            var _a3;
            index >= 0 && ((_a3 = vVirtualScrollRef.value) == null ? void 0 : _a3.scrollToIndex(index));
          });
        }
      });
      watch(() => props.items, (newVal, oldVal) => {
        if (menu.value)
          return;
        if (isFocused.value && !oldVal.length && newVal.length) {
          menu.value = true;
        }
      });
      useRender(() => {
        const hasList = !!(!props.hideNoData || displayItems.value.length || slots["prepend-item"] || slots["append-item"] || slots["no-data"]);
        const isDirty = model.value.length > 0;
        const textFieldProps = VTextField.filterProps(props);
        return createVNode(VTextField, mergeProps({
          "ref": vTextFieldRef
        }, textFieldProps, {
          "modelValue": search.value,
          "onUpdate:modelValue": [($event) => search.value = $event, onUpdateModelValue],
          "focused": isFocused.value,
          "onUpdate:focused": ($event) => isFocused.value = $event,
          "validationValue": model.externalValue,
          "counterValue": counterValue.value,
          "dirty": isDirty,
          "class": ["v-combobox", {
            "v-combobox--active-menu": menu.value,
            "v-combobox--chips": !!props.chips,
            "v-combobox--selection-slot": !!hasSelectionSlot.value,
            "v-combobox--selecting-index": selectionIndex.value > -1,
            [`v-combobox--${props.multiple ? "multiple" : "single"}`]: true
          }, props.class],
          "style": props.style,
          "readonly": props.readonly,
          "placeholder": isDirty ? void 0 : props.placeholder,
          "onClick:clear": onClear,
          "onMousedown:control": onMousedownControl,
          "onKeydown": onKeydown
        }), __spreadProps(__spreadValues({}, slots), {
          default: () => createVNode(Fragment, null, [createVNode(VMenu, mergeProps({
            "ref": vMenuRef,
            "modelValue": menu.value,
            "onUpdate:modelValue": ($event) => menu.value = $event,
            "activator": "parent",
            "contentClass": "v-combobox__content",
            "disabled": menuDisabled.value,
            "eager": props.eager,
            "maxHeight": 310,
            "openOnClick": false,
            "closeOnContentClick": false,
            "transition": props.transition,
            "onAfterLeave": onAfterLeave
          }, props.menuProps), {
            default: () => {
              var _a3;
              return [hasList && createVNode(VList, mergeProps({
                "ref": listRef,
                "selected": selectedValues.value,
                "selectStrategy": props.multiple ? "independent" : "single-independent",
                "onMousedown": (e) => e.preventDefault(),
                "onKeydown": onListKeydown,
                "onFocusin": onFocusin,
                "onFocusout": onFocusout,
                "onScrollPassive": onListScroll,
                "tabindex": "-1",
                "aria-live": "polite",
                "color": (_a3 = props.itemColor) != null ? _a3 : props.color
              }, props.listProps), {
                default: () => {
                  var _a4, _b2, _c, _d;
                  return [(_a4 = slots["prepend-item"]) == null ? void 0 : _a4.call(slots), !displayItems.value.length && !props.hideNoData && ((_c = (_b2 = slots["no-data"]) == null ? void 0 : _b2.call(slots)) != null ? _c : createVNode(VListItem, {
                    "title": t(props.noDataText)
                  }, null)), createVNode(VVirtualScroll, {
                    "ref": vVirtualScrollRef,
                    "renderless": true,
                    "items": displayItems.value
                  }, {
                    default: (_ref4) => {
                      var _a5, _b3;
                      let {
                        item,
                        index,
                        itemRef
                      } = _ref4;
                      const itemProps = mergeProps(item.props, {
                        ref: itemRef,
                        key: index,
                        active: highlightFirst.value && index === 0 ? true : void 0,
                        onClick: () => select(item, null)
                      });
                      return (_b3 = (_a5 = slots.item) == null ? void 0 : _a5.call(slots, {
                        item,
                        index,
                        props: itemProps
                      })) != null ? _b3 : createVNode(VListItem, mergeProps(itemProps, {
                        "role": "option"
                      }), {
                        prepend: (_ref5) => {
                          let {
                            isSelected
                          } = _ref5;
                          return createVNode(Fragment, null, [props.multiple && !props.hideSelected ? createVNode(VCheckboxBtn, {
                            "key": item.value,
                            "modelValue": isSelected,
                            "ripple": false,
                            "tabindex": "-1"
                          }, null) : void 0, item.props.prependAvatar && createVNode(VAvatar, {
                            "image": item.props.prependAvatar
                          }, null), item.props.prependIcon && createVNode(VIcon, {
                            "icon": item.props.prependIcon
                          }, null)]);
                        },
                        title: () => {
                          var _a6, _b4, _c2;
                          return isPristine.value ? item.title : highlightResult2(item.title, (_a6 = getMatches(item)) == null ? void 0 : _a6.title, (_c2 = (_b4 = search.value) == null ? void 0 : _b4.length) != null ? _c2 : 0);
                        }
                      });
                    }
                  }), (_d = slots["append-item"]) == null ? void 0 : _d.call(slots)];
                }
              })];
            }
          }), model.value.map((item, index) => {
            function onChipClose(e) {
              e.stopPropagation();
              e.preventDefault();
              select(item, false);
            }
            const slotProps = {
              "onClick:close": onChipClose,
              onKeydown(e) {
                if (e.key !== "Enter" && e.key !== " ")
                  return;
                e.preventDefault();
                e.stopPropagation();
                onChipClose(e);
              },
              onMousedown(e) {
                e.preventDefault();
                e.stopPropagation();
              },
              modelValue: true,
              "onUpdate:modelValue": void 0
            };
            const hasSlot = hasChips.value ? !!slots.chip : !!slots.selection;
            const slotContent = hasSlot ? ensureValidVNode(hasChips.value ? slots.chip({
              item,
              index,
              props: slotProps
            }) : slots.selection({
              item,
              index
            })) : void 0;
            if (hasSlot && !slotContent)
              return void 0;
            return createVNode("div", {
              "key": item.value,
              "class": ["v-combobox__selection", index === selectionIndex.value && ["v-combobox__selection--selected", textColorClasses.value]],
              "style": index === selectionIndex.value ? textColorStyles.value : {}
            }, [hasChips.value ? !slots.chip ? createVNode(VChip, mergeProps({
              "key": "chip",
              "closable": props.closableChips,
              "size": "small",
              "text": item.title,
              "disabled": item.props.disabled
            }, slotProps), null) : createVNode(VDefaultsProvider, {
              "key": "chip-defaults",
              "defaults": {
                VChip: {
                  closable: props.closableChips,
                  size: "small",
                  text: item.title
                }
              }
            }, {
              default: () => [slotContent]
            }) : slotContent != null ? slotContent : createVNode("span", {
              "class": "v-combobox__selection-text"
            }, [item.title, props.multiple && index < model.value.length - 1 && createVNode("span", {
              "class": "v-combobox__selection-comma"
            }, [createTextVNode(",")])])]);
          })]),
          "append-inner": function() {
            var _a3;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return createVNode(Fragment, null, [(_a3 = slots["append-inner"]) == null ? void 0 : _a3.call(slots, ...args), (!props.hideNoData || props.items.length) && props.menuIcon ? createVNode(VIcon, {
              "class": "v-combobox__menu-icon",
              "icon": props.menuIcon,
              "onMousedown": onMousedownMenuIcon,
              "onClick": noop2,
              "aria-label": t(label.value),
              "title": t(label.value)
            }, null) : void 0]);
          }
        }));
      });
      return forwardRefs({
        isFocused,
        isPristine,
        menu,
        search,
        selectionIndex,
        filteredItems,
        select
      }, vTextFieldRef);
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VDataTable/composables/expand.mjs
  var makeDataTableExpandProps = propsFactory({
    expandOnClick: Boolean,
    showExpand: Boolean,
    expanded: {
      type: Array,
      default: () => []
    }
  }, "DataTable-expand");
  var VDataTableExpandedKey = Symbol.for("vuetify:datatable:expanded");
  function provideExpanded(props) {
    const expandOnClick = toRef(props, "expandOnClick");
    const expanded = useProxiedModel(props, "expanded", props.expanded, (v) => {
      return new Set(v);
    }, (v) => {
      return [...v.values()];
    });
    function expand(item, value) {
      const newExpanded = new Set(expanded.value);
      if (!value) {
        newExpanded.delete(item.value);
      } else {
        newExpanded.add(item.value);
      }
      expanded.value = newExpanded;
    }
    function isExpanded(item) {
      return expanded.value.has(item.value);
    }
    function toggleExpand(item) {
      expand(item, !isExpanded(item));
    }
    const data = {
      expand,
      expanded,
      expandOnClick,
      isExpanded,
      toggleExpand
    };
    provide(VDataTableExpandedKey, data);
    return data;
  }
  function useExpanded() {
    const data = inject(VDataTableExpandedKey);
    if (!data)
      throw new Error("foo");
    return data;
  }

  // ../library_management/node_modules/vuetify/lib/components/VDataTable/composables/group.mjs
  var makeDataTableGroupProps = propsFactory({
    groupBy: {
      type: Array,
      default: () => []
    }
  }, "DataTable-group");
  var VDataTableGroupSymbol = Symbol.for("vuetify:data-table-group");
  function createGroupBy(props) {
    const groupBy = useProxiedModel(props, "groupBy");
    return {
      groupBy
    };
  }
  function provideGroupBy(options) {
    const {
      groupBy,
      sortBy
    } = options;
    const opened = ref(/* @__PURE__ */ new Set());
    const sortByWithGroups = computed2(() => {
      return groupBy.value.map((val) => {
        var _a2;
        return __spreadProps(__spreadValues({}, val), {
          order: (_a2 = val.order) != null ? _a2 : false
        });
      }).concat(sortBy.value);
    });
    function isGroupOpen(group) {
      return opened.value.has(group.id);
    }
    function toggleGroup(group) {
      const newOpened = new Set(opened.value);
      if (!isGroupOpen(group))
        newOpened.add(group.id);
      else
        newOpened.delete(group.id);
      opened.value = newOpened;
    }
    function extractRows(items) {
      function dive(group) {
        const arr = [];
        for (const item of group.items) {
          if ("type" in item && item.type === "group") {
            arr.push(...dive(item));
          } else {
            arr.push(item);
          }
        }
        return arr;
      }
      return dive({
        type: "group",
        items,
        id: "dummy",
        key: "dummy",
        value: "dummy",
        depth: 0
      });
    }
    const data = {
      sortByWithGroups,
      toggleGroup,
      opened,
      groupBy,
      extractRows,
      isGroupOpen
    };
    provide(VDataTableGroupSymbol, data);
    return data;
  }
  function useGroupBy() {
    const data = inject(VDataTableGroupSymbol);
    if (!data)
      throw new Error("Missing group!");
    return data;
  }
  function groupItemsByProperty(items, groupBy) {
    if (!items.length)
      return [];
    const groups = /* @__PURE__ */ new Map();
    for (const item of items) {
      const value = getObjectValueByPath(item.raw, groupBy);
      if (!groups.has(value)) {
        groups.set(value, []);
      }
      groups.get(value).push(item);
    }
    return groups;
  }
  function groupItems(items, groupBy) {
    let depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    let prefix = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "root";
    if (!groupBy.length)
      return [];
    const groupedItems = groupItemsByProperty(items, groupBy[0]);
    const groups = [];
    const rest = groupBy.slice(1);
    groupedItems.forEach((items2, value) => {
      const key = groupBy[0];
      const id = `${prefix}_${key}_${value}`;
      groups.push({
        depth,
        id,
        key,
        value,
        items: rest.length ? groupItems(items2, rest, depth + 1, id) : items2,
        type: "group"
      });
    });
    return groups;
  }
  function flattenItems(items, opened) {
    const flatItems = [];
    for (const item of items) {
      if ("type" in item && item.type === "group") {
        if (item.value != null) {
          flatItems.push(item);
        }
        if (opened.has(item.id) || item.value == null) {
          flatItems.push(...flattenItems(item.items, opened));
        }
      } else {
        flatItems.push(item);
      }
    }
    return flatItems;
  }
  function useGroupedItems(items, groupBy, opened) {
    const flatItems = computed2(() => {
      if (!groupBy.value.length)
        return items.value;
      const groupedItems = groupItems(items.value, groupBy.value.map((item) => item.key));
      return flattenItems(groupedItems, opened.value);
    });
    return {
      flatItems
    };
  }

  // ../library_management/node_modules/vuetify/lib/components/VDataTable/composables/options.mjs
  function useOptions(_ref) {
    let {
      page,
      itemsPerPage,
      sortBy,
      groupBy,
      search
    } = _ref;
    const vm = getCurrentInstance2("VDataTable");
    const options = computed2(() => ({
      page: page.value,
      itemsPerPage: itemsPerPage.value,
      sortBy: sortBy.value,
      groupBy: groupBy.value,
      search: search.value
    }));
    let oldOptions = null;
    watch(options, () => {
      if (deepEqual(oldOptions, options.value))
        return;
      if ((oldOptions == null ? void 0 : oldOptions.search) !== options.value.search) {
        page.value = 1;
      }
      vm.emit("update:options", options.value);
      oldOptions = options.value;
    }, {
      deep: true,
      immediate: true
    });
  }

  // ../library_management/node_modules/vuetify/lib/components/VDataTable/composables/paginate.mjs
  var makeDataTablePaginateProps = propsFactory({
    page: {
      type: [Number, String],
      default: 1
    },
    itemsPerPage: {
      type: [Number, String],
      default: 10
    }
  }, "DataTable-paginate");
  var VDataTablePaginationSymbol = Symbol.for("vuetify:data-table-pagination");
  function createPagination(props) {
    const page = useProxiedModel(props, "page", void 0, (value) => +(value != null ? value : 1));
    const itemsPerPage = useProxiedModel(props, "itemsPerPage", void 0, (value) => +(value != null ? value : 10));
    return {
      page,
      itemsPerPage
    };
  }
  function providePagination(options) {
    const {
      page,
      itemsPerPage,
      itemsLength
    } = options;
    const startIndex = computed2(() => {
      if (itemsPerPage.value === -1)
        return 0;
      return itemsPerPage.value * (page.value - 1);
    });
    const stopIndex = computed2(() => {
      if (itemsPerPage.value === -1)
        return itemsLength.value;
      return Math.min(itemsLength.value, startIndex.value + itemsPerPage.value);
    });
    const pageCount = computed2(() => {
      if (itemsPerPage.value === -1 || itemsLength.value === 0)
        return 1;
      return Math.ceil(itemsLength.value / itemsPerPage.value);
    });
    watchEffect(() => {
      if (page.value > pageCount.value) {
        page.value = pageCount.value;
      }
    });
    function setItemsPerPage(value) {
      itemsPerPage.value = value;
      page.value = 1;
    }
    function nextPage() {
      page.value = clamp(page.value + 1, 1, pageCount.value);
    }
    function prevPage() {
      page.value = clamp(page.value - 1, 1, pageCount.value);
    }
    function setPage(value) {
      page.value = clamp(value, 1, pageCount.value);
    }
    const data = {
      page,
      itemsPerPage,
      startIndex,
      stopIndex,
      pageCount,
      itemsLength,
      nextPage,
      prevPage,
      setPage,
      setItemsPerPage
    };
    provide(VDataTablePaginationSymbol, data);
    return data;
  }
  function usePagination() {
    const data = inject(VDataTablePaginationSymbol);
    if (!data)
      throw new Error("Missing pagination!");
    return data;
  }
  function usePaginatedItems(options) {
    const vm = getCurrentInstance2("usePaginatedItems");
    const {
      items,
      startIndex,
      stopIndex,
      itemsPerPage
    } = options;
    const paginatedItems = computed2(() => {
      if (itemsPerPage.value <= 0)
        return items.value;
      return items.value.slice(startIndex.value, stopIndex.value);
    });
    watch(paginatedItems, (val) => {
      vm.emit("update:currentItems", val);
    });
    return {
      paginatedItems
    };
  }

  // ../library_management/node_modules/vuetify/lib/components/VDataTable/composables/select.mjs
  var singleSelectStrategy = {
    showSelectAll: false,
    allSelected: () => [],
    select: (_ref) => {
      var _a2;
      let {
        items,
        value
      } = _ref;
      return new Set(value ? [(_a2 = items[0]) == null ? void 0 : _a2.value] : []);
    },
    selectAll: (_ref2) => {
      let {
        selected
      } = _ref2;
      return selected;
    }
  };
  var pageSelectStrategy = {
    showSelectAll: true,
    allSelected: (_ref3) => {
      let {
        currentPage
      } = _ref3;
      return currentPage;
    },
    select: (_ref4) => {
      let {
        items,
        value,
        selected
      } = _ref4;
      for (const item of items) {
        if (value)
          selected.add(item.value);
        else
          selected.delete(item.value);
      }
      return selected;
    },
    selectAll: (_ref5) => {
      let {
        value,
        currentPage,
        selected
      } = _ref5;
      return pageSelectStrategy.select({
        items: currentPage,
        value,
        selected
      });
    }
  };
  var allSelectStrategy = {
    showSelectAll: true,
    allSelected: (_ref6) => {
      let {
        allItems
      } = _ref6;
      return allItems;
    },
    select: (_ref7) => {
      let {
        items,
        value,
        selected
      } = _ref7;
      for (const item of items) {
        if (value)
          selected.add(item.value);
        else
          selected.delete(item.value);
      }
      return selected;
    },
    selectAll: (_ref8) => {
      let {
        value,
        allItems,
        selected
      } = _ref8;
      return allSelectStrategy.select({
        items: allItems,
        value,
        selected
      });
    }
  };
  var makeDataTableSelectProps = propsFactory({
    showSelect: Boolean,
    selectStrategy: {
      type: [String, Object],
      default: "page"
    },
    modelValue: {
      type: Array,
      default: () => []
    },
    valueComparator: {
      type: Function,
      default: deepEqual
    }
  }, "DataTable-select");
  var VDataTableSelectionSymbol = Symbol.for("vuetify:data-table-selection");
  function provideSelection(props, _ref9) {
    let {
      allItems,
      currentPage
    } = _ref9;
    const selected = useProxiedModel(props, "modelValue", props.modelValue, (v) => {
      return new Set(wrapInArray(v).map((v2) => {
        var _a2, _b;
        return (_b = (_a2 = allItems.value.find((item) => props.valueComparator(v2, item.value))) == null ? void 0 : _a2.value) != null ? _b : v2;
      }));
    }, (v) => {
      return [...v.values()];
    });
    const allSelectable = computed2(() => allItems.value.filter((item) => item.selectable));
    const currentPageSelectable = computed2(() => currentPage.value.filter((item) => item.selectable));
    const selectStrategy = computed2(() => {
      if (typeof props.selectStrategy === "object")
        return props.selectStrategy;
      switch (props.selectStrategy) {
        case "single":
          return singleSelectStrategy;
        case "all":
          return allSelectStrategy;
        case "page":
        default:
          return pageSelectStrategy;
      }
    });
    function isSelected(items) {
      return wrapInArray(items).every((item) => selected.value.has(item.value));
    }
    function isSomeSelected(items) {
      return wrapInArray(items).some((item) => selected.value.has(item.value));
    }
    function select(items, value) {
      const newSelected = selectStrategy.value.select({
        items,
        value,
        selected: new Set(selected.value)
      });
      selected.value = newSelected;
    }
    function toggleSelect(item) {
      select([item], !isSelected([item]));
    }
    function selectAll(value) {
      const newSelected = selectStrategy.value.selectAll({
        value,
        allItems: allSelectable.value,
        currentPage: currentPageSelectable.value,
        selected: new Set(selected.value)
      });
      selected.value = newSelected;
    }
    const someSelected = computed2(() => selected.value.size > 0);
    const allSelected = computed2(() => {
      const items = selectStrategy.value.allSelected({
        allItems: allSelectable.value,
        currentPage: currentPageSelectable.value
      });
      return !!items.length && isSelected(items);
    });
    const data = {
      toggleSelect,
      select,
      selectAll,
      isSelected,
      isSomeSelected,
      someSelected,
      allSelected,
      showSelectAll: selectStrategy.value.showSelectAll
    };
    provide(VDataTableSelectionSymbol, data);
    return data;
  }
  function useSelection() {
    const data = inject(VDataTableSelectionSymbol);
    if (!data)
      throw new Error("Missing selection!");
    return data;
  }

  // ../library_management/node_modules/vuetify/lib/components/VDataTable/composables/sort.mjs
  var makeDataTableSortProps = propsFactory({
    sortBy: {
      type: Array,
      default: () => []
    },
    customKeySort: Object,
    multiSort: Boolean,
    mustSort: Boolean
  }, "DataTable-sort");
  var VDataTableSortSymbol = Symbol.for("vuetify:data-table-sort");
  function createSort(props) {
    const sortBy = useProxiedModel(props, "sortBy");
    const mustSort = toRef(props, "mustSort");
    const multiSort = toRef(props, "multiSort");
    return {
      sortBy,
      mustSort,
      multiSort
    };
  }
  function provideSort(options) {
    const {
      sortBy,
      mustSort,
      multiSort,
      page
    } = options;
    const toggleSort = (column) => {
      var _a2;
      if (column.key == null)
        return;
      let newSortBy = (_a2 = sortBy.value.map((x) => __spreadValues({}, x))) != null ? _a2 : [];
      const item = newSortBy.find((x) => x.key === column.key);
      if (!item) {
        if (multiSort.value)
          newSortBy = [...newSortBy, {
            key: column.key,
            order: "asc"
          }];
        else
          newSortBy = [{
            key: column.key,
            order: "asc"
          }];
      } else if (item.order === "desc") {
        if (mustSort.value) {
          item.order = "asc";
        } else {
          newSortBy = newSortBy.filter((x) => x.key !== column.key);
        }
      } else {
        item.order = "desc";
      }
      sortBy.value = newSortBy;
      if (page)
        page.value = 1;
    };
    function isSorted(column) {
      return !!sortBy.value.find((item) => item.key === column.key);
    }
    const data = {
      sortBy,
      toggleSort,
      isSorted
    };
    provide(VDataTableSortSymbol, data);
    return data;
  }
  function useSort() {
    const data = inject(VDataTableSortSymbol);
    if (!data)
      throw new Error("Missing sort!");
    return data;
  }
  function useSortedItems(props, items, sortBy, sortFunctions, sortRawFunctions) {
    const locale = useLocale();
    const sortedItems = computed2(() => {
      if (!sortBy.value.length)
        return items.value;
      return sortItems(items.value, sortBy.value, locale.current.value, __spreadValues(__spreadValues({}, props.customKeySort), sortFunctions == null ? void 0 : sortFunctions.value), sortRawFunctions == null ? void 0 : sortRawFunctions.value);
    });
    return {
      sortedItems
    };
  }
  function sortItems(items, sortByItems, locale, customSorters, customRawSorters) {
    const stringCollator = new Intl.Collator(locale, {
      sensitivity: "accent",
      usage: "sort"
    });
    return [...items].sort((a, b) => {
      var _a2;
      for (let i = 0; i < sortByItems.length; i++) {
        const sortKey = sortByItems[i].key;
        const sortOrder = (_a2 = sortByItems[i].order) != null ? _a2 : "asc";
        if (sortOrder === false)
          continue;
        let sortA = getObjectValueByPath(a.raw, sortKey);
        let sortB = getObjectValueByPath(b.raw, sortKey);
        let sortARaw = a.raw;
        let sortBRaw = b.raw;
        if (sortOrder === "desc") {
          [sortA, sortB] = [sortB, sortA];
          [sortARaw, sortBRaw] = [sortBRaw, sortARaw];
        }
        if (customRawSorters == null ? void 0 : customRawSorters[sortKey]) {
          const customResult = customRawSorters[sortKey](sortARaw, sortBRaw);
          if (!customResult)
            continue;
          return customResult;
        }
        if (customSorters == null ? void 0 : customSorters[sortKey]) {
          const customResult = customSorters[sortKey](sortA, sortB);
          if (!customResult)
            continue;
          return customResult;
        }
        if (sortA instanceof Date && sortB instanceof Date) {
          return sortA.getTime() - sortB.getTime();
        }
        [sortA, sortB] = [sortA, sortB].map((s) => s != null ? s.toString().toLocaleLowerCase() : s);
        if (sortA !== sortB) {
          if (isEmpty(sortA) && isEmpty(sortB))
            return 0;
          if (isEmpty(sortA))
            return -1;
          if (isEmpty(sortB))
            return 1;
          if (!isNaN(sortA) && !isNaN(sortB))
            return Number(sortA) - Number(sortB);
          return stringCollator.compare(sortA, sortB);
        }
      }
      return 0;
    });
  }

  // ../library_management/node_modules/vuetify/lib/components/VDataIterator/composables/items.mjs
  var makeDataIteratorItemsProps = propsFactory({
    items: {
      type: Array,
      default: () => []
    },
    itemValue: {
      type: [String, Array, Function],
      default: "id"
    },
    itemSelectable: {
      type: [String, Array, Function],
      default: null
    },
    returnObject: Boolean
  }, "DataIterator-items");
  function transformItem3(props, item) {
    const value = props.returnObject ? item : getPropertyFromItem(item, props.itemValue);
    const selectable = getPropertyFromItem(item, props.itemSelectable, true);
    return {
      type: "item",
      value,
      selectable,
      raw: item
    };
  }
  function transformItems3(props, items) {
    const array = [];
    for (const item of items) {
      array.push(transformItem3(props, item));
    }
    return array;
  }
  function useDataIteratorItems(props) {
    const items = computed2(() => transformItems3(props, props.items));
    return {
      items
    };
  }

  // ../library_management/node_modules/vuetify/lib/components/VDataIterator/VDataIterator.mjs
  var makeVDataIteratorProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    search: String,
    loading: Boolean
  }, makeComponentProps()), makeDataIteratorItemsProps()), makeDataTableSelectProps()), makeDataTableSortProps()), makeDataTablePaginateProps({
    itemsPerPage: 5
  })), makeDataTableExpandProps()), makeDataTableGroupProps()), makeFilterProps()), makeTagProps()), "VDataIterator");
  var VDataIterator = genericComponent()({
    name: "VDataIterator",
    props: makeVDataIteratorProps(),
    emits: {
      "update:modelValue": (value) => true,
      "update:groupBy": (value) => true,
      "update:page": (value) => true,
      "update:itemsPerPage": (value) => true,
      "update:sortBy": (value) => true,
      "update:options": (value) => true,
      "update:expanded": (value) => true,
      "update:currentItems": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const groupBy = useProxiedModel(props, "groupBy");
      const search = toRef(props, "search");
      const {
        items
      } = useDataIteratorItems(props);
      const {
        filteredItems
      } = useFilter(props, items, search, {
        transform: (item) => item.raw
      });
      const {
        sortBy,
        multiSort,
        mustSort
      } = createSort(props);
      const {
        page,
        itemsPerPage
      } = createPagination(props);
      const {
        toggleSort
      } = provideSort({
        sortBy,
        multiSort,
        mustSort,
        page
      });
      const {
        sortByWithGroups,
        opened,
        extractRows,
        isGroupOpen,
        toggleGroup
      } = provideGroupBy({
        groupBy,
        sortBy
      });
      const {
        sortedItems
      } = useSortedItems(props, filteredItems, sortByWithGroups);
      const {
        flatItems
      } = useGroupedItems(sortedItems, groupBy, opened);
      const itemsLength = computed2(() => flatItems.value.length);
      const {
        startIndex,
        stopIndex,
        pageCount,
        prevPage,
        nextPage,
        setItemsPerPage,
        setPage
      } = providePagination({
        page,
        itemsPerPage,
        itemsLength
      });
      const {
        paginatedItems
      } = usePaginatedItems({
        items: flatItems,
        startIndex,
        stopIndex,
        itemsPerPage
      });
      const paginatedItemsWithoutGroups = computed2(() => extractRows(paginatedItems.value));
      const {
        isSelected,
        select,
        selectAll,
        toggleSelect
      } = provideSelection(props, {
        allItems: items,
        currentPage: paginatedItemsWithoutGroups
      });
      const {
        isExpanded,
        toggleExpand
      } = provideExpanded(props);
      useOptions({
        page,
        itemsPerPage,
        sortBy,
        groupBy,
        search
      });
      const slotProps = computed2(() => ({
        page: page.value,
        itemsPerPage: itemsPerPage.value,
        sortBy: sortBy.value,
        pageCount: pageCount.value,
        toggleSort,
        prevPage,
        nextPage,
        setPage,
        setItemsPerPage,
        isSelected,
        select,
        selectAll,
        toggleSelect,
        isExpanded,
        toggleExpand,
        isGroupOpen,
        toggleGroup,
        items: paginatedItemsWithoutGroups.value,
        groupedItems: paginatedItems.value
      }));
      useRender(() => createVNode(props.tag, {
        "class": ["v-data-iterator", props.class],
        "style": props.style
      }, {
        default: () => {
          var _a2, _b, _c, _d;
          return [(_a2 = slots.header) == null ? void 0 : _a2.call(slots, slotProps.value), !paginatedItems.value.length ? (_b = slots["no-data"]) == null ? void 0 : _b.call(slots) : (_c = slots.default) == null ? void 0 : _c.call(slots, slotProps.value), (_d = slots.footer) == null ? void 0 : _d.call(slots, slotProps.value)];
        }
      }));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/composables/refs.mjs
  function useRefs() {
    const refs = ref([]);
    onBeforeUpdate(() => refs.value = []);
    function updateRef(e, i) {
      refs.value[i] = e;
    }
    return {
      refs,
      updateRef
    };
  }

  // ../library_management/node_modules/vuetify/lib/components/VPagination/VPagination.mjs
  var makeVPaginationProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    activeColor: String,
    start: {
      type: [Number, String],
      default: 1
    },
    modelValue: {
      type: Number,
      default: (props) => props.start
    },
    disabled: Boolean,
    length: {
      type: [Number, String],
      default: 1,
      validator: (val) => val % 1 === 0
    },
    totalVisible: [Number, String],
    firstIcon: {
      type: IconValue,
      default: "$first"
    },
    prevIcon: {
      type: IconValue,
      default: "$prev"
    },
    nextIcon: {
      type: IconValue,
      default: "$next"
    },
    lastIcon: {
      type: IconValue,
      default: "$last"
    },
    ariaLabel: {
      type: String,
      default: "$vuetify.pagination.ariaLabel.root"
    },
    pageAriaLabel: {
      type: String,
      default: "$vuetify.pagination.ariaLabel.page"
    },
    currentPageAriaLabel: {
      type: String,
      default: "$vuetify.pagination.ariaLabel.currentPage"
    },
    firstAriaLabel: {
      type: String,
      default: "$vuetify.pagination.ariaLabel.first"
    },
    previousAriaLabel: {
      type: String,
      default: "$vuetify.pagination.ariaLabel.previous"
    },
    nextAriaLabel: {
      type: String,
      default: "$vuetify.pagination.ariaLabel.next"
    },
    lastAriaLabel: {
      type: String,
      default: "$vuetify.pagination.ariaLabel.last"
    },
    ellipsis: {
      type: String,
      default: "..."
    },
    showFirstLastPage: Boolean
  }, makeBorderProps()), makeComponentProps()), makeDensityProps()), makeElevationProps()), makeRoundedProps()), makeSizeProps()), makeTagProps({
    tag: "nav"
  })), makeThemeProps()), makeVariantProps({
    variant: "text"
  })), "VPagination");
  var VPagination = genericComponent()({
    name: "VPagination",
    props: makeVPaginationProps(),
    emits: {
      "update:modelValue": (value) => true,
      first: (value) => true,
      prev: (value) => true,
      next: (value) => true,
      last: (value) => true
    },
    setup(props, _ref) {
      let {
        slots,
        emit: emit2
      } = _ref;
      const page = useProxiedModel(props, "modelValue");
      const {
        t,
        n
      } = useLocale();
      const {
        isRtl
      } = useRtl();
      const {
        themeClasses
      } = provideTheme(props);
      const {
        width
      } = useDisplay();
      const maxButtons = shallowRef(-1);
      provideDefaults(void 0, {
        scoped: true
      });
      const {
        resizeRef
      } = useResizeObserver((entries) => {
        if (!entries.length)
          return;
        const {
          target,
          contentRect
        } = entries[0];
        const firstItem = target.querySelector(".v-pagination__list > *");
        if (!firstItem)
          return;
        const totalWidth = contentRect.width;
        const itemWidth = firstItem.offsetWidth + parseFloat(getComputedStyle(firstItem).marginRight) * 2;
        maxButtons.value = getMax(totalWidth, itemWidth);
      });
      const length = computed2(() => parseInt(props.length, 10));
      const start = computed2(() => parseInt(props.start, 10));
      const totalVisible = computed2(() => {
        if (props.totalVisible != null)
          return parseInt(props.totalVisible, 10);
        else if (maxButtons.value >= 0)
          return maxButtons.value;
        return getMax(width.value, 58);
      });
      function getMax(totalWidth, itemWidth) {
        const minButtons = props.showFirstLastPage ? 5 : 3;
        return Math.max(0, Math.floor(
          +((totalWidth - itemWidth * minButtons) / itemWidth).toFixed(2)
        ));
      }
      const range = computed2(() => {
        if (length.value <= 0 || isNaN(length.value) || length.value > Number.MAX_SAFE_INTEGER)
          return [];
        if (totalVisible.value <= 0)
          return [];
        else if (totalVisible.value === 1)
          return [page.value];
        if (length.value <= totalVisible.value) {
          return createRange(length.value, start.value);
        }
        const even = totalVisible.value % 2 === 0;
        const middle = even ? totalVisible.value / 2 : Math.floor(totalVisible.value / 2);
        const left = even ? middle : middle + 1;
        const right = length.value - middle;
        if (left - page.value >= 0) {
          return [...createRange(Math.max(1, totalVisible.value - 1), start.value), props.ellipsis, length.value];
        } else if (page.value - right >= (even ? 1 : 0)) {
          const rangeLength = totalVisible.value - 1;
          const rangeStart = length.value - rangeLength + start.value;
          return [start.value, props.ellipsis, ...createRange(rangeLength, rangeStart)];
        } else {
          const rangeLength = Math.max(1, totalVisible.value - 3);
          const rangeStart = rangeLength === 1 ? page.value : page.value - Math.ceil(rangeLength / 2) + start.value;
          return [start.value, props.ellipsis, ...createRange(rangeLength, rangeStart), props.ellipsis, length.value];
        }
      });
      function setValue(e, value, event) {
        e.preventDefault();
        page.value = value;
        event && emit2(event, value);
      }
      const {
        refs,
        updateRef
      } = useRefs();
      provideDefaults({
        VPaginationBtn: {
          color: toRef(props, "color"),
          border: toRef(props, "border"),
          density: toRef(props, "density"),
          size: toRef(props, "size"),
          variant: toRef(props, "variant"),
          rounded: toRef(props, "rounded"),
          elevation: toRef(props, "elevation")
        }
      });
      const items = computed2(() => {
        return range.value.map((item, index) => {
          const ref2 = (e) => updateRef(e, index);
          if (typeof item === "string") {
            return {
              isActive: false,
              key: `ellipsis-${index}`,
              page: item,
              props: {
                ref: ref2,
                ellipsis: true,
                icon: true,
                disabled: true
              }
            };
          } else {
            const isActive = item === page.value;
            return {
              isActive,
              key: item,
              page: n(item),
              props: {
                ref: ref2,
                ellipsis: false,
                icon: true,
                disabled: !!props.disabled || +props.length < 2,
                color: isActive ? props.activeColor : props.color,
                "aria-current": isActive,
                "aria-label": t(isActive ? props.currentPageAriaLabel : props.pageAriaLabel, item),
                onClick: (e) => setValue(e, item)
              }
            };
          }
        });
      });
      const controls = computed2(() => {
        const prevDisabled = !!props.disabled || page.value <= start.value;
        const nextDisabled = !!props.disabled || page.value >= start.value + length.value - 1;
        return {
          first: props.showFirstLastPage ? {
            icon: isRtl.value ? props.lastIcon : props.firstIcon,
            onClick: (e) => setValue(e, start.value, "first"),
            disabled: prevDisabled,
            "aria-label": t(props.firstAriaLabel),
            "aria-disabled": prevDisabled
          } : void 0,
          prev: {
            icon: isRtl.value ? props.nextIcon : props.prevIcon,
            onClick: (e) => setValue(e, page.value - 1, "prev"),
            disabled: prevDisabled,
            "aria-label": t(props.previousAriaLabel),
            "aria-disabled": prevDisabled
          },
          next: {
            icon: isRtl.value ? props.prevIcon : props.nextIcon,
            onClick: (e) => setValue(e, page.value + 1, "next"),
            disabled: nextDisabled,
            "aria-label": t(props.nextAriaLabel),
            "aria-disabled": nextDisabled
          },
          last: props.showFirstLastPage ? {
            icon: isRtl.value ? props.firstIcon : props.lastIcon,
            onClick: (e) => setValue(e, start.value + length.value - 1, "last"),
            disabled: nextDisabled,
            "aria-label": t(props.lastAriaLabel),
            "aria-disabled": nextDisabled
          } : void 0
        };
      });
      function updateFocus() {
        var _a2;
        const currentIndex = page.value - start.value;
        (_a2 = refs.value[currentIndex]) == null ? void 0 : _a2.$el.focus();
      }
      function onKeydown(e) {
        if (e.key === keyValues.left && !props.disabled && page.value > +props.start) {
          page.value = page.value - 1;
          nextTick(updateFocus);
        } else if (e.key === keyValues.right && !props.disabled && page.value < start.value + length.value - 1) {
          page.value = page.value + 1;
          nextTick(updateFocus);
        }
      }
      useRender(() => createVNode(props.tag, {
        "ref": resizeRef,
        "class": ["v-pagination", themeClasses.value, props.class],
        "style": props.style,
        "role": "navigation",
        "aria-label": t(props.ariaLabel),
        "onKeydown": onKeydown,
        "data-test": "v-pagination-root"
      }, {
        default: () => [createVNode("ul", {
          "class": "v-pagination__list"
        }, [props.showFirstLastPage && createVNode("li", {
          "key": "first",
          "class": "v-pagination__first",
          "data-test": "v-pagination-first"
        }, [slots.first ? slots.first(controls.value.first) : createVNode(VBtn, mergeProps({
          "_as": "VPaginationBtn"
        }, controls.value.first), null)]), createVNode("li", {
          "key": "prev",
          "class": "v-pagination__prev",
          "data-test": "v-pagination-prev"
        }, [slots.prev ? slots.prev(controls.value.prev) : createVNode(VBtn, mergeProps({
          "_as": "VPaginationBtn"
        }, controls.value.prev), null)]), items.value.map((item, index) => createVNode("li", {
          "key": item.key,
          "class": ["v-pagination__item", {
            "v-pagination__item--is-active": item.isActive
          }],
          "data-test": "v-pagination-item"
        }, [slots.item ? slots.item(item) : createVNode(VBtn, mergeProps({
          "_as": "VPaginationBtn"
        }, item.props), {
          default: () => [item.page]
        })])), createVNode("li", {
          "key": "next",
          "class": "v-pagination__next",
          "data-test": "v-pagination-next"
        }, [slots.next ? slots.next(controls.value.next) : createVNode(VBtn, mergeProps({
          "_as": "VPaginationBtn"
        }, controls.value.next), null)]), props.showFirstLastPage && createVNode("li", {
          "key": "last",
          "class": "v-pagination__last",
          "data-test": "v-pagination-last"
        }, [slots.last ? slots.last(controls.value.last) : createVNode(VBtn, mergeProps({
          "_as": "VPaginationBtn"
        }, controls.value.last), null)])])]
      }));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VDataTable/VDataTableFooter.mjs
  var makeVDataTableFooterProps = propsFactory({
    prevIcon: {
      type: String,
      default: "$prev"
    },
    nextIcon: {
      type: String,
      default: "$next"
    },
    firstIcon: {
      type: String,
      default: "$first"
    },
    lastIcon: {
      type: String,
      default: "$last"
    },
    itemsPerPageText: {
      type: String,
      default: "$vuetify.dataFooter.itemsPerPageText"
    },
    pageText: {
      type: String,
      default: "$vuetify.dataFooter.pageText"
    },
    firstPageLabel: {
      type: String,
      default: "$vuetify.dataFooter.firstPage"
    },
    prevPageLabel: {
      type: String,
      default: "$vuetify.dataFooter.prevPage"
    },
    nextPageLabel: {
      type: String,
      default: "$vuetify.dataFooter.nextPage"
    },
    lastPageLabel: {
      type: String,
      default: "$vuetify.dataFooter.lastPage"
    },
    itemsPerPageOptions: {
      type: Array,
      default: () => [{
        value: 10,
        title: "10"
      }, {
        value: 25,
        title: "25"
      }, {
        value: 50,
        title: "50"
      }, {
        value: 100,
        title: "100"
      }, {
        value: -1,
        title: "$vuetify.dataFooter.itemsPerPageAll"
      }]
    },
    showCurrentPage: Boolean
  }, "VDataTableFooter");
  var VDataTableFooter = genericComponent()({
    name: "VDataTableFooter",
    props: makeVDataTableFooterProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        t
      } = useLocale();
      const {
        page,
        pageCount,
        startIndex,
        stopIndex,
        itemsLength,
        itemsPerPage,
        setItemsPerPage
      } = usePagination();
      const itemsPerPageOptions = computed2(() => props.itemsPerPageOptions.map((option) => {
        if (typeof option === "number") {
          return {
            value: option,
            title: option === -1 ? t("$vuetify.dataFooter.itemsPerPageAll") : String(option)
          };
        }
        return __spreadProps(__spreadValues({}, option), {
          title: t(option.title)
        });
      }));
      useRender(() => {
        var _a2;
        const paginationProps = VPagination.filterProps(props);
        return createVNode("div", {
          "class": "v-data-table-footer"
        }, [(_a2 = slots.prepend) == null ? void 0 : _a2.call(slots), createVNode("div", {
          "class": "v-data-table-footer__items-per-page"
        }, [createVNode("span", null, [t(props.itemsPerPageText)]), createVNode(VSelect, {
          "items": itemsPerPageOptions.value,
          "modelValue": itemsPerPage.value,
          "onUpdate:modelValue": (v) => setItemsPerPage(Number(v)),
          "density": "compact",
          "variant": "outlined",
          "hide-details": true
        }, null)]), createVNode("div", {
          "class": "v-data-table-footer__info"
        }, [createVNode("div", null, [t(props.pageText, !itemsLength.value ? 0 : startIndex.value + 1, stopIndex.value, itemsLength.value)])]), createVNode("div", {
          "class": "v-data-table-footer__pagination"
        }, [createVNode(VPagination, mergeProps({
          "modelValue": page.value,
          "onUpdate:modelValue": ($event) => page.value = $event,
          "density": "comfortable",
          "first-aria-label": props.firstPageLabel,
          "last-aria-label": props.lastPageLabel,
          "length": pageCount.value,
          "next-aria-label": props.nextPageLabel,
          "previous-aria-label": props.prevPageLabel,
          "rounded": true,
          "show-first-last-page": true,
          "total-visible": props.showCurrentPage ? 1 : 0,
          "variant": "plain"
        }, paginationProps), null)])]);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VDataTable/VDataTableColumn.mjs
  var VDataTableColumn = defineFunctionalComponent({
    align: {
      type: String,
      default: "start"
    },
    fixed: Boolean,
    fixedOffset: [Number, String],
    height: [Number, String],
    lastFixed: Boolean,
    noPadding: Boolean,
    tag: String,
    width: [Number, String]
  }, (props, _ref) => {
    var _a2;
    let {
      slots
    } = _ref;
    const Tag = (_a2 = props.tag) != null ? _a2 : "td";
    return createVNode(Tag, {
      "class": ["v-data-table__td", {
        "v-data-table-column--fixed": props.fixed,
        "v-data-table-column--last-fixed": props.lastFixed,
        "v-data-table-column--no-padding": props.noPadding
      }, `v-data-table-column--align-${props.align}`],
      "style": {
        height: convertToUnit(props.height),
        width: convertToUnit(props.width),
        left: convertToUnit(props.fixedOffset || null)
      }
    }, {
      default: () => {
        var _a3;
        return [(_a3 = slots.default) == null ? void 0 : _a3.call(slots)];
      }
    });
  });

  // ../library_management/node_modules/vuetify/lib/components/VDataTable/composables/headers.mjs
  var makeDataTableHeaderProps = propsFactory({
    headers: Array
  }, "DataTable-header");
  var VDataTableHeadersSymbol = Symbol.for("vuetify:data-table-headers");
  var defaultHeader = {
    title: "",
    sortable: false
  };
  var defaultActionHeader = __spreadProps(__spreadValues({}, defaultHeader), {
    width: 48
  });
  function priorityQueue() {
    let arr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const queue2 = arr.map((element) => ({
      element,
      priority: 0
    }));
    return {
      enqueue: (element, priority) => {
        let added = false;
        for (let i = 0; i < queue2.length; i++) {
          const item = queue2[i];
          if (item.priority > priority) {
            queue2.splice(i, 0, {
              element,
              priority
            });
            added = true;
            break;
          }
        }
        if (!added)
          queue2.push({
            element,
            priority
          });
      },
      size: () => queue2.length,
      count: () => {
        let count = 0;
        if (!queue2.length)
          return 0;
        const whole = Math.floor(queue2[0].priority);
        for (let i = 0; i < queue2.length; i++) {
          if (Math.floor(queue2[i].priority) === whole)
            count += 1;
        }
        return count;
      },
      dequeue: () => {
        return queue2.shift();
      }
    };
  }
  function extractLeaves(item) {
    let columns = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    if (!item.children) {
      columns.push(item);
    } else {
      for (const child of item.children) {
        extractLeaves(child, columns);
      }
    }
    return columns;
  }
  function extractKeys(headers) {
    let keys2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /* @__PURE__ */ new Set();
    for (const item of headers) {
      if (item.key)
        keys2.add(item.key);
      if (item.children) {
        extractKeys(item.children, keys2);
      }
    }
    return keys2;
  }
  function getDefaultItem(item) {
    if (!item.key)
      return void 0;
    if (item.key === "data-table-group")
      return defaultHeader;
    if (["data-table-expand", "data-table-select"].includes(item.key))
      return defaultActionHeader;
    return void 0;
  }
  function getDepth(item) {
    let depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (!item.children)
      return depth;
    return Math.max(depth, ...item.children.map((child) => getDepth(child, depth + 1)));
  }
  function parseFixedColumns(items) {
    let seenFixed = false;
    function setFixed(item) {
      let parentFixed = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (!item)
        return;
      if (parentFixed) {
        item.fixed = true;
      }
      if (item.fixed) {
        if (item.children) {
          for (let i = item.children.length - 1; i >= 0; i--) {
            setFixed(item.children[i], true);
          }
        } else {
          if (!seenFixed) {
            item.lastFixed = true;
          } else if (isNaN(+item.width)) {
            consoleError(`Multiple fixed columns should have a static width (key: ${item.key})`);
          }
          seenFixed = true;
        }
      } else {
        if (item.children) {
          for (let i = item.children.length - 1; i >= 0; i--) {
            setFixed(item.children[i]);
          }
        } else {
          seenFixed = false;
        }
      }
    }
    for (let i = items.length - 1; i >= 0; i--) {
      setFixed(items[i]);
    }
    function setFixedOffset(item) {
      let fixedOffset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      if (!item)
        return fixedOffset2;
      if (item.children) {
        item.fixedOffset = fixedOffset2;
        for (const child of item.children) {
          fixedOffset2 = setFixedOffset(child, fixedOffset2);
        }
      } else if (item.fixed) {
        item.fixedOffset = fixedOffset2;
        fixedOffset2 += parseFloat(item.width || "0") || 0;
      }
      return fixedOffset2;
    }
    let fixedOffset = 0;
    for (const item of items) {
      fixedOffset = setFixedOffset(item, fixedOffset);
    }
  }
  function parse2(items, maxDepth) {
    const headers = [];
    let currentDepth = 0;
    const queue2 = priorityQueue(items);
    while (queue2.size() > 0) {
      let rowSize = queue2.count();
      const row = [];
      let fraction = 1;
      while (rowSize > 0) {
        const {
          element: item,
          priority
        } = queue2.dequeue();
        const diff = maxDepth - currentDepth - getDepth(item);
        row.push(__spreadProps(__spreadValues({}, item), {
          rowspan: diff != null ? diff : 1,
          colspan: item.children ? extractLeaves(item).length : 1
        }));
        if (item.children) {
          for (const child of item.children) {
            const sort = priority % 1 + fraction / Math.pow(10, currentDepth + 2);
            queue2.enqueue(child, currentDepth + diff + sort);
          }
        }
        fraction += 1;
        rowSize -= 1;
      }
      currentDepth += 1;
      headers.push(row);
    }
    const columns = items.map((item) => extractLeaves(item)).flat();
    return {
      columns,
      headers
    };
  }
  function convertToInternalHeaders(items) {
    var _a2, _b, _c, _d;
    const internalHeaders = [];
    for (const item of items) {
      const defaultItem = __spreadValues(__spreadValues({}, getDefaultItem(item)), item);
      const key = (_a2 = defaultItem.key) != null ? _a2 : typeof defaultItem.value === "string" ? defaultItem.value : null;
      const value = (_c = (_b = defaultItem.value) != null ? _b : key) != null ? _c : null;
      const internalItem = __spreadProps(__spreadValues({}, defaultItem), {
        key,
        value,
        sortable: (_d = defaultItem.sortable) != null ? _d : defaultItem.key != null || !!defaultItem.sort,
        children: defaultItem.children ? convertToInternalHeaders(defaultItem.children) : void 0
      });
      internalHeaders.push(internalItem);
    }
    return internalHeaders;
  }
  function createHeaders(props, options) {
    const headers = ref([]);
    const columns = ref([]);
    const sortFunctions = ref({});
    const sortRawFunctions = ref({});
    const filterFunctions = ref({});
    watchEffect(() => {
      var _a2, _b, _c, _d;
      const _headers = props.headers || Object.keys((_a2 = props.items[0]) != null ? _a2 : {}).map((key) => ({
        key,
        title: capitalize(key)
      }));
      const items = _headers.slice();
      const keys2 = extractKeys(items);
      if (((_b = options == null ? void 0 : options.groupBy) == null ? void 0 : _b.value.length) && !keys2.has("data-table-group")) {
        items.unshift({
          key: "data-table-group",
          title: "Group"
        });
      }
      if (((_c = options == null ? void 0 : options.showSelect) == null ? void 0 : _c.value) && !keys2.has("data-table-select")) {
        items.unshift({
          key: "data-table-select"
        });
      }
      if (((_d = options == null ? void 0 : options.showExpand) == null ? void 0 : _d.value) && !keys2.has("data-table-expand")) {
        items.push({
          key: "data-table-expand"
        });
      }
      const internalHeaders = convertToInternalHeaders(items);
      parseFixedColumns(internalHeaders);
      const maxDepth = Math.max(...internalHeaders.map((item) => getDepth(item))) + 1;
      const parsed = parse2(internalHeaders, maxDepth);
      headers.value = parsed.headers;
      columns.value = parsed.columns;
      const flatHeaders = parsed.headers.flat(1);
      for (const header of flatHeaders) {
        if (!header.key)
          continue;
        if (header.sortable) {
          if (header.sort) {
            sortFunctions.value[header.key] = header.sort;
          }
          if (header.sortRaw) {
            sortRawFunctions.value[header.key] = header.sortRaw;
          }
        }
        if (header.filter) {
          filterFunctions.value[header.key] = header.filter;
        }
      }
    });
    const data = {
      headers,
      columns,
      sortFunctions,
      sortRawFunctions,
      filterFunctions
    };
    provide(VDataTableHeadersSymbol, data);
    return data;
  }
  function useHeaders() {
    const data = inject(VDataTableHeadersSymbol);
    if (!data)
      throw new Error("Missing headers!");
    return data;
  }

  // ../library_management/node_modules/vuetify/lib/components/VDataTable/VDataTableHeaders.mjs
  var makeVDataTableHeadersProps = propsFactory(__spreadValues({
    color: String,
    sticky: Boolean,
    multiSort: Boolean,
    sortAscIcon: {
      type: IconValue,
      default: "$sortAsc"
    },
    sortDescIcon: {
      type: IconValue,
      default: "$sortDesc"
    },
    headerProps: {
      type: Object
    }
  }, makeLoaderProps()), "VDataTableHeaders");
  var VDataTableHeaders = genericComponent()({
    name: "VDataTableHeaders",
    props: makeVDataTableHeadersProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        toggleSort,
        sortBy,
        isSorted
      } = useSort();
      const {
        someSelected,
        allSelected,
        selectAll,
        showSelectAll
      } = useSelection();
      const {
        columns,
        headers
      } = useHeaders();
      const {
        loaderClasses
      } = useLoader(props);
      function getFixedStyles(column, y) {
        if (!props.sticky && !column.fixed)
          return void 0;
        return {
          position: "sticky",
          left: column.fixed ? convertToUnit(column.fixedOffset) : void 0,
          top: props.sticky ? `calc(var(--v-table-header-height) * ${y})` : void 0
        };
      }
      function getSortIcon(column) {
        const item = sortBy.value.find((item2) => item2.key === column.key);
        if (!item)
          return props.sortAscIcon;
        return item.order === "asc" ? props.sortAscIcon : props.sortDescIcon;
      }
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(props, "color");
      const slotProps = computed2(() => ({
        headers: headers.value,
        columns: columns.value,
        toggleSort,
        isSorted,
        sortBy: sortBy.value,
        someSelected: someSelected.value,
        allSelected: allSelected.value,
        selectAll,
        getSortIcon
      }));
      const VDataTableHeaderCell = (_ref2) => {
        var _a2, _b;
        let {
          column,
          x,
          y
        } = _ref2;
        const noPadding = column.key === "data-table-select" || column.key === "data-table-expand";
        const headerProps = mergeProps((_a2 = props.headerProps) != null ? _a2 : {}, (_b = column.headerProps) != null ? _b : {});
        return createVNode(VDataTableColumn, mergeProps({
          "tag": "th",
          "align": column.align,
          "class": ["v-data-table__th", {
            "v-data-table__th--sortable": column.sortable,
            "v-data-table__th--sorted": isSorted(column),
            "v-data-table__th--fixed": column.fixed,
            "v-data-table__th--sticky": props.sticky
          }, loaderClasses.value],
          "style": __spreadValues({
            width: convertToUnit(column.width),
            minWidth: convertToUnit(column.minWidth)
          }, getFixedStyles(column, y)),
          "colspan": column.colspan,
          "rowspan": column.rowspan,
          "onClick": column.sortable ? () => toggleSort(column) : void 0,
          "fixed": column.fixed,
          "lastFixed": column.lastFixed,
          "noPadding": noPadding
        }, headerProps), {
          default: () => {
            var _a3, _b2;
            const columnSlotName = `header.${column.key}`;
            const columnSlotProps = {
              column,
              selectAll,
              isSorted,
              toggleSort,
              sortBy: sortBy.value,
              someSelected: someSelected.value,
              allSelected: allSelected.value,
              getSortIcon
            };
            if (slots[columnSlotName])
              return slots[columnSlotName](columnSlotProps);
            if (column.key === "data-table-select") {
              return (_b2 = (_a3 = slots["header.data-table-select"]) == null ? void 0 : _a3.call(slots, columnSlotProps)) != null ? _b2 : showSelectAll && createVNode(VCheckboxBtn, {
                "modelValue": allSelected.value,
                "indeterminate": someSelected.value && !allSelected.value,
                "onUpdate:modelValue": selectAll
              }, null);
            }
            return createVNode("div", {
              "class": "v-data-table-header__content"
            }, [createVNode("span", null, [column.title]), column.sortable && createVNode(VIcon, {
              "key": "icon",
              "class": "v-data-table-header__sort-icon",
              "icon": getSortIcon(column)
            }, null), props.multiSort && isSorted(column) && createVNode("div", {
              "key": "badge",
              "class": ["v-data-table-header__sort-badge", ...backgroundColorClasses.value],
              "style": backgroundColorStyles.value
            }, [sortBy.value.findIndex((x2) => x2.key === column.key) + 1])]);
          }
        });
      };
      useRender(() => {
        return createVNode(Fragment, null, [slots.headers ? slots.headers(slotProps.value) : headers.value.map((row, y) => createVNode("tr", null, [row.map((column, x) => createVNode(VDataTableHeaderCell, {
          "column": column,
          "x": x,
          "y": y
        }, null))])), props.loading && createVNode("tr", {
          "class": "v-data-table-progress"
        }, [createVNode("th", {
          "colspan": columns.value.length
        }, [createVNode(LoaderSlot, {
          "name": "v-data-table-progress",
          "absolute": true,
          "active": true,
          "color": typeof props.loading === "boolean" ? void 0 : props.loading,
          "indeterminate": true
        }, {
          default: slots.loader
        })])])]);
      });
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VDataTable/VDataTableGroupHeaderRow.mjs
  var makeVDataTableGroupHeaderRowProps = propsFactory({
    item: {
      type: Object,
      required: true
    }
  }, "VDataTableGroupHeaderRow");
  var VDataTableGroupHeaderRow = genericComponent()({
    name: "VDataTableGroupHeaderRow",
    props: makeVDataTableGroupHeaderRowProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        isGroupOpen,
        toggleGroup,
        extractRows
      } = useGroupBy();
      const {
        isSelected,
        isSomeSelected,
        select
      } = useSelection();
      const {
        columns
      } = useHeaders();
      const rows = computed2(() => {
        return extractRows([props.item]);
      });
      return () => createVNode("tr", {
        "class": "v-data-table-group-header-row",
        "style": {
          "--v-data-table-group-header-row-depth": props.item.depth
        }
      }, [columns.value.map((column) => {
        var _a2, _b, _c, _d;
        if (column.key === "data-table-group") {
          const icon = isGroupOpen(props.item) ? "$expand" : "$next";
          const onClick = () => toggleGroup(props.item);
          return (_b = (_a2 = slots["data-table-group"]) == null ? void 0 : _a2.call(slots, {
            item: props.item,
            count: rows.value.length,
            props: {
              icon,
              onClick
            }
          })) != null ? _b : createVNode(VDataTableColumn, {
            "class": "v-data-table-group-header-row__column"
          }, {
            default: () => [createVNode(VBtn, {
              "size": "small",
              "variant": "text",
              "icon": icon,
              "onClick": onClick
            }, null), createVNode("span", null, [props.item.value]), createVNode("span", null, [createTextVNode("("), rows.value.length, createTextVNode(")")])]
          });
        }
        if (column.key === "data-table-select") {
          const modelValue = isSelected(rows.value);
          const indeterminate = isSomeSelected(rows.value) && !modelValue;
          const selectGroup = (v) => select(rows.value, v);
          return (_d = (_c = slots["data-table-select"]) == null ? void 0 : _c.call(slots, {
            props: {
              modelValue,
              indeterminate,
              "onUpdate:modelValue": selectGroup
            }
          })) != null ? _d : createVNode("td", null, [createVNode(VCheckboxBtn, {
            "modelValue": modelValue,
            "indeterminate": indeterminate,
            "onUpdate:modelValue": selectGroup
          }, null)]);
        }
        return createVNode("td", null, null);
      })]);
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VDataTable/VDataTableRow.mjs
  var makeVDataTableRowProps = propsFactory({
    index: Number,
    item: Object,
    cellProps: [Object, Function],
    onClick: EventProp(),
    onContextmenu: EventProp(),
    onDblclick: EventProp()
  }, "VDataTableRow");
  var VDataTableRow = genericComponent()({
    name: "VDataTableRow",
    props: makeVDataTableRowProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        isSelected,
        toggleSelect
      } = useSelection();
      const {
        isExpanded,
        toggleExpand
      } = useExpanded();
      const {
        columns
      } = useHeaders();
      useRender(() => createVNode("tr", {
        "class": ["v-data-table__tr", {
          "v-data-table__tr--clickable": !!(props.onClick || props.onContextmenu || props.onDblclick)
        }],
        "onClick": props.onClick,
        "onContextmenu": props.onContextmenu,
        "onDblclick": props.onDblclick
      }, [props.item && columns.value.map((column, i) => {
        const item = props.item;
        const slotName = `item.${column.key}`;
        const slotProps = {
          index: props.index,
          item: item.raw,
          internalItem: item,
          value: getObjectValueByPath(item.columns, column.key),
          column,
          isSelected,
          toggleSelect,
          isExpanded,
          toggleExpand
        };
        const cellProps = typeof props.cellProps === "function" ? props.cellProps({
          index: slotProps.index,
          item: slotProps.item,
          internalItem: slotProps.internalItem,
          value: slotProps.value,
          column
        }) : props.cellProps;
        const columnCellProps = typeof column.cellProps === "function" ? column.cellProps({
          index: slotProps.index,
          item: slotProps.item,
          internalItem: slotProps.internalItem,
          value: slotProps.value
        }) : column.cellProps;
        return createVNode(VDataTableColumn, mergeProps({
          "align": column.align,
          "fixed": column.fixed,
          "fixedOffset": column.fixedOffset,
          "lastFixed": column.lastFixed,
          "noPadding": column.key === "data-table-select" || column.key === "data-table-expand",
          "width": column.width
        }, cellProps, columnCellProps), {
          default: () => {
            var _a2, _b, _c, _d;
            if (slots[slotName])
              return slots[slotName](slotProps);
            if (column.key === "data-table-select") {
              return (_b = (_a2 = slots["item.data-table-select"]) == null ? void 0 : _a2.call(slots, slotProps)) != null ? _b : createVNode(VCheckboxBtn, {
                "disabled": !item.selectable,
                "modelValue": isSelected([item]),
                "onClick": withModifiers(() => toggleSelect(item), ["stop"])
              }, null);
            }
            if (column.key === "data-table-expand") {
              return (_d = (_c = slots["item.data-table-expand"]) == null ? void 0 : _c.call(slots, slotProps)) != null ? _d : createVNode(VBtn, {
                "icon": isExpanded(item) ? "$collapse" : "$expand",
                "size": "small",
                "variant": "text",
                "onClick": withModifiers(() => toggleExpand(item), ["stop"])
              }, null);
            }
            return toDisplayString(slotProps.value);
          }
        });
      })]));
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VDataTable/VDataTableRows.mjs
  var makeVDataTableRowsProps = propsFactory({
    loading: [Boolean, String],
    loadingText: {
      type: String,
      default: "$vuetify.dataIterator.loadingText"
    },
    hideNoData: Boolean,
    items: {
      type: Array,
      default: () => []
    },
    noDataText: {
      type: String,
      default: "$vuetify.noDataText"
    },
    rowProps: [Object, Function],
    cellProps: [Object, Function]
  }, "VDataTableRows");
  var VDataTableRows = genericComponent()({
    name: "VDataTableRows",
    inheritAttrs: false,
    props: makeVDataTableRowsProps(),
    setup(props, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const {
        columns
      } = useHeaders();
      const {
        expandOnClick,
        toggleExpand,
        isExpanded
      } = useExpanded();
      const {
        isSelected,
        toggleSelect
      } = useSelection();
      const {
        toggleGroup,
        isGroupOpen
      } = useGroupBy();
      const {
        t
      } = useLocale();
      useRender(() => {
        var _a2, _b, _c, _d;
        if (props.loading && (!props.items.length || slots.loading)) {
          return createVNode("tr", {
            "class": "v-data-table-rows-loading",
            "key": "loading"
          }, [createVNode("td", {
            "colspan": columns.value.length
          }, [(_b = (_a2 = slots.loading) == null ? void 0 : _a2.call(slots)) != null ? _b : t(props.loadingText)])]);
        }
        if (!props.loading && !props.items.length && !props.hideNoData) {
          return createVNode("tr", {
            "class": "v-data-table-rows-no-data",
            "key": "no-data"
          }, [createVNode("td", {
            "colspan": columns.value.length
          }, [(_d = (_c = slots["no-data"]) == null ? void 0 : _c.call(slots)) != null ? _d : t(props.noDataText)])]);
        }
        return createVNode(Fragment, null, [props.items.map((item, index) => {
          var _a3, _b2;
          if (item.type === "group") {
            const slotProps2 = {
              index,
              item,
              columns: columns.value,
              isExpanded,
              toggleExpand,
              isSelected,
              toggleSelect,
              toggleGroup,
              isGroupOpen
            };
            return slots["group-header"] ? slots["group-header"](slotProps2) : createVNode(VDataTableGroupHeaderRow, mergeProps({
              "key": `group-header_${item.id}`,
              "item": item
            }, getPrefixedEventHandlers(attrs, ":group-header", () => slotProps2)), slots);
          }
          const slotProps = {
            index,
            item: item.raw,
            internalItem: item,
            columns: columns.value,
            isExpanded,
            toggleExpand,
            isSelected,
            toggleSelect
          };
          const itemSlotProps = __spreadProps(__spreadValues({}, slotProps), {
            props: mergeProps({
              key: `item_${(_a3 = item.key) != null ? _a3 : item.index}`,
              onClick: expandOnClick.value ? () => {
                toggleExpand(item);
              } : void 0,
              index,
              item,
              cellProps: props.cellProps
            }, getPrefixedEventHandlers(attrs, ":row", () => slotProps), typeof props.rowProps === "function" ? props.rowProps({
              item: slotProps.item,
              index: slotProps.index,
              internalItem: slotProps.internalItem
            }) : props.rowProps)
          });
          return createVNode(Fragment, {
            "key": itemSlotProps.props.key
          }, [slots.item ? slots.item(itemSlotProps) : createVNode(VDataTableRow, itemSlotProps.props, slots), isExpanded(item) && ((_b2 = slots["expanded-row"]) == null ? void 0 : _b2.call(slots, slotProps))]);
        })]);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VTable/VTable.mjs
  var makeVTableProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    fixedHeader: Boolean,
    fixedFooter: Boolean,
    height: [Number, String],
    hover: Boolean
  }, makeComponentProps()), makeDensityProps()), makeTagProps()), makeThemeProps()), "VTable");
  var VTable = genericComponent()({
    name: "VTable",
    props: makeVTableProps(),
    setup(props, _ref) {
      let {
        slots,
        emit: emit2
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      const {
        densityClasses
      } = useDensity(props);
      useRender(() => createVNode(props.tag, {
        "class": ["v-table", {
          "v-table--fixed-height": !!props.height,
          "v-table--fixed-header": props.fixedHeader,
          "v-table--fixed-footer": props.fixedFooter,
          "v-table--has-top": !!slots.top,
          "v-table--has-bottom": !!slots.bottom,
          "v-table--hover": props.hover
        }, themeClasses.value, densityClasses.value, props.class],
        "style": props.style
      }, {
        default: () => {
          var _a2, _b, _c;
          return [(_a2 = slots.top) == null ? void 0 : _a2.call(slots), slots.default ? createVNode("div", {
            "class": "v-table__wrapper",
            "style": {
              height: convertToUnit(props.height)
            }
          }, [createVNode("table", null, [slots.default()])]) : (_b = slots.wrapper) == null ? void 0 : _b.call(slots), (_c = slots.bottom) == null ? void 0 : _c.call(slots)];
        }
      }));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VDataTable/composables/items.mjs
  var makeDataTableItemsProps = propsFactory({
    items: {
      type: Array,
      default: () => []
    },
    itemValue: {
      type: [String, Array, Function],
      default: "id"
    },
    itemSelectable: {
      type: [String, Array, Function],
      default: null
    },
    rowProps: [Object, Function],
    cellProps: [Object, Function],
    returnObject: Boolean
  }, "DataTable-items");
  function transformItem4(props, item, index, columns) {
    const value = props.returnObject ? item : getPropertyFromItem(item, props.itemValue);
    const selectable = getPropertyFromItem(item, props.itemSelectable, true);
    const itemColumns = columns.reduce((obj, column) => {
      if (column.key != null)
        obj[column.key] = getPropertyFromItem(item, column.value);
      return obj;
    }, {});
    return {
      type: "item",
      key: props.returnObject ? getPropertyFromItem(item, props.itemValue) : value,
      index,
      value,
      selectable,
      columns: itemColumns,
      raw: item
    };
  }
  function transformItems4(props, items, columns) {
    return items.map((item, index) => transformItem4(props, item, index, columns));
  }
  function useDataTableItems(props, columns) {
    const items = computed2(() => transformItems4(props, props.items, columns.value));
    return {
      items
    };
  }

  // ../library_management/node_modules/vuetify/lib/components/VDataTable/VDataTable.mjs
  var makeDataTableProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadProps(__spreadValues({}, makeVDataTableRowsProps()), {
    width: [String, Number],
    search: String
  }), makeDataTableExpandProps()), makeDataTableGroupProps()), makeDataTableHeaderProps()), makeDataTableItemsProps()), makeDataTableSelectProps()), makeDataTableSortProps()), makeVDataTableHeadersProps()), makeVTableProps()), "DataTable");
  var makeVDataTableProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, makeDataTablePaginateProps()), makeDataTableProps()), makeFilterProps()), makeVDataTableFooterProps()), "VDataTable");
  var VDataTable = genericComponent()({
    name: "VDataTable",
    props: makeVDataTableProps(),
    emits: {
      "update:modelValue": (value) => true,
      "update:page": (value) => true,
      "update:itemsPerPage": (value) => true,
      "update:sortBy": (value) => true,
      "update:options": (value) => true,
      "update:groupBy": (value) => true,
      "update:expanded": (value) => true,
      "update:currentItems": (value) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const {
        groupBy
      } = createGroupBy(props);
      const {
        sortBy,
        multiSort,
        mustSort
      } = createSort(props);
      const {
        page,
        itemsPerPage
      } = createPagination(props);
      const {
        columns,
        headers,
        sortFunctions,
        sortRawFunctions,
        filterFunctions
      } = createHeaders(props, {
        groupBy,
        showSelect: toRef(props, "showSelect"),
        showExpand: toRef(props, "showExpand")
      });
      const {
        items
      } = useDataTableItems(props, columns);
      const search = toRef(props, "search");
      const {
        filteredItems
      } = useFilter(props, items, search, {
        transform: (item) => item.columns,
        customKeyFilter: filterFunctions
      });
      const {
        toggleSort
      } = provideSort({
        sortBy,
        multiSort,
        mustSort,
        page
      });
      const {
        sortByWithGroups,
        opened,
        extractRows,
        isGroupOpen,
        toggleGroup
      } = provideGroupBy({
        groupBy,
        sortBy
      });
      const {
        sortedItems
      } = useSortedItems(props, filteredItems, sortByWithGroups, sortFunctions, sortRawFunctions);
      const {
        flatItems
      } = useGroupedItems(sortedItems, groupBy, opened);
      const itemsLength = computed2(() => flatItems.value.length);
      const {
        startIndex,
        stopIndex,
        pageCount,
        setItemsPerPage
      } = providePagination({
        page,
        itemsPerPage,
        itemsLength
      });
      const {
        paginatedItems
      } = usePaginatedItems({
        items: flatItems,
        startIndex,
        stopIndex,
        itemsPerPage
      });
      const paginatedItemsWithoutGroups = computed2(() => extractRows(paginatedItems.value));
      const {
        isSelected,
        select,
        selectAll,
        toggleSelect,
        someSelected,
        allSelected
      } = provideSelection(props, {
        allItems: items,
        currentPage: paginatedItemsWithoutGroups
      });
      const {
        isExpanded,
        toggleExpand
      } = provideExpanded(props);
      useOptions({
        page,
        itemsPerPage,
        sortBy,
        groupBy,
        search
      });
      provideDefaults({
        VDataTableRows: {
          hideNoData: toRef(props, "hideNoData"),
          noDataText: toRef(props, "noDataText"),
          loading: toRef(props, "loading"),
          loadingText: toRef(props, "loadingText")
        }
      });
      const slotProps = computed2(() => ({
        page: page.value,
        itemsPerPage: itemsPerPage.value,
        sortBy: sortBy.value,
        pageCount: pageCount.value,
        toggleSort,
        setItemsPerPage,
        someSelected: someSelected.value,
        allSelected: allSelected.value,
        isSelected,
        select,
        selectAll,
        toggleSelect,
        isExpanded,
        toggleExpand,
        isGroupOpen,
        toggleGroup,
        items: paginatedItemsWithoutGroups.value.map((item) => item.raw),
        internalItems: paginatedItemsWithoutGroups.value,
        groupedItems: paginatedItems.value,
        columns: columns.value,
        headers: headers.value
      }));
      useRender(() => {
        const dataTableFooterProps = VDataTableFooter.filterProps(props);
        const dataTableHeadersProps = VDataTableHeaders.filterProps(props);
        const dataTableRowsProps = VDataTableRows.filterProps(props);
        const tableProps = VTable.filterProps(props);
        return createVNode(VTable, mergeProps({
          "class": ["v-data-table", {
            "v-data-table--show-select": props.showSelect,
            "v-data-table--loading": props.loading
          }, props.class],
          "style": props.style
        }, tableProps), {
          top: () => {
            var _a2;
            return (_a2 = slots.top) == null ? void 0 : _a2.call(slots, slotProps.value);
          },
          default: () => {
            var _a2, _b, _c, _d, _e, _f;
            return slots.default ? slots.default(slotProps.value) : createVNode(Fragment, null, [(_a2 = slots.colgroup) == null ? void 0 : _a2.call(slots, slotProps.value), createVNode("thead", null, [createVNode(VDataTableHeaders, dataTableHeadersProps, slots)]), (_b = slots.thead) == null ? void 0 : _b.call(slots, slotProps.value), createVNode("tbody", null, [(_c = slots["body.prepend"]) == null ? void 0 : _c.call(slots, slotProps.value), slots.body ? slots.body(slotProps.value) : createVNode(VDataTableRows, mergeProps(attrs, dataTableRowsProps, {
              "items": paginatedItems.value
            }), slots), (_d = slots["body.append"]) == null ? void 0 : _d.call(slots, slotProps.value)]), (_e = slots.tbody) == null ? void 0 : _e.call(slots, slotProps.value), (_f = slots.tfoot) == null ? void 0 : _f.call(slots, slotProps.value)]);
          },
          bottom: () => slots.bottom ? slots.bottom(slotProps.value) : createVNode(Fragment, null, [createVNode(VDivider, null, null), createVNode(VDataTableFooter, dataTableFooterProps, {
            prepend: slots["footer.prepend"]
          })])
        });
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VDataTable/VDataTableVirtual.mjs
  var makeVDataTableVirtualProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, makeDataTableProps()), makeDataTableGroupProps()), makeVirtualProps()), makeFilterProps()), "VDataTableVirtual");
  var VDataTableVirtual = genericComponent()({
    name: "VDataTableVirtual",
    props: makeVDataTableVirtualProps(),
    emits: {
      "update:modelValue": (value) => true,
      "update:sortBy": (value) => true,
      "update:options": (value) => true,
      "update:groupBy": (value) => true,
      "update:expanded": (value) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const {
        groupBy
      } = createGroupBy(props);
      const {
        sortBy,
        multiSort,
        mustSort
      } = createSort(props);
      const {
        columns,
        headers,
        filterFunctions,
        sortFunctions,
        sortRawFunctions
      } = createHeaders(props, {
        groupBy,
        showSelect: toRef(props, "showSelect"),
        showExpand: toRef(props, "showExpand")
      });
      const {
        items
      } = useDataTableItems(props, columns);
      const search = toRef(props, "search");
      const {
        filteredItems
      } = useFilter(props, items, search, {
        transform: (item) => item.columns,
        customKeyFilter: filterFunctions
      });
      const {
        toggleSort
      } = provideSort({
        sortBy,
        multiSort,
        mustSort
      });
      const {
        sortByWithGroups,
        opened,
        extractRows,
        isGroupOpen,
        toggleGroup
      } = provideGroupBy({
        groupBy,
        sortBy
      });
      const {
        sortedItems
      } = useSortedItems(props, filteredItems, sortByWithGroups, sortFunctions, sortRawFunctions);
      const {
        flatItems
      } = useGroupedItems(sortedItems, groupBy, opened);
      const allItems = computed2(() => extractRows(flatItems.value));
      const {
        isSelected,
        select,
        selectAll,
        toggleSelect,
        someSelected,
        allSelected
      } = provideSelection(props, {
        allItems,
        currentPage: allItems
      });
      const {
        isExpanded,
        toggleExpand
      } = provideExpanded(props);
      const {
        containerRef,
        markerRef,
        paddingTop,
        paddingBottom,
        computedItems,
        handleItemResize,
        handleScroll,
        handleScrollend
      } = useVirtual(props, flatItems);
      const displayItems = computed2(() => computedItems.value.map((item) => item.raw));
      useOptions({
        sortBy,
        page: shallowRef(1),
        itemsPerPage: shallowRef(-1),
        groupBy,
        search
      });
      provideDefaults({
        VDataTableRows: {
          hideNoData: toRef(props, "hideNoData"),
          noDataText: toRef(props, "noDataText"),
          loading: toRef(props, "loading"),
          loadingText: toRef(props, "loadingText")
        }
      });
      const slotProps = computed2(() => ({
        sortBy: sortBy.value,
        toggleSort,
        someSelected: someSelected.value,
        allSelected: allSelected.value,
        isSelected,
        select,
        selectAll,
        toggleSelect,
        isExpanded,
        toggleExpand,
        isGroupOpen,
        toggleGroup,
        items: allItems.value.map((item) => item.raw),
        internalItems: allItems.value,
        groupedItems: flatItems.value,
        columns: columns.value,
        headers: headers.value
      }));
      useRender(() => {
        const dataTableHeadersProps = VDataTableHeaders.filterProps(props);
        const dataTableRowsProps = VDataTableRows.filterProps(props);
        const tableProps = VTable.filterProps(props);
        return createVNode(VTable, mergeProps({
          "class": ["v-data-table", {
            "v-data-table--loading": props.loading
          }, props.class],
          "style": props.style
        }, tableProps), {
          top: () => {
            var _a2;
            return (_a2 = slots.top) == null ? void 0 : _a2.call(slots, slotProps.value);
          },
          wrapper: () => {
            var _a2, _b, _c;
            return createVNode("div", {
              "ref": containerRef,
              "onScrollPassive": handleScroll,
              "onScrollend": handleScrollend,
              "class": "v-table__wrapper",
              "style": {
                height: convertToUnit(props.height)
              }
            }, [createVNode("table", null, [(_a2 = slots.colgroup) == null ? void 0 : _a2.call(slots, slotProps.value), createVNode("thead", null, [createVNode(VDataTableHeaders, mergeProps(dataTableHeadersProps, {
              "sticky": props.fixedHeader
            }), slots)]), createVNode("tbody", null, [createVNode("tr", {
              "ref": markerRef,
              "style": {
                height: convertToUnit(paddingTop.value),
                border: 0
              }
            }, [createVNode("td", {
              "colspan": columns.value.length,
              "style": {
                height: 0,
                border: 0
              }
            }, null)]), (_b = slots["body.prepend"]) == null ? void 0 : _b.call(slots, slotProps.value), createVNode(VDataTableRows, mergeProps(attrs, dataTableRowsProps, {
              "items": displayItems.value
            }), __spreadProps(__spreadValues({}, slots), {
              item: (itemSlotProps) => createVNode(VVirtualScrollItem, {
                "key": itemSlotProps.internalItem.index,
                "renderless": true,
                "onUpdate:height": (height) => handleItemResize(itemSlotProps.internalItem.index, height)
              }, {
                default: (_ref2) => {
                  var _a3, _b2;
                  let {
                    itemRef
                  } = _ref2;
                  return (_b2 = (_a3 = slots.item) == null ? void 0 : _a3.call(slots, __spreadProps(__spreadValues({}, itemSlotProps), {
                    itemRef
                  }))) != null ? _b2 : createVNode(VDataTableRow, mergeProps(itemSlotProps.props, {
                    "ref": itemRef,
                    "key": itemSlotProps.internalItem.index,
                    "index": itemSlotProps.internalItem.index
                  }), slots);
                }
              })
            })), (_c = slots["body.append"]) == null ? void 0 : _c.call(slots, slotProps.value), createVNode("tr", {
              "style": {
                height: convertToUnit(paddingBottom.value),
                border: 0
              }
            }, [createVNode("td", {
              "colspan": columns.value.length,
              "style": {
                height: 0,
                border: 0
              }
            }, null)])])])]);
          },
          bottom: () => {
            var _a2;
            return (_a2 = slots.bottom) == null ? void 0 : _a2.call(slots, slotProps.value);
          }
        });
      });
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VDataTable/VDataTableServer.mjs
  var makeVDataTableServerProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({
    itemsLength: {
      type: [Number, String],
      required: true
    }
  }, makeDataTablePaginateProps()), makeDataTableProps()), makeVDataTableFooterProps()), "VDataTableServer");
  var VDataTableServer = genericComponent()({
    name: "VDataTableServer",
    props: makeVDataTableServerProps(),
    emits: {
      "update:modelValue": (value) => true,
      "update:page": (page) => true,
      "update:itemsPerPage": (page) => true,
      "update:sortBy": (sortBy) => true,
      "update:options": (options) => true,
      "update:expanded": (options) => true,
      "update:groupBy": (value) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const {
        groupBy
      } = createGroupBy(props);
      const {
        sortBy,
        multiSort,
        mustSort
      } = createSort(props);
      const {
        page,
        itemsPerPage
      } = createPagination(props);
      const itemsLength = computed2(() => parseInt(props.itemsLength, 10));
      const {
        columns,
        headers
      } = createHeaders(props, {
        groupBy,
        showSelect: toRef(props, "showSelect"),
        showExpand: toRef(props, "showExpand")
      });
      const {
        items
      } = useDataTableItems(props, columns);
      const {
        toggleSort
      } = provideSort({
        sortBy,
        multiSort,
        mustSort,
        page
      });
      const {
        opened,
        isGroupOpen,
        toggleGroup,
        extractRows
      } = provideGroupBy({
        groupBy,
        sortBy
      });
      const {
        pageCount,
        setItemsPerPage
      } = providePagination({
        page,
        itemsPerPage,
        itemsLength
      });
      const {
        flatItems
      } = useGroupedItems(items, groupBy, opened);
      const {
        isSelected,
        select,
        selectAll,
        toggleSelect,
        someSelected,
        allSelected
      } = provideSelection(props, {
        allItems: items,
        currentPage: items
      });
      const {
        isExpanded,
        toggleExpand
      } = provideExpanded(props);
      const itemsWithoutGroups = computed2(() => extractRows(items.value));
      useOptions({
        page,
        itemsPerPage,
        sortBy,
        groupBy,
        search: toRef(props, "search")
      });
      provide("v-data-table", {
        toggleSort,
        sortBy
      });
      provideDefaults({
        VDataTableRows: {
          hideNoData: toRef(props, "hideNoData"),
          noDataText: toRef(props, "noDataText"),
          loading: toRef(props, "loading"),
          loadingText: toRef(props, "loadingText")
        }
      });
      const slotProps = computed2(() => ({
        page: page.value,
        itemsPerPage: itemsPerPage.value,
        sortBy: sortBy.value,
        pageCount: pageCount.value,
        toggleSort,
        setItemsPerPage,
        someSelected: someSelected.value,
        allSelected: allSelected.value,
        isSelected,
        select,
        selectAll,
        toggleSelect,
        isExpanded,
        toggleExpand,
        isGroupOpen,
        toggleGroup,
        items: itemsWithoutGroups.value.map((item) => item.raw),
        internalItems: itemsWithoutGroups.value,
        groupedItems: flatItems.value,
        columns: columns.value,
        headers: headers.value
      }));
      useRender(() => {
        const dataTableFooterProps = VDataTableFooter.filterProps(props);
        const dataTableHeadersProps = VDataTableHeaders.filterProps(props);
        const dataTableRowsProps = VDataTableRows.filterProps(props);
        const tableProps = VTable.filterProps(props);
        return createVNode(VTable, mergeProps({
          "class": ["v-data-table", {
            "v-data-table--loading": props.loading
          }, props.class],
          "style": props.style
        }, tableProps), {
          top: () => {
            var _a2;
            return (_a2 = slots.top) == null ? void 0 : _a2.call(slots, slotProps.value);
          },
          default: () => {
            var _a2, _b, _c, _d, _e, _f;
            return slots.default ? slots.default(slotProps.value) : createVNode(Fragment, null, [(_a2 = slots.colgroup) == null ? void 0 : _a2.call(slots, slotProps.value), createVNode("thead", {
              "class": "v-data-table__thead",
              "role": "rowgroup"
            }, [createVNode(VDataTableHeaders, mergeProps(dataTableHeadersProps, {
              "sticky": props.fixedHeader
            }), slots)]), (_b = slots.thead) == null ? void 0 : _b.call(slots, slotProps.value), createVNode("tbody", {
              "class": "v-data-table__tbody",
              "role": "rowgroup"
            }, [(_c = slots["body.prepend"]) == null ? void 0 : _c.call(slots, slotProps.value), slots.body ? slots.body(slotProps.value) : createVNode(VDataTableRows, mergeProps(attrs, dataTableRowsProps, {
              "items": flatItems.value
            }), slots), (_d = slots["body.append"]) == null ? void 0 : _d.call(slots, slotProps.value)]), (_e = slots.tbody) == null ? void 0 : _e.call(slots, slotProps.value), (_f = slots.tfoot) == null ? void 0 : _f.call(slots, slotProps.value)]);
          },
          bottom: () => slots.bottom ? slots.bottom(slotProps.value) : createVNode(Fragment, null, [createVNode(VDivider, null, null), createVNode(VDataTableFooter, dataTableFooterProps, {
            prepend: slots["footer.prepend"]
          })])
        });
      });
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VGrid/VContainer.mjs
  var makeVContainerProps = propsFactory(__spreadValues(__spreadValues({
    fluid: {
      type: Boolean,
      default: false
    }
  }, makeComponentProps()), makeTagProps()), "VContainer");
  var VContainer = genericComponent()({
    name: "VContainer",
    props: makeVContainerProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        rtlClasses
      } = useRtl();
      useRender(() => createVNode(props.tag, {
        "class": ["v-container", {
          "v-container--fluid": props.fluid
        }, rtlClasses.value, props.class],
        "style": props.style
      }, slots));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VGrid/VCol.mjs
  var breakpointProps = (() => {
    return breakpoints.reduce((props, val) => {
      props[val] = {
        type: [Boolean, String, Number],
        default: false
      };
      return props;
    }, {});
  })();
  var offsetProps = (() => {
    return breakpoints.reduce((props, val) => {
      const offsetKey = "offset" + capitalize(val);
      props[offsetKey] = {
        type: [String, Number],
        default: null
      };
      return props;
    }, {});
  })();
  var orderProps = (() => {
    return breakpoints.reduce((props, val) => {
      const orderKey = "order" + capitalize(val);
      props[orderKey] = {
        type: [String, Number],
        default: null
      };
      return props;
    }, {});
  })();
  var propMap = {
    col: Object.keys(breakpointProps),
    offset: Object.keys(offsetProps),
    order: Object.keys(orderProps)
  };
  function breakpointClass(type2, prop, val) {
    let className = type2;
    if (val == null || val === false) {
      return void 0;
    }
    if (prop) {
      const breakpoint = prop.replace(type2, "");
      className += `-${breakpoint}`;
    }
    if (type2 === "col") {
      className = "v-" + className;
    }
    if (type2 === "col" && (val === "" || val === true)) {
      return className.toLowerCase();
    }
    className += `-${val}`;
    return className.toLowerCase();
  }
  var ALIGN_SELF_VALUES = ["auto", "start", "end", "center", "baseline", "stretch"];
  var makeVColProps = propsFactory(__spreadValues(__spreadValues(__spreadProps(__spreadValues(__spreadProps(__spreadValues(__spreadProps(__spreadValues({
    cols: {
      type: [Boolean, String, Number],
      default: false
    }
  }, breakpointProps), {
    offset: {
      type: [String, Number],
      default: null
    }
  }), offsetProps), {
    order: {
      type: [String, Number],
      default: null
    }
  }), orderProps), {
    alignSelf: {
      type: String,
      default: null,
      validator: (str) => ALIGN_SELF_VALUES.includes(str)
    }
  }), makeComponentProps()), makeTagProps()), "VCol");
  var VCol = genericComponent()({
    name: "VCol",
    props: makeVColProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const classes = computed2(() => {
        const classList = [];
        let type2;
        for (type2 in propMap) {
          propMap[type2].forEach((prop) => {
            const value = props[prop];
            const className = breakpointClass(type2, prop, value);
            if (className)
              classList.push(className);
          });
        }
        const hasColClasses = classList.some((className) => className.startsWith("v-col-"));
        classList.push({
          "v-col": !hasColClasses || !props.cols,
          [`v-col-${props.cols}`]: props.cols,
          [`offset-${props.offset}`]: props.offset,
          [`order-${props.order}`]: props.order,
          [`align-self-${props.alignSelf}`]: props.alignSelf
        });
        return classList;
      });
      return () => {
        var _a2;
        return h(props.tag, {
          class: [classes.value, props.class],
          style: props.style
        }, (_a2 = slots.default) == null ? void 0 : _a2.call(slots));
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VGrid/VRow.mjs
  var ALIGNMENT = ["start", "end", "center"];
  var SPACE = ["space-between", "space-around", "space-evenly"];
  function makeRowProps(prefix, def2) {
    return breakpoints.reduce((props, val) => {
      const prefixKey = prefix + capitalize(val);
      props[prefixKey] = def2();
      return props;
    }, {});
  }
  var ALIGN_VALUES = [...ALIGNMENT, "baseline", "stretch"];
  var alignValidator = (str) => ALIGN_VALUES.includes(str);
  var alignProps = makeRowProps("align", () => ({
    type: String,
    default: null,
    validator: alignValidator
  }));
  var JUSTIFY_VALUES = [...ALIGNMENT, ...SPACE];
  var justifyValidator = (str) => JUSTIFY_VALUES.includes(str);
  var justifyProps = makeRowProps("justify", () => ({
    type: String,
    default: null,
    validator: justifyValidator
  }));
  var ALIGN_CONTENT_VALUES = [...ALIGNMENT, ...SPACE, "stretch"];
  var alignContentValidator = (str) => ALIGN_CONTENT_VALUES.includes(str);
  var alignContentProps = makeRowProps("alignContent", () => ({
    type: String,
    default: null,
    validator: alignContentValidator
  }));
  var propMap2 = {
    align: Object.keys(alignProps),
    justify: Object.keys(justifyProps),
    alignContent: Object.keys(alignContentProps)
  };
  var classMap = {
    align: "align",
    justify: "justify",
    alignContent: "align-content"
  };
  function breakpointClass2(type2, prop, val) {
    let className = classMap[type2];
    if (val == null) {
      return void 0;
    }
    if (prop) {
      const breakpoint = prop.replace(type2, "");
      className += `-${breakpoint}`;
    }
    className += `-${val}`;
    return className.toLowerCase();
  }
  var makeVRowProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadProps(__spreadValues(__spreadProps(__spreadValues({
    dense: Boolean,
    noGutters: Boolean,
    align: {
      type: String,
      default: null,
      validator: alignValidator
    }
  }, alignProps), {
    justify: {
      type: String,
      default: null,
      validator: justifyValidator
    }
  }), justifyProps), {
    alignContent: {
      type: String,
      default: null,
      validator: alignContentValidator
    }
  }), alignContentProps), makeComponentProps()), makeTagProps()), "VRow");
  var VRow = genericComponent()({
    name: "VRow",
    props: makeVRowProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const classes = computed2(() => {
        const classList = [];
        let type2;
        for (type2 in propMap2) {
          propMap2[type2].forEach((prop) => {
            const value = props[prop];
            const className = breakpointClass2(type2, prop, value);
            if (className)
              classList.push(className);
          });
        }
        classList.push({
          "v-row--no-gutters": props.noGutters,
          "v-row--dense": props.dense,
          [`align-${props.align}`]: props.align,
          [`justify-${props.justify}`]: props.justify,
          [`align-content-${props.alignContent}`]: props.alignContent
        });
        return classList;
      });
      return () => {
        var _a2;
        return h(props.tag, {
          class: ["v-row", classes.value, props.class],
          style: props.style
        }, (_a2 = slots.default) == null ? void 0 : _a2.call(slots));
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VGrid/VSpacer.mjs
  var VSpacer = createSimpleFunctional("v-spacer", "div", "VSpacer");

  // ../library_management/node_modules/vuetify/lib/components/VDatePicker/VDatePickerControls.mjs
  var makeVDatePickerControlsProps = propsFactory({
    active: {
      type: [String, Array],
      default: void 0
    },
    disabled: {
      type: [Boolean, String, Array],
      default: false
    },
    nextIcon: {
      type: [String],
      default: "$next"
    },
    prevIcon: {
      type: [String],
      default: "$prev"
    },
    modeIcon: {
      type: [String],
      default: "$subgroup"
    },
    text: String,
    viewMode: {
      type: String,
      default: "month"
    }
  }, "VDatePickerControls");
  var VDatePickerControls = genericComponent()({
    name: "VDatePickerControls",
    props: makeVDatePickerControlsProps(),
    emits: {
      "click:year": () => true,
      "click:month": () => true,
      "click:prev": () => true,
      "click:next": () => true,
      "click:text": () => true
    },
    setup(props, _ref) {
      let {
        emit: emit2
      } = _ref;
      const disableMonth = computed2(() => {
        return Array.isArray(props.disabled) ? props.disabled.includes("text") : !!props.disabled;
      });
      const disableYear = computed2(() => {
        return Array.isArray(props.disabled) ? props.disabled.includes("mode") : !!props.disabled;
      });
      const disablePrev = computed2(() => {
        return Array.isArray(props.disabled) ? props.disabled.includes("prev") : !!props.disabled;
      });
      const disableNext = computed2(() => {
        return Array.isArray(props.disabled) ? props.disabled.includes("next") : !!props.disabled;
      });
      function onClickPrev() {
        emit2("click:prev");
      }
      function onClickNext() {
        emit2("click:next");
      }
      function onClickYear() {
        emit2("click:year");
      }
      function onClickMonth() {
        emit2("click:month");
      }
      useRender(() => {
        return createVNode("div", {
          "class": ["v-date-picker-controls"]
        }, [createVNode(VBtn, {
          "class": "v-date-picker-controls__month-btn",
          "disabled": disableMonth.value,
          "text": props.text,
          "variant": "text",
          "rounded": true,
          "onClick": onClickMonth
        }, null), createVNode(VBtn, {
          "key": "mode-btn",
          "class": "v-date-picker-controls__mode-btn",
          "disabled": disableYear.value,
          "density": "comfortable",
          "icon": props.modeIcon,
          "variant": "text",
          "onClick": onClickYear
        }, null), createVNode(VSpacer, {
          "key": "mode-spacer"
        }, null), createVNode("div", {
          "key": "month-buttons",
          "class": "v-date-picker-controls__month"
        }, [createVNode(VBtn, {
          "disabled": disablePrev.value,
          "icon": props.prevIcon,
          "variant": "text",
          "onClick": onClickPrev
        }, null), createVNode(VBtn, {
          "disabled": disableNext.value,
          "icon": props.nextIcon,
          "variant": "text",
          "onClick": onClickNext
        }, null)])]);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VDatePicker/VDatePickerHeader.mjs
  var makeVDatePickerHeaderProps = propsFactory({
    appendIcon: String,
    color: String,
    header: String,
    transition: String,
    onClick: EventProp()
  }, "VDatePickerHeader");
  var VDatePickerHeader = genericComponent()({
    name: "VDatePickerHeader",
    props: makeVDatePickerHeaderProps(),
    emits: {
      click: () => true,
      "click:append": () => true
    },
    setup(props, _ref) {
      let {
        emit: emit2,
        slots
      } = _ref;
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(props, "color");
      function onClick() {
        emit2("click");
      }
      function onClickAppend() {
        emit2("click:append");
      }
      useRender(() => {
        const hasContent = !!(slots.default || props.header);
        const hasAppend = !!(slots.append || props.appendIcon);
        return createVNode("div", {
          "class": ["v-date-picker-header", {
            "v-date-picker-header--clickable": !!props.onClick
          }, backgroundColorClasses.value],
          "style": backgroundColorStyles.value,
          "onClick": onClick
        }, [slots.prepend && createVNode("div", {
          "key": "prepend",
          "class": "v-date-picker-header__prepend"
        }, [slots.prepend()]), hasContent && createVNode(MaybeTransition, {
          "key": "content",
          "name": props.transition
        }, {
          default: () => {
            var _a2, _b;
            return [createVNode("div", {
              "key": props.header,
              "class": "v-date-picker-header__content"
            }, [(_b = (_a2 = slots.default) == null ? void 0 : _a2.call(slots)) != null ? _b : props.header])];
          }
        }), hasAppend && createVNode("div", {
          "class": "v-date-picker-header__append"
        }, [!slots.append ? createVNode(VBtn, {
          "key": "append-btn",
          "icon": props.appendIcon,
          "variant": "text",
          "onClick": onClickAppend
        }, null) : createVNode(VDefaultsProvider, {
          "key": "append-defaults",
          "disabled": !props.appendIcon,
          "defaults": {
            VBtn: {
              icon: props.appendIcon,
              variant: "text"
            }
          }
        }, {
          default: () => {
            var _a2;
            return [(_a2 = slots.append) == null ? void 0 : _a2.call(slots)];
          }
        })])]);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/composables/calendar.mjs
  var makeCalendarProps = propsFactory({
    allowedDates: [Array, Function],
    disabled: Boolean,
    displayValue: null,
    modelValue: Array,
    month: [Number, String],
    max: null,
    min: null,
    showAdjacentMonths: Boolean,
    year: [Number, String],
    weekdays: {
      type: Array,
      default: () => [0, 1, 2, 3, 4, 5, 6]
    }
  }, "calendar");
  function useCalendar(props) {
    const adapter = useDate();
    const model = useProxiedModel(props, "modelValue", [], (v) => wrapInArray(v));
    const displayValue = computed2(() => {
      if (props.displayValue)
        return adapter.date(props.displayValue);
      if (model.value.length > 0)
        return adapter.date(model.value[0]);
      if (props.min)
        return adapter.date(props.min);
      if (Array.isArray(props.allowedDates))
        return adapter.date(props.allowedDates[0]);
      return adapter.date();
    });
    const year = useProxiedModel(props, "year", void 0, (v) => {
      const value = v != null ? Number(v) : adapter.getYear(displayValue.value);
      return adapter.startOfYear(adapter.setYear(adapter.date(), value));
    }, (v) => adapter.getYear(v));
    const month = useProxiedModel(props, "month", void 0, (v) => {
      const value = v != null ? Number(v) : adapter.getMonth(displayValue.value);
      const date2 = adapter.setYear(adapter.startOfMonth(adapter.date()), adapter.getYear(year.value));
      return adapter.setMonth(date2, value);
    }, (v) => adapter.getMonth(v));
    const weeksInMonth = computed2(() => {
      const weeks = adapter.getWeekArray(month.value);
      const days = weeks.flat();
      const daysInMonth2 = 6 * 7;
      if (days.length < daysInMonth2) {
        const lastDay = days[days.length - 1];
        let week = [];
        for (let day = 1; day <= daysInMonth2 - days.length; day++) {
          week.push(adapter.addDays(lastDay, day));
          if (day % 7 === 0) {
            weeks.push(week);
            week = [];
          }
        }
      }
      return weeks;
    });
    function genDays(days, today) {
      return days.filter((date2) => {
        return props.weekdays.includes(adapter.toJsDate(date2).getDay());
      }).map((date2, index) => {
        const isoDate = adapter.toISO(date2);
        const isAdjacent = !adapter.isSameMonth(date2, month.value);
        const isStart = adapter.isSameDay(date2, adapter.startOfMonth(month.value));
        const isEnd = adapter.isSameDay(date2, adapter.endOfMonth(month.value));
        const isSame = adapter.isSameDay(date2, month.value);
        return {
          date: date2,
          isoDate,
          formatted: adapter.format(date2, "keyboardDate"),
          year: adapter.getYear(date2),
          month: adapter.getMonth(date2),
          isDisabled: isDisabled(date2),
          isWeekStart: index % 7 === 0,
          isWeekEnd: index % 7 === 6,
          isToday: adapter.isSameDay(date2, today),
          isAdjacent,
          isHidden: isAdjacent && !props.showAdjacentMonths,
          isStart,
          isSelected: model.value.some((value) => adapter.isSameDay(date2, value)),
          isEnd,
          isSame,
          localized: adapter.format(date2, "dayOfMonth")
        };
      });
    }
    const daysInWeek = computed2(() => {
      const lastDay = adapter.startOfWeek(model.value);
      const week = [];
      for (let day = 0; day <= 6; day++) {
        week.push(adapter.addDays(lastDay, day));
      }
      const days = week;
      const today = adapter.date();
      return genDays(days, today);
    });
    const daysInMonth = computed2(() => {
      const days = weeksInMonth.value.flat();
      const today = adapter.date();
      return genDays(days, today);
    });
    const weekNumbers = computed2(() => {
      return weeksInMonth.value.map((week) => {
        return week.length ? getWeek(adapter, week[0]) : null;
      });
    });
    function isDisabled(value) {
      if (props.disabled)
        return true;
      const date2 = adapter.date(value);
      if (props.min && adapter.isAfter(adapter.date(props.min), date2))
        return true;
      if (props.max && adapter.isAfter(date2, adapter.date(props.max)))
        return true;
      if (Array.isArray(props.allowedDates) && props.allowedDates.length > 0) {
        return !props.allowedDates.some((d) => adapter.isSameDay(adapter.date(d), date2));
      }
      if (typeof props.allowedDates === "function") {
        return !props.allowedDates(date2);
      }
      return false;
    }
    return {
      displayValue,
      daysInMonth,
      daysInWeek,
      genDays,
      model,
      weeksInMonth,
      weekNumbers
    };
  }

  // ../library_management/node_modules/vuetify/lib/components/VDatePicker/VDatePickerMonth.mjs
  var makeVDatePickerMonthProps = propsFactory(__spreadValues({
    color: String,
    hideWeekdays: Boolean,
    multiple: [Boolean, Number, String],
    showWeek: Boolean
  }, makeCalendarProps()), "VDatePickerMonth");
  var VDatePickerMonth = genericComponent()({
    name: "VDatePickerMonth",
    props: makeVDatePickerMonthProps(),
    emits: {
      "update:modelValue": (date2) => true,
      "update:month": (date2) => true,
      "update:year": (date2) => true
    },
    setup(props, _ref) {
      let {
        emit: emit2,
        slots
      } = _ref;
      const daysRef = ref();
      const {
        daysInMonth,
        model,
        weekNumbers
      } = useCalendar(props);
      const adapter = useDate();
      const rangeStart = shallowRef();
      const rangeStop = shallowRef();
      if (props.multiple === "range" && model.value.length > 0) {
        rangeStart.value = model.value[0];
        if (model.value.length > 1) {
          rangeStop.value = model.value[model.value.length - 1];
        }
      }
      const atMax = computed2(() => {
        const max = ["number", "string"].includes(typeof props.multiple) ? Number(props.multiple) : Infinity;
        return model.value.length >= max;
      });
      function onRangeClick(value) {
        const _value = adapter.startOfDay(value);
        if (!rangeStart.value) {
          rangeStart.value = _value;
          model.value = [rangeStart.value];
        } else if (!rangeStop.value) {
          if (adapter.isSameDay(_value, rangeStart.value)) {
            rangeStart.value = void 0;
            model.value = [];
            return;
          } else if (adapter.isBefore(_value, rangeStart.value)) {
            rangeStop.value = adapter.endOfDay(rangeStart.value);
            rangeStart.value = _value;
          } else {
            rangeStop.value = adapter.endOfDay(_value);
          }
          const diff = adapter.getDiff(rangeStop.value, rangeStart.value, "days");
          const datesInRange = [rangeStart.value];
          for (let i = 1; i < diff; i++) {
            const nextDate = adapter.addDays(rangeStart.value, i);
            datesInRange.push(nextDate);
          }
          datesInRange.push(rangeStop.value);
          model.value = datesInRange;
        } else {
          rangeStart.value = value;
          rangeStop.value = void 0;
          model.value = [rangeStart.value];
        }
      }
      function onMultipleClick(value) {
        const index = model.value.findIndex((selection) => adapter.isSameDay(selection, value));
        if (index === -1) {
          model.value = [...model.value, value];
        } else {
          const value2 = [...model.value];
          value2.splice(index, 1);
          model.value = value2;
        }
      }
      function onClick(value) {
        if (props.multiple === "range") {
          onRangeClick(value);
        } else if (props.multiple) {
          onMultipleClick(value);
        } else {
          model.value = [value];
        }
      }
      return () => createVNode("div", {
        "class": "v-date-picker-month"
      }, [props.showWeek && createVNode("div", {
        "key": "weeks",
        "class": "v-date-picker-month__weeks"
      }, [!props.hideWeekdays && createVNode("div", {
        "key": "hide-week-days",
        "class": "v-date-picker-month__day"
      }, [createTextVNode("\xA0")]), weekNumbers.value.map((week) => createVNode("div", {
        "class": ["v-date-picker-month__day", "v-date-picker-month__day--adjacent"]
      }, [week]))]), createVNode("div", {
        "ref": daysRef,
        "class": "v-date-picker-month__days"
      }, [!props.hideWeekdays && adapter.getWeekdays().map((weekDay) => createVNode("div", {
        "class": ["v-date-picker-month__day", "v-date-picker-month__weekday"]
      }, [weekDay])), daysInMonth.value.map((item, i) => {
        const slotProps = {
          props: {
            onClick: () => onClick(item.date)
          },
          item,
          i
        };
        if (atMax.value && !item.isSelected) {
          item.isDisabled = true;
        }
        return createVNode("div", {
          "class": ["v-date-picker-month__day", {
            "v-date-picker-month__day--adjacent": item.isAdjacent,
            "v-date-picker-month__day--hide-adjacent": item.isHidden,
            "v-date-picker-month__day--selected": item.isSelected,
            "v-date-picker-month__day--week-end": item.isWeekEnd,
            "v-date-picker-month__day--week-start": item.isWeekStart
          }],
          "data-v-date": !item.isDisabled ? item.isoDate : void 0
        }, [(props.showAdjacentMonths || !item.isAdjacent) && createVNode(VDefaultsProvider, {
          "defaults": {
            VBtn: {
              class: "v-date-picker-month__day-btn",
              color: (item.isSelected || item.isToday) && !item.isDisabled ? props.color : void 0,
              disabled: item.isDisabled,
              icon: true,
              ripple: false,
              text: item.localized,
              variant: item.isDisabled ? item.isToday ? "outlined" : "text" : item.isToday && !item.isSelected ? "outlined" : "flat",
              onClick: () => onClick(item.date)
            }
          }
        }, {
          default: () => {
            var _a2, _b;
            return [(_b = (_a2 = slots.day) == null ? void 0 : _a2.call(slots, slotProps)) != null ? _b : createVNode(VBtn, slotProps.props, null)];
          }
        })]);
      })])]);
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VDatePicker/VDatePickerMonths.mjs
  var makeVDatePickerMonthsProps = propsFactory({
    color: String,
    height: [String, Number],
    modelValue: Number
  }, "VDatePickerMonths");
  var VDatePickerMonths = genericComponent()({
    name: "VDatePickerMonths",
    props: makeVDatePickerMonthsProps(),
    emits: {
      "update:modelValue": (date2) => true
    },
    setup(props, _ref) {
      let {
        emit: emit2,
        slots
      } = _ref;
      const adapter = useDate();
      const model = useProxiedModel(props, "modelValue");
      const months = computed2(() => {
        let date2 = adapter.startOfYear(adapter.date());
        return createRange(12).map((i) => {
          const text = adapter.format(date2, "monthShort");
          date2 = adapter.getNextMonth(date2);
          return {
            text,
            value: i
          };
        });
      });
      watchEffect(() => {
        var _a2;
        model.value = (_a2 = model.value) != null ? _a2 : adapter.getMonth(adapter.date());
      });
      useRender(() => createVNode("div", {
        "class": "v-date-picker-months",
        "style": {
          height: convertToUnit(props.height)
        }
      }, [createVNode("div", {
        "class": "v-date-picker-months__content"
      }, [months.value.map((month, i) => {
        var _a2, _b;
        const btnProps = {
          active: model.value === i,
          color: model.value === i ? props.color : void 0,
          rounded: true,
          text: month.text,
          variant: model.value === month.value ? "flat" : "text",
          onClick: () => onClick(i)
        };
        function onClick(i2) {
          if (model.value === i2) {
            emit2("update:modelValue", model.value);
            return;
          }
          model.value = i2;
        }
        return (_b = (_a2 = slots.month) == null ? void 0 : _a2.call(slots, {
          month,
          i,
          props: btnProps
        })) != null ? _b : createVNode(VBtn, mergeProps({
          "key": "month"
        }, btnProps), null);
      })])]));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VDatePicker/VDatePickerYears.mjs
  var makeVDatePickerYearsProps = propsFactory({
    color: String,
    height: [String, Number],
    min: null,
    max: null,
    modelValue: Number
  }, "VDatePickerYears");
  var VDatePickerYears = genericComponent()({
    name: "VDatePickerYears",
    props: makeVDatePickerYearsProps(),
    emits: {
      "update:modelValue": (year) => true
    },
    setup(props, _ref) {
      let {
        emit: emit2,
        slots
      } = _ref;
      const adapter = useDate();
      const model = useProxiedModel(props, "modelValue");
      const years = computed2(() => {
        const year = adapter.getYear(adapter.date());
        let min = year - 100;
        let max = year + 52;
        if (props.min) {
          min = adapter.getYear(adapter.date(props.min));
        }
        if (props.max) {
          max = adapter.getYear(adapter.date(props.max));
        }
        let date2 = adapter.startOfYear(adapter.date());
        date2 = adapter.setYear(date2, min);
        return createRange(max - min + 1, min).map((i) => {
          const text = adapter.format(date2, "year");
          date2 = adapter.setYear(date2, adapter.getYear(date2) + 1);
          return {
            text,
            value: i
          };
        });
      });
      watchEffect(() => {
        var _a2;
        model.value = (_a2 = model.value) != null ? _a2 : adapter.getYear(adapter.date());
      });
      const yearRef = ref();
      onMounted(async () => {
        var _a2;
        await nextTick();
        (_a2 = yearRef.value) == null ? void 0 : _a2.$el.scrollIntoView({
          block: "center"
        });
      });
      useRender(() => createVNode("div", {
        "class": "v-date-picker-years",
        "style": {
          height: convertToUnit(props.height)
        }
      }, [createVNode("div", {
        "class": "v-date-picker-years__content"
      }, [years.value.map((year, i) => {
        var _a2, _b;
        const btnProps = {
          ref: model.value === year.value ? yearRef : void 0,
          active: model.value === year.value,
          color: model.value === year.value ? props.color : void 0,
          rounded: true,
          text: year.text,
          variant: model.value === year.value ? "flat" : "text",
          onClick: () => {
            if (model.value === year.value) {
              emit2("update:modelValue", model.value);
              return;
            }
            model.value = year.value;
          }
        };
        return (_b = (_a2 = slots.year) == null ? void 0 : _a2.call(slots, {
          year,
          i,
          props: btnProps
        })) != null ? _b : createVNode(VBtn, mergeProps({
          "key": "month"
        }, btnProps), null);
      })])]));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/labs/VPicker/VPickerTitle.mjs
  var VPickerTitle = createSimpleFunctional("v-picker-title");

  // ../library_management/node_modules/vuetify/lib/labs/VPicker/VPicker.mjs
  var makeVPickerProps = propsFactory(__spreadValues({
    bgColor: String,
    landscape: Boolean,
    title: String,
    hideHeader: Boolean
  }, makeVSheetProps()), "VPicker");
  var VPicker = genericComponent()({
    name: "VPicker",
    props: makeVPickerProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(toRef(props, "color"));
      useRender(() => {
        const sheetProps = VSheet.filterProps(props);
        const hasTitle = !!(props.title || slots.title);
        return createVNode(VSheet, mergeProps(sheetProps, {
          "color": props.bgColor,
          "class": ["v-picker", {
            "v-picker--landscape": props.landscape,
            "v-picker--with-actions": !!slots.actions
          }, props.class],
          "style": props.style
        }), {
          default: () => {
            var _a2;
            return [!props.hideHeader && createVNode("div", {
              "key": "header",
              "class": [backgroundColorClasses.value],
              "style": [backgroundColorStyles.value]
            }, [hasTitle && createVNode(VPickerTitle, {
              "key": "picker-title"
            }, {
              default: () => {
                var _a3, _b;
                return [(_b = (_a3 = slots.title) == null ? void 0 : _a3.call(slots)) != null ? _b : props.title];
              }
            }), slots.header && createVNode("div", {
              "class": "v-picker__header"
            }, [slots.header()])]), createVNode("div", {
              "class": "v-picker__body"
            }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]), slots.actions && createVNode(VDefaultsProvider, {
              "defaults": {
                VBtn: {
                  slim: true,
                  variant: "text"
                }
              }
            }, {
              default: () => [createVNode("div", {
                "class": "v-picker__actions"
              }, [slots.actions()])]
            })];
          }
        });
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VDatePicker/VDatePicker.mjs
  var makeVDatePickerProps = propsFactory(__spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    header: {
      type: String,
      default: "$vuetify.datePicker.header"
    }
  }, makeVDatePickerControlsProps()), makeVDatePickerMonthProps()), omit(makeVDatePickerMonthsProps(), ["modelValue"])), omit(makeVDatePickerYearsProps(), ["modelValue"])), makeVPickerProps({
    title: "$vuetify.datePicker.title"
  })), {
    modelValue: null
  }), "VDatePicker");
  var VDatePicker = genericComponent()({
    name: "VDatePicker",
    props: makeVDatePickerProps(),
    emits: {
      "update:modelValue": (date2) => true,
      "update:month": (date2) => true,
      "update:year": (date2) => true,
      "update:viewMode": (date2) => true
    },
    setup(props, _ref) {
      var _a2, _b;
      let {
        emit: emit2,
        slots
      } = _ref;
      const adapter = useDate();
      const {
        t
      } = useLocale();
      const model = useProxiedModel(props, "modelValue", void 0, (v) => wrapInArray(v), (v) => props.multiple ? v : v[0]);
      const viewMode = useProxiedModel(props, "viewMode");
      const internal = computed2(() => {
        var _a3;
        const value = adapter.date((_a3 = model.value) == null ? void 0 : _a3[0]);
        return value && adapter.isValid(value) ? value : adapter.date();
      });
      const month = ref(Number((_a2 = props.month) != null ? _a2 : adapter.getMonth(adapter.startOfMonth(internal.value))));
      const year = ref(Number((_b = props.year) != null ? _b : adapter.getYear(adapter.startOfYear(adapter.setMonth(internal.value, month.value)))));
      const isReversing = shallowRef(false);
      const header = computed2(() => {
        if (props.multiple && model.value.length > 1) {
          return t("$vuetify.datePicker.itemsSelected", model.value.length);
        }
        return model.value[0] && adapter.isValid(model.value[0]) ? adapter.format(adapter.date(model.value[0]), "normalDateWithWeekday") : t(props.header);
      });
      const text = computed2(() => {
        let date2 = adapter.date();
        date2 = adapter.setYear(date2, year.value);
        date2 = adapter.setMonth(date2, month.value);
        date2 = adapter.setDate(date2, 1);
        return adapter.format(date2, "monthAndYear");
      });
      const headerTransition = computed2(() => `date-picker-header${isReversing.value ? "-reverse" : ""}-transition`);
      const minDate = computed2(() => {
        const date2 = adapter.date(props.min);
        return props.min && adapter.isValid(date2) ? date2 : null;
      });
      const maxDate = computed2(() => {
        const date2 = adapter.date(props.max);
        return props.max && adapter.isValid(date2) ? date2 : null;
      });
      const disabled = computed2(() => {
        if (props.disabled)
          return true;
        const targets = [];
        if (viewMode.value !== "month") {
          targets.push(...["prev", "next"]);
        } else {
          let _date = adapter.date();
          _date = adapter.setYear(_date, year.value);
          _date = adapter.setMonth(_date, month.value);
          if (minDate.value) {
            const date2 = adapter.addDays(adapter.startOfMonth(_date), -1);
            adapter.isAfter(minDate.value, date2) && targets.push("prev");
          }
          if (maxDate.value) {
            const date2 = adapter.addDays(adapter.endOfMonth(_date), 1);
            adapter.isAfter(date2, maxDate.value) && targets.push("next");
          }
        }
        return targets;
      });
      function onClickNext() {
        if (month.value < 11) {
          month.value++;
        } else {
          year.value++;
          month.value = 0;
          onUpdateYear(year.value);
        }
        onUpdateMonth(month.value);
      }
      function onClickPrev() {
        if (month.value > 0) {
          month.value--;
        } else {
          year.value--;
          month.value = 11;
          onUpdateYear(year.value);
        }
        onUpdateMonth(month.value);
      }
      function onClickDate() {
        viewMode.value = "month";
      }
      function onClickMonth() {
        viewMode.value = viewMode.value === "months" ? "month" : "months";
      }
      function onClickYear() {
        viewMode.value = viewMode.value === "year" ? "month" : "year";
      }
      function onUpdateMonth(value) {
        if (viewMode.value === "months")
          onClickMonth();
        emit2("update:month", value);
      }
      function onUpdateYear(value) {
        if (viewMode.value === "year")
          onClickYear();
        emit2("update:year", value);
      }
      watch(model, (val, oldVal) => {
        const before = adapter.date(wrapInArray(val)[0]);
        const after = adapter.date(wrapInArray(oldVal)[0]);
        isReversing.value = adapter.isBefore(before, after);
      });
      useRender(() => {
        const pickerProps = VPicker.filterProps(props);
        const datePickerControlsProps = VDatePickerControls.filterProps(props);
        const datePickerHeaderProps = VDatePickerHeader.filterProps(props);
        const datePickerMonthProps = VDatePickerMonth.filterProps(props);
        const datePickerMonthsProps = omit(VDatePickerMonths.filterProps(props), ["modelValue"]);
        const datePickerYearsProps = omit(VDatePickerYears.filterProps(props), ["modelValue"]);
        const headerProps = {
          header: header.value,
          transition: headerTransition.value
        };
        return createVNode(VPicker, mergeProps(pickerProps, {
          "class": ["v-date-picker", `v-date-picker--${viewMode.value}`, {
            "v-date-picker--show-week": props.showWeek
          }, props.class],
          "style": props.style
        }), {
          title: () => {
            var _a3, _b2;
            return (_b2 = (_a3 = slots.title) == null ? void 0 : _a3.call(slots)) != null ? _b2 : createVNode("div", {
              "class": "v-date-picker__title"
            }, [t(props.title)]);
          },
          header: () => slots.header ? createVNode(VDefaultsProvider, {
            "defaults": {
              VDatePickerHeader: __spreadValues({}, headerProps)
            }
          }, {
            default: () => {
              var _a3;
              return [(_a3 = slots.header) == null ? void 0 : _a3.call(slots, headerProps)];
            }
          }) : createVNode(VDatePickerHeader, mergeProps({
            "key": "header"
          }, datePickerHeaderProps, headerProps, {
            "onClick": viewMode.value !== "month" ? onClickDate : void 0
          }), __spreadProps(__spreadValues({}, slots), {
            default: void 0
          })),
          default: () => createVNode(Fragment, null, [createVNode(VDatePickerControls, mergeProps(datePickerControlsProps, {
            "disabled": disabled.value,
            "text": text.value,
            "onClick:next": onClickNext,
            "onClick:prev": onClickPrev,
            "onClick:month": onClickMonth,
            "onClick:year": onClickYear
          }), null), createVNode(VFadeTransition, {
            "hideOnLeave": true
          }, {
            default: () => [viewMode.value === "months" ? createVNode(VDatePickerMonths, mergeProps({
              "key": "date-picker-months"
            }, datePickerMonthsProps, {
              "modelValue": month.value,
              "onUpdate:modelValue": [($event) => month.value = $event, onUpdateMonth],
              "min": minDate.value,
              "max": maxDate.value
            }), null) : viewMode.value === "year" ? createVNode(VDatePickerYears, mergeProps({
              "key": "date-picker-years"
            }, datePickerYearsProps, {
              "modelValue": year.value,
              "onUpdate:modelValue": [($event) => year.value = $event, onUpdateYear],
              "min": minDate.value,
              "max": maxDate.value
            }), null) : createVNode(VDatePickerMonth, mergeProps({
              "key": "date-picker-month"
            }, datePickerMonthProps, {
              "modelValue": model.value,
              "onUpdate:modelValue": ($event) => model.value = $event,
              "month": month.value,
              "onUpdate:month": [($event) => month.value = $event, onUpdateMonth],
              "year": year.value,
              "onUpdate:year": [($event) => year.value = $event, onUpdateYear],
              "min": minDate.value,
              "max": maxDate.value
            }), null)]
          })]),
          actions: slots.actions
        });
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VExpansionPanel/VExpansionPanels.mjs
  var VExpansionPanelSymbol = Symbol.for("vuetify:v-expansion-panel");
  var allowedVariants3 = ["default", "accordion", "inset", "popout"];
  var makeVExpansionPanelsProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    color: String,
    flat: Boolean,
    focusable: Boolean,
    static: Boolean,
    tile: Boolean,
    variant: {
      type: String,
      default: "default",
      validator: (v) => allowedVariants3.includes(v)
    },
    readonly: Boolean
  }, makeComponentProps()), makeGroupProps()), makeTagProps()), makeThemeProps()), "VExpansionPanels");
  var VExpansionPanels = genericComponent()({
    name: "VExpansionPanels",
    props: makeVExpansionPanelsProps(),
    emits: {
      "update:modelValue": (val) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useGroup(props, VExpansionPanelSymbol);
      const {
        themeClasses
      } = provideTheme(props);
      const variantClass = computed2(() => props.variant && `v-expansion-panels--variant-${props.variant}`);
      provideDefaults({
        VExpansionPanel: {
          color: toRef(props, "color"),
          readonly: toRef(props, "readonly")
        },
        VExpansionPanelTitle: {
          focusable: toRef(props, "focusable"),
          static: toRef(props, "static")
        }
      });
      useRender(() => createVNode(props.tag, {
        "class": ["v-expansion-panels", {
          "v-expansion-panels--flat": props.flat,
          "v-expansion-panels--tile": props.tile
        }, themeClasses.value, variantClass.value, props.class],
        "style": props.style
      }, slots));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VExpansionPanel/VExpansionPanelText.mjs
  var makeVExpansionPanelTextProps = propsFactory(__spreadValues(__spreadValues({}, makeComponentProps()), makeLazyProps()), "VExpansionPanelText");
  var VExpansionPanelText = genericComponent()({
    name: "VExpansionPanelText",
    props: makeVExpansionPanelTextProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const expansionPanel = inject(VExpansionPanelSymbol);
      if (!expansionPanel)
        throw new Error("[Vuetify] v-expansion-panel-text needs to be placed inside v-expansion-panel");
      const {
        hasContent,
        onAfterLeave
      } = useLazy(props, expansionPanel.isSelected);
      useRender(() => createVNode(VExpandTransition, {
        "onAfterLeave": onAfterLeave
      }, {
        default: () => {
          var _a2;
          return [withDirectives(createVNode("div", {
            "class": ["v-expansion-panel-text", props.class],
            "style": props.style
          }, [slots.default && hasContent.value && createVNode("div", {
            "class": "v-expansion-panel-text__wrapper"
          }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)])]), [[vShow, expansionPanel.isSelected.value]])];
        }
      }));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VExpansionPanel/VExpansionPanelTitle.mjs
  var makeVExpansionPanelTitleProps = propsFactory(__spreadValues({
    color: String,
    expandIcon: {
      type: IconValue,
      default: "$expand"
    },
    collapseIcon: {
      type: IconValue,
      default: "$collapse"
    },
    hideActions: Boolean,
    focusable: Boolean,
    static: Boolean,
    ripple: {
      type: [Boolean, Object],
      default: false
    },
    readonly: Boolean
  }, makeComponentProps()), "VExpansionPanelTitle");
  var VExpansionPanelTitle = genericComponent()({
    name: "VExpansionPanelTitle",
    directives: {
      Ripple
    },
    props: makeVExpansionPanelTitleProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const expansionPanel = inject(VExpansionPanelSymbol);
      if (!expansionPanel)
        throw new Error("[Vuetify] v-expansion-panel-title needs to be placed inside v-expansion-panel");
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(props, "color");
      const slotProps = computed2(() => ({
        collapseIcon: props.collapseIcon,
        disabled: expansionPanel.disabled.value,
        expanded: expansionPanel.isSelected.value,
        expandIcon: props.expandIcon,
        readonly: props.readonly
      }));
      useRender(() => {
        var _a2;
        return withDirectives(createVNode("button", {
          "class": ["v-expansion-panel-title", {
            "v-expansion-panel-title--active": expansionPanel.isSelected.value,
            "v-expansion-panel-title--focusable": props.focusable,
            "v-expansion-panel-title--static": props.static
          }, backgroundColorClasses.value, props.class],
          "style": [backgroundColorStyles.value, props.style],
          "type": "button",
          "tabindex": expansionPanel.disabled.value ? -1 : void 0,
          "disabled": expansionPanel.disabled.value,
          "aria-expanded": expansionPanel.isSelected.value,
          "onClick": !props.readonly ? expansionPanel.toggle : void 0
        }, [createVNode("span", {
          "class": "v-expansion-panel-title__overlay"
        }, null), (_a2 = slots.default) == null ? void 0 : _a2.call(slots, slotProps.value), !props.hideActions && createVNode("span", {
          "class": "v-expansion-panel-title__icon"
        }, [slots.actions ? slots.actions(slotProps.value) : createVNode(VIcon, {
          "icon": expansionPanel.isSelected.value ? props.collapseIcon : props.expandIcon
        }, null)])]), [[resolveDirective("ripple"), props.ripple]]);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VExpansionPanel/VExpansionPanel.mjs
  var makeVExpansionPanelProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    title: String,
    text: String,
    bgColor: String
  }, makeComponentProps()), makeElevationProps()), makeGroupItemProps()), makeLazyProps()), makeRoundedProps()), makeTagProps()), makeVExpansionPanelTitleProps()), "VExpansionPanel");
  var VExpansionPanel = genericComponent()({
    name: "VExpansionPanel",
    props: makeVExpansionPanelProps(),
    emits: {
      "group:selected": (val) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const groupItem = useGroupItem(props, VExpansionPanelSymbol);
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(props, "bgColor");
      const {
        elevationClasses
      } = useElevation(props);
      const {
        roundedClasses
      } = useRounded(props);
      const isDisabled = computed2(() => (groupItem == null ? void 0 : groupItem.disabled.value) || props.disabled);
      const selectedIndices = computed2(() => groupItem.group.items.value.reduce((arr, item, index) => {
        if (groupItem.group.selected.value.includes(item.id))
          arr.push(index);
        return arr;
      }, []));
      const isBeforeSelected = computed2(() => {
        const index = groupItem.group.items.value.findIndex((item) => item.id === groupItem.id);
        return !groupItem.isSelected.value && selectedIndices.value.some((selectedIndex) => selectedIndex - index === 1);
      });
      const isAfterSelected = computed2(() => {
        const index = groupItem.group.items.value.findIndex((item) => item.id === groupItem.id);
        return !groupItem.isSelected.value && selectedIndices.value.some((selectedIndex) => selectedIndex - index === -1);
      });
      provide(VExpansionPanelSymbol, groupItem);
      provideDefaults({
        VExpansionPanelText: {
          eager: toRef(props, "eager")
        },
        VExpansionPanelTitle: {
          readonly: toRef(props, "readonly")
        }
      });
      useRender(() => {
        const hasText = !!(slots.text || props.text);
        const hasTitle = !!(slots.title || props.title);
        return createVNode(props.tag, {
          "class": ["v-expansion-panel", {
            "v-expansion-panel--active": groupItem.isSelected.value,
            "v-expansion-panel--before-active": isBeforeSelected.value,
            "v-expansion-panel--after-active": isAfterSelected.value,
            "v-expansion-panel--disabled": isDisabled.value
          }, roundedClasses.value, backgroundColorClasses.value, props.class],
          "style": [backgroundColorStyles.value, props.style]
        }, {
          default: () => {
            var _a2;
            return [createVNode("div", {
              "class": ["v-expansion-panel__shadow", ...elevationClasses.value]
            }, null), hasTitle && createVNode(VExpansionPanelTitle, {
              "key": "title",
              "collapseIcon": props.collapseIcon,
              "color": props.color,
              "expandIcon": props.expandIcon,
              "hideActions": props.hideActions,
              "ripple": props.ripple
            }, {
              default: () => [slots.title ? slots.title() : props.title]
            }), hasText && createVNode(VExpansionPanelText, {
              "key": "text"
            }, {
              default: () => [slots.text ? slots.text() : props.text]
            }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots)];
          }
        });
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VFileInput/VFileInput.mjs
  var makeVFileInputProps = propsFactory(__spreadValues(__spreadProps(__spreadValues({
    chips: Boolean,
    counter: Boolean,
    counterSizeString: {
      type: String,
      default: "$vuetify.fileInput.counterSize"
    },
    counterString: {
      type: String,
      default: "$vuetify.fileInput.counter"
    },
    multiple: Boolean,
    showSize: {
      type: [Boolean, Number, String],
      default: false,
      validator: (v) => {
        return typeof v === "boolean" || [1e3, 1024].includes(Number(v));
      }
    }
  }, makeVInputProps({
    prependIcon: "$file"
  })), {
    modelValue: {
      type: [Array, Object],
      default: () => [],
      validator: (val) => {
        return wrapInArray(val).every((v) => v != null && typeof v === "object");
      }
    }
  }), makeVFieldProps({
    clearable: true
  })), "VFileInput");
  var VFileInput = genericComponent()({
    name: "VFileInput",
    inheritAttrs: false,
    props: makeVFileInputProps(),
    emits: {
      "click:control": (e) => true,
      "mousedown:control": (e) => true,
      "update:focused": (focused) => true,
      "update:modelValue": (files) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        emit: emit2,
        slots
      } = _ref;
      const {
        t
      } = useLocale();
      const model = useProxiedModel(props, "modelValue", props.modelValue, (val) => wrapInArray(val), (val) => props.multiple || Array.isArray(props.modelValue) ? val : val[0]);
      const {
        isFocused,
        focus,
        blur
      } = useFocus(props);
      const base = computed2(() => typeof props.showSize !== "boolean" ? props.showSize : void 0);
      const totalBytes = computed2(() => {
        var _a2;
        return ((_a2 = model.value) != null ? _a2 : []).reduce((bytes, _ref2) => {
          let {
            size: size2 = 0
          } = _ref2;
          return bytes + size2;
        }, 0);
      });
      const totalBytesReadable = computed2(() => humanReadableFileSize(totalBytes.value, base.value));
      const fileNames = computed2(() => {
        var _a2;
        return ((_a2 = model.value) != null ? _a2 : []).map((file) => {
          const {
            name = "",
            size: size2 = 0
          } = file;
          return !props.showSize ? name : `${name} (${humanReadableFileSize(size2, base.value)})`;
        });
      });
      const counterValue = computed2(() => {
        var _a2, _b;
        const fileCount = (_b = (_a2 = model.value) == null ? void 0 : _a2.length) != null ? _b : 0;
        if (props.showSize)
          return t(props.counterSizeString, fileCount, totalBytesReadable.value);
        else
          return t(props.counterString, fileCount);
      });
      const vInputRef = ref();
      const vFieldRef = ref();
      const inputRef = ref();
      const isActive = computed2(() => isFocused.value || props.active);
      const isPlainOrUnderlined = computed2(() => ["plain", "underlined"].includes(props.variant));
      function onFocus() {
        var _a2;
        if (inputRef.value !== document.activeElement) {
          (_a2 = inputRef.value) == null ? void 0 : _a2.focus();
        }
        if (!isFocused.value)
          focus();
      }
      function onClickPrepend(e) {
        var _a2;
        (_a2 = inputRef.value) == null ? void 0 : _a2.click();
      }
      function onControlMousedown(e) {
        emit2("mousedown:control", e);
      }
      function onControlClick(e) {
        var _a2;
        (_a2 = inputRef.value) == null ? void 0 : _a2.click();
        emit2("click:control", e);
      }
      function onClear(e) {
        e.stopPropagation();
        onFocus();
        nextTick(() => {
          model.value = [];
          callEvent(props["onClick:clear"], e);
        });
      }
      watch(model, (newValue) => {
        const hasModelReset = !Array.isArray(newValue) || !newValue.length;
        if (hasModelReset && inputRef.value) {
          inputRef.value.value = "";
        }
      });
      useRender(() => {
        const hasCounter = !!(slots.counter || props.counter);
        const hasDetails = !!(hasCounter || slots.details);
        const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
        const _a2 = VInput.filterProps(props), {
          modelValue: _
        } = _a2, inputProps = __objRest(_a2, [
          "modelValue"
        ]);
        const fieldProps = filterFieldProps(props);
        return createVNode(VInput, mergeProps({
          "ref": vInputRef,
          "modelValue": model.value,
          "onUpdate:modelValue": ($event) => model.value = $event,
          "class": ["v-file-input", {
            "v-file-input--chips": !!props.chips,
            "v-input--plain-underlined": isPlainOrUnderlined.value
          }, props.class],
          "style": props.style,
          "onClick:prepend": onClickPrepend
        }, rootAttrs, inputProps, {
          "centerAffix": !isPlainOrUnderlined.value,
          "focused": isFocused.value
        }), __spreadProps(__spreadValues({}, slots), {
          default: (_ref3) => {
            let {
              id,
              isDisabled,
              isDirty,
              isReadonly: isReadonly2,
              isValid: isValid2
            } = _ref3;
            return createVNode(VField, mergeProps({
              "ref": vFieldRef,
              "prepend-icon": props.prependIcon,
              "onMousedown": onControlMousedown,
              "onClick": onControlClick,
              "onClick:clear": onClear,
              "onClick:prependInner": props["onClick:prependInner"],
              "onClick:appendInner": props["onClick:appendInner"]
            }, fieldProps, {
              "id": id.value,
              "active": isActive.value || isDirty.value,
              "dirty": isDirty.value,
              "disabled": isDisabled.value,
              "focused": isFocused.value,
              "error": isValid2.value === false
            }), __spreadProps(__spreadValues({}, slots), {
              default: (_ref4) => {
                var _c;
                let {
                  props: _a3
                } = _ref4, _b = _a3, {
                  class: fieldClass
                } = _b, slotProps = __objRest(_b, [
                  "class"
                ]);
                return createVNode(Fragment, null, [createVNode("input", mergeProps({
                  "ref": inputRef,
                  "type": "file",
                  "readonly": isReadonly2.value,
                  "disabled": isDisabled.value,
                  "multiple": props.multiple,
                  "name": props.name,
                  "onClick": (e) => {
                    e.stopPropagation();
                    if (isReadonly2.value)
                      e.preventDefault();
                    onFocus();
                  },
                  "onChange": (e) => {
                    var _a4;
                    if (!e.target)
                      return;
                    const target = e.target;
                    model.value = [...(_a4 = target.files) != null ? _a4 : []];
                  },
                  "onFocus": onFocus,
                  "onBlur": blur
                }, slotProps, inputAttrs), null), createVNode("div", {
                  "class": fieldClass
                }, [!!((_c = model.value) == null ? void 0 : _c.length) && (slots.selection ? slots.selection({
                  fileNames: fileNames.value,
                  totalBytes: totalBytes.value,
                  totalBytesReadable: totalBytesReadable.value
                }) : props.chips ? fileNames.value.map((text) => createVNode(VChip, {
                  "key": text,
                  "size": "small",
                  "color": props.color
                }, {
                  default: () => [text]
                })) : fileNames.value.join(", "))])]);
              }
            }));
          },
          details: hasDetails ? (slotProps) => {
            var _a3, _b;
            return createVNode(Fragment, null, [(_a3 = slots.details) == null ? void 0 : _a3.call(slots, slotProps), hasCounter && createVNode(Fragment, null, [createVNode("span", null, null), createVNode(VCounter, {
              "active": !!((_b = model.value) == null ? void 0 : _b.length),
              "value": counterValue.value
            }, slots.counter)])]);
          } : void 0
        }));
      });
      return forwardRefs({}, vInputRef, vFieldRef, inputRef);
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VFooter/VFooter.mjs
  var makeVFooterProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    app: Boolean,
    color: String,
    height: {
      type: [Number, String],
      default: "auto"
    }
  }, makeBorderProps()), makeComponentProps()), makeElevationProps()), makeLayoutItemProps()), makeRoundedProps()), makeTagProps({
    tag: "footer"
  })), makeThemeProps()), "VFooter");
  var VFooter = genericComponent()({
    name: "VFooter",
    props: makeVFooterProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(toRef(props, "color"));
      const {
        borderClasses
      } = useBorder(props);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        roundedClasses
      } = useRounded(props);
      const autoHeight = shallowRef(32);
      const {
        resizeRef
      } = useResizeObserver((entries) => {
        if (!entries.length)
          return;
        autoHeight.value = entries[0].target.clientHeight;
      });
      const height = computed2(() => props.height === "auto" ? autoHeight.value : parseInt(props.height, 10));
      const {
        layoutItemStyles
      } = useLayoutItem({
        id: props.name,
        order: computed2(() => parseInt(props.order, 10)),
        position: computed2(() => "bottom"),
        layoutSize: height,
        elementSize: computed2(() => props.height === "auto" ? void 0 : height.value),
        active: computed2(() => props.app),
        absolute: toRef(props, "absolute")
      });
      useRender(() => createVNode(props.tag, {
        "ref": resizeRef,
        "class": ["v-footer", themeClasses.value, backgroundColorClasses.value, borderClasses.value, elevationClasses.value, roundedClasses.value, props.class],
        "style": [backgroundColorStyles.value, props.app ? layoutItemStyles.value : {
          height: convertToUnit(props.height)
        }, props.style]
      }, slots));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VForm/VForm.mjs
  var makeVFormProps = propsFactory(__spreadValues(__spreadValues({}, makeComponentProps()), makeFormProps()), "VForm");
  var VForm = genericComponent()({
    name: "VForm",
    props: makeVFormProps(),
    emits: {
      "update:modelValue": (val) => true,
      submit: (e) => true
    },
    setup(props, _ref) {
      let {
        slots,
        emit: emit2
      } = _ref;
      const form = createForm(props);
      const formRef = ref();
      function onReset(e) {
        e.preventDefault();
        form.reset();
      }
      function onSubmit(_e) {
        const e = _e;
        const ready = form.validate();
        e.then = ready.then.bind(ready);
        e.catch = ready.catch.bind(ready);
        e.finally = ready.finally.bind(ready);
        emit2("submit", e);
        if (!e.defaultPrevented) {
          ready.then((_ref2) => {
            var _a2;
            let {
              valid
            } = _ref2;
            if (valid) {
              (_a2 = formRef.value) == null ? void 0 : _a2.submit();
            }
          });
        }
        e.preventDefault();
      }
      useRender(() => {
        var _a2;
        return createVNode("form", {
          "ref": formRef,
          "class": ["v-form", props.class],
          "style": props.style,
          "novalidate": true,
          "onReset": onReset,
          "onSubmit": onSubmit
        }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, form)]);
      });
      return forwardRefs(form, formRef);
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VHover/VHover.mjs
  var makeVHoverProps = propsFactory(__spreadValues({
    disabled: Boolean,
    modelValue: {
      type: Boolean,
      default: void 0
    }
  }, makeDelayProps()), "VHover");
  var VHover = genericComponent()({
    name: "VHover",
    props: makeVHoverProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const isHovering = useProxiedModel(props, "modelValue");
      const {
        runOpenDelay,
        runCloseDelay
      } = useDelay(props, (value) => !props.disabled && (isHovering.value = value));
      return () => {
        var _a2;
        return (_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
          isHovering: isHovering.value,
          props: {
            onMouseenter: runOpenDelay,
            onMouseleave: runCloseDelay
          }
        });
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VInfiniteScroll/VInfiniteScroll.mjs
  var makeVInfiniteScrollProps = propsFactory(__spreadValues(__spreadValues({
    color: String,
    direction: {
      type: String,
      default: "vertical",
      validator: (v) => ["vertical", "horizontal"].includes(v)
    },
    side: {
      type: String,
      default: "end",
      validator: (v) => ["start", "end", "both"].includes(v)
    },
    mode: {
      type: String,
      default: "intersect",
      validator: (v) => ["intersect", "manual"].includes(v)
    },
    margin: [Number, String],
    loadMoreText: {
      type: String,
      default: "$vuetify.infiniteScroll.loadMore"
    },
    emptyText: {
      type: String,
      default: "$vuetify.infiniteScroll.empty"
    }
  }, makeDimensionProps()), makeTagProps()), "VInfiniteScroll");
  var VInfiniteScrollIntersect = defineComponent2({
    name: "VInfiniteScrollIntersect",
    props: {
      side: {
        type: String,
        required: true
      },
      rootRef: null,
      rootMargin: String
    },
    emits: {
      intersect: (side, isIntersecting) => true
    },
    setup(props, _ref) {
      let {
        emit: emit2
      } = _ref;
      const {
        intersectionRef,
        isIntersecting
      } = useIntersectionObserver((entries) => {
      }, props.rootMargin ? {
        rootMargin: props.rootMargin
      } : void 0);
      watch(isIntersecting, async (val) => {
        emit2("intersect", props.side, val);
      });
      useRender(() => createVNode("div", {
        "class": "v-infinite-scroll-intersect",
        "ref": intersectionRef
      }, [createTextVNode("\xA0")]));
      return {};
    }
  });
  var VInfiniteScroll = genericComponent()({
    name: "VInfiniteScroll",
    props: makeVInfiniteScrollProps(),
    emits: {
      load: (options) => true
    },
    setup(props, _ref2) {
      let {
        slots,
        emit: emit2
      } = _ref2;
      const rootEl = ref();
      const startStatus = shallowRef("ok");
      const endStatus = shallowRef("ok");
      const margin = computed2(() => convertToUnit(props.margin));
      const isIntersecting = shallowRef(false);
      function setScrollAmount(amount) {
        if (!rootEl.value)
          return;
        const property = props.direction === "vertical" ? "scrollTop" : "scrollLeft";
        rootEl.value[property] = amount;
      }
      function getScrollAmount() {
        if (!rootEl.value)
          return 0;
        const property = props.direction === "vertical" ? "scrollTop" : "scrollLeft";
        return rootEl.value[property];
      }
      function getScrollSize() {
        if (!rootEl.value)
          return 0;
        const property = props.direction === "vertical" ? "scrollHeight" : "scrollWidth";
        return rootEl.value[property];
      }
      function getContainerSize() {
        if (!rootEl.value)
          return 0;
        const property = props.direction === "vertical" ? "clientHeight" : "clientWidth";
        return rootEl.value[property];
      }
      onMounted(() => {
        if (!rootEl.value)
          return;
        if (props.side === "start") {
          setScrollAmount(getScrollSize());
        } else if (props.side === "both") {
          setScrollAmount(getScrollSize() / 2 - getContainerSize() / 2);
        }
      });
      function setStatus(side, status) {
        if (side === "start") {
          startStatus.value = status;
        } else if (side === "end") {
          endStatus.value = status;
        }
      }
      function getStatus(side) {
        return side === "start" ? startStatus.value : endStatus.value;
      }
      let previousScrollSize = 0;
      function handleIntersect(side, _isIntersecting) {
        isIntersecting.value = _isIntersecting;
        if (isIntersecting.value) {
          intersecting(side);
        }
      }
      function intersecting(side) {
        if (props.mode !== "manual" && !isIntersecting.value)
          return;
        const status = getStatus(side);
        if (!rootEl.value || status === "loading")
          return;
        previousScrollSize = getScrollSize();
        setStatus(side, "loading");
        function done(status2) {
          setStatus(side, status2);
          nextTick(() => {
            if (status2 === "empty" || status2 === "error")
              return;
            if (status2 === "ok" && side === "start") {
              setScrollAmount(getScrollSize() - previousScrollSize + getScrollAmount());
            }
            if (props.mode !== "manual") {
              nextTick(() => {
                window.requestAnimationFrame(() => {
                  window.requestAnimationFrame(() => {
                    window.requestAnimationFrame(() => {
                      intersecting(side);
                    });
                  });
                });
              });
            }
          });
        }
        emit2("load", {
          side,
          done
        });
      }
      const {
        t
      } = useLocale();
      function renderSide(side, status) {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _i;
        if (props.side !== side && props.side !== "both")
          return;
        const onClick = () => intersecting(side);
        const slotProps = {
          side,
          props: {
            onClick,
            color: props.color
          }
        };
        if (status === "error")
          return (_a2 = slots.error) == null ? void 0 : _a2.call(slots, slotProps);
        if (status === "empty")
          return (_c = (_b = slots.empty) == null ? void 0 : _b.call(slots, slotProps)) != null ? _c : createVNode("div", null, [t(props.emptyText)]);
        if (props.mode === "manual") {
          if (status === "loading") {
            return (_e = (_d = slots.loading) == null ? void 0 : _d.call(slots, slotProps)) != null ? _e : createVNode(VProgressCircular, {
              "indeterminate": true,
              "color": props.color
            }, null);
          }
          return (_g = (_f = slots["load-more"]) == null ? void 0 : _f.call(slots, slotProps)) != null ? _g : createVNode(VBtn, {
            "variant": "outlined",
            "color": props.color,
            "onClick": onClick
          }, {
            default: () => [t(props.loadMoreText)]
          });
        }
        return (_i = (_h = slots.loading) == null ? void 0 : _h.call(slots, slotProps)) != null ? _i : createVNode(VProgressCircular, {
          "indeterminate": true,
          "color": props.color
        }, null);
      }
      const {
        dimensionStyles
      } = useDimension(props);
      useRender(() => {
        const Tag = props.tag;
        const hasStartIntersect = props.side === "start" || props.side === "both";
        const hasEndIntersect = props.side === "end" || props.side === "both";
        const intersectMode = props.mode === "intersect";
        return createVNode(Tag, {
          "ref": rootEl,
          "class": ["v-infinite-scroll", `v-infinite-scroll--${props.direction}`, {
            "v-infinite-scroll--start": hasStartIntersect,
            "v-infinite-scroll--end": hasEndIntersect
          }],
          "style": dimensionStyles.value
        }, {
          default: () => {
            var _a2;
            return [createVNode("div", {
              "class": "v-infinite-scroll__side"
            }, [renderSide("start", startStatus.value)]), rootEl.value && hasStartIntersect && intersectMode && createVNode(VInfiniteScrollIntersect, {
              "key": "start",
              "side": "start",
              "onIntersect": handleIntersect,
              "rootRef": rootEl.value,
              "rootMargin": margin.value
            }, null), (_a2 = slots.default) == null ? void 0 : _a2.call(slots), rootEl.value && hasEndIntersect && intersectMode && createVNode(VInfiniteScrollIntersect, {
              "key": "end",
              "side": "end",
              "onIntersect": handleIntersect,
              "rootRef": rootEl.value,
              "rootMargin": margin.value
            }, null), createVNode("div", {
              "class": "v-infinite-scroll__side"
            }, [renderSide("end", endStatus.value)])];
          }
        });
      });
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VItemGroup/VItemGroup.mjs
  var VItemGroupSymbol = Symbol.for("vuetify:v-item-group");
  var makeVItemGroupProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, makeComponentProps()), makeGroupProps({
    selectedClass: "v-item--selected"
  })), makeTagProps()), makeThemeProps()), "VItemGroup");
  var VItemGroup = genericComponent()({
    name: "VItemGroup",
    props: makeVItemGroupProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      const {
        isSelected,
        select,
        next,
        prev,
        selected
      } = useGroup(props, VItemGroupSymbol);
      return () => createVNode(props.tag, {
        "class": ["v-item-group", themeClasses.value, props.class],
        "style": props.style
      }, {
        default: () => {
          var _a2;
          return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
            isSelected,
            select,
            next,
            prev,
            selected: selected.value
          })];
        }
      });
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VItemGroup/VItem.mjs
  var VItem = genericComponent()({
    name: "VItem",
    props: makeGroupItemProps(),
    emits: {
      "group:selected": (val) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        isSelected,
        select,
        toggle,
        selectedClass,
        value,
        disabled
      } = useGroupItem(props, VItemGroupSymbol);
      return () => {
        var _a2;
        return (_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
          isSelected: isSelected.value,
          selectedClass: selectedClass.value,
          select,
          toggle,
          value: value.value,
          disabled: disabled.value
        });
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VKbd/index.mjs
  var VKbd = createSimpleFunctional("v-kbd");

  // ../library_management/node_modules/vuetify/lib/components/VLayout/VLayout.mjs
  var makeVLayoutProps = propsFactory(__spreadValues(__spreadValues({}, makeComponentProps()), makeLayoutProps()), "VLayout");
  var VLayout = genericComponent()({
    name: "VLayout",
    props: makeVLayoutProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        layoutClasses,
        layoutStyles,
        getLayoutItem,
        items,
        layoutRef
      } = createLayout(props);
      useRender(() => {
        var _a2;
        return createVNode("div", {
          "ref": layoutRef,
          "class": [layoutClasses.value, props.class],
          "style": [layoutStyles.value, props.style]
        }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
      });
      return {
        getLayoutItem,
        items
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VLayout/VLayoutItem.mjs
  var makeVLayoutItemProps = propsFactory(__spreadValues(__spreadValues({
    position: {
      type: String,
      required: true
    },
    size: {
      type: [Number, String],
      default: 300
    },
    modelValue: Boolean
  }, makeComponentProps()), makeLayoutItemProps()), "VLayoutItem");
  var VLayoutItem = genericComponent()({
    name: "VLayoutItem",
    props: makeVLayoutItemProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        layoutItemStyles
      } = useLayoutItem({
        id: props.name,
        order: computed2(() => parseInt(props.order, 10)),
        position: toRef(props, "position"),
        elementSize: toRef(props, "size"),
        layoutSize: toRef(props, "size"),
        active: toRef(props, "modelValue"),
        absolute: toRef(props, "absolute")
      });
      return () => {
        var _a2;
        return createVNode("div", {
          "class": ["v-layout-item", props.class],
          "style": [layoutItemStyles.value, props.style]
        }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VLazy/VLazy.mjs
  var makeVLazyProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    modelValue: Boolean,
    options: {
      type: Object,
      default: () => ({
        root: void 0,
        rootMargin: void 0,
        threshold: void 0
      })
    }
  }, makeComponentProps()), makeDimensionProps()), makeTagProps()), makeTransitionProps2({
    transition: "fade-transition"
  })), "VLazy");
  var VLazy = genericComponent()({
    name: "VLazy",
    directives: {
      intersect: intersect_default
    },
    props: makeVLazyProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        dimensionStyles
      } = useDimension(props);
      const isActive = useProxiedModel(props, "modelValue");
      function onIntersect(isIntersecting) {
        if (isActive.value)
          return;
        isActive.value = isIntersecting;
      }
      useRender(() => withDirectives(createVNode(props.tag, {
        "class": ["v-lazy", props.class],
        "style": [dimensionStyles.value, props.style]
      }, {
        default: () => [isActive.value && createVNode(MaybeTransition, {
          "transition": props.transition,
          "appear": true
        }, {
          default: () => {
            var _a2;
            return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)];
          }
        })]
      }), [[resolveDirective("intersect"), {
        handler: onIntersect,
        options: props.options
      }, null]]));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VLocaleProvider/VLocaleProvider.mjs
  var makeVLocaleProviderProps = propsFactory(__spreadValues({
    locale: String,
    fallbackLocale: String,
    messages: Object,
    rtl: {
      type: Boolean,
      default: void 0
    }
  }, makeComponentProps()), "VLocaleProvider");
  var VLocaleProvider = genericComponent()({
    name: "VLocaleProvider",
    props: makeVLocaleProviderProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        rtlClasses
      } = provideLocale(props);
      useRender(() => {
        var _a2;
        return createVNode("div", {
          "class": ["v-locale-provider", rtlClasses.value, props.class],
          "style": props.style
        }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VMain/VMain.mjs
  var makeVMainProps = propsFactory(__spreadValues(__spreadValues({
    scrollable: Boolean
  }, makeComponentProps()), makeTagProps({
    tag: "main"
  })), "VMain");
  var VMain = genericComponent()({
    name: "VMain",
    props: makeVMainProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        mainStyles
      } = useLayout();
      const {
        ssrBootStyles
      } = useSsrBoot();
      useRender(() => createVNode(props.tag, {
        "class": ["v-main", {
          "v-main--scrollable": props.scrollable
        }, props.class],
        "style": [mainStyles.value, ssrBootStyles.value, props.style]
      }, {
        default: () => {
          var _a2, _b;
          return [props.scrollable ? createVNode("div", {
            "class": "v-main__scroller"
          }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]) : (_b = slots.default) == null ? void 0 : _b.call(slots)];
        }
      }));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VNavigationDrawer/sticky.mjs
  function useSticky(_ref) {
    let {
      rootEl,
      isSticky,
      layoutItemStyles
    } = _ref;
    const isStuck = shallowRef(false);
    const stuckPosition = shallowRef(0);
    const stickyStyles = computed2(() => {
      const side = typeof isStuck.value === "boolean" ? "top" : isStuck.value;
      return [isSticky.value ? {
        top: "auto",
        bottom: "auto",
        height: void 0
      } : void 0, isStuck.value ? {
        [side]: convertToUnit(stuckPosition.value)
      } : {
        top: layoutItemStyles.value.top
      }];
    });
    onMounted(() => {
      watch(isSticky, (val) => {
        if (val) {
          window.addEventListener("scroll", onScroll, {
            passive: true
          });
        } else {
          window.removeEventListener("scroll", onScroll);
        }
      }, {
        immediate: true
      });
    });
    onBeforeUnmount(() => {
      window.removeEventListener("scroll", onScroll);
    });
    let lastScrollTop = 0;
    function onScroll() {
      var _a2;
      const direction = lastScrollTop > window.scrollY ? "up" : "down";
      const rect = rootEl.value.getBoundingClientRect();
      const layoutTop = parseFloat((_a2 = layoutItemStyles.value.top) != null ? _a2 : 0);
      const top = window.scrollY - Math.max(0, stuckPosition.value - layoutTop);
      const bottom = rect.height + Math.max(stuckPosition.value, layoutTop) - window.scrollY - window.innerHeight;
      const bodyScroll = parseFloat(getComputedStyle(rootEl.value).getPropertyValue("--v-body-scroll-y")) || 0;
      if (rect.height < window.innerHeight - layoutTop) {
        isStuck.value = "top";
        stuckPosition.value = layoutTop;
      } else if (direction === "up" && isStuck.value === "bottom" || direction === "down" && isStuck.value === "top") {
        stuckPosition.value = window.scrollY + rect.top - bodyScroll;
        isStuck.value = true;
      } else if (direction === "down" && bottom <= 0) {
        stuckPosition.value = 0;
        isStuck.value = "bottom";
      } else if (direction === "up" && top <= 0) {
        if (!bodyScroll) {
          stuckPosition.value = rect.top + top;
          isStuck.value = "top";
        } else if (isStuck.value !== "top") {
          stuckPosition.value = -top + bodyScroll + layoutTop;
          isStuck.value = "top";
        }
      }
      lastScrollTop = window.scrollY;
    }
    return {
      isStuck,
      stickyStyles
    };
  }

  // ../library_management/node_modules/vuetify/lib/composables/touch.mjs
  var HORIZON = 100;
  var HISTORY = 20;
  function kineticEnergyToVelocity(work) {
    const sqrt2 = 1.41421356237;
    return (work < 0 ? -1 : 1) * Math.sqrt(Math.abs(work)) * sqrt2;
  }
  function calculateImpulseVelocity(samples) {
    if (samples.length < 2) {
      return 0;
    }
    if (samples.length === 2) {
      if (samples[1].t === samples[0].t) {
        return 0;
      }
      return (samples[1].d - samples[0].d) / (samples[1].t - samples[0].t);
    }
    let work = 0;
    for (let i = samples.length - 1; i > 0; i--) {
      if (samples[i].t === samples[i - 1].t) {
        continue;
      }
      const vprev = kineticEnergyToVelocity(work);
      const vcurr = (samples[i].d - samples[i - 1].d) / (samples[i].t - samples[i - 1].t);
      work += (vcurr - vprev) * Math.abs(vcurr);
      if (i === samples.length - 1) {
        work *= 0.5;
      }
    }
    return kineticEnergyToVelocity(work) * 1e3;
  }
  function useVelocity() {
    const touches = {};
    function addMovement(e) {
      Array.from(e.changedTouches).forEach((touch) => {
        var _a2;
        const samples = (_a2 = touches[touch.identifier]) != null ? _a2 : touches[touch.identifier] = new CircularBuffer(HISTORY);
        samples.push([e.timeStamp, touch]);
      });
    }
    function endTouch(e) {
      Array.from(e.changedTouches).forEach((touch) => {
        delete touches[touch.identifier];
      });
    }
    function getVelocity(id) {
      var _a2;
      const samples = (_a2 = touches[id]) == null ? void 0 : _a2.values().reverse();
      if (!samples) {
        throw new Error(`No samples for touch id ${id}`);
      }
      const newest = samples[0];
      const x = [];
      const y = [];
      for (const val of samples) {
        if (newest[0] - val[0] > HORIZON)
          break;
        x.push({
          t: val[0],
          d: val[1].clientX
        });
        y.push({
          t: val[0],
          d: val[1].clientY
        });
      }
      return {
        x: calculateImpulseVelocity(x),
        y: calculateImpulseVelocity(y),
        get direction() {
          const {
            x: x2,
            y: y2
          } = this;
          const [absX, absY] = [Math.abs(x2), Math.abs(y2)];
          return absX > absY && x2 >= 0 ? "right" : absX > absY && x2 <= 0 ? "left" : absY > absX && y2 >= 0 ? "down" : absY > absX && y2 <= 0 ? "up" : oops();
        }
      };
    }
    return {
      addMovement,
      endTouch,
      getVelocity
    };
  }
  function oops() {
    throw new Error();
  }

  // ../library_management/node_modules/vuetify/lib/components/VNavigationDrawer/touch.mjs
  function useTouch(_ref) {
    let {
      isActive,
      isTemporary,
      width,
      touchless,
      position
    } = _ref;
    onMounted(() => {
      window.addEventListener("touchstart", onTouchstart, {
        passive: true
      });
      window.addEventListener("touchmove", onTouchmove, {
        passive: false
      });
      window.addEventListener("touchend", onTouchend, {
        passive: true
      });
    });
    onBeforeUnmount(() => {
      window.removeEventListener("touchstart", onTouchstart);
      window.removeEventListener("touchmove", onTouchmove);
      window.removeEventListener("touchend", onTouchend);
    });
    const isHorizontal = computed2(() => ["left", "right"].includes(position.value));
    const {
      addMovement,
      endTouch,
      getVelocity
    } = useVelocity();
    let maybeDragging = false;
    const isDragging = shallowRef(false);
    const dragProgress = shallowRef(0);
    const offset = shallowRef(0);
    let start;
    function getOffset3(pos, active) {
      return (position.value === "left" ? pos : position.value === "right" ? document.documentElement.clientWidth - pos : position.value === "top" ? pos : position.value === "bottom" ? document.documentElement.clientHeight - pos : oops2()) - (active ? width.value : 0);
    }
    function getProgress(pos) {
      let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      const progress = position.value === "left" ? (pos - offset.value) / width.value : position.value === "right" ? (document.documentElement.clientWidth - pos - offset.value) / width.value : position.value === "top" ? (pos - offset.value) / width.value : position.value === "bottom" ? (document.documentElement.clientHeight - pos - offset.value) / width.value : oops2();
      return limit ? Math.max(0, Math.min(1, progress)) : progress;
    }
    function onTouchstart(e) {
      if (touchless.value)
        return;
      const touchX = e.changedTouches[0].clientX;
      const touchY = e.changedTouches[0].clientY;
      const touchZone = 25;
      const inTouchZone = position.value === "left" ? touchX < touchZone : position.value === "right" ? touchX > document.documentElement.clientWidth - touchZone : position.value === "top" ? touchY < touchZone : position.value === "bottom" ? touchY > document.documentElement.clientHeight - touchZone : oops2();
      const inElement = isActive.value && (position.value === "left" ? touchX < width.value : position.value === "right" ? touchX > document.documentElement.clientWidth - width.value : position.value === "top" ? touchY < width.value : position.value === "bottom" ? touchY > document.documentElement.clientHeight - width.value : oops2());
      if (inTouchZone || inElement || isActive.value && isTemporary.value) {
        maybeDragging = true;
        start = [touchX, touchY];
        offset.value = getOffset3(isHorizontal.value ? touchX : touchY, isActive.value);
        dragProgress.value = getProgress(isHorizontal.value ? touchX : touchY);
        endTouch(e);
        addMovement(e);
      }
    }
    function onTouchmove(e) {
      const touchX = e.changedTouches[0].clientX;
      const touchY = e.changedTouches[0].clientY;
      if (maybeDragging) {
        if (!e.cancelable) {
          maybeDragging = false;
          return;
        }
        const dx = Math.abs(touchX - start[0]);
        const dy = Math.abs(touchY - start[1]);
        const thresholdMet = isHorizontal.value ? dx > dy && dx > 3 : dy > dx && dy > 3;
        if (thresholdMet) {
          isDragging.value = true;
          maybeDragging = false;
        } else if ((isHorizontal.value ? dy : dx) > 3) {
          maybeDragging = false;
        }
      }
      if (!isDragging.value)
        return;
      e.preventDefault();
      addMovement(e);
      const progress = getProgress(isHorizontal.value ? touchX : touchY, false);
      dragProgress.value = Math.max(0, Math.min(1, progress));
      if (progress > 1) {
        offset.value = getOffset3(isHorizontal.value ? touchX : touchY, true);
      } else if (progress < 0) {
        offset.value = getOffset3(isHorizontal.value ? touchX : touchY, false);
      }
    }
    function onTouchend(e) {
      maybeDragging = false;
      if (!isDragging.value)
        return;
      addMovement(e);
      isDragging.value = false;
      const velocity = getVelocity(e.changedTouches[0].identifier);
      const vx = Math.abs(velocity.x);
      const vy = Math.abs(velocity.y);
      const thresholdMet = isHorizontal.value ? vx > vy && vx > 400 : vy > vx && vy > 3;
      if (thresholdMet) {
        isActive.value = velocity.direction === ({
          left: "right",
          right: "left",
          top: "down",
          bottom: "up"
        }[position.value] || oops2());
      } else {
        isActive.value = dragProgress.value > 0.5;
      }
    }
    const dragStyles = computed2(() => {
      return isDragging.value ? {
        transform: position.value === "left" ? `translateX(calc(-100% + ${dragProgress.value * width.value}px))` : position.value === "right" ? `translateX(calc(100% - ${dragProgress.value * width.value}px))` : position.value === "top" ? `translateY(calc(-100% + ${dragProgress.value * width.value}px))` : position.value === "bottom" ? `translateY(calc(100% - ${dragProgress.value * width.value}px))` : oops2(),
        transition: "none"
      } : void 0;
    });
    return {
      isDragging,
      dragProgress,
      dragStyles
    };
  }
  function oops2() {
    throw new Error();
  }

  // ../library_management/node_modules/vuetify/lib/components/VNavigationDrawer/VNavigationDrawer.mjs
  var locations = ["start", "end", "left", "right", "top", "bottom"];
  var makeVNavigationDrawerProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    color: String,
    disableResizeWatcher: Boolean,
    disableRouteWatcher: Boolean,
    expandOnHover: Boolean,
    floating: Boolean,
    modelValue: {
      type: Boolean,
      default: null
    },
    permanent: Boolean,
    rail: {
      type: Boolean,
      default: null
    },
    railWidth: {
      type: [Number, String],
      default: 56
    },
    scrim: {
      type: [Boolean, String],
      default: true
    },
    image: String,
    temporary: Boolean,
    touchless: Boolean,
    width: {
      type: [Number, String],
      default: 256
    },
    location: {
      type: String,
      default: "start",
      validator: (value) => locations.includes(value)
    },
    sticky: Boolean
  }, makeBorderProps()), makeComponentProps()), makeDisplayProps()), makeElevationProps()), makeLayoutItemProps()), makeRoundedProps()), makeTagProps({
    tag: "nav"
  })), makeThemeProps()), "VNavigationDrawer");
  var VNavigationDrawer = genericComponent()({
    name: "VNavigationDrawer",
    props: makeVNavigationDrawerProps(),
    emits: {
      "update:modelValue": (val) => true,
      "update:rail": (val) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        emit: emit2,
        slots
      } = _ref;
      const {
        isRtl
      } = useRtl();
      const {
        themeClasses
      } = provideTheme(props);
      const {
        borderClasses
      } = useBorder(props);
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(toRef(props, "color"));
      const {
        elevationClasses
      } = useElevation(props);
      const {
        displayClasses,
        mobile
      } = useDisplay(props);
      const {
        roundedClasses
      } = useRounded(props);
      const router = useRouter();
      const isActive = useProxiedModel(props, "modelValue", null, (v) => !!v);
      const {
        ssrBootStyles
      } = useSsrBoot();
      const {
        scopeId
      } = useScopeId();
      const rootEl = ref();
      const isHovering = shallowRef(false);
      const width = computed2(() => {
        return props.rail && props.expandOnHover && isHovering.value ? Number(props.width) : Number(props.rail ? props.railWidth : props.width);
      });
      const location2 = computed2(() => {
        return toPhysical(props.location, isRtl.value);
      });
      const isTemporary = computed2(() => !props.permanent && (mobile.value || props.temporary));
      const isSticky = computed2(() => props.sticky && !isTemporary.value && location2.value !== "bottom");
      useToggleScope(() => props.expandOnHover && props.rail != null, () => {
        watch(isHovering, (val) => emit2("update:rail", !val));
      });
      useToggleScope(() => !props.disableResizeWatcher, () => {
        watch(isTemporary, (val) => !props.permanent && nextTick(() => isActive.value = !val));
      });
      useToggleScope(() => !props.disableRouteWatcher && !!router, () => {
        watch(router.currentRoute, () => isTemporary.value && (isActive.value = false));
      });
      watch(() => props.permanent, (val) => {
        if (val)
          isActive.value = true;
      });
      onBeforeMount(() => {
        if (props.modelValue != null || isTemporary.value)
          return;
        isActive.value = props.permanent || !mobile.value;
      });
      const {
        isDragging,
        dragProgress,
        dragStyles
      } = useTouch({
        isActive,
        isTemporary,
        width,
        touchless: toRef(props, "touchless"),
        position: location2
      });
      const layoutSize = computed2(() => {
        const size2 = isTemporary.value ? 0 : props.rail && props.expandOnHover ? Number(props.railWidth) : width.value;
        return isDragging.value ? size2 * dragProgress.value : size2;
      });
      const {
        layoutItemStyles,
        layoutItemScrimStyles
      } = useLayoutItem({
        id: props.name,
        order: computed2(() => parseInt(props.order, 10)),
        position: location2,
        layoutSize,
        elementSize: width,
        active: computed2(() => isActive.value || isDragging.value),
        disableTransitions: computed2(() => isDragging.value),
        absolute: computed2(() => props.absolute || isSticky.value && typeof isStuck.value !== "string")
      });
      const {
        isStuck,
        stickyStyles
      } = useSticky({
        rootEl,
        isSticky,
        layoutItemStyles
      });
      const scrimColor = useBackgroundColor(computed2(() => {
        return typeof props.scrim === "string" ? props.scrim : null;
      }));
      const scrimStyles = computed2(() => __spreadValues(__spreadValues({}, isDragging.value ? {
        opacity: dragProgress.value * 0.2,
        transition: "none"
      } : void 0), layoutItemScrimStyles.value));
      provideDefaults({
        VList: {
          bgColor: "transparent"
        }
      });
      function onMouseenter() {
        isHovering.value = true;
      }
      function onMouseleave() {
        isHovering.value = false;
      }
      useRender(() => {
        const hasImage = slots.image || props.image;
        return createVNode(Fragment, null, [createVNode(props.tag, mergeProps({
          "ref": rootEl,
          "onMouseenter": onMouseenter,
          "onMouseleave": onMouseleave,
          "class": ["v-navigation-drawer", `v-navigation-drawer--${location2.value}`, {
            "v-navigation-drawer--expand-on-hover": props.expandOnHover,
            "v-navigation-drawer--floating": props.floating,
            "v-navigation-drawer--is-hovering": isHovering.value,
            "v-navigation-drawer--rail": props.rail,
            "v-navigation-drawer--temporary": isTemporary.value,
            "v-navigation-drawer--active": isActive.value,
            "v-navigation-drawer--sticky": isSticky.value
          }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, displayClasses.value, elevationClasses.value, roundedClasses.value, props.class],
          "style": [backgroundColorStyles.value, layoutItemStyles.value, dragStyles.value, ssrBootStyles.value, stickyStyles.value, props.style]
        }, scopeId, attrs), {
          default: () => {
            var _a2, _b, _c;
            return [hasImage && createVNode("div", {
              "key": "image",
              "class": "v-navigation-drawer__img"
            }, [!slots.image ? createVNode(VImg, {
              "key": "image-img",
              "alt": "",
              "cover": true,
              "height": "inherit",
              "src": props.image
            }, null) : createVNode(VDefaultsProvider, {
              "key": "image-defaults",
              "disabled": !props.image,
              "defaults": {
                VImg: {
                  alt: "",
                  cover: true,
                  height: "inherit",
                  src: props.image
                }
              }
            }, slots.image)]), slots.prepend && createVNode("div", {
              "class": "v-navigation-drawer__prepend"
            }, [(_a2 = slots.prepend) == null ? void 0 : _a2.call(slots)]), createVNode("div", {
              "class": "v-navigation-drawer__content"
            }, [(_b = slots.default) == null ? void 0 : _b.call(slots)]), slots.append && createVNode("div", {
              "class": "v-navigation-drawer__append"
            }, [(_c = slots.append) == null ? void 0 : _c.call(slots)])];
          }
        }), createVNode(Transition, {
          "name": "fade-transition"
        }, {
          default: () => [isTemporary.value && (isDragging.value || isActive.value) && !!props.scrim && createVNode("div", mergeProps({
            "class": ["v-navigation-drawer__scrim", scrimColor.backgroundColorClasses.value],
            "style": [scrimStyles.value, scrimColor.backgroundColorStyles.value],
            "onClick": () => isActive.value = false
          }, scopeId), null)]
        })]);
      });
      return {
        isStuck
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VNoSsr/VNoSsr.mjs
  var VNoSsr = defineComponent2({
    name: "VNoSsr",
    setup(_, _ref) {
      let {
        slots
      } = _ref;
      const show = useHydration();
      return () => {
        var _a2;
        return show.value && ((_a2 = slots.default) == null ? void 0 : _a2.call(slots));
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VOtpInput/VOtpInput.mjs
  var makeVOtpInputProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({
    autofocus: Boolean,
    divider: String,
    focusAll: Boolean,
    label: {
      type: String,
      default: "$vuetify.input.otp"
    },
    length: {
      type: [Number, String],
      default: 6
    },
    modelValue: {
      type: [Number, String],
      default: void 0
    },
    placeholder: String,
    type: {
      type: String,
      default: "number"
    }
  }, makeDimensionProps()), makeFocusProps()), only(makeVFieldProps({
    variant: "outlined"
  }), ["baseColor", "bgColor", "class", "color", "disabled", "error", "loading", "rounded", "style", "theme", "variant"])), "VOtpInput");
  var VOtpInput = genericComponent()({
    name: "VOtpInput",
    props: makeVOtpInputProps(),
    emits: {
      finish: (val) => true,
      "update:focused": (val) => true,
      "update:modelValue": (val) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        emit: emit2,
        slots
      } = _ref;
      const {
        dimensionStyles
      } = useDimension(props);
      const {
        isFocused,
        focus,
        blur
      } = useFocus(props);
      const model = useProxiedModel(props, "modelValue", "", (val) => val == null ? [] : String(val).split(""), (val) => val.join(""));
      const {
        t
      } = useLocale();
      const length = computed2(() => Number(props.length));
      const fields = computed2(() => Array(length.value).fill(0));
      const focusIndex = ref(-1);
      const contentRef = ref();
      const inputRef = ref([]);
      const current = computed2(() => inputRef.value[focusIndex.value]);
      function onInput() {
        if (isValidNumber(current.value.value)) {
          current.value.value = "";
          return;
        }
        const array = model.value.slice();
        const value = current.value.value;
        array[focusIndex.value] = value;
        let target = null;
        if (focusIndex.value > model.value.length) {
          target = model.value.length + 1;
        } else if (focusIndex.value + 1 !== length.value) {
          target = "next";
        }
        model.value = array;
        if (target)
          focusChild(contentRef.value, target);
      }
      function onKeydown(e) {
        const array = model.value.slice();
        const index = focusIndex.value;
        let target = null;
        if (!["ArrowLeft", "ArrowRight", "Backspace", "Delete"].includes(e.key))
          return;
        e.preventDefault();
        if (e.key === "ArrowLeft") {
          target = "prev";
        } else if (e.key === "ArrowRight") {
          target = "next";
        } else if (["Backspace", "Delete"].includes(e.key)) {
          array[focusIndex.value] = "";
          model.value = array;
          if (focusIndex.value > 0 && e.key === "Backspace") {
            target = "prev";
          } else {
            requestAnimationFrame(() => {
              var _a2;
              (_a2 = inputRef.value[index]) == null ? void 0 : _a2.select();
            });
          }
        }
        requestAnimationFrame(() => {
          if (target != null) {
            focusChild(contentRef.value, target);
          }
        });
      }
      function onPaste(index, e) {
        var _a2, _b, _c;
        e.preventDefault();
        e.stopPropagation();
        const clipboardText = (_b = (_a2 = e == null ? void 0 : e.clipboardData) == null ? void 0 : _a2.getData("Text")) != null ? _b : "";
        if (isValidNumber(clipboardText))
          return;
        model.value = clipboardText.split("");
        (_c = inputRef.value) == null ? void 0 : _c[index].blur();
      }
      function reset() {
        model.value = [];
      }
      function onFocus(e, index) {
        focus();
        focusIndex.value = index;
      }
      function onBlur() {
        blur();
        focusIndex.value = -1;
      }
      function isValidNumber(value) {
        return props.type === "number" && /[^0-9]/g.test(value);
      }
      provideDefaults({
        VField: {
          color: computed2(() => props.color),
          bgColor: computed2(() => props.color),
          baseColor: computed2(() => props.baseColor),
          disabled: computed2(() => props.disabled),
          error: computed2(() => props.error),
          variant: computed2(() => props.variant)
        }
      }, {
        scoped: true
      });
      watch(model, (val) => {
        if (val.length === length.value)
          emit2("finish", val.join(""));
      }, {
        deep: true
      });
      watch(focusIndex, (val) => {
        if (val < 0)
          return;
        nextTick(() => {
          var _a2;
          (_a2 = inputRef.value[val]) == null ? void 0 : _a2.select();
        });
      });
      useRender(() => {
        var _a2;
        const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
        return createVNode("div", mergeProps({
          "class": ["v-otp-input", {
            "v-otp-input--divided": !!props.divider
          }, props.class],
          "style": [props.style]
        }, rootAttrs), [createVNode("div", {
          "ref": contentRef,
          "class": "v-otp-input__content",
          "style": [dimensionStyles.value]
        }, [fields.value.map((_, i) => createVNode(Fragment, null, [props.divider && i !== 0 && createVNode("span", {
          "class": "v-otp-input__divider"
        }, [props.divider]), createVNode(VField, {
          "focused": isFocused.value && props.focusAll || focusIndex.value === i,
          "key": i
        }, __spreadProps(__spreadValues({}, slots), {
          loader: void 0,
          default: () => {
            return createVNode("input", {
              "ref": (val) => inputRef.value[i] = val,
              "aria-label": t(props.label, i + 1),
              "autofocus": i === 0 && props.autofocus,
              "autocomplete": "one-time-code",
              "class": ["v-otp-input__field"],
              "disabled": props.disabled,
              "inputmode": props.type === "number" ? "numeric" : "text",
              "min": props.type === "number" ? 0 : void 0,
              "maxlength": "1",
              "placeholder": props.placeholder,
              "type": props.type === "number" ? "text" : props.type,
              "value": model.value[i],
              "onInput": onInput,
              "onFocus": (e) => onFocus(e, i),
              "onBlur": onBlur,
              "onKeydown": onKeydown,
              "onPaste": (event) => onPaste(i, event)
            }, null);
          }
        }))])), createVNode("input", mergeProps({
          "class": "v-otp-input-input",
          "type": "hidden"
        }, inputAttrs, {
          "value": model.value.join("")
        }), null), createVNode(VOverlay, {
          "contained": true,
          "content-class": "v-otp-input__loader",
          "model-value": !!props.loading,
          "persistent": true
        }, {
          default: () => {
            var _a3, _b;
            return [(_b = (_a3 = slots.loader) == null ? void 0 : _a3.call(slots)) != null ? _b : createVNode(VProgressCircular, {
              "color": typeof props.loading === "boolean" ? void 0 : props.loading,
              "indeterminate": true,
              "size": "24",
              "width": "2"
            }, null)];
          }
        }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots)])]);
      });
      return {
        blur: () => {
          var _a2;
          (_a2 = inputRef.value) == null ? void 0 : _a2.some((input) => input.blur());
        },
        focus: () => {
          var _a2;
          (_a2 = inputRef.value) == null ? void 0 : _a2[0].focus();
        },
        reset,
        isFocused
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VParallax/VParallax.mjs
  function floor(val) {
    return Math.floor(Math.abs(val)) * Math.sign(val);
  }
  var makeVParallaxProps = propsFactory(__spreadValues({
    scale: {
      type: [Number, String],
      default: 0.5
    }
  }, makeComponentProps()), "VParallax");
  var VParallax = genericComponent()({
    name: "VParallax",
    props: makeVParallaxProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        intersectionRef,
        isIntersecting
      } = useIntersectionObserver();
      const {
        resizeRef,
        contentRect
      } = useResizeObserver();
      const {
        height: displayHeight
      } = useDisplay();
      const root = ref();
      watchEffect(() => {
        var _a2;
        intersectionRef.value = resizeRef.value = (_a2 = root.value) == null ? void 0 : _a2.$el;
      });
      let scrollParent;
      watch(isIntersecting, (val) => {
        if (val) {
          scrollParent = getScrollParent(intersectionRef.value);
          scrollParent = scrollParent === document.scrollingElement ? document : scrollParent;
          scrollParent.addEventListener("scroll", onScroll, {
            passive: true
          });
          onScroll();
        } else {
          scrollParent.removeEventListener("scroll", onScroll);
        }
      });
      onBeforeUnmount(() => {
        scrollParent == null ? void 0 : scrollParent.removeEventListener("scroll", onScroll);
      });
      watch(displayHeight, onScroll);
      watch(() => {
        var _a2;
        return (_a2 = contentRect.value) == null ? void 0 : _a2.height;
      }, onScroll);
      const scale = computed2(() => {
        return 1 - clamp(+props.scale);
      });
      let frame = -1;
      function onScroll() {
        if (!isIntersecting.value)
          return;
        cancelAnimationFrame(frame);
        frame = requestAnimationFrame(() => {
          var _a2;
          const el = ((_a2 = root.value) == null ? void 0 : _a2.$el).querySelector(".v-img__img");
          if (!el)
            return;
          const scrollHeight = scrollParent instanceof Document ? document.documentElement.clientHeight : scrollParent.clientHeight;
          const scrollPos = scrollParent instanceof Document ? window.scrollY : scrollParent.scrollTop;
          const top = intersectionRef.value.getBoundingClientRect().top + scrollPos;
          const height = contentRect.value.height;
          const center = top + (height - scrollHeight) / 2;
          const translate = floor((scrollPos - center) * scale.value);
          const sizeScale = Math.max(1, (scale.value * (scrollHeight - height) + height) / height);
          el.style.setProperty("transform", `translateY(${translate}px) scale(${sizeScale})`);
        });
      }
      useRender(() => createVNode(VImg, {
        "class": ["v-parallax", {
          "v-parallax--active": isIntersecting.value
        }, props.class],
        "style": props.style,
        "ref": root,
        "cover": true,
        "onLoadstart": onScroll,
        "onLoad": onScroll
      }, slots));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VRadio/VRadio.mjs
  var makeVRadioProps = propsFactory(__spreadValues({}, makeVSelectionControlProps({
    falseIcon: "$radioOff",
    trueIcon: "$radioOn"
  })), "VRadio");
  var VRadio = genericComponent()({
    name: "VRadio",
    props: makeVRadioProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useRender(() => createVNode(VSelectionControl, mergeProps(props, {
        "class": ["v-radio", props.class],
        "style": props.style,
        "type": "radio"
      }), slots));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VRadioGroup/VRadioGroup.mjs
  var makeVRadioGroupProps = propsFactory(__spreadProps(__spreadValues(__spreadValues({
    height: {
      type: [Number, String],
      default: "auto"
    }
  }, makeVInputProps()), omit(makeSelectionControlGroupProps(), ["multiple"])), {
    trueIcon: {
      type: IconValue,
      default: "$radioOn"
    },
    falseIcon: {
      type: IconValue,
      default: "$radioOff"
    },
    type: {
      type: String,
      default: "radio"
    }
  }), "VRadioGroup");
  var VRadioGroup = genericComponent()({
    name: "VRadioGroup",
    inheritAttrs: false,
    props: makeVRadioGroupProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const uid2 = getUid();
      const id = computed2(() => props.id || `radio-group-${uid2}`);
      const model = useProxiedModel(props, "modelValue");
      useRender(() => {
        const [rootAttrs, controlAttrs] = filterInputAttrs(attrs);
        const inputProps = VInput.filterProps(props);
        const controlProps = VSelectionControl.filterProps(props);
        const label = slots.label ? slots.label({
          label: props.label,
          props: {
            for: id.value
          }
        }) : props.label;
        return createVNode(VInput, mergeProps({
          "class": ["v-radio-group", props.class],
          "style": props.style
        }, rootAttrs, inputProps, {
          "modelValue": model.value,
          "onUpdate:modelValue": ($event) => model.value = $event,
          "id": id.value
        }), __spreadProps(__spreadValues({}, slots), {
          default: (_ref2) => {
            let {
              id: id2,
              messagesId,
              isDisabled,
              isReadonly: isReadonly2
            } = _ref2;
            return createVNode(Fragment, null, [label && createVNode(VLabel, {
              "id": id2.value
            }, {
              default: () => [label]
            }), createVNode(VSelectionControlGroup, mergeProps(controlProps, {
              "id": id2.value,
              "aria-describedby": messagesId.value,
              "defaultsTarget": "VRadio",
              "trueIcon": props.trueIcon,
              "falseIcon": props.falseIcon,
              "type": props.type,
              "disabled": isDisabled.value,
              "readonly": isReadonly2.value,
              "aria-labelledby": label ? id2.value : void 0,
              "multiple": false
            }, controlAttrs, {
              "modelValue": model.value,
              "onUpdate:modelValue": ($event) => model.value = $event
            }), slots)]);
          }
        }));
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VRangeSlider/VRangeSlider.mjs
  var makeVRangeSliderProps = propsFactory(__spreadProps(__spreadValues(__spreadValues(__spreadValues({}, makeFocusProps()), makeVInputProps()), makeSliderProps()), {
    strict: Boolean,
    modelValue: {
      type: Array,
      default: () => [0, 0]
    }
  }), "VRangeSlider");
  var VRangeSlider = genericComponent()({
    name: "VRangeSlider",
    props: makeVRangeSliderProps(),
    emits: {
      "update:focused": (value) => true,
      "update:modelValue": (value) => true,
      end: (value) => true,
      start: (value) => true
    },
    setup(props, _ref) {
      let {
        slots,
        emit: emit2
      } = _ref;
      const startThumbRef = ref();
      const stopThumbRef = ref();
      const inputRef = ref();
      const {
        rtlClasses
      } = useRtl();
      function getActiveThumb(e) {
        if (!startThumbRef.value || !stopThumbRef.value)
          return;
        const startOffset = getOffset2(e, startThumbRef.value.$el, props.direction);
        const stopOffset = getOffset2(e, stopThumbRef.value.$el, props.direction);
        const a = Math.abs(startOffset);
        const b = Math.abs(stopOffset);
        return a < b || a === b && startOffset < 0 ? startThumbRef.value.$el : stopThumbRef.value.$el;
      }
      const steps = useSteps(props);
      const model = useProxiedModel(props, "modelValue", void 0, (arr) => {
        if (!(arr == null ? void 0 : arr.length))
          return [0, 0];
        return arr.map((value) => steps.roundValue(value));
      });
      const {
        activeThumbRef,
        hasLabels,
        max,
        min,
        mousePressed,
        onSliderMousedown,
        onSliderTouchstart,
        position,
        trackContainerRef,
        readonly: readonly2
      } = useSlider({
        props,
        steps,
        onSliderStart: () => {
          emit2("start", model.value);
        },
        onSliderEnd: (_ref2) => {
          var _a2;
          let {
            value
          } = _ref2;
          const newValue = activeThumbRef.value === ((_a2 = startThumbRef.value) == null ? void 0 : _a2.$el) ? [value, model.value[1]] : [model.value[0], value];
          if (!props.strict && newValue[0] < newValue[1]) {
            model.value = newValue;
          }
          emit2("end", model.value);
        },
        onSliderMove: (_ref3) => {
          var _a2, _b, _c, _d;
          let {
            value
          } = _ref3;
          const [start, stop2] = model.value;
          if (!props.strict && start === stop2 && start !== min.value) {
            activeThumbRef.value = value > start ? (_a2 = stopThumbRef.value) == null ? void 0 : _a2.$el : (_b = startThumbRef.value) == null ? void 0 : _b.$el;
            (_c = activeThumbRef.value) == null ? void 0 : _c.focus();
          }
          if (activeThumbRef.value === ((_d = startThumbRef.value) == null ? void 0 : _d.$el)) {
            model.value = [Math.min(value, stop2), stop2];
          } else {
            model.value = [start, Math.max(start, value)];
          }
        },
        getActiveThumb
      });
      const {
        isFocused,
        focus,
        blur
      } = useFocus(props);
      const trackStart = computed2(() => position(model.value[0]));
      const trackStop = computed2(() => position(model.value[1]));
      useRender(() => {
        const inputProps = VInput.filterProps(props);
        const hasPrepend = !!(props.label || slots.label || slots.prepend);
        return createVNode(VInput, mergeProps({
          "class": ["v-slider", "v-range-slider", {
            "v-slider--has-labels": !!slots["tick-label"] || hasLabels.value,
            "v-slider--focused": isFocused.value,
            "v-slider--pressed": mousePressed.value,
            "v-slider--disabled": props.disabled
          }, rtlClasses.value, props.class],
          "style": props.style,
          "ref": inputRef
        }, inputProps, {
          "focused": isFocused.value
        }), __spreadProps(__spreadValues({}, slots), {
          prepend: hasPrepend ? (slotProps) => {
            var _a2, _b, _c;
            return createVNode(Fragment, null, [(_b = (_a2 = slots.label) == null ? void 0 : _a2.call(slots, slotProps)) != null ? _b : props.label ? createVNode(VLabel, {
              "class": "v-slider__label",
              "text": props.label
            }, null) : void 0, (_c = slots.prepend) == null ? void 0 : _c.call(slots, slotProps)]);
          } : void 0,
          default: (_ref4) => {
            var _a2, _b;
            let {
              id,
              messagesId
            } = _ref4;
            return createVNode("div", {
              "class": "v-slider__container",
              "onMousedown": !readonly2.value ? onSliderMousedown : void 0,
              "onTouchstartPassive": !readonly2.value ? onSliderTouchstart : void 0
            }, [createVNode("input", {
              "id": `${id.value}_start`,
              "name": props.name || id.value,
              "disabled": !!props.disabled,
              "readonly": !!props.readonly,
              "tabindex": "-1",
              "value": model.value[0]
            }, null), createVNode("input", {
              "id": `${id.value}_stop`,
              "name": props.name || id.value,
              "disabled": !!props.disabled,
              "readonly": !!props.readonly,
              "tabindex": "-1",
              "value": model.value[1]
            }, null), createVNode(VSliderTrack, {
              "ref": trackContainerRef,
              "start": trackStart.value,
              "stop": trackStop.value
            }, {
              "tick-label": slots["tick-label"]
            }), createVNode(VSliderThumb, {
              "ref": startThumbRef,
              "aria-describedby": messagesId.value,
              "focused": isFocused && activeThumbRef.value === ((_a2 = startThumbRef.value) == null ? void 0 : _a2.$el),
              "modelValue": model.value[0],
              "onUpdate:modelValue": (v) => model.value = [v, model.value[1]],
              "onFocus": (e) => {
                var _a3, _b2, _c, _d;
                focus();
                activeThumbRef.value = (_a3 = startThumbRef.value) == null ? void 0 : _a3.$el;
                if (model.value[0] === model.value[1] && model.value[1] === min.value && e.relatedTarget !== ((_b2 = stopThumbRef.value) == null ? void 0 : _b2.$el)) {
                  (_c = startThumbRef.value) == null ? void 0 : _c.$el.blur();
                  (_d = stopThumbRef.value) == null ? void 0 : _d.$el.focus();
                }
              },
              "onBlur": () => {
                blur();
                activeThumbRef.value = void 0;
              },
              "min": min.value,
              "max": model.value[1],
              "position": trackStart.value,
              "ripple": props.ripple
            }, {
              "thumb-label": slots["thumb-label"]
            }), createVNode(VSliderThumb, {
              "ref": stopThumbRef,
              "aria-describedby": messagesId.value,
              "focused": isFocused && activeThumbRef.value === ((_b = stopThumbRef.value) == null ? void 0 : _b.$el),
              "modelValue": model.value[1],
              "onUpdate:modelValue": (v) => model.value = [model.value[0], v],
              "onFocus": (e) => {
                var _a3, _b2, _c, _d;
                focus();
                activeThumbRef.value = (_a3 = stopThumbRef.value) == null ? void 0 : _a3.$el;
                if (model.value[0] === model.value[1] && model.value[0] === max.value && e.relatedTarget !== ((_b2 = startThumbRef.value) == null ? void 0 : _b2.$el)) {
                  (_c = stopThumbRef.value) == null ? void 0 : _c.$el.blur();
                  (_d = startThumbRef.value) == null ? void 0 : _d.$el.focus();
                }
              },
              "onBlur": () => {
                blur();
                activeThumbRef.value = void 0;
              },
              "min": model.value[0],
              "max": max.value,
              "position": trackStop.value,
              "ripple": props.ripple
            }, {
              "thumb-label": slots["thumb-label"]
            })]);
          }
        }));
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VRating/VRating.mjs
  var makeVRatingProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    name: String,
    itemAriaLabel: {
      type: String,
      default: "$vuetify.rating.ariaLabel.item"
    },
    activeColor: String,
    color: String,
    clearable: Boolean,
    disabled: Boolean,
    emptyIcon: {
      type: IconValue,
      default: "$ratingEmpty"
    },
    fullIcon: {
      type: IconValue,
      default: "$ratingFull"
    },
    halfIncrements: Boolean,
    hover: Boolean,
    length: {
      type: [Number, String],
      default: 5
    },
    readonly: Boolean,
    modelValue: {
      type: [Number, String],
      default: 0
    },
    itemLabels: Array,
    itemLabelPosition: {
      type: String,
      default: "top",
      validator: (v) => ["top", "bottom"].includes(v)
    },
    ripple: Boolean
  }, makeComponentProps()), makeDensityProps()), makeSizeProps()), makeTagProps()), makeThemeProps()), "VRating");
  var VRating = genericComponent()({
    name: "VRating",
    props: makeVRatingProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        t
      } = useLocale();
      const {
        themeClasses
      } = provideTheme(props);
      const rating = useProxiedModel(props, "modelValue");
      const normalizedValue = computed2(() => clamp(parseFloat(rating.value), 0, +props.length));
      const range = computed2(() => createRange(Number(props.length), 1));
      const increments = computed2(() => range.value.flatMap((v) => props.halfIncrements ? [v - 0.5, v] : [v]));
      const hoverIndex = shallowRef(-1);
      const itemState = computed2(() => increments.value.map((value) => {
        var _a2;
        const isHovering = props.hover && hoverIndex.value > -1;
        const isFilled = normalizedValue.value >= value;
        const isHovered = hoverIndex.value >= value;
        const isFullIcon = isHovering ? isHovered : isFilled;
        const icon = isFullIcon ? props.fullIcon : props.emptyIcon;
        const activeColor = (_a2 = props.activeColor) != null ? _a2 : props.color;
        const color = isFilled || isHovered ? activeColor : props.color;
        return {
          isFilled,
          isHovered,
          icon,
          color
        };
      }));
      const eventState = computed2(() => [0, ...increments.value].map((value) => {
        function onMouseenter() {
          hoverIndex.value = value;
        }
        function onMouseleave() {
          hoverIndex.value = -1;
        }
        function onClick() {
          if (props.disabled || props.readonly)
            return;
          rating.value = normalizedValue.value === value && props.clearable ? 0 : value;
        }
        return {
          onMouseenter: props.hover ? onMouseenter : void 0,
          onMouseleave: props.hover ? onMouseleave : void 0,
          onClick
        };
      }));
      const name = computed2(() => {
        var _a2;
        return (_a2 = props.name) != null ? _a2 : `v-rating-${getUid()}`;
      });
      function VRatingItem(_ref2) {
        var _a2, _b;
        let {
          value,
          index,
          showStar = true
        } = _ref2;
        const {
          onMouseenter,
          onMouseleave,
          onClick
        } = eventState.value[index + 1];
        const id = `${name.value}-${String(value).replace(".", "-")}`;
        const btnProps = {
          color: (_a2 = itemState.value[index]) == null ? void 0 : _a2.color,
          density: props.density,
          disabled: props.disabled,
          icon: (_b = itemState.value[index]) == null ? void 0 : _b.icon,
          ripple: props.ripple,
          size: props.size,
          variant: "plain"
        };
        return createVNode(Fragment, null, [createVNode("label", {
          "for": id,
          "class": {
            "v-rating__item--half": props.halfIncrements && value % 1 > 0,
            "v-rating__item--full": props.halfIncrements && value % 1 === 0
          },
          "onMouseenter": onMouseenter,
          "onMouseleave": onMouseleave,
          "onClick": onClick
        }, [createVNode("span", {
          "class": "v-rating__hidden"
        }, [t(props.itemAriaLabel, value, props.length)]), !showStar ? void 0 : slots.item ? slots.item(__spreadProps(__spreadValues({}, itemState.value[index]), {
          props: btnProps,
          value,
          index,
          rating: normalizedValue.value
        })) : createVNode(VBtn, mergeProps({
          "aria-label": t(props.itemAriaLabel, value, props.length)
        }, btnProps), null)]), createVNode("input", {
          "class": "v-rating__hidden",
          "name": name.value,
          "id": id,
          "type": "radio",
          "value": value,
          "checked": normalizedValue.value === value,
          "tabindex": -1,
          "readonly": props.readonly,
          "disabled": props.disabled
        }, null)]);
      }
      function createLabel(labelProps) {
        if (slots["item-label"])
          return slots["item-label"](labelProps);
        if (labelProps.label)
          return createVNode("span", null, [labelProps.label]);
        return createVNode("span", null, [createTextVNode("\xA0")]);
      }
      useRender(() => {
        var _a2;
        const hasLabels = !!((_a2 = props.itemLabels) == null ? void 0 : _a2.length) || slots["item-label"];
        return createVNode(props.tag, {
          "class": ["v-rating", {
            "v-rating--hover": props.hover,
            "v-rating--readonly": props.readonly
          }, themeClasses.value, props.class],
          "style": props.style
        }, {
          default: () => [createVNode(VRatingItem, {
            "value": 0,
            "index": -1,
            "showStar": false
          }, null), range.value.map((value, i) => {
            var _a3, _b;
            return createVNode("div", {
              "class": "v-rating__wrapper"
            }, [hasLabels && props.itemLabelPosition === "top" ? createLabel({
              value,
              index: i,
              label: (_a3 = props.itemLabels) == null ? void 0 : _a3[i]
            }) : void 0, createVNode("div", {
              "class": "v-rating__item"
            }, [props.halfIncrements ? createVNode(Fragment, null, [createVNode(VRatingItem, {
              "value": value - 0.5,
              "index": i * 2
            }, null), createVNode(VRatingItem, {
              "value": value,
              "index": i * 2 + 1
            }, null)]) : createVNode(VRatingItem, {
              "value": value,
              "index": i
            }, null)]), hasLabels && props.itemLabelPosition === "bottom" ? createLabel({
              value,
              index: i,
              label: (_b = props.itemLabels) == null ? void 0 : _b[i]
            }) : void 0]);
          })]
        });
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VSkeletonLoader/VSkeletonLoader.mjs
  var rootTypes = {
    actions: "button@2",
    article: "heading, paragraph",
    avatar: "avatar",
    button: "button",
    card: "image, heading",
    "card-avatar": "image, list-item-avatar",
    chip: "chip",
    "date-picker": "list-item, heading, divider, date-picker-options, date-picker-days, actions",
    "date-picker-options": "text, avatar@2",
    "date-picker-days": "avatar@28",
    divider: "divider",
    heading: "heading",
    image: "image",
    "list-item": "text",
    "list-item-avatar": "avatar, text",
    "list-item-two-line": "sentences",
    "list-item-avatar-two-line": "avatar, sentences",
    "list-item-three-line": "paragraph",
    "list-item-avatar-three-line": "avatar, paragraph",
    ossein: "ossein",
    paragraph: "text@3",
    sentences: "text@2",
    subtitle: "text",
    table: "table-heading, table-thead, table-tbody, table-tfoot",
    "table-heading": "chip, text",
    "table-thead": "heading@6",
    "table-tbody": "table-row-divider@6",
    "table-row-divider": "table-row, divider",
    "table-row": "text@6",
    "table-tfoot": "text@2, avatar@2",
    text: "text"
  };
  function genBone(type2) {
    let children = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return createVNode("div", {
      "class": ["v-skeleton-loader__bone", `v-skeleton-loader__${type2}`]
    }, [children]);
  }
  function genBones(bone) {
    const [type2, length] = bone.split("@");
    return Array.from({
      length
    }).map(() => genStructure(type2));
  }
  function genStructure(type2) {
    let children = [];
    if (!type2)
      return children;
    const bone = rootTypes[type2];
    if (type2 === bone) {
    } else if (type2.includes(","))
      return mapBones(type2);
    else if (type2.includes("@"))
      return genBones(type2);
    else if (bone.includes(","))
      children = mapBones(bone);
    else if (bone.includes("@"))
      children = genBones(bone);
    else if (bone)
      children.push(genStructure(bone));
    return [genBone(type2, children)];
  }
  function mapBones(bones) {
    return bones.replace(/\s/g, "").split(",").map(genStructure);
  }
  var makeVSkeletonLoaderProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({
    boilerplate: Boolean,
    color: String,
    loading: Boolean,
    loadingText: {
      type: String,
      default: "$vuetify.loading"
    },
    type: {
      type: [String, Array],
      default: "ossein"
    }
  }, makeDimensionProps()), makeElevationProps()), makeThemeProps()), "VSkeletonLoader");
  var VSkeletonLoader = genericComponent()({
    name: "VSkeletonLoader",
    props: makeVSkeletonLoaderProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(toRef(props, "color"));
      const {
        dimensionStyles
      } = useDimension(props);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        themeClasses
      } = provideTheme(props);
      const {
        t
      } = useLocale();
      const items = computed2(() => genStructure(wrapInArray(props.type).join(",")));
      useRender(() => {
        var _a2;
        const isLoading = !slots.default || props.loading;
        return createVNode("div", {
          "class": ["v-skeleton-loader", {
            "v-skeleton-loader--boilerplate": props.boilerplate
          }, themeClasses.value, backgroundColorClasses.value, elevationClasses.value],
          "style": [backgroundColorStyles.value, isLoading ? dimensionStyles.value : {}],
          "aria-busy": !props.boilerplate ? isLoading : void 0,
          "aria-live": !props.boilerplate ? "polite" : void 0,
          "aria-label": !props.boilerplate ? t(props.loadingText) : void 0,
          "role": !props.boilerplate ? "alert" : void 0
        }, [isLoading ? items.value : (_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VSlideGroup/VSlideGroupItem.mjs
  var VSlideGroupItem = genericComponent()({
    name: "VSlideGroupItem",
    props: makeGroupItemProps(),
    emits: {
      "group:selected": (val) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const slideGroupItem = useGroupItem(props, VSlideGroupSymbol);
      return () => {
        var _a2;
        return (_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
          isSelected: slideGroupItem.isSelected.value,
          select: slideGroupItem.select,
          toggle: slideGroupItem.toggle,
          selectedClass: slideGroupItem.selectedClass.value
        });
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VSnackbar/VSnackbar.mjs
  function useCountdown(milliseconds) {
    const time = shallowRef(milliseconds);
    let timer = -1;
    function clear2() {
      clearInterval(timer);
    }
    function reset() {
      clear2();
      nextTick(() => time.value = milliseconds);
    }
    function start(el) {
      const style = el ? getComputedStyle(el) : {
        transitionDuration: 0.2
      };
      const interval = parseFloat(style.transitionDuration) * 1e3 || 200;
      clear2();
      if (time.value <= 0)
        return;
      const startTime = performance.now();
      timer = window.setInterval(() => {
        const elapsed = performance.now() - startTime + interval;
        time.value = Math.max(milliseconds - elapsed, 0);
        if (time.value <= 0)
          clear2();
      }, interval);
    }
    onScopeDispose(clear2);
    return {
      clear: clear2,
      time,
      start,
      reset
    };
  }
  var makeVSnackbarProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    multiLine: Boolean,
    text: String,
    timer: [Boolean, String],
    timeout: {
      type: [Number, String],
      default: 5e3
    },
    vertical: Boolean
  }, makeLocationProps({
    location: "bottom"
  })), makePositionProps()), makeRoundedProps()), makeVariantProps()), makeThemeProps()), omit(makeVOverlayProps({
    transition: "v-snackbar-transition"
  }), ["persistent", "noClickAnimation", "scrim", "scrollStrategy"])), "VSnackbar");
  var VSnackbar = genericComponent()({
    name: "VSnackbar",
    props: makeVSnackbarProps(),
    emits: {
      "update:modelValue": (v) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const isActive = useProxiedModel(props, "modelValue");
      const {
        locationStyles
      } = useLocation(props);
      const {
        positionClasses
      } = usePosition(props);
      const {
        scopeId
      } = useScopeId();
      const {
        themeClasses
      } = provideTheme(props);
      const {
        colorClasses,
        colorStyles,
        variantClasses
      } = useVariant(props);
      const {
        roundedClasses
      } = useRounded(props);
      const countdown = useCountdown(Number(props.timeout));
      const overlay = ref();
      const timerRef = ref();
      const isHovering = shallowRef(false);
      watch(isActive, startTimeout);
      watch(() => props.timeout, startTimeout);
      onMounted(() => {
        if (isActive.value)
          startTimeout();
      });
      let activeTimeout = -1;
      function startTimeout() {
        countdown.reset();
        window.clearTimeout(activeTimeout);
        const timeout = Number(props.timeout);
        if (!isActive.value || timeout === -1)
          return;
        const element = refElement(timerRef.value);
        countdown.start(element);
        activeTimeout = window.setTimeout(() => {
          isActive.value = false;
        }, timeout);
      }
      function clearTimeout2() {
        countdown.reset();
        window.clearTimeout(activeTimeout);
      }
      function onPointerenter() {
        isHovering.value = true;
        clearTimeout2();
      }
      function onPointerleave() {
        isHovering.value = false;
        startTimeout();
      }
      useRender(() => {
        const overlayProps = VOverlay.filterProps(props);
        const hasContent = !!(slots.default || slots.text || props.text);
        return createVNode(VOverlay, mergeProps({
          "ref": overlay,
          "class": ["v-snackbar", {
            "v-snackbar--active": isActive.value,
            "v-snackbar--multi-line": props.multiLine && !props.vertical,
            "v-snackbar--timer": !!props.timer,
            "v-snackbar--vertical": props.vertical
          }, positionClasses.value, props.class],
          "style": props.style
        }, overlayProps, {
          "modelValue": isActive.value,
          "onUpdate:modelValue": ($event) => isActive.value = $event,
          "contentProps": mergeProps({
            class: ["v-snackbar__wrapper", themeClasses.value, colorClasses.value, roundedClasses.value, variantClasses.value],
            style: [locationStyles.value, colorStyles.value],
            onPointerenter,
            onPointerleave
          }, overlayProps.contentProps),
          "persistent": true,
          "noClickAnimation": true,
          "scrim": false,
          "scrollStrategy": "none",
          "_disableGlobalStack": true
        }, scopeId), {
          default: () => {
            var _a2, _b, _c;
            return [genOverlays(false, "v-snackbar"), props.timer && !isHovering.value && createVNode("div", {
              "key": "timer",
              "class": "v-snackbar__timer"
            }, [createVNode(VProgressLinear, {
              "ref": timerRef,
              "color": typeof props.timer === "string" ? props.timer : "info",
              "max": props.timeout,
              "model-value": countdown.time.value
            }, null)]), hasContent && createVNode("div", {
              "key": "content",
              "class": "v-snackbar__content",
              "role": "status",
              "aria-live": "polite"
            }, [(_b = (_a2 = slots.text) == null ? void 0 : _a2.call(slots)) != null ? _b : props.text, (_c = slots.default) == null ? void 0 : _c.call(slots)]), slots.actions && createVNode(VDefaultsProvider, {
              "defaults": {
                VBtn: {
                  variant: "text",
                  ripple: false,
                  slim: true
                }
              }
            }, {
              default: () => [createVNode("div", {
                "class": "v-snackbar__actions"
              }, [slots.actions()])]
            })];
          },
          activator: slots.activator
        });
      });
      return forwardRefs({}, overlay);
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VStepper/VStepperActions.mjs
  var makeVStepperActionsProps = propsFactory({
    color: String,
    disabled: {
      type: [Boolean, String],
      default: false
    },
    prevText: {
      type: String,
      default: "$vuetify.stepper.prev"
    },
    nextText: {
      type: String,
      default: "$vuetify.stepper.next"
    }
  }, "VStepperActions");
  var VStepperActions = genericComponent()({
    name: "VStepperActions",
    props: makeVStepperActionsProps(),
    emits: {
      "click:prev": () => true,
      "click:next": () => true
    },
    setup(props, _ref) {
      let {
        emit: emit2,
        slots
      } = _ref;
      const {
        t
      } = useLocale();
      function onClickPrev() {
        emit2("click:prev");
      }
      function onClickNext() {
        emit2("click:next");
      }
      useRender(() => {
        const prevSlotProps = {
          onClick: onClickPrev
        };
        const nextSlotProps = {
          onClick: onClickNext
        };
        return createVNode("div", {
          "class": "v-stepper-actions"
        }, [createVNode(VDefaultsProvider, {
          "defaults": {
            VBtn: {
              disabled: ["prev", true].includes(props.disabled),
              text: t(props.prevText),
              variant: "text"
            }
          }
        }, {
          default: () => {
            var _a2, _b;
            return [(_b = (_a2 = slots.prev) == null ? void 0 : _a2.call(slots, {
              props: prevSlotProps
            })) != null ? _b : createVNode(VBtn, prevSlotProps, null)];
          }
        }), createVNode(VDefaultsProvider, {
          "defaults": {
            VBtn: {
              color: props.color,
              disabled: ["next", true].includes(props.disabled),
              text: t(props.nextText),
              variant: "tonal"
            }
          }
        }, {
          default: () => {
            var _a2, _b;
            return [(_b = (_a2 = slots.next) == null ? void 0 : _a2.call(slots, {
              props: nextSlotProps
            })) != null ? _b : createVNode(VBtn, nextSlotProps, null)];
          }
        })]);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VStepper/VStepperHeader.mjs
  var VStepperHeader = createSimpleFunctional("v-stepper-header");

  // ../library_management/node_modules/vuetify/lib/components/VStepper/VStepperItem.mjs
  var makeVStepperItemProps = propsFactory(__spreadValues({
    color: String,
    title: String,
    subtitle: String,
    complete: Boolean,
    completeIcon: {
      type: String,
      default: "$complete"
    },
    editable: Boolean,
    editIcon: {
      type: String,
      default: "$edit"
    },
    error: Boolean,
    errorIcon: {
      type: String,
      default: "$error"
    },
    icon: String,
    ripple: {
      type: [Boolean, Object],
      default: true
    },
    rules: {
      type: Array,
      default: () => []
    }
  }, makeGroupItemProps()), "VStepperItem");
  var VStepperItem = genericComponent()({
    name: "VStepperItem",
    directives: {
      Ripple
    },
    props: makeVStepperItemProps(),
    emits: {
      "group:selected": (val) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const group = useGroupItem(props, VStepperSymbol, true);
      const step = computed2(() => {
        var _a2;
        return (_a2 = group == null ? void 0 : group.value.value) != null ? _a2 : props.value;
      });
      const isValid2 = computed2(() => props.rules.every((handler) => handler() === true));
      const canEdit = computed2(() => !props.disabled && props.editable);
      const hasError = computed2(() => props.error || !isValid2.value);
      const hasCompleted = computed2(() => props.complete || props.rules.length > 0 && isValid2.value);
      const icon = computed2(() => {
        if (hasError.value)
          return props.errorIcon;
        if (hasCompleted.value)
          return props.completeIcon;
        if (props.editable)
          return props.editIcon;
        return props.icon;
      });
      const slotProps = computed2(() => ({
        canEdit: canEdit.value,
        hasError: hasError.value,
        hasCompleted: hasCompleted.value,
        title: props.title,
        subtitle: props.subtitle,
        step: step.value,
        value: props.value
      }));
      useRender(() => {
        var _a2, _b, _c, _d, _e;
        const hasColor = (!group || group.isSelected.value || hasCompleted.value || canEdit.value) && !hasError.value && !props.disabled;
        const hasTitle = !!(props.title != null || slots.title);
        const hasSubtitle = !!(props.subtitle != null || slots.subtitle);
        function onClick() {
          group == null ? void 0 : group.toggle();
        }
        return withDirectives(createVNode("button", {
          "class": ["v-stepper-item", {
            "v-stepper-item--complete": hasCompleted.value,
            "v-stepper-item--disabled": props.disabled,
            "v-stepper-item--error": hasError.value
          }, group == null ? void 0 : group.selectedClass.value],
          "disabled": !props.editable,
          "onClick": onClick
        }, [createVNode(VAvatar, {
          "key": "stepper-avatar",
          "class": "v-stepper-item__avatar",
          "color": hasColor ? props.color : void 0,
          "size": 24
        }, {
          default: () => {
            var _a3, _b2;
            return [(_b2 = (_a3 = slots.icon) == null ? void 0 : _a3.call(slots, slotProps.value)) != null ? _b2 : icon.value ? createVNode(VIcon, {
              "icon": icon.value
            }, null) : step.value];
          }
        }), createVNode("div", {
          "class": "v-stepper-item__content"
        }, [hasTitle && createVNode("div", {
          "key": "title",
          "class": "v-stepper-item__title"
        }, [(_b = (_a2 = slots.title) == null ? void 0 : _a2.call(slots, slotProps.value)) != null ? _b : props.title]), hasSubtitle && createVNode("div", {
          "key": "subtitle",
          "class": "v-stepper-item__subtitle"
        }, [(_d = (_c = slots.subtitle) == null ? void 0 : _c.call(slots, slotProps.value)) != null ? _d : props.subtitle]), (_e = slots.default) == null ? void 0 : _e.call(slots, slotProps.value)])]), [[resolveDirective("ripple"), props.ripple && props.editable, null]]);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VStepper/VStepperWindow.mjs
  var VStepperSymbol2 = Symbol.for("vuetify:v-stepper");
  var makeVStepperWindowProps = propsFactory(__spreadValues({}, omit(makeVWindowProps(), ["continuous", "nextIcon", "prevIcon", "showArrows", "touch", "mandatory"])), "VStepperWindow");
  var VStepperWindow = genericComponent()({
    name: "VStepperWindow",
    props: makeVStepperWindowProps(),
    emits: {
      "update:modelValue": (v) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const group = inject(VStepperSymbol2, null);
      const _model = useProxiedModel(props, "modelValue");
      const model = computed2({
        get() {
          var _a2;
          if (_model.value != null || !group)
            return _model.value;
          return (_a2 = group.items.value.find((item) => group.selected.value.includes(item.id))) == null ? void 0 : _a2.value;
        },
        set(val) {
          _model.value = val;
        }
      });
      useRender(() => {
        const windowProps = VWindow.filterProps(props);
        return createVNode(VWindow, mergeProps({
          "_as": "VStepperWindow"
        }, windowProps, {
          "modelValue": model.value,
          "onUpdate:modelValue": ($event) => model.value = $event,
          "class": "v-stepper-window",
          "mandatory": false,
          "touch": false
        }), slots);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VStepper/VStepperWindowItem.mjs
  var makeVStepperWindowItemProps = propsFactory(__spreadValues({}, makeVWindowItemProps()), "VStepperWindowItem");
  var VStepperWindowItem = genericComponent()({
    name: "VStepperWindowItem",
    props: makeVStepperWindowItemProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useRender(() => {
        const windowItemProps = VWindowItem.filterProps(props);
        return createVNode(VWindowItem, mergeProps({
          "_as": "VStepperWindowItem"
        }, windowItemProps, {
          "class": "v-stepper-window-item"
        }), slots);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VStepper/VStepper.mjs
  var VStepperSymbol = Symbol.for("vuetify:v-stepper");
  var makeVStepperProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({
    altLabels: Boolean,
    bgColor: String,
    editable: Boolean,
    hideActions: Boolean,
    items: {
      type: Array,
      default: () => []
    },
    itemTitle: {
      type: String,
      default: "title"
    },
    itemValue: {
      type: String,
      default: "value"
    },
    mobile: Boolean,
    nonLinear: Boolean,
    flat: Boolean
  }, makeGroupProps({
    mandatory: "force",
    selectedClass: "v-stepper-item--selected"
  })), makeVSheetProps()), only(makeVStepperActionsProps(), ["prevText", "nextText"])), "VStepper");
  var VStepper = genericComponent()({
    name: "VStepper",
    props: makeVStepperProps(),
    emits: {
      "update:modelValue": (v) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        items: _items,
        next,
        prev,
        selected
      } = useGroup(props, VStepperSymbol);
      const {
        color,
        editable,
        prevText,
        nextText
      } = toRefs(props);
      const items = computed2(() => props.items.map((item, index) => {
        const title = getPropertyFromItem(item, props.itemTitle, item);
        const value = getPropertyFromItem(item, props.itemValue, index + 1);
        return {
          title,
          value,
          raw: item
        };
      }));
      const activeIndex = computed2(() => {
        return _items.value.findIndex((item) => selected.value.includes(item.id));
      });
      const disabled = computed2(() => {
        if (props.disabled)
          return props.disabled;
        if (activeIndex.value === 0)
          return "prev";
        if (activeIndex.value === _items.value.length - 1)
          return "next";
        return false;
      });
      provideDefaults({
        VStepperItem: {
          editable,
          prevText,
          nextText
        },
        VStepperActions: {
          color,
          disabled,
          prevText,
          nextText
        }
      });
      useRender(() => {
        const sheetProps = VSheet.filterProps(props);
        const hasHeader = !!(slots.header || props.items.length);
        const hasWindow = props.items.length > 0;
        const hasActions = !props.hideActions && !!(hasWindow || slots.actions);
        return createVNode(VSheet, mergeProps(sheetProps, {
          "color": props.bgColor,
          "class": ["v-stepper", {
            "v-stepper--alt-labels": props.altLabels,
            "v-stepper--flat": props.flat,
            "v-stepper--non-linear": props.nonLinear,
            "v-stepper--mobile": props.mobile
          }, props.class],
          "style": props.style
        }), {
          default: () => {
            var _a2, _b, _c;
            return [hasHeader && createVNode(VStepperHeader, {
              "key": "stepper-header"
            }, {
              default: () => [items.value.map((item, index) => {
                var _a3;
                return createVNode(Fragment, null, [!!index && createVNode(VDivider, null, null), createVNode(VStepperItem, item, {
                  default: (_a3 = slots[`header-item.${item.value}`]) != null ? _a3 : slots.header,
                  icon: slots.icon,
                  title: slots.title,
                  subtitle: slots.subtitle
                })]);
              })]
            }), hasWindow && createVNode(VStepperWindow, {
              "key": "stepper-window"
            }, {
              default: () => [items.value.map((item) => createVNode(VStepperWindowItem, {
                "value": item.value
              }, {
                default: () => {
                  var _a3, _b2, _c2;
                  return (_c2 = (_a3 = slots[`item.${item.value}`]) == null ? void 0 : _a3.call(slots, item)) != null ? _c2 : (_b2 = slots.item) == null ? void 0 : _b2.call(slots, item);
                }
              }))]
            }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
              prev,
              next
            }), hasActions && ((_c = (_b = slots.actions) == null ? void 0 : _b.call(slots, {
              next,
              prev
            })) != null ? _c : createVNode(VStepperActions, {
              "key": "stepper-actions",
              "onClick:prev": prev,
              "onClick:next": next
            }, slots))];
          }
        });
      });
      return {
        prev,
        next
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VSwitch/VSwitch.mjs
  var makeVSwitchProps = propsFactory(__spreadValues(__spreadValues({
    indeterminate: Boolean,
    inset: Boolean,
    flat: Boolean,
    loading: {
      type: [Boolean, String],
      default: false
    }
  }, makeVInputProps()), makeVSelectionControlProps()), "VSwitch");
  var VSwitch = genericComponent()({
    name: "VSwitch",
    inheritAttrs: false,
    props: makeVSwitchProps(),
    emits: {
      "update:focused": (focused) => true,
      "update:modelValue": (value) => true,
      "update:indeterminate": (value) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const indeterminate = useProxiedModel(props, "indeterminate");
      const model = useProxiedModel(props, "modelValue");
      const {
        loaderClasses
      } = useLoader(props);
      const {
        isFocused,
        focus,
        blur
      } = useFocus(props);
      const control = ref();
      const loaderColor = computed2(() => {
        return typeof props.loading === "string" && props.loading !== "" ? props.loading : props.color;
      });
      const uid2 = getUid();
      const id = computed2(() => props.id || `switch-${uid2}`);
      function onChange() {
        if (indeterminate.value) {
          indeterminate.value = false;
        }
      }
      function onTrackClick(e) {
        var _a2, _b;
        e.stopPropagation();
        e.preventDefault();
        (_b = (_a2 = control.value) == null ? void 0 : _a2.input) == null ? void 0 : _b.click();
      }
      useRender(() => {
        const [rootAttrs, controlAttrs] = filterInputAttrs(attrs);
        const inputProps = VInput.filterProps(props);
        const controlProps = VSelectionControl.filterProps(props);
        return createVNode(VInput, mergeProps({
          "class": ["v-switch", {
            "v-switch--flat": props.flat
          }, {
            "v-switch--inset": props.inset
          }, {
            "v-switch--indeterminate": indeterminate.value
          }, loaderClasses.value, props.class]
        }, rootAttrs, inputProps, {
          "modelValue": model.value,
          "onUpdate:modelValue": ($event) => model.value = $event,
          "id": id.value,
          "focused": isFocused.value,
          "style": props.style
        }), __spreadProps(__spreadValues({}, slots), {
          default: (_ref2) => {
            let {
              id: id2,
              messagesId,
              isDisabled,
              isReadonly: isReadonly2,
              isValid: isValid2
            } = _ref2;
            const slotProps = {
              model,
              isValid: isValid2
            };
            return createVNode(VSelectionControl, mergeProps({
              "ref": control
            }, controlProps, {
              "modelValue": model.value,
              "onUpdate:modelValue": [($event) => model.value = $event, onChange],
              "id": id2.value,
              "aria-describedby": messagesId.value,
              "type": "checkbox",
              "aria-checked": indeterminate.value ? "mixed" : void 0,
              "disabled": isDisabled.value,
              "readonly": isReadonly2.value,
              "onFocus": focus,
              "onBlur": blur
            }, controlAttrs), __spreadProps(__spreadValues({}, slots), {
              default: (_ref3) => {
                let {
                  backgroundColorClasses,
                  backgroundColorStyles
                } = _ref3;
                return createVNode("div", {
                  "class": ["v-switch__track", ...backgroundColorClasses.value],
                  "style": backgroundColorStyles.value,
                  "onClick": onTrackClick
                }, [slots["track-true"] && createVNode("div", {
                  "key": "prepend",
                  "class": "v-switch__track-true"
                }, [slots["track-true"](slotProps)]), slots["track-false"] && createVNode("div", {
                  "key": "append",
                  "class": "v-switch__track-false"
                }, [slots["track-false"](slotProps)])]);
              },
              input: (_ref4) => {
                let {
                  inputNode,
                  icon,
                  backgroundColorClasses,
                  backgroundColorStyles
                } = _ref4;
                return createVNode(Fragment, null, [inputNode, createVNode("div", {
                  "class": ["v-switch__thumb", {
                    "v-switch__thumb--filled": icon || props.loading
                  }, props.inset ? void 0 : backgroundColorClasses.value],
                  "style": props.inset ? void 0 : backgroundColorStyles.value
                }, [slots.thumb ? createVNode(VDefaultsProvider, {
                  "defaults": {
                    VIcon: {
                      icon,
                      size: "x-small"
                    }
                  }
                }, {
                  default: () => [slots.thumb(__spreadProps(__spreadValues({}, slotProps), {
                    icon
                  }))]
                }) : createVNode(VScaleTransition, null, {
                  default: () => [!props.loading ? icon && createVNode(VIcon, {
                    "key": String(icon),
                    "icon": icon,
                    "size": "x-small"
                  }, null) : createVNode(LoaderSlot, {
                    "name": "v-switch",
                    "active": true,
                    "color": isValid2.value === false ? void 0 : loaderColor.value
                  }, {
                    default: (slotProps2) => slots.loader ? slots.loader(slotProps2) : createVNode(VProgressCircular, {
                      "active": slotProps2.isActive,
                      "color": slotProps2.color,
                      "indeterminate": true,
                      "size": "16",
                      "width": "2"
                    }, null)
                  })]
                })])]);
              }
            }));
          }
        }));
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VSystemBar/VSystemBar.mjs
  var makeVSystemBarProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    color: String,
    height: [Number, String],
    window: Boolean
  }, makeComponentProps()), makeElevationProps()), makeLayoutItemProps()), makeRoundedProps()), makeTagProps()), makeThemeProps()), "VSystemBar");
  var VSystemBar = genericComponent()({
    name: "VSystemBar",
    props: makeVSystemBarProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(toRef(props, "color"));
      const {
        elevationClasses
      } = useElevation(props);
      const {
        roundedClasses
      } = useRounded(props);
      const {
        ssrBootStyles
      } = useSsrBoot();
      const height = computed2(() => {
        var _a2;
        return (_a2 = props.height) != null ? _a2 : props.window ? 32 : 24;
      });
      const {
        layoutItemStyles
      } = useLayoutItem({
        id: props.name,
        order: computed2(() => parseInt(props.order, 10)),
        position: shallowRef("top"),
        layoutSize: height,
        elementSize: height,
        active: computed2(() => true),
        absolute: toRef(props, "absolute")
      });
      useRender(() => createVNode(props.tag, {
        "class": ["v-system-bar", {
          "v-system-bar--window": props.window
        }, themeClasses.value, backgroundColorClasses.value, elevationClasses.value, roundedClasses.value, props.class],
        "style": [backgroundColorStyles.value, layoutItemStyles.value, ssrBootStyles.value, props.style]
      }, slots));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VTabs/shared.mjs
  var VTabsSymbol = Symbol.for("vuetify:v-tabs");

  // ../library_management/node_modules/vuetify/lib/components/VTabs/VTab.mjs
  var makeVTabProps = propsFactory(__spreadValues({
    fixed: Boolean,
    sliderColor: String,
    hideSlider: Boolean,
    direction: {
      type: String,
      default: "horizontal"
    }
  }, omit(makeVBtnProps({
    selectedClass: "v-tab--selected",
    variant: "text"
  }), ["active", "block", "flat", "location", "position", "symbol"])), "VTab");
  var VTab = genericComponent()({
    name: "VTab",
    props: makeVTabProps(),
    setup(props, _ref) {
      let {
        slots,
        attrs
      } = _ref;
      const {
        textColorClasses: sliderColorClasses,
        textColorStyles: sliderColorStyles
      } = useTextColor(props, "sliderColor");
      const rootEl = ref();
      const sliderEl = ref();
      const isHorizontal = computed2(() => props.direction === "horizontal");
      const isSelected = computed2(() => {
        var _a2, _b, _c;
        return (_c = (_b = (_a2 = rootEl.value) == null ? void 0 : _a2.group) == null ? void 0 : _b.isSelected.value) != null ? _c : false;
      });
      function updateSlider(_ref2) {
        var _a2, _b;
        let {
          value
        } = _ref2;
        if (value) {
          const prevEl = (_b = (_a2 = rootEl.value) == null ? void 0 : _a2.$el.parentElement) == null ? void 0 : _b.querySelector(".v-tab--selected .v-tab__slider");
          const nextEl = sliderEl.value;
          if (!prevEl || !nextEl)
            return;
          const color = getComputedStyle(prevEl).color;
          const prevBox = prevEl.getBoundingClientRect();
          const nextBox = nextEl.getBoundingClientRect();
          const xy = isHorizontal.value ? "x" : "y";
          const XY = isHorizontal.value ? "X" : "Y";
          const rightBottom = isHorizontal.value ? "right" : "bottom";
          const widthHeight = isHorizontal.value ? "width" : "height";
          const prevPos = prevBox[xy];
          const nextPos = nextBox[xy];
          const delta2 = prevPos > nextPos ? prevBox[rightBottom] - nextBox[rightBottom] : prevBox[xy] - nextBox[xy];
          const origin = Math.sign(delta2) > 0 ? isHorizontal.value ? "right" : "bottom" : Math.sign(delta2) < 0 ? isHorizontal.value ? "left" : "top" : "center";
          const size2 = Math.abs(delta2) + (Math.sign(delta2) < 0 ? prevBox[widthHeight] : nextBox[widthHeight]);
          const scale = size2 / Math.max(prevBox[widthHeight], nextBox[widthHeight]) || 0;
          const initialScale = prevBox[widthHeight] / nextBox[widthHeight] || 0;
          const sigma = 1.5;
          animate(nextEl, {
            backgroundColor: [color, "currentcolor"],
            transform: [`translate${XY}(${delta2}px) scale${XY}(${initialScale})`, `translate${XY}(${delta2 / sigma}px) scale${XY}(${(scale - 1) / sigma + 1})`, "none"],
            transformOrigin: Array(3).fill(origin)
          }, {
            duration: 225,
            easing: standardEasing
          });
        }
      }
      useRender(() => {
        const btnProps = VBtn.filterProps(props);
        return createVNode(VBtn, mergeProps({
          "symbol": VTabsSymbol,
          "ref": rootEl,
          "class": ["v-tab", props.class],
          "style": props.style,
          "tabindex": isSelected.value ? 0 : -1,
          "role": "tab",
          "aria-selected": String(isSelected.value),
          "active": false
        }, btnProps, attrs, {
          "block": props.fixed,
          "maxWidth": props.fixed ? 300 : void 0,
          "onGroup:selected": updateSlider
        }), __spreadProps(__spreadValues({}, slots), {
          default: () => {
            var _a2, _b;
            return createVNode(Fragment, null, [(_b = (_a2 = slots.default) == null ? void 0 : _a2.call(slots)) != null ? _b : props.text, !props.hideSlider && createVNode("div", {
              "ref": sliderEl,
              "class": ["v-tab__slider", sliderColorClasses.value],
              "style": sliderColorStyles.value
            }, null)]);
          }
        }));
      });
      return forwardRefs({}, rootEl);
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VTabs/VTabs.mjs
  function parseItems(items) {
    if (!items)
      return [];
    return items.map((item) => {
      if (!isObject2(item))
        return {
          text: item,
          value: item
        };
      return item;
    });
  }
  var makeVTabsProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({
    alignTabs: {
      type: String,
      default: "start"
    },
    color: String,
    fixedTabs: Boolean,
    items: {
      type: Array,
      default: () => []
    },
    stacked: Boolean,
    bgColor: String,
    grow: Boolean,
    height: {
      type: [Number, String],
      default: void 0
    },
    hideSlider: Boolean,
    sliderColor: String
  }, makeVSlideGroupProps({
    mandatory: "force"
  })), makeDensityProps()), makeTagProps()), "VTabs");
  var VTabs = genericComponent()({
    name: "VTabs",
    props: makeVTabsProps(),
    emits: {
      "update:modelValue": (v) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const model = useProxiedModel(props, "modelValue");
      const parsedItems = computed2(() => parseItems(props.items));
      const {
        densityClasses
      } = useDensity(props);
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(toRef(props, "bgColor"));
      provideDefaults({
        VTab: {
          color: toRef(props, "color"),
          direction: toRef(props, "direction"),
          stacked: toRef(props, "stacked"),
          fixed: toRef(props, "fixedTabs"),
          sliderColor: toRef(props, "sliderColor"),
          hideSlider: toRef(props, "hideSlider")
        }
      });
      useRender(() => {
        const slideGroupProps = VSlideGroup.filterProps(props);
        return createVNode(VSlideGroup, mergeProps(slideGroupProps, {
          "modelValue": model.value,
          "onUpdate:modelValue": ($event) => model.value = $event,
          "class": ["v-tabs", `v-tabs--${props.direction}`, `v-tabs--align-tabs-${props.alignTabs}`, {
            "v-tabs--fixed-tabs": props.fixedTabs,
            "v-tabs--grow": props.grow,
            "v-tabs--stacked": props.stacked
          }, densityClasses.value, backgroundColorClasses.value, props.class],
          "style": [{
            "--v-tabs-height": convertToUnit(props.height)
          }, backgroundColorStyles.value, props.style],
          "role": "tablist",
          "symbol": VTabsSymbol
        }), {
          default: () => [slots.default ? slots.default() : parsedItems.value.map((item) => createVNode(VTab, mergeProps(item, {
            "key": item.text
          }), null))]
        });
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VTextarea/VTextarea.mjs
  var makeVTextareaProps = propsFactory(__spreadValues(__spreadValues({
    autoGrow: Boolean,
    autofocus: Boolean,
    counter: [Boolean, Number, String],
    counterValue: Function,
    prefix: String,
    placeholder: String,
    persistentPlaceholder: Boolean,
    persistentCounter: Boolean,
    noResize: Boolean,
    rows: {
      type: [Number, String],
      default: 5,
      validator: (v) => !isNaN(parseFloat(v))
    },
    maxRows: {
      type: [Number, String],
      validator: (v) => !isNaN(parseFloat(v))
    },
    suffix: String,
    modelModifiers: Object
  }, makeVInputProps()), makeVFieldProps()), "VTextarea");
  var VTextarea = genericComponent()({
    name: "VTextarea",
    directives: {
      Intersect: intersect_default
    },
    inheritAttrs: false,
    props: makeVTextareaProps(),
    emits: {
      "click:control": (e) => true,
      "mousedown:control": (e) => true,
      "update:focused": (focused) => true,
      "update:modelValue": (val) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        emit: emit2,
        slots
      } = _ref;
      const model = useProxiedModel(props, "modelValue");
      const {
        isFocused,
        focus,
        blur
      } = useFocus(props);
      const counterValue = computed2(() => {
        return typeof props.counterValue === "function" ? props.counterValue(model.value) : (model.value || "").toString().length;
      });
      const max = computed2(() => {
        if (attrs.maxlength)
          return attrs.maxlength;
        if (!props.counter || typeof props.counter !== "number" && typeof props.counter !== "string")
          return void 0;
        return props.counter;
      });
      function onIntersect(isIntersecting, entries) {
        var _a2, _b;
        if (!props.autofocus || !isIntersecting)
          return;
        (_b = (_a2 = entries[0].target) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
      }
      const vInputRef = ref();
      const vFieldRef = ref();
      const controlHeight = shallowRef("");
      const textareaRef = ref();
      const isActive = computed2(() => props.persistentPlaceholder || isFocused.value || props.active);
      function onFocus() {
        var _a2;
        if (textareaRef.value !== document.activeElement) {
          (_a2 = textareaRef.value) == null ? void 0 : _a2.focus();
        }
        if (!isFocused.value)
          focus();
      }
      function onControlClick(e) {
        onFocus();
        emit2("click:control", e);
      }
      function onControlMousedown(e) {
        emit2("mousedown:control", e);
      }
      function onClear(e) {
        e.stopPropagation();
        onFocus();
        nextTick(() => {
          model.value = "";
          callEvent(props["onClick:clear"], e);
        });
      }
      function onInput(e) {
        var _a2;
        const el = e.target;
        model.value = el.value;
        if ((_a2 = props.modelModifiers) == null ? void 0 : _a2.trim) {
          const caretPosition = [el.selectionStart, el.selectionEnd];
          nextTick(() => {
            el.selectionStart = caretPosition[0];
            el.selectionEnd = caretPosition[1];
          });
        }
      }
      const sizerRef = ref();
      const rows = ref(+props.rows);
      const isPlainOrUnderlined = computed2(() => ["plain", "underlined"].includes(props.variant));
      watchEffect(() => {
        if (!props.autoGrow)
          rows.value = +props.rows;
      });
      function calculateInputHeight() {
        if (!props.autoGrow)
          return;
        nextTick(() => {
          if (!sizerRef.value || !vFieldRef.value)
            return;
          const style = getComputedStyle(sizerRef.value);
          const fieldStyle = getComputedStyle(vFieldRef.value.$el);
          const padding = parseFloat(style.getPropertyValue("--v-field-padding-top")) + parseFloat(style.getPropertyValue("--v-input-padding-top")) + parseFloat(style.getPropertyValue("--v-field-padding-bottom"));
          const height = sizerRef.value.scrollHeight;
          const lineHeight = parseFloat(style.lineHeight);
          const minHeight = Math.max(parseFloat(props.rows) * lineHeight + padding, parseFloat(fieldStyle.getPropertyValue("--v-input-control-height")));
          const maxHeight = parseFloat(props.maxRows) * lineHeight + padding || Infinity;
          const newHeight = clamp(height != null ? height : 0, minHeight, maxHeight);
          rows.value = Math.floor((newHeight - padding) / lineHeight);
          controlHeight.value = convertToUnit(newHeight);
        });
      }
      onMounted(calculateInputHeight);
      watch(model, calculateInputHeight);
      watch(() => props.rows, calculateInputHeight);
      watch(() => props.maxRows, calculateInputHeight);
      watch(() => props.density, calculateInputHeight);
      let observer;
      watch(sizerRef, (val) => {
        if (val) {
          observer = new ResizeObserver(calculateInputHeight);
          observer.observe(sizerRef.value);
        } else {
          observer == null ? void 0 : observer.disconnect();
        }
      });
      onBeforeUnmount(() => {
        observer == null ? void 0 : observer.disconnect();
      });
      useRender(() => {
        const hasCounter = !!(slots.counter || props.counter || props.counterValue);
        const hasDetails = !!(hasCounter || slots.details);
        const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
        const _a2 = VInput.filterProps(props), {
          modelValue: _
        } = _a2, inputProps = __objRest(_a2, [
          "modelValue"
        ]);
        const fieldProps = filterFieldProps(props);
        return createVNode(VInput, mergeProps({
          "ref": vInputRef,
          "modelValue": model.value,
          "onUpdate:modelValue": ($event) => model.value = $event,
          "class": ["v-textarea v-text-field", {
            "v-textarea--prefixed": props.prefix,
            "v-textarea--suffixed": props.suffix,
            "v-text-field--prefixed": props.prefix,
            "v-text-field--suffixed": props.suffix,
            "v-textarea--auto-grow": props.autoGrow,
            "v-textarea--no-resize": props.noResize || props.autoGrow,
            "v-input--plain-underlined": isPlainOrUnderlined.value
          }, props.class],
          "style": props.style
        }, rootAttrs, inputProps, {
          "centerAffix": rows.value === 1 && !isPlainOrUnderlined.value,
          "focused": isFocused.value
        }), __spreadProps(__spreadValues({}, slots), {
          default: (_ref2) => {
            let {
              id,
              isDisabled,
              isDirty,
              isReadonly: isReadonly2,
              isValid: isValid2
            } = _ref2;
            return createVNode(VField, mergeProps({
              "ref": vFieldRef,
              "style": {
                "--v-textarea-control-height": controlHeight.value
              },
              "onClick": onControlClick,
              "onMousedown": onControlMousedown,
              "onClick:clear": onClear,
              "onClick:prependInner": props["onClick:prependInner"],
              "onClick:appendInner": props["onClick:appendInner"]
            }, fieldProps, {
              "id": id.value,
              "active": isActive.value || isDirty.value,
              "centerAffix": rows.value === 1 && !isPlainOrUnderlined.value,
              "dirty": isDirty.value || props.dirty,
              "disabled": isDisabled.value,
              "focused": isFocused.value,
              "error": isValid2.value === false
            }), __spreadProps(__spreadValues({}, slots), {
              default: (_ref3) => {
                let {
                  props: _a3
                } = _ref3, _b = _a3, {
                  class: fieldClass
                } = _b, slotProps = __objRest(_b, [
                  "class"
                ]);
                return createVNode(Fragment, null, [props.prefix && createVNode("span", {
                  "class": "v-text-field__prefix"
                }, [props.prefix]), withDirectives(createVNode("textarea", mergeProps({
                  "ref": textareaRef,
                  "class": fieldClass,
                  "value": model.value,
                  "onInput": onInput,
                  "autofocus": props.autofocus,
                  "readonly": isReadonly2.value,
                  "disabled": isDisabled.value,
                  "placeholder": props.placeholder,
                  "rows": props.rows,
                  "name": props.name,
                  "onFocus": onFocus,
                  "onBlur": blur
                }, slotProps, inputAttrs), null), [[resolveDirective("intersect"), {
                  handler: onIntersect
                }, null, {
                  once: true
                }]]), props.autoGrow && withDirectives(createVNode("textarea", {
                  "class": [fieldClass, "v-textarea__sizer"],
                  "id": `${slotProps.id}-sizer`,
                  "onUpdate:modelValue": ($event) => model.value = $event,
                  "ref": sizerRef,
                  "readonly": true,
                  "aria-hidden": "true"
                }, null), [[vModelText, model.value]]), props.suffix && createVNode("span", {
                  "class": "v-text-field__suffix"
                }, [props.suffix])]);
              }
            }));
          },
          details: hasDetails ? (slotProps) => {
            var _a3;
            return createVNode(Fragment, null, [(_a3 = slots.details) == null ? void 0 : _a3.call(slots, slotProps), hasCounter && createVNode(Fragment, null, [createVNode("span", null, null), createVNode(VCounter, {
              "active": props.persistentCounter || isFocused.value,
              "value": counterValue.value,
              "max": max.value
            }, slots.counter)])]);
          } : void 0
        }));
      });
      return forwardRefs({}, vInputRef, vFieldRef, textareaRef);
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VThemeProvider/VThemeProvider.mjs
  var makeVThemeProviderProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({
    withBackground: Boolean
  }, makeComponentProps()), makeThemeProps()), makeTagProps()), "VThemeProvider");
  var VThemeProvider = genericComponent()({
    name: "VThemeProvider",
    props: makeVThemeProviderProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      return () => {
        var _a2;
        if (!props.withBackground)
          return (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
        return createVNode(props.tag, {
          "class": ["v-theme-provider", themeClasses.value, props.class],
          "style": props.style
        }, {
          default: () => {
            var _a3;
            return [(_a3 = slots.default) == null ? void 0 : _a3.call(slots)];
          }
        });
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VTimeline/VTimeline.mjs
  var makeVTimelineProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    align: {
      type: String,
      default: "center",
      validator: (v) => ["center", "start"].includes(v)
    },
    direction: {
      type: String,
      default: "vertical",
      validator: (v) => ["vertical", "horizontal"].includes(v)
    },
    justify: {
      type: String,
      default: "auto",
      validator: (v) => ["auto", "center"].includes(v)
    },
    side: {
      type: String,
      validator: (v) => v == null || ["start", "end"].includes(v)
    },
    lineInset: {
      type: [String, Number],
      default: 0
    },
    lineThickness: {
      type: [String, Number],
      default: 2
    },
    lineColor: String,
    truncateLine: {
      type: String,
      validator: (v) => ["start", "end", "both"].includes(v)
    }
  }, makeComponentProps()), makeDensityProps()), makeTagProps()), makeThemeProps()), "VTimeline");
  var VTimeline = genericComponent()({
    name: "VTimeline",
    props: makeVTimelineProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      const {
        densityClasses
      } = useDensity(props);
      const {
        rtlClasses
      } = useRtl();
      provideDefaults({
        VTimelineDivider: {
          lineColor: toRef(props, "lineColor")
        },
        VTimelineItem: {
          density: toRef(props, "density"),
          lineInset: toRef(props, "lineInset")
        }
      });
      const sideClasses = computed2(() => {
        const side = props.side ? props.side : props.density !== "default" ? "end" : null;
        return side && `v-timeline--side-${side}`;
      });
      const truncateClasses = computed2(() => {
        const classes = ["v-timeline--truncate-line-start", "v-timeline--truncate-line-end"];
        switch (props.truncateLine) {
          case "both":
            return classes;
          case "start":
            return classes[0];
          case "end":
            return classes[1];
          default:
            return null;
        }
      });
      useRender(() => createVNode(props.tag, {
        "class": ["v-timeline", `v-timeline--${props.direction}`, `v-timeline--align-${props.align}`, `v-timeline--justify-${props.justify}`, truncateClasses.value, {
          "v-timeline--inset-line": !!props.lineInset
        }, themeClasses.value, densityClasses.value, sideClasses.value, rtlClasses.value, props.class],
        "style": [{
          "--v-timeline-line-thickness": convertToUnit(props.lineThickness)
        }, props.style]
      }, slots));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VTimeline/VTimelineDivider.mjs
  var makeVTimelineDividerProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    dotColor: String,
    fillDot: Boolean,
    hideDot: Boolean,
    icon: IconValue,
    iconColor: String,
    lineColor: String
  }, makeComponentProps()), makeRoundedProps()), makeSizeProps()), makeElevationProps()), "VTimelineDivider");
  var VTimelineDivider = genericComponent()({
    name: "VTimelineDivider",
    props: makeVTimelineDividerProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        sizeClasses,
        sizeStyles
      } = useSize(props, "v-timeline-divider__dot");
      const {
        backgroundColorStyles,
        backgroundColorClasses
      } = useBackgroundColor(toRef(props, "dotColor"));
      const {
        roundedClasses
      } = useRounded(props, "v-timeline-divider__dot");
      const {
        elevationClasses
      } = useElevation(props);
      const {
        backgroundColorClasses: lineColorClasses,
        backgroundColorStyles: lineColorStyles
      } = useBackgroundColor(toRef(props, "lineColor"));
      useRender(() => createVNode("div", {
        "class": ["v-timeline-divider", {
          "v-timeline-divider--fill-dot": props.fillDot
        }, props.class],
        "style": props.style
      }, [createVNode("div", {
        "class": ["v-timeline-divider__before", lineColorClasses.value],
        "style": lineColorStyles.value
      }, null), !props.hideDot && createVNode("div", {
        "key": "dot",
        "class": ["v-timeline-divider__dot", elevationClasses.value, roundedClasses.value, sizeClasses.value],
        "style": sizeStyles.value
      }, [createVNode("div", {
        "class": ["v-timeline-divider__inner-dot", backgroundColorClasses.value, roundedClasses.value],
        "style": backgroundColorStyles.value
      }, [!slots.default ? createVNode(VIcon, {
        "key": "icon",
        "color": props.iconColor,
        "icon": props.icon,
        "size": props.size
      }, null) : createVNode(VDefaultsProvider, {
        "key": "icon-defaults",
        "disabled": !props.icon,
        "defaults": {
          VIcon: {
            color: props.iconColor,
            icon: props.icon,
            size: props.size
          }
        }
      }, slots.default)])]), createVNode("div", {
        "class": ["v-timeline-divider__after", lineColorClasses.value],
        "style": lineColorStyles.value
      }, null)]));
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VTimeline/VTimelineItem.mjs
  var makeVTimelineItemProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    density: String,
    dotColor: String,
    fillDot: Boolean,
    hideDot: Boolean,
    hideOpposite: {
      type: Boolean,
      default: void 0
    },
    icon: IconValue,
    iconColor: String,
    lineInset: [Number, String]
  }, makeComponentProps()), makeDimensionProps()), makeElevationProps()), makeRoundedProps()), makeSizeProps()), makeTagProps()), "VTimelineItem");
  var VTimelineItem = genericComponent()({
    name: "VTimelineItem",
    props: makeVTimelineItemProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        dimensionStyles
      } = useDimension(props);
      const dotSize = shallowRef(0);
      const dotRef = ref();
      watch(dotRef, (newValue) => {
        var _a2, _b;
        if (!newValue)
          return;
        dotSize.value = (_b = (_a2 = newValue.$el.querySelector(".v-timeline-divider__dot")) == null ? void 0 : _a2.getBoundingClientRect().width) != null ? _b : 0;
      }, {
        flush: "post"
      });
      useRender(() => {
        var _a2, _b;
        return createVNode("div", {
          "class": ["v-timeline-item", {
            "v-timeline-item--fill-dot": props.fillDot
          }, props.class],
          "style": [{
            "--v-timeline-dot-size": convertToUnit(dotSize.value),
            "--v-timeline-line-inset": props.lineInset ? `calc(var(--v-timeline-dot-size) / 2 + ${convertToUnit(props.lineInset)})` : convertToUnit(0)
          }, props.style]
        }, [createVNode("div", {
          "class": "v-timeline-item__body",
          "style": dimensionStyles.value
        }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]), createVNode(VTimelineDivider, {
          "ref": dotRef,
          "hideDot": props.hideDot,
          "icon": props.icon,
          "iconColor": props.iconColor,
          "size": props.size,
          "elevation": props.elevation,
          "dotColor": props.dotColor,
          "fillDot": props.fillDot,
          "rounded": props.rounded
        }, {
          default: slots.icon
        }), props.density !== "compact" && createVNode("div", {
          "class": "v-timeline-item__opposite"
        }, [!props.hideOpposite && ((_b = slots.opposite) == null ? void 0 : _b.call(slots))])]);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VToolbar/VToolbarItems.mjs
  var makeVToolbarItemsProps = propsFactory(__spreadValues(__spreadValues({}, makeComponentProps()), makeVariantProps({
    variant: "text"
  })), "VToolbarItems");
  var VToolbarItems = genericComponent()({
    name: "VToolbarItems",
    props: makeVToolbarItemsProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      provideDefaults({
        VBtn: {
          color: toRef(props, "color"),
          height: "inherit",
          variant: toRef(props, "variant")
        }
      });
      useRender(() => {
        var _a2;
        return createVNode("div", {
          "class": ["v-toolbar-items", props.class],
          "style": props.style
        }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
      });
      return {};
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VTooltip/VTooltip.mjs
  var makeVTooltipProps = propsFactory(__spreadValues({
    id: String,
    text: String
  }, omit(makeVOverlayProps({
    closeOnBack: false,
    location: "end",
    locationStrategy: "connected",
    eager: true,
    minWidth: 0,
    offset: 10,
    openOnClick: false,
    openOnHover: true,
    origin: "auto",
    scrim: false,
    scrollStrategy: "reposition",
    transition: false
  }), ["absolute", "persistent"])), "VTooltip");
  var VTooltip = genericComponent()({
    name: "VTooltip",
    props: makeVTooltipProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const isActive = useProxiedModel(props, "modelValue");
      const {
        scopeId
      } = useScopeId();
      const uid2 = getUid();
      const id = computed2(() => props.id || `v-tooltip-${uid2}`);
      const overlay = ref();
      const location2 = computed2(() => {
        return props.location.split(" ").length > 1 ? props.location : props.location + " center";
      });
      const origin = computed2(() => {
        return props.origin === "auto" || props.origin === "overlap" || props.origin.split(" ").length > 1 || props.location.split(" ").length > 1 ? props.origin : props.origin + " center";
      });
      const transition = computed2(() => {
        if (props.transition)
          return props.transition;
        return isActive.value ? "scale-transition" : "fade-transition";
      });
      const activatorProps = computed2(() => mergeProps({
        "aria-describedby": id.value
      }, props.activatorProps));
      useRender(() => {
        const overlayProps = VOverlay.filterProps(props);
        return createVNode(VOverlay, mergeProps({
          "ref": overlay,
          "class": ["v-tooltip", props.class],
          "style": props.style,
          "id": id.value
        }, overlayProps, {
          "modelValue": isActive.value,
          "onUpdate:modelValue": ($event) => isActive.value = $event,
          "transition": transition.value,
          "absolute": true,
          "location": location2.value,
          "origin": origin.value,
          "persistent": true,
          "role": "tooltip",
          "activatorProps": activatorProps.value,
          "_disableGlobalStack": true
        }, scopeId), {
          activator: slots.activator,
          default: function() {
            var _a2, _b;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return (_b = (_a2 = slots.default) == null ? void 0 : _a2.call(slots, ...args)) != null ? _b : props.text;
          }
        });
      });
      return forwardRefs({}, overlay);
    }
  });

  // ../library_management/node_modules/vuetify/lib/components/VValidation/VValidation.mjs
  var VValidation = genericComponent()({
    name: "VValidation",
    props: makeValidationProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const validation = useValidation(props, "validation");
      return () => {
        var _a2;
        return (_a2 = slots.default) == null ? void 0 : _a2.call(slots, validation);
      };
    }
  });

  // ../library_management/node_modules/vuetify/lib/directives/index.mjs
  var directives_exports = {};
  __export(directives_exports, {
    ClickOutside: () => ClickOutside,
    Intersect: () => Intersect,
    Mutate: () => Mutate,
    Resize: () => Resize,
    Ripple: () => Ripple,
    Scroll: () => Scroll,
    Touch: () => Touch
  });

  // ../library_management/node_modules/vuetify/lib/directives/mutate/index.mjs
  function mounted4(el, binding) {
    var _b, _c, _d, _e;
    const modifiers = binding.modifiers || {};
    const value = binding.value;
    const _a2 = modifiers, {
      once,
      immediate
    } = _a2, modifierKeys = __objRest(_a2, [
      "once",
      "immediate"
    ]);
    const defaultValue2 = !Object.keys(modifierKeys).length;
    const {
      handler,
      options
    } = typeof value === "object" ? value : {
      handler: value,
      options: {
        attributes: (_b = modifierKeys == null ? void 0 : modifierKeys.attr) != null ? _b : defaultValue2,
        characterData: (_c = modifierKeys == null ? void 0 : modifierKeys.char) != null ? _c : defaultValue2,
        childList: (_d = modifierKeys == null ? void 0 : modifierKeys.child) != null ? _d : defaultValue2,
        subtree: (_e = modifierKeys == null ? void 0 : modifierKeys.sub) != null ? _e : defaultValue2
      }
    };
    const observer = new MutationObserver(function() {
      let mutations = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      let observer2 = arguments.length > 1 ? arguments[1] : void 0;
      handler == null ? void 0 : handler(mutations, observer2);
      if (once)
        unmounted4(el, binding);
    });
    if (immediate)
      handler == null ? void 0 : handler([], observer);
    el._mutate = Object(el._mutate);
    el._mutate[binding.instance.$.uid] = {
      observer
    };
    observer.observe(el, options);
  }
  function unmounted4(el, binding) {
    var _a2;
    if (!((_a2 = el._mutate) == null ? void 0 : _a2[binding.instance.$.uid]))
      return;
    el._mutate[binding.instance.$.uid].observer.disconnect();
    delete el._mutate[binding.instance.$.uid];
  }
  var Mutate = {
    mounted: mounted4,
    unmounted: unmounted4
  };

  // ../library_management/node_modules/vuetify/lib/directives/resize/index.mjs
  function mounted5(el, binding) {
    var _a2, _b;
    const handler = binding.value;
    const options = {
      passive: !((_a2 = binding.modifiers) == null ? void 0 : _a2.active)
    };
    window.addEventListener("resize", handler, options);
    el._onResize = Object(el._onResize);
    el._onResize[binding.instance.$.uid] = {
      handler,
      options
    };
    if (!((_b = binding.modifiers) == null ? void 0 : _b.quiet)) {
      handler();
    }
  }
  function unmounted5(el, binding) {
    var _a2;
    if (!((_a2 = el._onResize) == null ? void 0 : _a2[binding.instance.$.uid]))
      return;
    const {
      handler,
      options
    } = el._onResize[binding.instance.$.uid];
    window.removeEventListener("resize", handler, options);
    delete el._onResize[binding.instance.$.uid];
  }
  var Resize = {
    mounted: mounted5,
    unmounted: unmounted5
  };

  // ../library_management/node_modules/vuetify/lib/directives/scroll/index.mjs
  function mounted6(el, binding) {
    var _a2;
    const {
      self: self2 = false
    } = (_a2 = binding.modifiers) != null ? _a2 : {};
    const value = binding.value;
    const options = typeof value === "object" && value.options || {
      passive: true
    };
    const handler = typeof value === "function" || "handleEvent" in value ? value : value.handler;
    const target = self2 ? el : binding.arg ? document.querySelector(binding.arg) : window;
    if (!target)
      return;
    target.addEventListener("scroll", handler, options);
    el._onScroll = Object(el._onScroll);
    el._onScroll[binding.instance.$.uid] = {
      handler,
      options,
      target: self2 ? void 0 : target
    };
  }
  function unmounted6(el, binding) {
    var _a2;
    if (!((_a2 = el._onScroll) == null ? void 0 : _a2[binding.instance.$.uid]))
      return;
    const {
      handler,
      options,
      target = el
    } = el._onScroll[binding.instance.$.uid];
    target.removeEventListener("scroll", handler, options);
    delete el._onScroll[binding.instance.$.uid];
  }
  function updated2(el, binding) {
    if (binding.value === binding.oldValue)
      return;
    unmounted6(el, binding);
    mounted6(el, binding);
  }
  var Scroll = {
    mounted: mounted6,
    unmounted: unmounted6,
    updated: updated2
  };

  // ../library_management/library_management/public/js/utils.js
  function loadCSS(href) {
    const link = document.createElement("link");
    link.href = href;
    link.rel = "stylesheet";
    document.head.appendChild(link);
  }
  function loadPdfJs(url) {
    return new Promise((resolve2, reject) => {
      const script = document.createElement("script");
      script.src = url;
      script.onload = resolve2;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }

  // ../library_management/library_management/public/js/books/books.bundle.js
  loadCSS("https://cdn.jsdelivr.net/npm/vuetify@3.5.14/dist/vuetify.min.css");
  loadCSS("https://cdn.jsdelivr.net/npm/@mdi/font/css/materialdesignicons.min.css");
  loadPdfJs("https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.7.570/pdf.min.js");
  var Book2 = class {
    constructor(wrapper) {
      this.wrapper = $(wrapper);
      this.page = frappe.ui.make_app_page({
        parent: wrapper
      });
      this.wrapper.bind("show", () => {
        this.show();
      });
    }
    show() {
      this.setup_page();
    }
    setup_page() {
      const vuetify = createVuetify({
        icons: {
          defaultSet: "mdi"
        },
        components: components_exports,
        directives: directives_exports
      });
      const pinia = createPinia();
      const app = createApp(Books_default2);
      SetVueGlobals(app);
      app.use(vuetify);
      app.use(pinia);
      this.bookstore = useBooksStore();
      this.$books = app.mount(".page-container");
    }
  };
  frappe.require("frappe-ui");
  frappe.ui.Book = Book2;
  var books_bundle_default = Book2;
})();
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
/*!
    localForage -- Offline Storage, Improved
    Version 1.10.0
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
/*!
 * pinia v2.1.7
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */
/*! #__NO_SIDE_EFFECTS__ */
/**
* @vue/reactivity v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/**
* @vue/runtime-core v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/**
* @vue/runtime-dom v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/**
* @vue/shared v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/**
* vue v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
//# sourceMappingURL=books.bundle.URTX2PXJ.js.map
